# -*- mode: org; geiser-scheme-implementation: chibi; geiser-autodoc--inhibit: t; -*-
# Time-stamp: <2021-03-27 18:17:34 lockywolf>
# Created   : [2019-08-18 Sun 20:11]
#+Author:  lockywolf gmail.com

#+STARTUP: inlineimages
#+STARTUP: latexpreview
#+HTML_MATHJAX: align: left indent: 5em tagside: left font: Neo-Euler
#+HTML_MATHJAX: cancel.js noErrors.js
#+OPTIONS: tex:imagemagick
#+latex_class: book
#+LATEX_CLASS_OPTIONS: [a4paper,12pt,twoside]
#+latex_header: \usepackage[a4paper,margin=2cm]{geometry}
#+LATEX_HEADER: \usepackage{supertabular}
#+LATEX_HEADER: \usepackage{color}



* noweb + common
** Existing solutions
 - Racket https://github.com/skanev/playground/tree/master/scheme/sicp

** Unfinished solutions
 - https://github.com/MarkCurtiss/sicp (5.51, 5.52 missing)
 - Racket: https://www.inchmeal.io/sicp/ (5.51, 5.52 missing)
 - Common Lisp + Racket: https://eli.thegreenplace.net/tag/sicp (until
   5.43)
 - Racket: https://github.com/wentaocn/SICP-Solution
 - Racket: https://wizardbook.wordpress.com/solutions-index/
 - Guile: https://github.com/zv/SICP-guile
 - http://sioramen.sub.jp/blog/sicp/
 - MIT-scheme: https://sicp.readthedocs.io/en/latest/
 - https://gist.github.com/lagenorhynque/ca0916b110fc2ef226c30f8a61290da7
 - https://github.com/jiacai2050/sicp
 - Clojure + Common Lisp: https://github.com/lagenorhynque/sicp
 - https://github.com/ananthakumaran/SICP
 - Clojure: http://grinnbearit.github.io/sicp/
 - https://github.com/cxphoe/SICP-solutions
** Setting chibi arguments. DANGEROUS                       :dangerous:elisp:

#

#+begin_src elisp :export code :results none
  (setq geiser-chibi-extra-command-line-parameters
     '("-m" "chibi"
       "-m" "scheme show"
       "-m" "chibi ast"
       "-m" "srfi 27"
       "-m" "chibi process"
       "-m" "scheme list"
       "-m" "srfi 18"))
  (setq geiser-connection-timeout 120000)
#+end_src

#+RESULTS[4b09abc1e048c56020004a5a0ac6b595766a9d38]:
: 60000

#+name: common
#+begin_src scheme :results none :exports code
  (import (chibi ast))
  (import (chibi show))
   (define (disp sexp)
     (display sexp)
     (newline))
#+end_src

#+RESULTS: common

#+name: export-interpreter
#+begin_src scheme :exports code :results none
(import (srfi 159))
#+end_src

** Common noweb blocks

#+name: empty
#+begin_quote

#+end_quote

#+name: common-pretty-includes
#+begin_quote
#!/usr/bin/chibi-scheme
(import (scheme small))
(import (srfi 159))

#+end_quote

\(E=mc^{2} \)


** SRFI Library

Nonstandard functions used in SICP:

- (runtime) :: can be implemented using (current-second) from r7rs
- (random-in-range) :: implementable using (random-integer) from (srfi 27)
- (parallel-execute) :: implementable with (srfi 18)
- (test-and-set!) :: implementable with (srfi 18)
- (cons-stream) :: implementable using (syntax-rules) from r7rs
-  


#+begin_src shell :results output

chibi-scheme -I ~/DevLinux/srfi-sicp-prerequisites/ -msrfi.199 -p "(sicp-helloworld)"

#+end_src

#+RESULTS:
: hello from srfi-199#<undef>

* SICP [363/363]
:PROPERTIES:
:header-args: :noweb yes :cache yes
:END:

** Chapter 1: Building abstractions with procedures [47/47]

*** Snippet
#+attr_latex: :options caption=Snippet
#+BEGIN_SRC scheme :exports both :results value
   (* (+ 2 (* 4 6))
      (+ 3 5 7))
#+END_SRC

#+RESULTS[d6ae410a43e8778057209aad61d9b32fb0379457]:
 : 390

*** Thought
 Tree accumulation is the process of computing a thing by traversing a tree.

*** DONE Figure 1.1 Tree representation, showing the value of each subcombination :graphviz:plantuml:tikz:
    CLOSED: [2019-08-20 Tue 14:35]
 For the sake of pedagogical clarity, I have formatted it as a picture.

#+attr_latex: :options caption=Code
 #+BEGIN_SRC plantuml :exports both :results value file graphics :file figure-1-1-mm.png
 @startmindmap
 skinparam monochrome true
 +_ 390
 ++_ *
 ++_ 26
 +++_ +
 +++_ 2
 +++_ 24
 ++++_ *
 ++++_ 4
 ++++_ 6
 ++_ 15
 +++_ +
 +++_ 3
 +++_ 5
 +++_ 7
 @endmindmap
 #+END_SRC

 #+RESULTS[daebeccd2a0fb2b4ae204e435919505948585f63]:
 [[file:figure-1-1-mm.png]]


 # Then next line is the same diagram verbose, using DOT.
 #+begin_src plantuml :exports both :results value file graphics :file figure-1-1-dot.png
 @startdot
 graph g {
	 node [shape=plaintext];
	 A1 [label="390"];

	 B1 [label="*"];
	 B2 [label="26"];
	 B3 [label="15"];

	 C1 [label="+"];
	 C2 [label="2"];
	 C3 [label="24"];

	 D1 [label="*"];
	 D2 [label="4"];
	 D3 [label="6"];

	 E1 [label="+"];
	 E2 [label="3"];
	 E3 [label="5"];
	 E4 [label="7"];

 // edges
	 A1 -- B1;
	 A1 -- B2;
	 A1 -- B3;

	 B2 -- C1;
	 B2 -- C2;
	 B2 -- C3;

	 C3 -- D1;
	 C3 -- D2;
	 C3 -- D3;

	 B3 -- E1;
	 B3 -- E2;
	 B3 -- E3;
	 B3 -- E4;

 //	B1 -> B3 [label="(g o f)'" tailport=s headport=s];

	 { rank=same; A1 }
	 { rank=same; B1 B2 B3 }
	 { rank=same; C1 C2 C3 }
	 { rank=same; D1 D2 D3 }
	 { rank=same; E1 E2 E3 E4 }
 }
 @enddot
 #+end_src

 #+RESULTS[e830837ee299db94d775c05223b85630f9fdacbb]:
 [[file:figure-1-1-dot.png]]

*** Snippet
#+name: square
#+begin_src scheme :exports both :results value scalar code
  (define (square x) (* x x))
  (define (sum-of-squares x y)
    (+ (square x) (square y)))
  (sum-of-squares 3 4)
#+end_src

#+RESULTS[48037817c7c08d7879a79d5f71d8119c9b7f4eb0]: square
#+begin_src scheme
25
#+end_src

*** DONE Exercise 1.1 Interpreter result
    CLOSED: [2019-08-20 Tue 14:23]
 #+begin_src scheme :exports both :results output scalar code
   (define (disp sexp)
     (display sexp)
     (newline))
   (disp 10)
   (disp (+ 2 3 4))
   (disp (- 9 1))
   (disp (/ 6 2))
   (disp (+ (* 2 4) (- 4 6)))
   (define a 3)
   (define b (+ a 1))
   (disp (+ a b (* a b)))
   (disp (= a b))
   (disp
    (if (and (> b a) (< b (* a b )))
	b
	a))
   (disp (cond ((= a 4) 6)
	((= b 4) (+ 6 7 a))
	(else 25)))
   (disp (+ 2 (if (< b a) b a)))
   (disp (* (cond ((> a b) a)
               ((< a b) b)
               (else -1))
            (+ a 1)))

 #+end_src

 #+RESULTS[20a4e1d7ff2772afc03b0ee16e1dbf4ddc9fde44]:
 #+begin_src scheme
 10
 9
 8
 3
 6
 19
 #f
 4
 16
 5
 16
 #+end_src

*** DONE Exercise 1.2 Prefix form
    CLOSED: [2019-08-20 Tue 14:25]
#+begin_src scheme :exports both :results value scalar code
(/ (+ 5 4 (- 2 (- 3 (+ 6 (/ 4 5))))) (* 3 (- 6 2) (- 2 7)))
#+end_src

#+RESULTS[11833097e5774b13769f311f83e11a513ac7de4e]:
#+begin_src scheme
-37/150
#+end_src

*** DONE Exercise 1.3 Sum of squares
    CLOSED: [2020-02-28 Fri 12:01]

#+begin_src shell :shebang "#!/usr/bin/chibi-scheme" :exports both :results output scalar code
 (import (scheme small))
 (import (srfi 95))
 (import (srfi 159))
 (define (sum-of-squares x y)
   (+ (square x) (square y)))
 (define (sum-of-two-max a b c)
   (let ((num_list (sort (list a b c) (lambda (a b) (if (> a b) a b)))))
    (sum-of-squares (car num_list) (cadr num_list))))
 (show #t (pretty (sum-of-two-max 1 2 3)))
#+end_src

#+RESULTS[019cf497f55c3234fbeb5e2d5d203b3c95c17755]:
#+begin_src shell
13
#+end_src

*** DONE Exercise 1.4 Compound expressions
    CLOSED: [2019-08-20 Tue 14:39]
 #+begin_src scheme :exports both :results output scalar code
 (define (a-plus-abs-b a b)
   ((if (> b 0) + -) a b))
 (display (a-plus-abs-b  3 4))
 (newline)
 (display (a-plus-abs-b  3 -4))
 #+end_src

 #+RESULTS[b23ad005436ed485ad7c3a5e81e39801a6166e39]:
 #+begin_src scheme
 7
 7
 #+end_src

*** DONE Exercise 1.5 Ben's test
    CLOSED: [2019-08-20 Tue 14:50]
 #+begin_src scheme :exports both :results value scalar code
 (define (p) (p))
 (define (test x y)
   (if (= x 0) 0 y))
 (test 0 (p))
 #+end_src

 #+RESULTS[546cc337f12386737bd973dbb01f5309cf3bcbb6]:
 #+begin_src scheme
 #+end_src

 On my interpreter this code goes into an infinite recursion, which
 makes sense, I guess, since the second argument to (test) is evaluated
 before executing (test). However, if we only substitute /p/ into the
 application of test and try to traverse the tree depth-first, this
 code should be able to terminate successfully?

*** DONE Exercise 1.6 If is a special form
    CLOSED: [2019-08-21 Wed 14:05]
The problem with this Alyssa's (new-if) is that both arguments would
be computed, so this (new-if) would be either very inefficient or even
not working at all in the case when one of the arguments is
infeasible.
Consider:

#+begin_src scheme :exports both :results output scalar code
<<common>>
(define (new-if predicate then-clause else-clause)
  (cond (predicate then-clause)
        (else else-clause)))
(define a 1)
(define b 0)
(disp (if (not (= b 0)) (/ a b) a))
(new-if (not (= b 0)) (/ a b) a)
#+end_src

#+RESULTS[0608c5bc3f65fca59764bb0435b3ae86e2aadd24]:
#+begin_src scheme
1

Output (exception): {Exception #19 user "divide by zero" () #<procedure #f> (#f . 13)}
Stack trace:
  called from <anonymous> on line 817 of file /usr/lib64/chibi/init-7.scm
  called from <anonymous> on line 280 of file /usr/lib64/chibi/init-7.scm
  called from <anonymous> on line 1206 of file /usr/lib64/chibi/init-7.scm
  called from <anonymous> on line 817 of file /usr/lib64/chibi/init-7.scm
  called from <anonymous> on line 394 of file /usr/lib64/chibi/meta-7.scm
  called from <anonymous> on line 817 of file /usr/lib64/chibi/init-7.scm
  called from call-with-current-continuation on line 844 of file /usr/lib64/chibi/init-7.scm
  called from <anonymous> on line 817 of file /usr/lib64/chibi/init-7.scm
  called from <anonymous> on line 280 of file /usr/lib64/chibi/init-7.scm
  called from <anonymous> on line 280 of file /usr/lib64/chibi/init-7.scm
  called from <anonymous> on line 817 of file /usr/lib64/chibi/init-7.scm
  called from call-with-current-continuation on line 844 of file /usr/lib64/chibi/init-7.scm
  called from geiser:eval on line 25 of file /usr/lib64/chibi/scheme/misc-macros.scm
#+end_src

However, this issue can be solved using scheme macros.

#+begin_src scheme :exports both :results output scalar code
  <<common>>
  (define-syntax new-if
    (syntax-rules ()
      ( (new-if predicate then-clause else-clause)
	(cond (predicate then-clause)
	      (else else-clause))
      )
    )
  )
  (define a 1)
  (define b 0)
  (disp (if (not (= b 0)) (/ a b) a))
  (disp (new-if (not (= b 0)) (/ a b) a))

#+end_src

#+RESULTS[ea2f6600b8331e543a394082bde53ba4260367dc]:
#+begin_src scheme
1
1
#+end_src

The code above works as expected, because the macro does not evaluate
its arguments, and (cond) is a special form.

*** DONE Exercise 1.7 Good enough?
    CLOSED: [2019-08-22 Thu 12:52]
This exercise is a very misleading one. On the first glance is seems
that this is just about formulating a good criterion. Make no mistake,
practically solving this task means really writing all this code
carefully.

The function we are interested in is:
\begin{equation}
\label{eq:5}
f(x) = \sqrt{x}
\end{equation}

The code given in the chapter before is equivalent to the following
Newton's method formula, where $f_i$ denotes the next guess:

\begin{equation}
\label{eq:1}
f_{i+1} = \frac{f_i + \frac{x}{f_i}}{2}
\end{equation}

How on Earth does this formula even appear? Let's remember some
mathematics, namely, the Taylor series (variables unbound):
\begin{equation}
\label{eq:2}
 f(x) = f(x_{0}) + f'(x_{0})(x-x_{0}) + o(x)
\end{equation}

Let us call `true' value of $\sqrt{x}=f$. Let us call our first guess
$f_{0}$. What is the value of the difference (error) between them?
Clearly, $f-f_0$. Well, the problem is — we don't know $f$. But we do
know $f^2$. Therefore $f^2-f^2_0$ is a number we know. What will be the
error on the next step of the algorithm? Let's find $f_1$ as
$f_1=f_0+\delta$. If $\delta$ is not too big, we can use the Taylor
expansion from ref:eq:1 $\delta$.
\begin{equation}
\label{eq:8}
E = f^2 - f_0^2 = f^2 - (f_0 + \delta)^2 \approx f^2 - f_0^2 - 2f_0\delta
\end{equation}


Be careful. What I expanded here is not the function value. It is the
_error_ value. Now, clearly we want our error to be as small as
possible, desirably as little as machine precision would allow. So
assuming $E=0$, we get an equation to solve:
\begin{align}
\label{eq:9}
E=0 \leftrightarrow & f^2-f_0^2-2f_0\delta=0 \\
\delta = & \frac{f_0^2 -f^2 }{2f_0}
\end{align}

Remember though that we don't need just $\delta$ here. We actually need
$f_1$. But $f_1$ is just $f_0+\delta$.
\begin{align}
\label{eq:10}
f_1 = \frac{f^2 - f_0^2}{2f_0} + f_0
\end{align}
Now if you rearrange this formula, you will get exactly the formula
ref:eq:1.

The code below is copied from SICP verbatim and implements the
algorithm above.

#+name: simple-sqrt-iter
#+begin_src scheme :exports code :results none
  (define (sqrt-iter guess x)
    (if (good-enough? guess x)
	guess
	(sqrt-iter (improve guess x) x)))
#+end_src

#+name: square-improve
#+begin_src scheme :exports code :results none
  (define (improve guess x)
    (average guess (/ x guess)))
#+end_src

#+name: simple-newton-recursion
#+begin_src scheme :exports code :results none
  (define (good-enough? guess x)
    (< (abs (- (square guess) x)) 0.001))
  <<square-improve>>
  (define (average x y)
    (/ (+ x y) 2))
  (define (sqrt x)
    (sqrt-iter 1.0 x))

#+end_src

#+name: simple-newton
#+begin_src scheme :exports both :results value scalar code
  <<common>>
  <<square>>
  <<simple-sqrt-iter>>
  <<simple-newton-recursion>>
  (sqrt 9)
#+end_src

#+RESULTS[44c9c2222e2b50417e70e33392eddc3bd418a649]: simple-newton
#+begin_src scheme
3.00009155413138
#+end_src

An example of how this fails on small numbers:

#+begin_src scheme :exports both :results value scalar code
<<simple-newton>>
(square (sqrt 0.0004))
#+end_src

#+RESULTS[cc25737b90376e66b04710560a977f11e7087a57]:
#+begin_src scheme
0.0012532224857331766
#+end_src

An example of why this fails on big numbers I didn't manage to
craft. Perhaps chibi-scheme has some clever way to deal with rounding?
Anyway — here is the code:
#+begin_src scheme :exports both :results value scalar code
  <<simple-newton>>
  (square (sqrt 9999999999.0))
#+end_src

#+RESULTS[3d14721febeca74f7e71fc1427b6d61df1adcc42]:
#+begin_src scheme
9999999998.999998
#+end_src

Why exactly this is not very good algorithms is a good question. The
derivative of the square is well-defined near the 0, although the
derivative of the square root is not. Therefore, the equation ref:eq:8
become very imprecise. As we see, big number seem to be working fine
in my scheme implementation.

Let us write a better sqrt-iter?.

#+name: better-sqrt-iter
#+begin_src scheme :exports both :results none
  (define (sqrt-iter guess x)
   (let ((better-guess (improve guess x)))
    (if (good-enough? guess (square better-guess))
	better-guess
	(sqrt-iter better-guess x))))
#+end_src

#+name: better-newton
#+begin_src scheme :exports both :results none
<<common>>
<<square>>
<<better-sqrt-iter>>
<<simple-newton-recursion>>
#+end_src

#+begin_src scheme :exports both :results value scalar code
<<better-newton>>
(square (sqrt 0.0004))
#+end_src

#+RESULTS[6585fff2006aa0d1751c8d8adce94c92969259a5]:
#+begin_src scheme
0.0005452233379244715
#+end_src


Works faster and gives a better result. Seemingly. QED[fn:1].

*** DONE Exercise 1.8 Newton's method
    CLOSED: [2019-08-22 Thu 17:36]

This exercise is not very hard. The only difference is that the
`improve' function is not derived from a derivative of a square but
rather from a derivative of a cube.

#+name: cube
#+begin_src scheme :exports code :results none
(define (cube x) (* x x x))
#+end_src

#+name: cube-improve
#+begin_src scheme :exports code :results none
(define (cube-improve guess x)
    (/ (+ (/ x (* guess guess)) (* 2 guess)) 3))
#+end_src

#+name: cube-good-enough
#+begin_src scheme :exports code :results none
(define (cube-good-enough? guess x)
  (< (abs (- (cube guess) x)) 0.001))
#+end_src

#+name: cube-root-iter
#+begin_src scheme :exports code :results none
  (define (cube-root-iter guess x)
    (let ((better-guess (cube-improve guess x)))
      (disp better-guess)
      (if (cube-good-enough? better-guess (cube guess))
	  better-guess
	  (cube-root-iter better-guess x))))
#+end_src

#+name: cube-simple
#+begin_src scheme :exports both :results output scalar code
<<common>>
<<cube>>
<<cube-improve>>
<<cube-good-enough>>
<<cube-root-iter>>
(display (cube-root-iter 1.0 27.0))
#+end_src

#+RESULTS[4807ba1e3d85c14b6766d978cb8ab81e0f638e86]: cube-simple
#+begin_src scheme
9.666666666666666
6.540758356453956
4.570876778578707
3.4780192333867963
3.0626891086275365
3.001274406506175
3.0000005410641766
3.0000000000000977
3.0000000000000977
#+end_src

*** Figure 1.2 Procedural decomposition of the sqrt program

#+name: figure-1-2
#+header: :imagemagick yes :iminoptions -density 300 :imoutoptions -geometry 1200
#+header: :fit yes :headers '("\\usepackage{tikz}")
#+header: :buffer on
#+begin_src latex :results value graphics file :exports both :file figure-1-2-tree.png
\usetikzlibrary{trees}
\begin{minipage}{14cm}
\begin{tikzpicture}[color=blue]
\node {sqrt} % root
  child { node {sqrt-iter}
                  child[sibling distance=3cm] { node{ good-enough }
                          child[sibling distance=1cm] { node { square } }
                          child[sibling distance=1cm] { node { abs } } }
                  child { node{ improve }
                          child { node { average } } } };
\end{tikzpicture}
\end{minipage}
#+end_src

#+RESULTS[d953864ed9b99e06adec7b710ee3eb2d2c14540d]: figure-1-2
[[file:figure-1-2-tree.png]]

*** Figure 1.3 A linear recursive process for computing \(6!\).

#+name: figure-1-3
#+header: :imagemagick yes :iminoptions -density 300 :imoutoptions -geometry 1200
#+header: :fit yes :headers '("\\usepackage{tikz}" "\\usetikzlibrary{positioning,fit,arrows.meta}")
#+header: :buffer on
#+begin_src latex :results value raw file :exports both :file figure-1-3-factorial.png
\begin{minipage}{18cm}
\begin{tikzpicture}[color=blue]
\path node[align=left] (0,0) {
(factorial 6)\\
(* 6 (factorial 5))\\
(* 6 (* 5 (factorial 4)))\\
(* 6 (* 5 (* 4 (factorial 3))))\\
(* 6 (* 5 (* 4 (* 3 (factorial 2)))))\\
(* 6 (* 5 (* 4 (* 3 (* 2 (factorial 1))))))\\
(* 6 (* 5 (* 4 (* 3 (* 2 1)))))\\
(* 6 (* 5 (* 4 (* 3 2))))\\
(* 6 (* 5 (* 4 6)))\\
(* 6 (* 5 24))\\
(* 6 120)\\
720};
\path[draw,>->,>={Triangle[open]},thick,rounded corners=30pt] 
(-1cm,2.3cm) .. controls (0cm,2.3cm) and (-0.8cm,2.3cm) .. (4cm, 0.2cm)
 .. controls (-1.6cm,-2.3cm) .. (-2.4cm,-2.3cm );
\end{tikzpicture}
\end{minipage}
#+end_src

#+RESULTS[77c5d59d54c58245163990de55f9e05038928361]: figure-1-3
[[file:figure-1-3-factorial.png]]

*** DONE Exercise 1.9 Iterative or recursive? :macro:er_macro_transformer:chicken:
    CLOSED: [2019-08-29 Thu 15:14]

I didn't find (inc) and (dec) in my scheme, so I define them myself.

I still don't want to overload the "+" and "-" symbols, so I will call
them `plus' and `minus'.

#+name: example-substitution-first
#+begin_src scheme :exports both :results value  code
  (define (inc x)
    (+ 1 x))
  (define (dec x)
    (- x 1))
  (define-syntax plusF
    (er-macro-transformer
     (lambda (form rename compare?)
       (let ((a (cadr form))
	     (b (caddr form)))
	 (if (= a 0) b `(inc (plusF ,(dec a) ,b)))))))
  (macroexpand '(plusF 4 5))
#+end_src

#+RESULTS[89b3e6aefac6879eb2765be04fab78cea7585908]: example-substitution-first
#+begin_src scheme
(inc (inc (inc (inc 5))))
#+end_src




We can see that the macro expander has expanded the computation in to
a tree of length 4. This happens because the algorithm is genuinely
recursive, the return value is not produced by a call to itself, and
therefore recursion cannot be tail-optimized.

#+name: example-substitution-second
#+begin_src scheme :exports both :results value scalar code
  (define (inc x)
    (+ 1 x))
  (define (dec x)
    (- x 1))
  (define-syntax plusS
    (er-macro-transformer
     (lambda (form rename compare?)
       (let ((a (cadr form))
	     (b (caddr form)))
	 (if (= a 0) b `(plusS ,(dec a) ,(inc b)))))))
  (macroexpand '(plusS 4 5))
#+end_src

#+RESULTS[4dd2dcbc21ea81566e3f5f7b332337390ef45149]: example-substitution-second
#+begin_src scheme
9
#+end_src


We can clearly see the difference. The first macro is genuinely
recursive, it expands to a series of calls, and needs to keep the
information about this calls on the stack. The second one is actually
iterative. The macro call only happens as the last step, and no
information is kept, as the return value will be just the last result,
so this macro is expanded until it's just a number.

*** DONE Exercise 1.10 Ackermann's function
    CLOSED: [2019-08-25 Sun 18:31]
Let's run the demos first:
#+name: ackerman
#+begin_src scheme :exports both :results output scalar code
  <<common>>
  (define (A x y)
    (cond ((= y 0.0) 0.0)
	  ((= x 0.0) (* 2.0 y))
	  ((= y 1.0) 2.0)
	  (else (A (- x 1.0) (A x (- y 1.0))))))
  (disp (A 1 10))
  (disp (A 2 4))
  (disp (A 3 3))
#+end_src

#+RESULTS[9d919963b9a54f499af7e5bd320ceae158d3bd2e]: ackerman
#+begin_src scheme
1024.0
65536.0
65536.0
#+end_src

The values of these expressions are listed above.

#+begin_src scheme :exports code :results none
  (define (f n) (A 0 n))
  (define (g n) (A 1 n))
  (define (h n) (A 2 n))
  (define (k n) (* 5 n n))
#+end_src

The mathematical expressions for these formulae are:
\begin{eqnarray}
\label{eq:3}
f(n) & = & 2y\\
g(n) & = & 2^y \\
h(n) & = & 2^{2^n}\\
k(n) & = & 5n^2\\
\end{eqnarray}

Actually this is not the Ackermann's function as it is most often
defined, for example, see
[[http://mathworld.wolfram.com/AckermannFunction.html]]. But the
recurrent relation is the same. This version of the Ackermann's
function seems to be equivalent to the powers tower.

I may have lied with the coefficients, but essentially, the
Ackermann's function with parameters $n$ and $m$ works by applying the
n-the hyperoperator m times to 2. A hyperoperator is a generalization
of the standard matematical operator sequence `+', `*', `^', see
[[https://googology.wikia.org/wiki/Hyper_operator]]

*** DONE Exercise 1.11 Recursive vs iterative
    CLOSED: [2019-08-25 Sun 19:25]

\begin{equation}
\label{eq:4}
f(n)=\left\{
\begin{array}{l@{\quad:\quad}l}
n & n<3\\
f(n-1) + 2f(n-2) + 3f(n-3) & \ge 3
\end{array}\right.
\end{equation}

#+begin_src scheme :exports both :results value scalar code
    (define (f-recursive n)
      (cond ((< n 3) n)
	    (else
	     (+
	      (f-recursive (- n 1))
	      (* 2 (f-recursive (- n 2)))
	      (* 3 (f-recursive (- n 3)))))))
    (f-recursive 7)
#+end_src

#+RESULTS[fc162b8b87953eb45df21c1e85cb44a05a453e1c]:
#+begin_src scheme
142
#+end_src

#+begin_src scheme :exports both :results value scalar code
  (define (f-iter m n fn-1 fn-2 fn-3)
    (let ((fn (+ fn-1 (* 2 fn-2) (* 3 fn-3))))
      (cond ((= m n) fn)
	     (else (f-iter m (+ n 1) fn fn-1 fn-2)))))

  (define (f-iterative n)
    (cond ((< n 3) n)
	  (else (f-iter n 3 2 1 0))))

  (f-iterative 7)
#+end_src

#+RESULTS[47ae9af31837d805987fe87ef3852b1e16b4b7af]:
#+begin_src scheme
142
#+end_src

*** DONE Exercise 1.12 Recursive Pascal's triangle
    CLOSED: [2019-08-25 Sun 19:42]

\begin{tabular}{rcccccccccc}
 &    &    &    &    &  1\\\noalign{\smallskip\smallskip}
 &    &    &    &  1 &    &  1\\\noalign{\smallskip\smallskip}
 &    &    &  1 &    &  2 &    &  1\\\noalign{\smallskip\smallskip}
 &    &  1 &    &  3 &    &  3 &    &  1\\\noalign{\smallskip\smallskip}
 &  1 &    &  4 &    &  6 &    &  4 &    &  1\\\noalign{\smallskip\smallskip}
 &    &    &    &  . &  . &  . &    &    &   &   \\\noalign{\smallskip\smallskip}
\end{tabular}

#+BEGIN_SRC scheme :exports both :results value scalar code
    (define (pascal-number line-number column-number)
      (cond ((= line-number 1) 1)
	    ((= line-number 2) 1)
	    ((= column-number 1) 1)
	    ((= column-number line-number) 1)
	    (else (+
		   (pascal-number (- line-number 1) (- column-number 1))
		   (pascal-number (- line-number 1) column-number)))))
    (pascal-number 5 3)
#+END_SRC

#+RESULTS[9a6f69b84f01e6094fb141209bd10f698c9c9369]:
#+begin_src scheme
6
#+end_src

*** DONE Exercise 1.13 Fibonacci
    CLOSED: [2019-08-25 Sun 21:54]

\begin{equation}
\mbox{Fib}(n) = \left\{
\begin{array}{l@{\quad:\quad}l}
0 & n=0 \\
1 & n=1 \\
\mbox{Fib} (n-1) + \mbox{Fib} (n-2) & \mbox{otherwise} \\
\end{array}\right\}
\end{equation}

Abelson and Sussman define \( \varphi=(1+\sqrt{5})/2\) and \(\psi=(1-\sqrt{5})/2\).

Knowing that \( \mbox{Fib}(n) = (\varphi^{n} - \psi^n)/\sqrt{5}\) is almost all the
problem done, because \(\psi\) is clearly less than \(1\), so for large
\(n\) it will be exponentially close to \(0\), and this is where the
``closest integer'' comes from.

Let us prove the rest by induction.
\begin{eqnarray}
\label{eq:13}
\frac{\varphi^{n-1} - \psi^{n-1} + \varphi^{n-2} - \psi^{n-2}}{\sqrt{5}} & = & \frac{\varphi^{n} - \psi^{n}}{\sqrt{5}}\\
\varphi^{n-1} - \psi^{n-1} + \varphi^{n-2} - \psi^{n-2} & = & \varphi^{n} - \psi^{n} \\
(\varphi + 1)\varphi^{n-2} - (\psi + 1)\psi^{n-2} & = &  \varphi^{n} - \psi^{n}\\
(\varphi + 1 - \varphi^2)\varphi^{n-2} & = &  (\psi + 1 - \psi^2)\psi^{n-2}\\
(\frac{1+\sqrt{5}}{2} + 1 - (\frac{1+\sqrt{5}}{2})^2)\varphi^{n-2} & = &
(\frac{1-\sqrt{5}}{2} + 1 - (\frac{1-\sqrt{5}}{2}))\psi^{n-2} \\
(\frac{2+2\sqrt{5}}{4} + \frac{4}{4} - \frac{1+2\sqrt{5}+5}{4})\varphi^{n-2} & = &
(\frac{2-2\sqrt{5}}{4} + \frac{4}{4} - \frac{1-2\sqrt{5}+5}{4})\psi^{n-2}\\
0 & = & 0
\end{eqnarray}

This proves that the recurrent relation for \(\frac{\varphi^n-\psi^n}{\sqrt{5}}\) is the
same as for the Fibonacci sequence. Then if we prove that there exist
such \(n\) and \(n-1\) so that \(\mbox{Fib}(n) =
\frac{\varphi^n-\psi^n}{\sqrt{5}}\), then we're done.

Indeed, let's have a look at \(n=1\): \(\frac{1+\sqrt{5}}{2
\sqrt{5}} - \frac{1-\sqrt{5}}{2 \sqrt{5}} = 1\); and \(n=0\): \(
\frac{1-1}{\sqrt{5}} = 0\).

*** DONE Exercise 1.14 count-change              :macro:er_macro_transformer:
    CLOSED: [2019-08-30 Fri 16:09]

Let us use the non-standard but common er-macro-transformer to plot
the execution tree.

#+begin_src scheme :exports both :results output scalar code
  (define-syntax cc
    (er-macro-transformer
     (lambda (form rename compare?)
       (let ((amount (cadr form))
	     (kinds-of-coins (caddr form)))
	 (cond ((= amount 0) 1)
	       ((or (< amount 0) (= kinds-of-coins 0)) 0)
	       (`(+ (cc ,amount
			,(- kinds-of-coins 1))
		    (cc ,(- amount
			    (first-denomination
			     kinds-of-coins))
			,kinds-of-coins))))))))
  (define (first-denomination kinds-of-coins)
    (cond ((= kinds-of-coins 1) 1)
	  ((= kinds-of-coins 2) 5)
	  ((= kinds-of-coins 3) 10)
	  ((= kinds-of-coins 4) 25)
	  ((= kinds-of-coins 5) 50)))
(show #t " "(pretty (macroexpand '(cc 11 5))))
#+end_src

#+RESULTS[3388aa5593845ac6e0e2d0c5c6607b680b85d921]:
#+begin_src scheme
 (+
  (+
   (+
    (+ (+ 0 (+ 0 (+ 0 (+ 0 (+ 0 (+ 0 (+ 0 (+ 0 (+ 0 (+ 0 (+ 0 1)))))))))))
       (+ (+ 0 (+ 0 (+ 0 (+ 0 (+ 0 (+ 0 1)))))) (+ (+ 0 1) 0)))
    (+ (+ (+ 0 1) 0) 0))
   0)
  0)
#+end_src


Initially I wrote the same code in Emacs Lisp, I am leaving it here
for future reference.

#+name: count-change-elisp
#+begin_src elisp :exports both :results output
    (defmacro cc (amount kinds-of-coins)
      (cond ((= amount 0) 1)
	    ((or (< amount 0) (= kinds-of-coins 0)) 0)
	    (`(+ (cc ,amount
		    ,(- kinds-of-coins 1))
		(cc ,(- amount
		       (first-denomination
			kinds-of-coins))
		    ,kinds-of-coins)))))
  (defun first-denomination (kinds-of-coins)
    (cond ((= kinds-of-coins 1) 1)
	  ((= kinds-of-coins 2) 5)
	  ((= kinds-of-coins 3) 10)
	  ((= kinds-of-coins 4) 25)
	  ((= kinds-of-coins 5) 50)))
  (pp (macroexpand-all '(cc 11 5)))

#+end_src

#+RESULTS[25f217f5d49c51cfba0dfc407311cf9b15404653]: count-change-elisp
#+begin_example
(+
 (+
  (+
   (+
    (+ 0
       (+ 0
	  (+ 0
	     (+ 0
		(+ 0
		   (+ 0
		      (+ 0
			 (+ 0
			    (+ 0
			       (+ 0
				  (+ 0 1)))))))))))
    (+
     (+ 0
	(+ 0
	   (+ 0
	      (+ 0
		 (+ 0
		    (+ 0 1))))))
     (+
      (+ 0 1)
      0)))
   (+
    (+
     (+ 0 1)
     0)
    0))
  0)
 0)
#+end_example

The space complexity of the algorithm will be dominated by the depth
of the tree — that is the value to be changed, as there is no need to
keep any additional information.

The time complexity can be estimated as follows: for every additional
value the algorithm will have to go through all passes of the
algorithm without an additional denomination, times the amount divided
by the value of an additional denomination. We can consider the
additional denomination value as a constant, and the amount of steps
for the simplest case of only one denomination is the
amount. Therefore, the algorithm is linear in amount and exponential
in the number of denominations.

\begin{equation}
\label{eq:14}
C = \Theta(n^a)
\end{equation}

*** DONE Exercise 1.15 sine                      :macro:er_macro_transformer:
    CLOSED: [2019-08-30 Fri 22:34]

First let us code this thing:

Loop version:

#+begin_src scheme :exports both :results output code
  (define niter 0)
  (define (cube x) (* x x x))
  (define (p x)
    (set! niter (+ niter 1))
    (- (* 3 x) (* 4 (cube x))))
  (define (sine angle)
    (if (not (> (abs angle) 0.1))
	angle
	(p (sine (/ angle 3.0)))))
  (display "sine=" )
  (display (sine 12.15))
  (newline)
  (display "niter=")
  (display niter)
#+end_src

#+RESULTS[134df2e3aab487f9386ebcede852d59fd6dcdc90]:
#+begin_src scheme
sine=-0.39980345741334
niter=5
#+end_src

Let's have the macro system expand this for us.

#+begin_src scheme :exports both :results output code
  (define (cube x)
    (* x x x))
  (define (p x)
    (- (* 3  x)
       (* 4 (cube x))))
  (define-syntax sine
    (er-macro-transformer
     (lambda (form rename compare?)
       (let ((a (cadr form)))
	 (if (< (abs a) 0.1)
	     a
	     `(p (sine ,(/ a 3))))))))
  (show #t " " (pretty (macroexpand '(sine 12.15))))

#+end_src

#+RESULTS[3c266950ae07a244ce7693e9fa1ec01ae733da81]:
#+begin_src scheme
 (p (p (p (p (p 0.049999999999999996)))))
#+end_src

Theoretically, we can expand everything at once.

#+begin_src scheme :exports both :results output code
  (define-syntax cube
    (er-macro-transformer
     (lambda (form rename compare?)
       (let ((x (cadr form)))
	 `(* ,x ,x ,x)))))
  (define-syntax p
    (er-macro-transformer
     (lambda (form rename compare?)
       (let ((x (cadr form)))
	 `(- (* 3 ,x)
	     (* 4 (cube ,x)))))))
  (define-syntax sine
    (er-macro-transformer
     (lambda (form rename compare?)
       (let ((a (cadr form)))
	 (if (< (abs a) 0.1)
	     a
	     `(p (sine ,(/ a 3))))))))
  (show #t " " (pretty (macroexpand '(sine 12.15))))
#+end_src

#+RESULTS[a15b68722af64f7f5f78d197a9b7845f70f40d21]:
#+begin_src scheme
 (-
  (* 3
     (-
      (* 3
         (-
          (* 3
             (-
              (* 3
                 (- (* 3 0.049999999999999996)
                    (* 4
                       (* 0.049999999999999996
                          0.049999999999999996
                          0.049999999999999996))))
              (* 4
                 (*
                  (- (* 3 0.049999999999999996)
                     (* 4
                        (* 0.049999999999999996
                           0.049999999999999996
                           0.049999999999999996)))
                  (- (* 3 0.049999999999999996)
                     (* 4
                        (* 0.049999999999999996
                           0.049999999999999996
                           0.049999999999999996)))
                  (- (* 3 0.049999999999999996)
                     (* 4
                        (* 0.049999999999999996
                           0.049999999999999996
                           0.049999999999999996)))))))
          (* 4
             (*
              (-
               (* 3
                  (- (* 3 0.049999999999999996)
                     (* 4
                        (* 0.049999999999999996
                           0.049999999999999996
                           0.049999999999999996))))
               (* 4
                  (*
                   (- (* 3 0.049999999999999996)
                      (* 4
                         (* 0.049999999999999996
                            0.049999999999999996
                            0.049999999999999996)))
                   (- (* 3 0.049999999999999996)
                      (* 4
                         (* 0.049999999999999996
                            0.049999999999999996
                            0.049999999999999996)))
                   (- (* 3 0.049999999999999996)
                      (* 4
                         (* 0.049999999999999996
                            0.049999999999999996
                            0.049999999999999996))))))
              (-
               (* 3
                  (- (* 3 0.049999999999999996)
                     (* 4
                        (* 0.049999999999999996
                           0.049999999999999996
                           0.049999999999999996))))
               (* 4
                  (*
                   (- (* 3 0.049999999999999996)
                      (* 4
                         (* 0.049999999999999996
                            0.049999999999999996
                            0.049999999999999996)))
                   (- (* 3 0.049999999999999996)
                      (* 4
                         (* 0.049999999999999996
                            0.049999999999999996
                            0.049999999999999996)))
                   (- (* 3 0.049999999999999996)
                      (* 4
                         (* 0.049999999999999996
                            0.049999999999999996
                            0.049999999999999996))))))
              (-
               (* 3
                  (- (* 3 0.049999999999999996)
                     (* 4
                        (* 0.049999999999999996
                           0.049999999999999996
                           0.049999999999999996))))
               (* 4
                  (*
                   (- (* 3 0.049999999999999996)
                      (* 4
                         (* 0.049999999999999996
                            0.049999999999999996
                            0.049999999999999996)))
                   (- (* 3 0.049999999999999996)
                      (* 4
                         (* 0.049999999999999996
                            0.049999999999999996
                            0.049999999999999996)))
                   (- (* 3 0.049999999999999996)
                      (* 4
                         (* 0.049999999999999996
                            0.049999999999999996
                            0.049999999999999996))))))))))
      (* 4
         (*
          (-
           (* 3
              (-
               (* 3
                  (- (* 3 0.049999999999999996)
                     (* 4
                        (* 0.049999999999999996
                           0.049999999999999996
                           0.049999999999999996))))
               (* 4
                  (*
                   (- (* 3 0.049999999999999996)
                      (* 4
                         (* 0.049999999999999996
                            0.049999999999999996
                            0.049999999999999996)))
                   (- (* 3 0.049999999999999996)
                      (* 4
                         (* 0.049999999999999996
                            0.049999999999999996
                            0.049999999999999996)))
                   (- (* 3 0.049999999999999996)
                      (* 4
                         (* 0.049999999999999996
                            0.049999999999999996
                            0.049999999999999996)))))))
           (* 4
              (*
               (-
                (* 3
                   (- (* 3 0.049999999999999996)
                      (* 4
                         (* 0.049999999999999996
                            0.049999999999999996
                            0.049999999999999996))))
                (* 4
                   (*
                    (- (* 3 0.049999999999999996)
                       (* 4
                          (* 0.049999999999999996
                             0.049999999999999996
                             0.049999999999999996)))
                    (- (* 3 0.049999999999999996)
                       (* 4
                          (* 0.049999999999999996
                             0.049999999999999996
                             0.049999999999999996)))
                    (- (* 3 0.049999999999999996)
                       (* 4
                          (* 0.049999999999999996
                             0.049999999999999996
                             0.049999999999999996))))))
               (-
                (* 3
                   (- (* 3 0.049999999999999996)
                      (* 4
                         (* 0.049999999999999996
                            0.049999999999999996
                            0.049999999999999996))))
                (* 4
                   (*
                    (- (* 3 0.049999999999999996)
                       (* 4
                          (* 0.049999999999999996
                             0.049999999999999996
                             0.049999999999999996)))
                    (- (* 3 0.049999999999999996)
                       (* 4
                          (* 0.049999999999999996
                             0.049999999999999996
                             0.049999999999999996)))
                    (- (* 3 0.049999999999999996)
                       (* 4
                          (* 0.049999999999999996
                             0.049999999999999996
                             0.049999999999999996))))))
               (-
                (* 3
                   (- (* 3 0.049999999999999996)
                      (* 4
                         (* 0.049999999999999996
                            0.049999999999999996
                            0.049999999999999996))))
                (* 4
                   (*
                    (- (* 3 0.049999999999999996)
                       (* 4
                          (* 0.049999999999999996
                             0.049999999999999996
                             0.049999999999999996)))
                    (- (* 3 0.049999999999999996)
                       (* 4
                          (* 0.049999999999999996
                             0.049999999999999996
                             0.049999999999999996)))
                    (- (* 3 0.049999999999999996)
                       (* 4
                          (* 0.049999999999999996
                             0.049999999999999996
                             0.049999999999999996)))))))))
          (-
           (* 3
              (-
               (* 3
                  (- (* 3 0.049999999999999996)
                     (* 4
                        (* 0.049999999999999996
                           0.049999999999999996
                           0.049999999999999996))))
               (* 4
                  (*
                   (- (* 3 0.049999999999999996)
                      (* 4
                         (* 0.049999999999999996
                            0.049999999999999996
                            0.049999999999999996)))
                   (- (* 3 0.049999999999999996)
                      (* 4
                         (* 0.049999999999999996
                            0.049999999999999996
                            0.049999999999999996)))
                   (- (* 3 0.049999999999999996)
                      (* 4
                         (* 0.049999999999999996
                            0.049999999999999996
                            0.049999999999999996)))))))
           (* 4
              (*
               (-
                (* 3
                   (- (* 3 0.049999999999999996)
                      (* 4
                         (* 0.049999999999999996
                            0.049999999999999996
                            0.049999999999999996))))
                (* 4
                   (*
                    (- (* 3 0.049999999999999996)
                       (* 4
                          (* 0.049999999999999996
                             0.049999999999999996
                             0.049999999999999996)))
                    (- (* 3 0.049999999999999996)
                       (* 4
                          (* 0.049999999999999996
                             0.049999999999999996
                             0.049999999999999996)))
                    (- (* 3 0.049999999999999996)
                       (* 4
                          (* 0.049999999999999996
                             0.049999999999999996
                             0.049999999999999996))))))
               (-
                (* 3
                   (- (* 3 0.049999999999999996)
                      (* 4
                         (* 0.049999999999999996
                            0.049999999999999996
                            0.049999999999999996))))
                (* 4
                   (*
                    (- (* 3 0.049999999999999996)
                       (* 4
                          (* 0.049999999999999996
                             0.049999999999999996
                             0.049999999999999996)))
                    (- (* 3 0.049999999999999996)
                       (* 4
                          (* 0.049999999999999996
                             0.049999999999999996
                             0.049999999999999996)))
                    (- (* 3 0.049999999999999996)
                       (* 4
                          (* 0.049999999999999996
                             0.049999999999999996
                             0.049999999999999996))))))
               (-
                (* 3
                   (- (* 3 0.049999999999999996)
                      (* 4
                         (* 0.049999999999999996
                            0.049999999999999996
                            0.049999999999999996))))
                (* 4
                   (*
                    (- (* 3 0.049999999999999996)
                       (* 4
                          (* 0.049999999999999996
                             0.049999999999999996
                             0.049999999999999996)))
                    (- (* 3 0.049999999999999996)
                       (* 4
                          (* 0.049999999999999996
                             0.049999999999999996
                             0.049999999999999996)))
                    (- (* 3 0.049999999999999996)
                       (* 4
                          (* 0.049999999999999996
                             0.049999999999999996
                             0.049999999999999996)))))))))
          (-
           (* 3
              (-
               (* 3
                  (- (* 3 0.049999999999999996)
                     (* 4
                        (* 0.049999999999999996
                           0.049999999999999996
                           0.049999999999999996))))
               (* 4
                  (*
                   (- (* 3 0.049999999999999996)
                      (* 4
                         (* 0.049999999999999996
                            0.049999999999999996
                            0.049999999999999996)))
                   (- (* 3 0.049999999999999996)
                      (* 4
                         (* 0.049999999999999996
                            0.049999999999999996
                            0.049999999999999996)))
                   (- (* 3 0.049999999999999996)
                      (* 4
                         (* 0.049999999999999996
                            0.049999999999999996
                            0.049999999999999996)))))))
           (* 4
              (*
               (-
                (* 3
                   (- (* 3 0.049999999999999996)
                      (* 4
                         (* 0.049999999999999996
                            0.049999999999999996
                            0.049999999999999996))))
                (* 4
                   (*
                    (- (* 3 0.049999999999999996)
                       (* 4
                          (* 0.049999999999999996
                             0.049999999999999996
                             0.049999999999999996)))
                    (- (* 3 0.049999999999999996)
                       (* 4
                          (* 0.049999999999999996
                             0.049999999999999996
                             0.049999999999999996)))
                    (- (* 3 0.049999999999999996)
                       (* 4
                          (* 0.049999999999999996
                             0.049999999999999996
                             0.049999999999999996))))))
               (-
                (* 3
                   (- (* 3 0.049999999999999996)
                      (* 4
                         (* 0.049999999999999996
                            0.049999999999999996
                            0.049999999999999996))))
                (* 4
                   (*
                    (- (* 3 0.049999999999999996)
                       (* 4
                          (* 0.049999999999999996
                             0.049999999999999996
                             0.049999999999999996)))
                    (- (* 3 0.049999999999999996)
                       (* 4
                          (* 0.049999999999999996
                             0.049999999999999996
                             0.049999999999999996)))
                    (- (* 3 0.049999999999999996)
                       (* 4
                          (* 0.049999999999999996
                             0.049999999999999996
                             0.049999999999999996))))))
               (-
                (* 3
                   (- (* 3 0.049999999999999996)
                      (* 4
                         (* 0.049999999999999996
                            0.049999999999999996
                            0.049999999999999996))))
                (* 4
                   (*
                    (- (* 3 0.049999999999999996)
                       (* 4
                          (* 0.049999999999999996
                             0.049999999999999996
                             0.049999999999999996)))
                    (- (* 3 0.049999999999999996)
                       (* 4
                          (* 0.049999999999999996
                             0.049999999999999996
                             0.049999999999999996)))
                    (- (* 3 0.049999999999999996)
                       (* 4
                          (* 0.049999999999999996
                             0.049999999999999996
                             0.049999999999999996)))))))))))))
  (* 4
     (*
      (-
       (* 3
          (-
           (* 3
              (-
               (* 3
                  (- (* 3 0.049999999999999996)
                     (* 4
                        (* 0.049999999999999996
                           0.049999999999999996
                           0.049999999999999996))))
               (* 4
                  (*
                   (- (* 3 0.049999999999999996)
                      (* 4
                         (* 0.049999999999999996
                            0.049999999999999996
                            0.049999999999999996)))
                   (- (* 3 0.049999999999999996)
                      (* 4
                         (* 0.049999999999999996
                            0.049999999999999996
                            0.049999999999999996)))
                   (- (* 3 0.049999999999999996)
                      (* 4
                         (* 0.049999999999999996
                            0.049999999999999996
                            0.049999999999999996)))))))
           (* 4
              (*
               (-
                (* 3
                   (- (* 3 0.049999999999999996)
                      (* 4
                         (* 0.049999999999999996
                            0.049999999999999996
                            0.049999999999999996))))
                (* 4
                   (*
                    (- (* 3 0.049999999999999996)
                       (* 4
                          (* 0.049999999999999996
                             0.049999999999999996
                             0.049999999999999996)))
                    (- (* 3 0.049999999999999996)
                       (* 4
                          (* 0.049999999999999996
                             0.049999999999999996
                             0.049999999999999996)))
                    (- (* 3 0.049999999999999996)
                       (* 4
                          (* 0.049999999999999996
                             0.049999999999999996
                             0.049999999999999996))))))
               (-
                (* 3
                   (- (* 3 0.049999999999999996)
                      (* 4
                         (* 0.049999999999999996
                            0.049999999999999996
                            0.049999999999999996))))
                (* 4
                   (*
                    (- (* 3 0.049999999999999996)
                       (* 4
                          (* 0.049999999999999996
                             0.049999999999999996
                             0.049999999999999996)))
                    (- (* 3 0.049999999999999996)
                       (* 4
                          (* 0.049999999999999996
                             0.049999999999999996
                             0.049999999999999996)))
                    (- (* 3 0.049999999999999996)
                       (* 4
                          (* 0.049999999999999996
                             0.049999999999999996
                             0.049999999999999996))))))
               (-
                (* 3
                   (- (* 3 0.049999999999999996)
                      (* 4
                         (* 0.049999999999999996
                            0.049999999999999996
                            0.049999999999999996))))
                (* 4
                   (*
                    (- (* 3 0.049999999999999996)
                       (* 4
                          (* 0.049999999999999996
                             0.049999999999999996
                             0.049999999999999996)))
                    (- (* 3 0.049999999999999996)
                       (* 4
                          (* 0.049999999999999996
                             0.049999999999999996
                             0.049999999999999996)))
                    (- (* 3 0.049999999999999996)
                       (* 4
                          (* 0.049999999999999996
                             0.049999999999999996
                             0.049999999999999996))))))))))
       (* 4
          (*
           (-
            (* 3
               (-
                (* 3
                   (- (* 3 0.049999999999999996)
                      (* 4
                         (* 0.049999999999999996
                            0.049999999999999996
                            0.049999999999999996))))
                (* 4
                   (*
                    (- (* 3 0.049999999999999996)
                       (* 4
                          (* 0.049999999999999996
                             0.049999999999999996
                             0.049999999999999996)))
                    (- (* 3 0.049999999999999996)
                       (* 4
                          (* 0.049999999999999996
                             0.049999999999999996
                             0.049999999999999996)))
                    (- (* 3 0.049999999999999996)
                       (* 4
                          (* 0.049999999999999996
                             0.049999999999999996
                             0.049999999999999996)))))))
            (* 4
               (*
                (-
                 (* 3
                    (- (* 3 0.049999999999999996)
                       (* 4
                          (* 0.049999999999999996
                             0.049999999999999996
                             0.049999999999999996))))
                 (* 4
                    (*
                     (- (* 3 0.049999999999999996)
                        (* 4
                           (* 0.049999999999999996
                              0.049999999999999996
                              0.049999999999999996)))
                     (- (* 3 0.049999999999999996)
                        (* 4
                           (* 0.049999999999999996
                              0.049999999999999996
                              0.049999999999999996)))
                     (- (* 3 0.049999999999999996)
                        (* 4
                           (* 0.049999999999999996
                              0.049999999999999996
                              0.049999999999999996))))))
                (-
                 (* 3
                    (- (* 3 0.049999999999999996)
                       (* 4
                          (* 0.049999999999999996
                             0.049999999999999996
                             0.049999999999999996))))
                 (* 4
                    (*
                     (- (* 3 0.049999999999999996)
                        (* 4
                           (* 0.049999999999999996
                              0.049999999999999996
                              0.049999999999999996)))
                     (- (* 3 0.049999999999999996)
                        (* 4
                           (* 0.049999999999999996
                              0.049999999999999996
                              0.049999999999999996)))
                     (- (* 3 0.049999999999999996)
                        (* 4
                           (* 0.049999999999999996
                              0.049999999999999996
                              0.049999999999999996))))))
                (-
                 (* 3
                    (- (* 3 0.049999999999999996)
                       (* 4
                          (* 0.049999999999999996
                             0.049999999999999996
                             0.049999999999999996))))
                 (* 4
                    (*
                     (- (* 3 0.049999999999999996)
                        (* 4
                           (* 0.049999999999999996
                              0.049999999999999996
                              0.049999999999999996)))
                     (- (* 3 0.049999999999999996)
                        (* 4
                           (* 0.049999999999999996
                              0.049999999999999996
                              0.049999999999999996)))
                     (- (* 3 0.049999999999999996)
                        (* 4
                           (* 0.049999999999999996
                              0.049999999999999996
                              0.049999999999999996)))))))))
           (-
            (* 3
               (-
                (* 3
                   (- (* 3 0.049999999999999996)
                      (* 4
                         (* 0.049999999999999996
                            0.049999999999999996
                            0.049999999999999996))))
                (* 4
                   (*
                    (- (* 3 0.049999999999999996)
                       (* 4
                          (* 0.049999999999999996
                             0.049999999999999996
                             0.049999999999999996)))
                    (- (* 3 0.049999999999999996)
                       (* 4
                          (* 0.049999999999999996
                             0.049999999999999996
                             0.049999999999999996)))
                    (- (* 3 0.049999999999999996)
                       (* 4
                          (* 0.049999999999999996
                             0.049999999999999996
                             0.049999999999999996)))))))
            (* 4
               (*
                (-
                 (* 3
                    (- (* 3 0.049999999999999996)
                       (* 4
                          (* 0.049999999999999996
                             0.049999999999999996
                             0.049999999999999996))))
                 (* 4
                    (*
                     (- (* 3 0.049999999999999996)
                        (* 4
                           (* 0.049999999999999996
                              0.049999999999999996
                              0.049999999999999996)))
                     (- (* 3 0.049999999999999996)
                        (* 4
                           (* 0.049999999999999996
                              0.049999999999999996
                              0.049999999999999996)))
                     (- (* 3 0.049999999999999996)
                        (* 4
                           (* 0.049999999999999996
                              0.049999999999999996
                              0.049999999999999996))))))
                (-
                 (* 3
                    (- (* 3 0.049999999999999996)
                       (* 4
                          (* 0.049999999999999996
                             0.049999999999999996
                             0.049999999999999996))))
                 (* 4
                    (*
                     (- (* 3 0.049999999999999996)
                        (* 4
                           (* 0.049999999999999996
                              0.049999999999999996
                              0.049999999999999996)))
                     (- (* 3 0.049999999999999996)
                        (* 4
                           (* 0.049999999999999996
                              0.049999999999999996
                              0.049999999999999996)))
                     (- (* 3 0.049999999999999996)
                        (* 4
                           (* 0.049999999999999996
                              0.049999999999999996
                              0.049999999999999996))))))
                (-
                 (* 3
                    (- (* 3 0.049999999999999996)
                       (* 4
                          (* 0.049999999999999996
                             0.049999999999999996
                             0.049999999999999996))))
                 (* 4
                    (*
                     (- (* 3 0.049999999999999996)
                        (* 4
                           (* 0.049999999999999996
                              0.049999999999999996
                              0.049999999999999996)))
                     (- (* 3 0.049999999999999996)
                        (* 4
                           (* 0.049999999999999996
                              0.049999999999999996
                              0.049999999999999996)))
                     (- (* 3 0.049999999999999996)
                        (* 4
                           (* 0.049999999999999996
                              0.049999999999999996
                              0.049999999999999996)))))))))
           (-
            (* 3
               (-
                (* 3
                   (- (* 3 0.049999999999999996)
                      (* 4
                         (* 0.049999999999999996
                            0.049999999999999996
                            0.049999999999999996))))
                (* 4
                   (*
                    (- (* 3 0.049999999999999996)
                       (* 4
                          (* 0.049999999999999996
                             0.049999999999999996
                             0.049999999999999996)))
                    (- (* 3 0.049999999999999996)
                       (* 4
                          (* 0.049999999999999996
                             0.049999999999999996
                             0.049999999999999996)))
                    (- (* 3 0.049999999999999996)
                       (* 4
                          (* 0.049999999999999996
                             0.049999999999999996
                             0.049999999999999996)))))))
            (* 4
               (*
                (-
                 (* 3
                    (- (* 3 0.049999999999999996)
                       (* 4
                          (* 0.049999999999999996
                             0.049999999999999996
                             0.049999999999999996))))
                 (* 4
                    (*
                     (- (* 3 0.049999999999999996)
                        (* 4
                           (* 0.049999999999999996
                              0.049999999999999996
                              0.049999999999999996)))
                     (- (* 3 0.049999999999999996)
                        (* 4
                           (* 0.049999999999999996
                              0.049999999999999996
                              0.049999999999999996)))
                     (- (* 3 0.049999999999999996)
                        (* 4
                           (* 0.049999999999999996
                              0.049999999999999996
                              0.049999999999999996))))))
                (-
                 (* 3
                    (- (* 3 0.049999999999999996)
                       (* 4
                          (* 0.049999999999999996
                             0.049999999999999996
                             0.049999999999999996))))
                 (* 4
                    (*
                     (- (* 3 0.049999999999999996)
                        (* 4
                           (* 0.049999999999999996
                              0.049999999999999996
                              0.049999999999999996)))
                     (- (* 3 0.049999999999999996)
                        (* 4
                           (* 0.049999999999999996
                              0.049999999999999996
                              0.049999999999999996)))
                     (- (* 3 0.049999999999999996)
                        (* 4
                           (* 0.049999999999999996
                              0.049999999999999996
                              0.049999999999999996))))))
                (-
                 (* 3
                    (- (* 3 0.049999999999999996)
                       (* 4
                          (* 0.049999999999999996
                             0.049999999999999996
                             0.049999999999999996))))
                 (* 4
                    (*
                     (- (* 3 0.049999999999999996)
                        (* 4
                           (* 0.049999999999999996
                              0.049999999999999996
                              0.049999999999999996)))
                     (- (* 3 0.049999999999999996)
                        (* 4
                           (* 0.049999999999999996
                              0.049999999999999996
                              0.049999999999999996)))
                     (- (* 3 0.049999999999999996)
                        (* 4
                           (* 0.049999999999999996
                              0.049999999999999996
                              0.049999999999999996))))))))))))
      (-
       (* 3
          (-
           (* 3
              (-
               (* 3
                  (- (* 3 0.049999999999999996)
                     (* 4
                        (* 0.049999999999999996
                           0.049999999999999996
                           0.049999999999999996))))
               (* 4
                  (*
                   (- (* 3 0.049999999999999996)
                      (* 4
                         (* 0.049999999999999996
                            0.049999999999999996
                            0.049999999999999996)))
                   (- (* 3 0.049999999999999996)
                      (* 4
                         (* 0.049999999999999996
                            0.049999999999999996
                            0.049999999999999996)))
                   (- (* 3 0.049999999999999996)
                      (* 4
                         (* 0.049999999999999996
                            0.049999999999999996
                            0.049999999999999996)))))))
           (* 4
              (*
               (-
                (* 3
                   (- (* 3 0.049999999999999996)
                      (* 4
                         (* 0.049999999999999996
                            0.049999999999999996
                            0.049999999999999996))))
                (* 4
                   (*
                    (- (* 3 0.049999999999999996)
                       (* 4
                          (* 0.049999999999999996
                             0.049999999999999996
                             0.049999999999999996)))
                    (- (* 3 0.049999999999999996)
                       (* 4
                          (* 0.049999999999999996
                             0.049999999999999996
                             0.049999999999999996)))
                    (- (* 3 0.049999999999999996)
                       (* 4
                          (* 0.049999999999999996
                             0.049999999999999996
                             0.049999999999999996))))))
               (-
                (* 3
                   (- (* 3 0.049999999999999996)
                      (* 4
                         (* 0.049999999999999996
                            0.049999999999999996
                            0.049999999999999996))))
                (* 4
                   (*
                    (- (* 3 0.049999999999999996)
                       (* 4
                          (* 0.049999999999999996
                             0.049999999999999996
                             0.049999999999999996)))
                    (- (* 3 0.049999999999999996)
                       (* 4
                          (* 0.049999999999999996
                             0.049999999999999996
                             0.049999999999999996)))
                    (- (* 3 0.049999999999999996)
                       (* 4
                          (* 0.049999999999999996
                             0.049999999999999996
                             0.049999999999999996))))))
               (-
                (* 3
                   (- (* 3 0.049999999999999996)
                      (* 4
                         (* 0.049999999999999996
                            0.049999999999999996
                            0.049999999999999996))))
                (* 4
                   (*
                    (- (* 3 0.049999999999999996)
                       (* 4
                          (* 0.049999999999999996
                             0.049999999999999996
                             0.049999999999999996)))
                    (- (* 3 0.049999999999999996)
                       (* 4
                          (* 0.049999999999999996
                             0.049999999999999996
                             0.049999999999999996)))
                    (- (* 3 0.049999999999999996)
                       (* 4
                          (* 0.049999999999999996
                             0.049999999999999996
                             0.049999999999999996))))))))))
       (* 4
          (*
           (-
            (* 3
               (-
                (* 3
                   (- (* 3 0.049999999999999996)
                      (* 4
                         (* 0.049999999999999996
                            0.049999999999999996
                            0.049999999999999996))))
                (* 4
                   (*
                    (- (* 3 0.049999999999999996)
                       (* 4
                          (* 0.049999999999999996
                             0.049999999999999996
                             0.049999999999999996)))
                    (- (* 3 0.049999999999999996)
                       (* 4
                          (* 0.049999999999999996
                             0.049999999999999996
                             0.049999999999999996)))
                    (- (* 3 0.049999999999999996)
                       (* 4
                          (* 0.049999999999999996
                             0.049999999999999996
                             0.049999999999999996)))))))
            (* 4
               (*
                (-
                 (* 3
                    (- (* 3 0.049999999999999996)
                       (* 4
                          (* 0.049999999999999996
                             0.049999999999999996
                             0.049999999999999996))))
                 (* 4
                    (*
                     (- (* 3 0.049999999999999996)
                        (* 4
                           (* 0.049999999999999996
                              0.049999999999999996
                              0.049999999999999996)))
                     (- (* 3 0.049999999999999996)
                        (* 4
                           (* 0.049999999999999996
                              0.049999999999999996
                              0.049999999999999996)))
                     (- (* 3 0.049999999999999996)
                        (* 4
                           (* 0.049999999999999996
                              0.049999999999999996
                              0.049999999999999996))))))
                (-
                 (* 3
                    (- (* 3 0.049999999999999996)
                       (* 4
                          (* 0.049999999999999996
                             0.049999999999999996
                             0.049999999999999996))))
                 (* 4
                    (*
                     (- (* 3 0.049999999999999996)
                        (* 4
                           (* 0.049999999999999996
                              0.049999999999999996
                              0.049999999999999996)))
                     (- (* 3 0.049999999999999996)
                        (* 4
                           (* 0.049999999999999996
                              0.049999999999999996
                              0.049999999999999996)))
                     (- (* 3 0.049999999999999996)
                        (* 4
                           (* 0.049999999999999996
                              0.049999999999999996
                              0.049999999999999996))))))
                (-
                 (* 3
                    (- (* 3 0.049999999999999996)
                       (* 4
                          (* 0.049999999999999996
                             0.049999999999999996
                             0.049999999999999996))))
                 (* 4
                    (*
                     (- (* 3 0.049999999999999996)
                        (* 4
                           (* 0.049999999999999996
                              0.049999999999999996
                              0.049999999999999996)))
                     (- (* 3 0.049999999999999996)
                        (* 4
                           (* 0.049999999999999996
                              0.049999999999999996
                              0.049999999999999996)))
                     (- (* 3 0.049999999999999996)
                        (* 4
                           (* 0.049999999999999996
                              0.049999999999999996
                              0.049999999999999996)))))))))
           (-
            (* 3
               (-
                (* 3
                   (- (* 3 0.049999999999999996)
                      (* 4
                         (* 0.049999999999999996
                            0.049999999999999996
                            0.049999999999999996))))
                (* 4
                   (*
                    (- (* 3 0.049999999999999996)
                       (* 4
                          (* 0.049999999999999996
                             0.049999999999999996
                             0.049999999999999996)))
                    (- (* 3 0.049999999999999996)
                       (* 4
                          (* 0.049999999999999996
                             0.049999999999999996
                             0.049999999999999996)))
                    (- (* 3 0.049999999999999996)
                       (* 4
                          (* 0.049999999999999996
                             0.049999999999999996
                             0.049999999999999996)))))))
            (* 4
               (*
                (-
                 (* 3
                    (- (* 3 0.049999999999999996)
                       (* 4
                          (* 0.049999999999999996
                             0.049999999999999996
                             0.049999999999999996))))
                 (* 4
                    (*
                     (- (* 3 0.049999999999999996)
                        (* 4
                           (* 0.049999999999999996
                              0.049999999999999996
                              0.049999999999999996)))
                     (- (* 3 0.049999999999999996)
                        (* 4
                           (* 0.049999999999999996
                              0.049999999999999996
                              0.049999999999999996)))
                     (- (* 3 0.049999999999999996)
                        (* 4
                           (* 0.049999999999999996
                              0.049999999999999996
                              0.049999999999999996))))))
                (-
                 (* 3
                    (- (* 3 0.049999999999999996)
                       (* 4
                          (* 0.049999999999999996
                             0.049999999999999996
                             0.049999999999999996))))
                 (* 4
                    (*
                     (- (* 3 0.049999999999999996)
                        (* 4
                           (* 0.049999999999999996
                              0.049999999999999996
                              0.049999999999999996)))
                     (- (* 3 0.049999999999999996)
                        (* 4
                           (* 0.049999999999999996
                              0.049999999999999996
                              0.049999999999999996)))
                     (- (* 3 0.049999999999999996)
                        (* 4
                           (* 0.049999999999999996
                              0.049999999999999996
                              0.049999999999999996))))))
                (-
                 (* 3
                    (- (* 3 0.049999999999999996)
                       (* 4
                          (* 0.049999999999999996
                             0.049999999999999996
                             0.049999999999999996))))
                 (* 4
                    (*
                     (- (* 3 0.049999999999999996)
                        (* 4
                           (* 0.049999999999999996
                              0.049999999999999996
                              0.049999999999999996)))
                     (- (* 3 0.049999999999999996)
                        (* 4
                           (* 0.049999999999999996
                              0.049999999999999996
                              0.049999999999999996)))
                     (- (* 3 0.049999999999999996)
                        (* 4
                           (* 0.049999999999999996
                              0.049999999999999996
                              0.049999999999999996)))))))))
           (-
            (* 3
               (-
                (* 3
                   (- (* 3 0.049999999999999996)
                      (* 4
                         (* 0.049999999999999996
                            0.049999999999999996
                            0.049999999999999996))))
                (* 4
                   (*
                    (- (* 3 0.049999999999999996)
                       (* 4
                          (* 0.049999999999999996
                             0.049999999999999996
                             0.049999999999999996)))
                    (- (* 3 0.049999999999999996)
                       (* 4
                          (* 0.049999999999999996
                             0.049999999999999996
                             0.049999999999999996)))
                    (- (* 3 0.049999999999999996)
                       (* 4
                          (* 0.049999999999999996
                             0.049999999999999996
                             0.049999999999999996)))))))
            (* 4
               (*
                (-
                 (* 3
                    (- (* 3 0.049999999999999996)
                       (* 4
                          (* 0.049999999999999996
                             0.049999999999999996
                             0.049999999999999996))))
                 (* 4
                    (*
                     (- (* 3 0.049999999999999996)
                        (* 4
                           (* 0.049999999999999996
                              0.049999999999999996
                              0.049999999999999996)))
                     (- (* 3 0.049999999999999996)
                        (* 4
                           (* 0.049999999999999996
                              0.049999999999999996
                              0.049999999999999996)))
                     (- (* 3 0.049999999999999996)
                        (* 4
                           (* 0.049999999999999996
                              0.049999999999999996
                              0.049999999999999996))))))
                (-
                 (* 3
                    (- (* 3 0.049999999999999996)
                       (* 4
                          (* 0.049999999999999996
                             0.049999999999999996
                             0.049999999999999996))))
                 (* 4
                    (*
                     (- (* 3 0.049999999999999996)
                        (* 4
                           (* 0.049999999999999996
                              0.049999999999999996
                              0.049999999999999996)))
                     (- (* 3 0.049999999999999996)
                        (* 4
                           (* 0.049999999999999996
                              0.049999999999999996
                              0.049999999999999996)))
                     (- (* 3 0.049999999999999996)
                        (* 4
                           (* 0.049999999999999996
                              0.049999999999999996
                              0.049999999999999996))))))
                (-
                 (* 3
                    (- (* 3 0.049999999999999996)
                       (* 4
                          (* 0.049999999999999996
                             0.049999999999999996
                             0.049999999999999996))))
                 (* 4
                    (*
                     (- (* 3 0.049999999999999996)
                        (* 4
                           (* 0.049999999999999996
                              0.049999999999999996
                              0.049999999999999996)))
                     (- (* 3 0.049999999999999996)
                        (* 4
                           (* 0.049999999999999996
                              0.049999999999999996
                              0.049999999999999996)))
                     (- (* 3 0.049999999999999996)
                        (* 4
                           (* 0.049999999999999996
                              0.049999999999999996
                              0.049999999999999996))))))))))))
      (-
       (* 3
          (-
           (* 3
              (-
               (* 3
                  (- (* 3 0.049999999999999996)
                     (* 4
                        (* 0.049999999999999996
                           0.049999999999999996
                           0.049999999999999996))))
               (* 4
                  (*
                   (- (* 3 0.049999999999999996)
                      (* 4
                         (* 0.049999999999999996
                            0.049999999999999996
                            0.049999999999999996)))
                   (- (* 3 0.049999999999999996)
                      (* 4
                         (* 0.049999999999999996
                            0.049999999999999996
                            0.049999999999999996)))
                   (- (* 3 0.049999999999999996)
                      (* 4
                         (* 0.049999999999999996
                            0.049999999999999996
                            0.049999999999999996)))))))
           (* 4
              (*
               (-
                (* 3
                   (- (* 3 0.049999999999999996)
                      (* 4
                         (* 0.049999999999999996
                            0.049999999999999996
                            0.049999999999999996))))
                (* 4
                   (*
                    (- (* 3 0.049999999999999996)
                       (* 4
                          (* 0.049999999999999996
                             0.049999999999999996
                             0.049999999999999996)))
                    (- (* 3 0.049999999999999996)
                       (* 4
                          (* 0.049999999999999996
                             0.049999999999999996
                             0.049999999999999996)))
                    (- (* 3 0.049999999999999996)
                       (* 4
                          (* 0.049999999999999996
                             0.049999999999999996
                             0.049999999999999996))))))
               (-
                (* 3
                   (- (* 3 0.049999999999999996)
                      (* 4
                         (* 0.049999999999999996
                            0.049999999999999996
                            0.049999999999999996))))
                (* 4
                   (*
                    (- (* 3 0.049999999999999996)
                       (* 4
                          (* 0.049999999999999996
                             0.049999999999999996
                             0.049999999999999996)))
                    (- (* 3 0.049999999999999996)
                       (* 4
                          (* 0.049999999999999996
                             0.049999999999999996
                             0.049999999999999996)))
                    (- (* 3 0.049999999999999996)
                       (* 4
                          (* 0.049999999999999996
                             0.049999999999999996
                             0.049999999999999996))))))
               (-
                (* 3
                   (- (* 3 0.049999999999999996)
                      (* 4
                         (* 0.049999999999999996
                            0.049999999999999996
                            0.049999999999999996))))
                (* 4
                   (*
                    (- (* 3 0.049999999999999996)
                       (* 4
                          (* 0.049999999999999996
                             0.049999999999999996
                             0.049999999999999996)))
                    (- (* 3 0.049999999999999996)
                       (* 4
                          (* 0.049999999999999996
                             0.049999999999999996
                             0.049999999999999996)))
                    (- (* 3 0.049999999999999996)
                       (* 4
                          (* 0.049999999999999996
                             0.049999999999999996
                             0.049999999999999996))))))))))
       (* 4
          (*
           (-
            (* 3
               (-
                (* 3
                   (- (* 3 0.049999999999999996)
                      (* 4
                         (* 0.049999999999999996
                            0.049999999999999996
                            0.049999999999999996))))
                (* 4
                   (*
                    (- (* 3 0.049999999999999996)
                       (* 4
                          (* 0.049999999999999996
                             0.049999999999999996
                             0.049999999999999996)))
                    (- (* 3 0.049999999999999996)
                       (* 4
                          (* 0.049999999999999996
                             0.049999999999999996
                             0.049999999999999996)))
                    (- (* 3 0.049999999999999996)
                       (* 4
                          (* 0.049999999999999996
                             0.049999999999999996
                             0.049999999999999996)))))))
            (* 4
               (*
                (-
                 (* 3
                    (- (* 3 0.049999999999999996)
                       (* 4
                          (* 0.049999999999999996
                             0.049999999999999996
                             0.049999999999999996))))
                 (* 4
                    (*
                     (- (* 3 0.049999999999999996)
                        (* 4
                           (* 0.049999999999999996
                              0.049999999999999996
                              0.049999999999999996)))
                     (- (* 3 0.049999999999999996)
                        (* 4
                           (* 0.049999999999999996
                              0.049999999999999996
                              0.049999999999999996)))
                     (- (* 3 0.049999999999999996)
                        (* 4
                           (* 0.049999999999999996
                              0.049999999999999996
                              0.049999999999999996))))))
                (-
                 (* 3
                    (- (* 3 0.049999999999999996)
                       (* 4
                          (* 0.049999999999999996
                             0.049999999999999996
                             0.049999999999999996))))
                 (* 4
                    (*
                     (- (* 3 0.049999999999999996)
                        (* 4
                           (* 0.049999999999999996
                              0.049999999999999996
                              0.049999999999999996)))
                     (- (* 3 0.049999999999999996)
                        (* 4
                           (* 0.049999999999999996
                              0.049999999999999996
                              0.049999999999999996)))
                     (- (* 3 0.049999999999999996)
                        (* 4
                           (* 0.049999999999999996
                              0.049999999999999996
                              0.049999999999999996))))))
                (-
                 (* 3
                    (- (* 3 0.049999999999999996)
                       (* 4
                          (* 0.049999999999999996
                             0.049999999999999996
                             0.049999999999999996))))
                 (* 4
                    (*
                     (- (* 3 0.049999999999999996)
                        (* 4
                           (* 0.049999999999999996
                              0.049999999999999996
                              0.049999999999999996)))
                     (- (* 3 0.049999999999999996)
                        (* 4
                           (* 0.049999999999999996
                              0.049999999999999996
                              0.049999999999999996)))
                     (- (* 3 0.049999999999999996)
                        (* 4
                           (* 0.049999999999999996
                              0.049999999999999996
                              0.049999999999999996)))))))))
           (-
            (* 3
               (-
                (* 3
                   (- (* 3 0.049999999999999996)
                      (* 4
                         (* 0.049999999999999996
                            0.049999999999999996
                            0.049999999999999996))))
                (* 4
                   (*
                    (- (* 3 0.049999999999999996)
                       (* 4
                          (* 0.049999999999999996
                             0.049999999999999996
                             0.049999999999999996)))
                    (- (* 3 0.049999999999999996)
                       (* 4
                          (* 0.049999999999999996
                             0.049999999999999996
                             0.049999999999999996)))
                    (- (* 3 0.049999999999999996)
                       (* 4
                          (* 0.049999999999999996
                             0.049999999999999996
                             0.049999999999999996)))))))
            (* 4
               (*
                (-
                 (* 3
                    (- (* 3 0.049999999999999996)
                       (* 4
                          (* 0.049999999999999996
                             0.049999999999999996
                             0.049999999999999996))))
                 (* 4
                    (*
                     (- (* 3 0.049999999999999996)
                        (* 4
                           (* 0.049999999999999996
                              0.049999999999999996
                              0.049999999999999996)))
                     (- (* 3 0.049999999999999996)
                        (* 4
                           (* 0.049999999999999996
                              0.049999999999999996
                              0.049999999999999996)))
                     (- (* 3 0.049999999999999996)
                        (* 4
                           (* 0.049999999999999996
                              0.049999999999999996
                              0.049999999999999996))))))
                (-
                 (* 3
                    (- (* 3 0.049999999999999996)
                       (* 4
                          (* 0.049999999999999996
                             0.049999999999999996
                             0.049999999999999996))))
                 (* 4
                    (*
                     (- (* 3 0.049999999999999996)
                        (* 4
                           (* 0.049999999999999996
                              0.049999999999999996
                              0.049999999999999996)))
                     (- (* 3 0.049999999999999996)
                        (* 4
                           (* 0.049999999999999996
                              0.049999999999999996
                              0.049999999999999996)))
                     (- (* 3 0.049999999999999996)
                        (* 4
                           (* 0.049999999999999996
                              0.049999999999999996
                              0.049999999999999996))))))
                (-
                 (* 3
                    (- (* 3 0.049999999999999996)
                       (* 4
                          (* 0.049999999999999996
                             0.049999999999999996
                             0.049999999999999996))))
                 (* 4
                    (*
                     (- (* 3 0.049999999999999996)
                        (* 4
                           (* 0.049999999999999996
                              0.049999999999999996
                              0.049999999999999996)))
                     (- (* 3 0.049999999999999996)
                        (* 4
                           (* 0.049999999999999996
                              0.049999999999999996
                              0.049999999999999996)))
                     (- (* 3 0.049999999999999996)
                        (* 4
                           (* 0.049999999999999996
                              0.049999999999999996
                              0.049999999999999996)))))))))
           (-
            (* 3
               (-
                (* 3
                   (- (* 3 0.049999999999999996)
                      (* 4
                         (* 0.049999999999999996
                            0.049999999999999996
                            0.049999999999999996))))
                (* 4
                   (*
                    (- (* 3 0.049999999999999996)
                       (* 4
                          (* 0.049999999999999996
                             0.049999999999999996
                             0.049999999999999996)))
                    (- (* 3 0.049999999999999996)
                       (* 4
                          (* 0.049999999999999996
                             0.049999999999999996
                             0.049999999999999996)))
                    (- (* 3 0.049999999999999996)
                       (* 4
                          (* 0.049999999999999996
                             0.049999999999999996
                             0.049999999999999996)))))))
            (* 4
               (*
                (-
                 (* 3
                    (- (* 3 0.049999999999999996)
                       (* 4
                          (* 0.049999999999999996
                             0.049999999999999996
                             0.049999999999999996))))
                 (* 4
                    (*
                     (- (* 3 0.049999999999999996)
                        (* 4
                           (* 0.049999999999999996
                              0.049999999999999996
                              0.049999999999999996)))
                     (- (* 3 0.049999999999999996)
                        (* 4
                           (* 0.049999999999999996
                              0.049999999999999996
                              0.049999999999999996)))
                     (- (* 3 0.049999999999999996)
                        (* 4
                           (* 0.049999999999999996
                              0.049999999999999996
                              0.049999999999999996))))))
                (-
                 (* 3
                    (- (* 3 0.049999999999999996)
                       (* 4
                          (* 0.049999999999999996
                             0.049999999999999996
                             0.049999999999999996))))
                 (* 4
                    (*
                     (- (* 3 0.049999999999999996)
                        (* 4
                           (* 0.049999999999999996
                              0.049999999999999996
                              0.049999999999999996)))
                     (- (* 3 0.049999999999999996)
                        (* 4
                           (* 0.049999999999999996
                              0.049999999999999996
                              0.049999999999999996)))
                     (- (* 3 0.049999999999999996)
                        (* 4
                           (* 0.049999999999999996
                              0.049999999999999996
                              0.049999999999999996))))))
                (-
                 (* 3
                    (- (* 3 0.049999999999999996)
                       (* 4
                          (* 0.049999999999999996
                             0.049999999999999996
                             0.049999999999999996))))
                 (* 4
                    (*
                     (- (* 3 0.049999999999999996)
                        (* 4
                           (* 0.049999999999999996
                              0.049999999999999996
                              0.049999999999999996)))
                     (- (* 3 0.049999999999999996)
                        (* 4
                           (* 0.049999999999999996
                              0.049999999999999996
                              0.049999999999999996)))
                     (- (* 3 0.049999999999999996)
                        (* 4
                           (* 0.049999999999999996
                              0.049999999999999996
                              0.049999999999999996)))))))))))))))
#+end_src

As seen from the code above, the amount of steps is 5. It is easily
seen from the fact that the application of ~p~ starts when *x* is
sufficiently small, and that requires \(0.1 > 12.15\cdot(\frac{1}{3})^n \Rightarrow n
= O(\log_3 121.5)\) steps.

~(sine x)~ is expandable in constant space and time, ~(cube x)~ is
expandable in constant space and time if multiplication is an
elementary operation. Therefore the only operation left is
~p~. Therefore, time and space are of equal order of magnitude.

 - \(\left\lceil \log_3 121.5 \right\rceil = 5\)
 - \(O(\ln(a\cdot b))\) where \(a\) is the angle and \(b\) is precision

*** DONE Exercise 1.16 Iterative exponentiation
    CLOSED: [2019-08-30 Fri 23:20]

For the start, let's input the code.

#+begin_src scheme :exports code :results none
  (define (expt b n)
    (if (= n 0)
	1
	(* b (expt b (- n 1)))))
#+end_src

#+begin_src scheme :exports code :results none
  (define (expt b n)
    (expt-iter b n 1))
  (define (expt-iter b counter product)
    (if (= counter 0)
	product
	(expt-iter b
		   (- counter 1)
		   (* b counter product))))
#+end_src

#+begin_src scheme :exports both :results value scalar code
  (define (fast-expt b n)
    (cond ((= n 0) 1)
	  ((even? n) (square (fast-expt b (/ n 2))))
	  (else (* b (fast-expt b (- n 1))))))
  (define (even? n)
    (= (remainder n 2) 0))
  (fast-expt 2 10)
#+end_src

#+RESULTS[24433c9813fe1e3370023862d0c3b61171d0d673]:
#+begin_src scheme
1024
#+end_src

#+begin_src scheme :exports both :results value scalar code
    (define (fast-expt b n a)
      (cond ((= n 0) a)
	    ((even? n)  (fast-expt (square b) (/ n 2) a))
	    (else (fast-expt b (- n 1) (* a b)))))
    (define (even? n)
      (= (remainder n 2) 0))
    (define (faster-expt b n)
      (fast-expt b n 1))
    (faster-expt 2 10)
#+end_src

#+RESULTS[e49eb207c3381833db5da8f35e103c5a66b54627]:
#+begin_src scheme
1024
#+end_src

The answer is the code block above. We just collect some data and put
it into the state variable *a*.

*** DONE Exercise 1.17 Fast multiplication
    CLOSED: [2019-08-30 Fri 23:48]
#+begin_src scheme :exports both :results value scalar code
  (define (double a)
    (* 2 a))
  (define (halve a)
    (if (even? a)
	(/ a 2)
	(raise "Error: a not even.")))
  (define (even? n)
	(= (remainder n 2) 0))
  (define (* a b)
    (cond
     ((= b 0) 0)
     ((even? b) (double (* a (halve b))))
     (else (+ a (* a (- b 1))))))
  (* 137 17)
#+end_src

#+RESULTS[4e2b5e198c1a8938e7253fdd17cd31b1c6772a03]:
#+begin_src scheme
2329
#+end_src

The procedure above uses logarithmic time and space, because for every
subtraction there is also at least one division, so the total
convergence speed is exponential. This could be reformulated as an
iterative procedure, with an accumulator variable, but I am too lazy.

*** DONE Exercise 1.18 Iterative multiplication
    CLOSED: [2019-08-31 Sat 11:43]

In [[Exercise 1.17 Fast multiplication][Exercise 1.17]] I said that I was too lazy to design an iterative
procedure. Well, now I do it in this exercise.

#+begin_src scheme :exports both :results value scalar code
  (define (double a)
    (* 2 a))
  (define (halve a)
    (if (even? a)
	(/ a 2)
	(raise "Error: a not even.")))
  (define (even? n)
	(= (remainder n 2) 0))
  (define (mul a b accumulator)
    (cond
     ((= b 0) accumulator)
     ((even? b) (mul (double a) (halve b)))
     (else (mul a (- b 1) (+ a accumulator)))))
  (* 137 17)
#+end_src

#+RESULTS[f9c6f5115e026ef2466552f14fa016da8f499b7e]:
#+begin_src scheme
2329
#+end_src

The idea here is exactly the same as in the previous Exercise 1.18.

*** DONE Exercise 1.19 Logarithmic Fibonacci
    CLOSED: [2019-09-01 Sun 20:42]

As usualy, let's first copy the code of ~fib-iter~.

#+begin_src scheme :exports both :results value scalar code
  (define (fib n)
    (fib-iter 1 0 n))
  (define (fib-iter a b count)
    (if (= count 0)
	b
	(fib-iter (+ a b) a (- count 1))))
  (fib 10)
#+end_src

x#+RESULTS[c2b25d928562d89dac80ba304c7abc37e14b0df5]:
#+begin_src scheme
55
#+end_src

The formula for \(T\) is the following:

\begin{eqnarray}
T_{pq} \begin{pmatrix} a\\ b \end{pmatrix} & = & \begin{pmatrix} aq+bq+ap
 \\ bp + aq \end{pmatrix} \\
T_{pq} \left( T_{pq} \begin{pmatrix} a\\ b \end{pmatrix} \right)
& = & \begin{pmatrix} (aq+bq+ap)q+(bp + aq)q+(aq+bq+ap)p \\
(bp + aq)p + (aq+bq+ap)q \end{pmatrix} \\
T_{p'q'}\begin{pmatrix} a\\ b \end{pmatrix} & = & \begin{pmatrix}a(2pq + qq)
 + a(pp+qq) + b(2pq + qq)\\ a(2pq + qq) + b(pp + qq) \end{pmatrix} \\
\end{eqnarray}
From here we can easily see the values for \(p\prime\) and \(q'\):
# \(a(2pq + qq) + a(pp+qq) + b(2pq + qq)\)
# \(a(2pq + qq) + b(pp + qq)\)

\(p'=pp+qq\), \(q' = 2pq+qq\)

Let us substitute them into the code given by Abelson and Sussman.

#+begin_src scheme :exports both :results value scalar code
  (define (fib n)
    (fib-iter 1 0 0 1 n))
  (define (fib-iter a b p q count)
    (cond ((= count 0) b)
	  ((even? count)
	   (fib-iter a
		     b
		     (+ (* p p) (* q q))
		     (+ (* 2 p q) (* q q))
		     (/ count 2)))
	  (else (fib-iter (+ (* b q) (* a q) (* a p))
			  (+ (* b p) (* a q))
			  p
			  q
			  (- count 1)))))
  (fib 10)
#+end_src

#+RESULTS[dcabc65ae489ecfb2fec09f7d04d149b7c5c1329]:
#+begin_src scheme
55
#+end_src

Works.

*** DONE Exercise 1.20 GCD applicative vs normal :er_macro_transformer:macro:
    CLOSED: [2019-09-01 Sun 23:04]
The exercise urges us to recall the difference between the normal
order and the applicative order of evaluation.

 *Normal*: fully expand the computation tree until obtained an
expression involving only primitive operators.

 *Applicative*: evaluate the arguments and then apply.

First let us print the execution tree of the normal order.

#+begin_src scheme :exports both :results output scalar code
    (define-syntax gcd-normal
      (er-macro-transformer
       (lambda (form rename compare?)
	 (let ((a (cadr form))
	       (b (caddr form)))
	   (if (= b 0)
		`(if (= ,b 0)
                     ,a
                     (remainder ,a ,b))
		`(if (= ,b 0)
		     (,a (remainder ,a ,b))
		     (gcd-normal ,b ,(remainder a b))))))))
      (display (show #f " " (pretty (macroexpand '(gcd-normal 206 40)))))
#+end_src

#+RESULTS[7854f2e05239b4329438fcb62b5a07124424816c]:
#+begin_src scheme
 (if (= 40 0)
     (206 (remainder 206 40))
     (if (= 6 0)
         (40 (remainder 40 6))
         (if (= 4 0)
             (6 (remainder 6 4))
             (if (= 2 0) (4 (remainder 4 2)) (if (= 0 0) 2 (remainder 2 0))))))
#+end_src

Now let us show the applicative order.
#+begin_src scheme :exports both :results output scalar code
    (define-syntax gcd-normal
      (er-macro-transformer
       (lambda (form rename compare?)
	 (let ((a (cadr form))
	       (b (caddr form)))
	   (if (= b 0)
		`(if (= ,b 0)
                     ,a
                     'division-by-zero)
		`(if (= ,b 0)
		     (,a (remainder ,a ,b))
		     (gcd-normal ,b ,(remainder a b))))))))
      (display (show #f " " (pretty (macroexpand '(gcd-normal 206 40)))))
#+end_src

#+RESULTS[37aaf98a8e600dd999bee700e079276f5a6bc10c]:
#+begin_src scheme
 (if (= 40 0)
     (206 (remainder 206 40))
     (if
      (= 6 0)
      (40 (remainder 40 6))
      (if (= 4 0)
          (6 (remainder 6 4))
          (if (= 2 0) (4 (remainder 4 2)) (if (= 0 0) 2 'division-by-zero)))))
#+end_src

The problem here would arise, if the ~(if)~ form had a normal
evaluation order, because the last division, ~(remainder 2 0)~ may be
a forbidden operation, involving a division by zero. On the other
hand, the evaluation of ~(remainder x 0)~ could be defined as *x*, and
then the algorithm would evaluate one more (useless) remainder.

*** DONE Exercise 1.21 smallest-divisor
    CLOSED: [2019-09-01 Sun 23:43]

As usual, let us first copy the code for the ~smallest-divisor~.

#+name: primetest
#+begin_src scheme :exports code :results none
  (define (smallest-divisor n)
    (find-divisor n 2))
  (define (find-divisor n test-divisor)
    (cond ((> (square test-divisor) n) n)
	  ((divides? test-divisor n) test-divisor)
	  (else (find-divisor n (+ test-divisor 1)))))
  (define (divides? a b) (= (remainder b a) 0))

  (define (prime? n)
    (= n (smallest-divisor n)))
#+end_src

#+begin_src scheme :exports both :results output scalar code
  <<primetest>>
  (display (smallest-divisor 199))
  (newline)
  (display (smallest-divisor 1999))
  (newline)
  (display (smallest-divisor 19999))
  (newline)
  (display (/ 19999 7))
  (newline)
#+end_src

#+RESULTS[0cee68aeebf4e92dec749225ead117488b3b45e1]:
#+begin_src scheme
199
1999
7
2857
#+end_src

Well, this problem doesn't look too complicated on the first glance.

*** DONE Exercise 1.22 timed-prime-test
    CLOSED: [2019-09-02 Mon 00:44]

#+name: timed-primetest
#+begin_src scheme :exports code :results none
  (define (runtime) (* 1000 (current-second)))

  (define (timed-prime-test n)
    (newline)
    (display n)
    (start-prime-test n (runtime)))

  (define (start-prime-test n start-time)
    (if (prime? n)
	(report-prime (- (runtime) start-time))))

  (define (report-prime elapsed-time)
    (display " *** ")
    (display elapsed-time))
  (define (search-for-primes start finish)
    (timed-prime-test start)
    (if (< (+ 1 start) finish)
	(if (even? start)
	    (search-for-primes (+ start 1) finish)
	    (search-for-primes (+ start 2) finish))))
#+end_src

#+begin_src scheme :exports both :results output scalar code
  <<primetest>>
  <<timed-primetest>>
  (search-for-primes 1000 1020)
  (newline)
  (search-for-primes 10000 10038)
  (newline)
  (search-for-primes 100000 100044)
  (newline)
  (search-for-primes 1000000 1000038)
#+end_src

#+RESULTS[6f5bc18e167ecf4684a6dcc23a82ea0e94c10333]:
#+begin_src scheme

1000
1001
1003
1005
1007
1009 *** 0.012939453125
1011
1013 *** 0.012939453125
1015
1017
1019 *** 0.01318359375

10000
10001
10003
10005
10007 *** 0.03369140625
10009 *** 0.03515625
10011
10013
10015
10017
10019
10021
10023
10025
10027
10029
10031
10033
10035
10037 *** 0.0341796875

100000
100001
100003 *** 0.098876953125
100005
100007
100009
100011
100013
100015
100017
100019 *** 0.10107421875
100021
100023
100025
100027
100029
100031
100033
100035
100037
100039
100041
100043 *** 0.10400390625

1000000
1000001
1000003 *** 0.30908203125
1000005
1000007
1000009
1000011
1000013
1000015
1000017
1000019
1000021
1000023
1000025
1000027
1000029
1000031
1000033 *** 0.31689453125
1000035
1000037 *** 0.30712890625
#+end_src



 - Write the procedure: done.
 - Find the smallest three primes greater than 1000   : found.
 - Find the smallest three primes greater than 10000  : found.
 - Find the smallest three primes greater than 100000 : found.
 - Find the smallest three primes greater than 1000000: found.
 - The timing data confirms the prediction. \(\sqrt{10}\approx3\), \(0.16 \approx 3\cdot1.05\).
 - The execution time per step for testing 1.000.000 is 1.63e-07. The
   execution time per step for testing 100.000 5.3199e-07. At least on
   my machine the claim doesn't seem to hold very well.

*** DONE Exercise 1.23 (next test-divisor)
    CLOSED: [2019-09-02 Mon 09:56]

#+name: improved-primetest
#+begin_src scheme :exports code :results none
  (define (next x)
    (if (= 2 x)
	3
	(+ x 2)))
  (define (smallest-divisor n)
    (find-divisor n 2))
  (define (find-divisor n test-divisor)
    (cond ((> (square test-divisor) n) n)
	  ((divides? test-divisor n) test-divisor)
	  (else (find-divisor n (next test-divisor)))))
  (define (divides? a b) (= (remainder b a) 0))

  (define (prime? n)
    (= n (smallest-divisor n)))

#+end_src

#+begin_src scheme :exports both :results output scalar code
<<improved-primetest>>
<<timed-primetest>>
(timed-prime-test 1009)
(timed-prime-test 1013)
(timed-prime-test 1019)
(timed-prime-test 10007)
(timed-prime-test 10009)
(timed-prime-test 10037)
(timed-prime-test 100003)
(timed-prime-test 100019)
(timed-prime-test 100043)
(timed-prime-test 1000003)
(timed-prime-test 1000033)
(timed-prime-test 1000037)

#+end_src

#+RESULTS[8a0a6acfb84d853d29ed690c276e4f41d3a225b2]:
#+begin_src scheme

1009 *** 0.011962890625
1013 *** 0.007080078125
1019 *** 0.008056640625
10007 *** 0.017822265625
10009 *** 0.01611328125
10037 *** 0.01611328125
100003 *** 0.051025390625
100019 *** 0.047119140625
100043 *** 0.052001953125
1000003 *** 0.197021484375
1000033 *** 0.14892578125
1000037 *** 0.14306640625
#+end_src

We can see that the test does show a speed improvement, although not
as impressive as 2 times. We can observe that the number of steps is
not really halved, since ~(+ a b)~ requires one operation, and ~(if (=
2 x) 3 else (+ 3 2))~ requires three operations, so the speed should
improve by 3/2, which we can observe.

*** DONE Exercise 1.24 Fermat method
    CLOSED: [2019-09-02 Mon 11:32]

Firstly we need the ~(fast-prime?)~ procedure.

#+name: random
#+begin_src scheme :exports code :results none
(define (random x)
  (random-integer x))
#+end_src

#+name: expmod
#+begin_src scheme :exports code :results none
  (define (expmod base exp m)
    (cond ((= exp 0) 1)
	  ((even? exp)
	   (remainder
	    (square (expmod base (/ exp 2) m))
	    m))
	  (else
	   (remainder
	    (* base (expmod base (- exp 1) m))
	    m))))
#+end_src

#+name: fermat-primetest
#+begin_src scheme :exports code :results none
<<random>>
  (define (fermat-test n)
    (define (try-it a)
      (= (expmod a n n) a))
    (try-it (+ 1 (random (- n 1)))))
  (define prime-test fermat-test)
#+end_src

#+name: fast-prime
#+begin_src scheme :exports code :results none
  (define (fast-prime? n times)
    (cond ((= times 0) true)
	  ((prime-test n) (fast-prime? n (- times 1)))
	  (else false)))
  (define true #t)
  (define false #f)
  (define (prime? x)
    (fast-prime? x 10))
#+end_src

#+begin_src scheme :exports both :results output scalar code
<<expmod>>
<<fermat-primetest>>
<<fast-prime>>
<<timed-primetest>>
(timed-prime-test 1009)
(timed-prime-test 1013)
(timed-prime-test 1019)
(timed-prime-test 10007)
(timed-prime-test 10009)
(timed-prime-test 10037)
(timed-prime-test 100003)
(timed-prime-test 100019)
(timed-prime-test 100043)
(timed-prime-test 1000003)
(timed-prime-test 1000033)
(timed-prime-test 1000037)
(timed-prime-test 1000)
(timed-prime-test 6601)
#+end_src

#+RESULTS[b92f301a3e5f166ec9aec349fa97854fce1afac7]:
#+begin_src scheme

1009 *** 0.092041015625
1013 *** 0.060791015625
1019 *** 0.057861328125
10007 *** 0.078125
10009 *** 0.066162109375
10037 *** 0.073974609375
100003 *** 0.0771484375
100019 *** 0.080322265625
100043 *** 0.080810546875
1000003 *** 0.0888671875
1000033 *** 0.087890625
1000037 *** 0.092041015625
1000
6601 *** 0.06201171875
#+end_src

Firstly, observe that the interpreter seems to be doing some black magic, so
that the test for 1009 takes more time than the test for 1013.

Secondly, observe that indeed, the speed seems to have reduced its dependence
on the length of a number, and if we want to test even bigger numbers, the
dependency should become even smaller, as \(\log(n)\) grows very slowly. In
particular, comparing the range around 1000 and 1000.000, the ratio of
\(\frac{\log_{10}(1000000)}{\log_{10}(1000)} = \frac{6}{3} = 2\). This doesn't seem
to be completely the case, but hey, there may be some constants involved, as
well as some interpreter dark magic.

*** DONE Exercise 1.25 expmod
    CLOSED: [2019-09-02 Mon 12:46]

Well, in principle, Alyssa's algorithm should work. The problem here really
is that we would have to store the number \(a^n\), which is a very big number,
especially because we are interested in testing primality of very large
numbers (e.g., 512-bit long cryptography keys), and \((2^{256-1})^{2^{256}}\)
is a very large number.

*** DONE Exercise 1.26 square vs mul
    CLOSED: [2019-09-02 Mon 12:50]

The hint here lies in the name of the person helping Louis. Eva Lu Ator
sounds similar to "evaluator", and the reason for Louis's problem really lies
in the optimization capabilities of the interpreter. That is, if the
evaluating algorithm uses applicative order, then the ~expmod~ is evaluated
twice per step, which makes ~(/ exp 2)~ useless. If, however, the interpreter
can memoize the results, his algorithm would be just as good.

*** DONE Exercise 1.27 Carmichael numbers
    CLOSED: [2019-09-02 Mon 20:50]

First let us recall some Carmichael numbers.

| # |      |
|---+------|
| 1 |  561 |
| 2 | 1105 |
| 3 | 1729 |
| 4 | 2465 |
| 5 | 2821 |
| 6 | 6601 |

We already have a procedure that computes \(a^n\mod n\), and a procedure that
computes \(a\mod n\) is even a scheme primitive. Moreover, we even have all
the code that does the comparison, with the single difference - our existing
code takes an initial guess uniformly at random, whereas we need to check all
\( a < n\).

#+begin_src scheme :exports both :results output scalar code
<<expmod>>
  (define (congruent? a n)
    (= (expmod a n n) a))
  (define (carmichael-iter a n)
    (cond ((= a n) #t)
	  ((not (congruent? a n)) #f)
	  (else (carmichael-iter (+ 1 a) n))))
  (define (carmichael-or-prime? n)
    (carmichael-iter 1 n))
  (define (test-carmichael n)
    (display "Testing ")
    (display n)
    (display ": ")
    (if (carmichael-or-prime? n)
      (display "true")
      (display "false"))
    (newline))
  (test-carmichael 561)
  (test-carmichael 1105)
  (test-carmichael 1729)
  (test-carmichael 2465)
  (test-carmichael 2821)
  (test-carmichael 6601)
  (test-carmichael 20)
  (test-carmichael 7)
#+end_src

#+RESULTS[ad510ed2ffe66cb1be46fb274bc9c2024dfd1853]:
#+begin_src scheme
Testing 561: true
Testing 1105: true
Testing 1729: true
Testing 2465: true
Testing 2821: true
Testing 6601: true
Testing 20: false
Testing 7: true
#+end_src

*** DONE Exercise 1.28 Miller-Rabin
    CLOSED: [2019-09-02 Mon 23:28]

#+name: expmod-miller-rabin
#+begin_src scheme :exports code :results none
  (define (expmod base exp m)
    (cond ((= exp 0) 1)
	  ((even? exp)
	   (let* ((root (expmod base (/ exp 2) m))
		  (sq (square root)))
	     (if (and (= (remainder sq m) 1) (not (or (= root 1) (= root (- m 1)))))
	      0
	      (remainder sq m))))
	  (else
	   (remainder
	    (* base (expmod base (- exp 1) m))
	    m))))
#+end_src

#+name: miller-rabin-primetest
#+begin_src scheme :exports code :results none
    <<random>>
      (define (rabin-test n)
	(define (try-it a)
	  (let ((result (expmod a (- n 1) n) ))
	    (if (or (= 1 result)  (= n 1) (= n 0))
	    #t
	    #f)))
	(if (not (= n 1)) (try-it (+ 1 (random (- n 1)))) #t))
      (define prime-test rabin-test)

#+end_src

#+begin_src scheme :exports both :results output scalar code

<<expmod-miller-rabin>>
<<miller-rabin-primetest>>
<<fast-prime>>
<<timed-primetest>>

(timed-prime-test 1009)
(timed-prime-test 1013)
(timed-prime-test 1019)
(timed-prime-test 10007)
(timed-prime-test 10009)
(timed-prime-test 10037)
(timed-prime-test 100003)
(timed-prime-test 100019)
(timed-prime-test 100043)
(timed-prime-test 1000003)
(timed-prime-test 1000033)
(timed-prime-test 1000037)
(timed-prime-test 1000)
(timed-prime-test 6601)

#+end_src

#+RESULTS[4c09a4e0ac7d95ac27f49f834ba713bab0595c5a]:
#+begin_src scheme

1009 *** 0.1748046875
1013 *** 0.1728515625
1019 *** 0.171875
10007 *** 0.2109375
10009 *** 0.212890625
10037 *** 0.215087890625
100003 *** 0.2548828125
100019 *** 0.256591796875
100043 *** 0.262939453125
1000003 *** 0.290771484375
1000033 *** 0.297119140625
1000037 *** 0.2958984375
1000
6601
#+end_src

I used the ~(let)~ construction introduced in the later chapters, because I
find bindings with nested procedures confusing.

*** DONE Exercise 1.29 Simpson's integral
    CLOSED: [2019-09-03 Tue 10:36]

Since at the end of the task we are told to compare the result of our
algorithm with the results of the ~integral~ procedure, let us first copy the
integral code.

#+name: integral-common
#+begin_src scheme :exports code :results none 
  (define (sum term a next b)
    (if (> a b)
	0
	(+ (term a)
	   (sum term (next a) next b))))
  (define (cube x)
    (* x x x))
  (define (next point)
    (+ point 1))
#+end_src

#+begin_src scheme :exports both :results value scalar code
<<integral-common>>
  (define (integral f a b dx)
    (define (add-dx x)
      (+ x dx))
    (* (sum f (+ a (/ dx 2.0)) add-dx b)
       dx))
  (list (integral cube 0 1 0.01) (integral cube 0 1 0.001))

#+end_src

#+RESULTS[ad78ce6d682144773e718e10ae303f05a70e9dbf]:
#+begin_src scheme
(0.24998750000000042 0.249999875000001)
#+end_src

#+begin_src scheme :exports both :results output scalar code
  <<integral-common>>
  (define (integral-simpson f a b npoints)
    (define h (/ (- b a) npoints))
    (define h/3 (/ h 3))
    (define (f_k k)
      (* (f (+ a (* k h))) (cond ((= k 0) 1)
				 ((= k npoints) 1)
				 ((odd? k) 4)
				 ((even? k) 2))))
    (* h/3 (sum f_k 0 next npoints)))
  (display (integral-simpson cube 0 1 100))
  (newline)
  (display (integral-simpson cube 0 1 1000))
#+end_src

#+RESULTS[f4d0bd0cfdda3b8ed9bc25502aa6ea48d2f23ee7]:
#+begin_src scheme
1/4
1/4
#+end_src

An impressive result. I don't know at which point of the computation the
interpreter switches to an exact representation, but meh, this result is good.

*** DONE Exercise 1.30 Iterative sum
    CLOSED: [2019-09-03 Tue 11:19]

<2021-03-27 Sat> This solution has a bug! ~term~ is not called! Below is the solution (courtesy of Shengyi Wang) that is correct.

#+begin_src scheme :exports both :results value scalar code
  (define (inc x) (+ x 1))
  (define (identity x) x)
  (define (sum term a next b)
    (define (iter a result)
      (if (= a b)
	  (+ a result)
	  (iter (next a) (+ a result))))
    (iter a 0))

  (sum identity 1 inc 10)

#+end_src

#+RESULTS[8ea6a66307ad3db576b0c2ce2dcef390a42aebf2]:
#+begin_src scheme
55
#+end_src

#+begin_src scheme :exports both :results value scalar code
(define (inc x) (+ x 1))
(define (identity x) x)
(define (sum term a next b)
  (define (iter a result)
    (if (> a b)
        result
        (iter (next a) (+ (term a) result))))
(iter a 0))
(sum identity 1 inc 10)
#+end_src

#+RESULTS[66312a0ffa4c985999658c069ee31add8407f637]:
#+begin_src scheme
55
#+end_src

*** DONE Exercise 1.31 Product
    CLOSED: [2019-09-03 Tue 11:59]

**** a. Defining product
     CLOSED: [2019-09-03 Tue 11:56]

#+begin_src scheme :exports both :results value scalar code
  (define (inc x) (+ x 1))
  (define (identity x) x)
  (define (product term a next b)
    (define (iter a result)
      (if (= a b)
   (* (term a) result)
   (iter (next a) (* (term a) result))))
    (iter a 1.0))
  (define (factorial x) (product identity 1 inc 6))
  (factorial 6)
  (define (pi precision)
    (define (enumerator index)
      (cond ((odd?  index) (+ index 1.0))
     ((even? index) (+ index 2.0))
     (else (error "Error"))))
    (define (denominator index)
      (cond ((odd?  index) (+ index 2.0))
     ((even? index) (+ index 1.0))
     (else (error "Error"))))
    (define (fraction index)
      (/ (enumerator index) (denominator index)))
    (* 4.0 (product fraction 1 inc precision)))
    (pi 1280)
#+end_src

#+RESULTS[4c5c244278f80542029adfce9735be47286c5cf2]:
#+begin_src scheme
3.142818162579486
#+end_src

I can say that it converges very-very slowly.

**** b. A recursive version
     CLOSED: [2019-09-03 Tue 11:59]

#+begin_src scheme :exports both :results value scalar code
   (define (inc x) (+ x 1))
   (define (identity x) x)
   (define (product term a next b)
     (define (iter a result)
       (if (= a b)
	   (* (term a) result)
	   (* (iter (next a) (term a)) result)))
     (iter a 1.0))
   (define (factorial x) (product identity 1 inc 6))
   (factorial 6)
#+end_src

#+RESULTS[56f549a08d360a2547918bf9bd9a00ccae48654c]:
#+begin_src scheme
720.0
#+end_src

Doesn't make too much sense to me, but here you are.

*** DONE Exercise 1.32 Accumulator
    CLOSED: [2019-09-03 Tue 12:23]
I will cheat a little bit in this exercise, I will run ~sum~ as an iterative
procedure and ~product~ as a recursive procedure, so at the end I will have
two implementations, not 4, but that should not be too much of a digression.

#+name: accumulator-common
#+begin_src scheme :exports code :results none
   (define (inc x) (+ x 1))
   (define (identity x) x)
#+end_src

**** Implement ~sum~ in terms of an iterative accumulator
     CLOSED: [2019-09-03 Tue 12:23]

#+begin_src scheme :exports both :results value scalar code
<<accumulator-common>>
  (define (accumulate combiner null-value term a next b)
       (define (iter a result)
	 (if (>= a b)
	     (combiner (term a) result)
	     (combiner (iter (next a) (term a)) result)))
       (iter a null-value))
  (define (sum term a next b)
    (accumulate + 0 term a next b))
  (sum identity 1 inc 10)
#+end_src

#+RESULTS[ca5876204215d63a222d92e363ce530e90bff4f7]:
#+begin_src scheme
55
#+end_src

**** Implement ~product~ in terms of a recursive process
     CLOSED: [2019-09-03 Tue 12:22]

#+begin_src scheme :exports both :results value scalar code
<<accumulator-common>>
  (define (accumulate combiner null-value term a next b)
       (define (iter a result)
	 (if (= a b)
	     (combiner (term a) result)
	      (iter (next a) (combiner (term a) result) )))
       (iter a null-value))
  (define (product term a next b)
    (accumulate * 1 term a next b))
  (product identity 1 inc 10)

#+end_src

#+RESULTS[03a07b84beb615dc47b5ff62a44bdd42a1300264]:
#+begin_src scheme
3628800
#+end_src

*** DONE Exercise 1.33 filtered-accumulate
    CLOSED: [2019-09-03 Tue 14:36]

**** a. Sum-of-squares-of-primes
    CLOSED: [2019-09-03 Tue 14:24]

#+name: filtered-accumulate
#+begin_src scheme :exports code :results value scalar code
    (define (filtered-accumulate combiner filter null-value term a next b)
     (define (iter a result)
       (if (= a b)
	   (combiner (if (filter a) (term a) null-value) result)
	   (iter (next a) (combiner (if (filter a) (term a) null-value) result))))
     (iter a null-value))
#+end_src

#+begin_src scheme :exports both :results value scalar code
<<accumulator-common>>
<<filtered-accumulate>>
<<fast-prime>>
<<expmod-miller-rabin>>
<<miller-rabin-primetest>>
<<fast-prime>>
<<timed-primetest>>

    (define (sum-square-prime a next b)
      (filtered-accumulate + prime? 0 square a next b))
    (sum-square-prime 1 inc 10)
#+end_src

#+RESULTS[f059df2ed955aa2e0ae34a4e4934d8004399bc77]:
#+begin_src scheme
88
#+end_src

**** b. Product of positive integers mutually prime with n
     CLOSED: [2019-09-03 Tue 14:36]

#+begin_src scheme :exports both :results output scalar code
<<accumulator-common>>
<<filtered-accumulate>>
  (define (product-mutually-prime n)
    (define (filter-gcd x)
      (if (= (gcd n x) 1)
	  #t
	  #f))
    (filtered-accumulate * filter-gcd 1 identity 1 inc n))
  (display (product-mutually-prime 10))
#+end_src

#+RESULTS[83586b163ebf07f167361ab80635b54ec8e14bb4]:
#+begin_src scheme
189
#+end_src

Here I used the ~gcd~ function from the standard library.

*** DONE Exercise 1.34 lambda
    CLOSED: [2019-09-03 Tue 14:44]

#+name: example-lambda
#+begin_src scheme :exports code :results none
(define (f g) (g 2))
#+end_src

#+begin_src scheme :exports both :results value scalar code
<<example-lambda>>
(define (square x) (* x x))
(f square)
#+end_src

#+RESULTS[86c6774a5ac0998f53dccf5df3cb035d4152ac77]:
#+begin_src scheme
4
#+end_src

#+begin_src scheme :exports both :results value scalar code
<<example-lambda>>
(f (lambda (z) (* z (+ z 1))))
#+end_src

#+RESULTS[832e4f278134aca9a721a6cfb47ab0f3fb0ce694]:
#+begin_src scheme
6
#+end_src

#+begin_src scheme :exports both :results value scalar output
<<example-lambda>>
(f f)
#+end_src

#+RESULTS[451a4b2166c867628e1591e84ac83766f0ab176c]:
#+begin_example

Output (exception): {Exception #19 user "non procedure application" (2) #<procedure #f> ("/usr/lib64/chibi/init-7.scm" . 280)} 
Stack trace:
  called from <anonymous> on line 817 of file /usr/lib64/chibi/init-7.scm
  called from <anonymous> on line 280 of file /usr/lib64/chibi/init-7.scm
  called from <anonymous> on line 1206 of file /usr/lib64/chibi/init-7.scm
  called from <anonymous> on line 817 of file /usr/lib64/chibi/init-7.scm
  called from <anonymous> on line 817 of file /usr/lib64/chibi/init-7.scm
  called from call-with-current-continuation on line 844 of file /usr/lib64/chibi/init-7.scm
  called from <anonymous> on line 817 of file /usr/lib64/chibi/init-7.scm
  called from <anonymous> on line 280 of file /usr/lib64/chibi/init-7.scm
  called from <anonymous> on line 280 of file /usr/lib64/chibi/init-7.scm
  called from <anonymous> on line 817 of file /usr/lib64/chibi/init-7.scm
  called from call-with-current-continuation on line 844 of file /usr/lib64/chibi/init-7.scm
  called from geiser:eval on line 25 of file /usr/lib64/chibi/scheme/misc-macros.scm
#+end_example

Well, no wonder. The final combination reduces to ~(2 2)~, which *IS* a
non-procedure application.

*** DONE Exercise 1.35 fixed-point
    CLOSED: [2019-09-03 Tue 21:05]



\(\varphi = \frac{1+\sqrt{5}}{2}\)
\(x\mapsto 1+\frac{1}{x}\)
Let's substitute:
\( \frac{1+\sqrt{5}}{2} = 1+ \frac{2}{1+\sqrt{5}} \)
\( (1+\sqrt{5})^2 = 2(1+\sqrt{5})+ 4\)
\( 1 + 2 \sqrt{5} + 5 = 2 + 2 \sqrt{5} + 4 \)
\(6 = 6\)

#+name: fixed-point-silent
#+begin_src scheme :exports code :results none
  (define tolerance 0.00001)
  (define (fixed-point f first-guess)
    (define (close-enough? v1 v2)
      (< (abs (- v1 v2))
	 tolerance))
    (define (try guess)
      (let ((next (f guess)))
	(if (close-enough? guess next)
	    next
	    (try next))))
  (try first-guess))
#+end_src

#+begin_src scheme :exports both :results value scalar code
<<fixed-point-silent>>
(fixed-point cos 1.0)
#+end_src

#+RESULTS[07b982361312ab77643a2792c5e9b1dfe9c978be]:
#+begin_src scheme
0.7390822985224024
#+end_src

#+begin_src scheme :exports both :results value scalar code
  <<fixed-point-silent>>
  (define (golden-transform x)
    (+ 1 (/ 1 x)))
  (fixed-point golden-transform 1.0)
#+end_src

#+RESULTS[62ab91e1290e865b9398f77d2fcbb31e04894408]:
#+begin_src scheme
1.6180327868852458
#+end_src

#+begin_src scheme :exports both :results value scalar code
(/ (+ 1 (sqrt 5)) 2)
#+end_src

#+RESULTS[baa3de3c53fbe82834d91a60a0265293bc49ce77]:
#+begin_src scheme
1.618033988749895
#+end_src

The difference is not too big.

*** DONE Exercise 1.36 fixed-point-with-dampening
    CLOSED: [2019-09-03 Tue 21:55]

#+name: fixed-point-verbose
#+begin_src scheme :exports code :results none
  (define tolerance 0.00001)
  (define (fixed-point f first-guess)
    (define (close-enough? v1 v2)
      (display "Guesses: ")
      (display v1)
      (display " ")
      (display v2)
      (newline)
      (< (abs (- v1 v2))
	 tolerance))
    (define (try guess)
      (let ((next (f guess)))
	(if (close-enough? guess next)
	    next
	    (try next))))
  (try first-guess))
#+end_src

To find a solution to \(x^x=1000\), let us rearrange: \( x = \log_x1000 =
\frac{\log 1000}{\log x}\).

#+name: log1000
#+begin_src scheme :exports code :results none
(define (log1000/logx x)
  (/ (log 1000) (log x)))
#+end_src

#+begin_src scheme :exports both :results output scalar code
<<fixed-point-verbose>>
<<log1000>>
(display (fixed-point log1000/logx 5))
#+end_src

#+RESULTS[14bcbc0b1db499daa48379ff5f9e4b2357fb084b]:
#+begin_src scheme
Guesses: 5 4.29202967422018
Guesses: 4.29202967422018 4.741863119908242
Guesses: 4.741863119908242 4.438204569837609
Guesses: 4.438204569837609 4.635299887107611
Guesses: 4.635299887107611 4.50397811613643
Guesses: 4.50397811613643 4.589989462723705
Guesses: 4.589989462723705 4.53301150767844
Guesses: 4.53301150767844 4.570475672855484
Guesses: 4.570475672855484 4.545720389670642
Guesses: 4.545720389670642 4.562024936588171
Guesses: 4.562024936588171 4.551263234080531
Guesses: 4.551263234080531 4.55835638768598
Guesses: 4.55835638768598 4.553676852183342
Guesses: 4.553676852183342 4.55676216434628
Guesses: 4.55676216434628 4.554727130670954
Guesses: 4.554727130670954 4.556069054770006
Guesses: 4.556069054770006 4.555184018843625
Guesses: 4.555184018843625 4.5557676565438205
Guesses: 4.5557676565438205 4.555382746639082
Guesses: 4.555382746639082 4.55563658243586
Guesses: 4.55563658243586 4.555469180245326
Guesses: 4.555469180245326 4.555579577900997
Guesses: 4.555579577900997 4.5555067722873686
Guesses: 4.5555067722873686 4.5555547860484085
Guesses: 4.5555547860484085 4.555523121789556
Guesses: 4.555523121789556 4.555544003742869
Guesses: 4.555544003742869 4.555530232469306
Guesses: 4.555530232469306 4.555539314360711
4.555539314360711
#+end_src

#+name: fixed-point-verbose-with-dampening
#+begin_src scheme :exports code :results none
  (define tolerance 0.00001)
  (define (fixed-point f first-guess)
    (define (close-enough? v1 v2)
      (display "Guesses: ")
      (display v1)
      (display " ")
      (display v2)
      (newline)
      (< (abs (- v1 v2))
	 tolerance))
    (define (try guess)
      (let ((next (f guess)))
	(if (close-enough? guess next)
	    next
	    (try (/ (+ guess next) 2)))))
  (try first-guess))
#+end_src

#+begin_src scheme :exports both :results output scalar code
<<fixed-point-verbose-with-dampening>>
<<log1000>>
(display (fixed-point log1000/logx 5))
#+end_src

#+RESULTS[1db22c830c5e50ff8bb638efc758db1a7ef6e769]:
#+begin_src scheme
Guesses: 5 4.29202967422018
Guesses: 4.64601483711009 4.49720773504196
Guesses: 4.571611286076025 4.544977348996107
Guesses: 4.558294317536066 4.553717728226165
Guesses: 4.556006022881116 4.555225576581478
Guesses: 4.555615799731297 4.555482885419889
Guesses: 4.555549342575593 4.555526711628406
Guesses: 4.555538027101999 4.555534173941779
4.555534173941779
#+end_src

Well, the amount of steps is visibly smaller. Works.

*** DONE Exercise 1.37 cont-frac
    CLOSED: [2019-09-04 Wed 11:35]

**** a. recursive
     CLOSED: [2019-09-04 Wed 11:35]

#+name: cont-frac-recursive
#+begin_src scheme :exports code :results none
  (define (cont-frac n d k)
    (define (next step)
      (if (< step k)
	  (/ (n step) (+ (d step) (next (+ step 1))) )
	  0))
    (next 1))
#+end_src

#+begin_src scheme :exports both :results value scalar code
<<cont-frac-recursive>>
  (/ 1 (cont-frac (lambda (i) 1.0) (lambda (i) 1.0) 14))
#+end_src

#+RESULTS[b4b39ebc339a70ff3a47a199cb2336b5f605e9f8]:
#+begin_src scheme
1.6180257510729614
#+end_src

Abelson and Sussman tell us to estimate \(k\) needed to approximate the \(\varphi\) to a required
degree (0.0001). I didn't manage to derive the formula myself, however, I can
give a link to the book where this proof is given:

Khinchin, Continued Fractions (1935), chapter 2, section 7, gives an upper
bound on the speed of convergence as \(\frac{1}{k^2}\). Therefore we should
expect \(k \approx \sqrt{1000} \approx 33\). This holds for an arbitrary convergent
continued fraction. In our case, however, when \(N_k=D_k=1\), the constant in
the rate is also known as \(\sqrt{5}\), so the equation we need to solve is
in fact \(k^2 \sqrt{5} = 1000\), and in practice that is
\(\sqrt{\frac{1000}{2.23}} = 21\). How exactly we managed to do it in 14
steps, I don't know.

**** b. iterative
     CLOSED: [2019-09-04 Wed 11:35]

We just start computing from the end.

#+name: cont-frac
#+begin_src scheme :exports code :results none
  (define (cont-frac n d k)
    (define (next step accumulator)
      (if (> step 0)
	  (next (- step 1) (/ (n step) (+ (d step) accumulator)))
	  accumulator))
    (next k 0))
#+end_src

#+begin_src scheme :exports both :results value scalar code
<<cont-frac>>
  (/ 1 (cont-frac (lambda (i) 1.0) (lambda (i) 1.0) 14))
#+end_src

#+RESULTS[0b02b4029ea818eaa447b667e2cd6492984a42a3]:
#+begin_src scheme
1.6180371352785146
#+end_src

Remark: this exercise took me 7 hours.

*** DONE Exercise 1.38 euler constant
    CLOSED: [2019-09-04 Wed 11:35]

The only difficulty with this exercise is to derive the formula for the
second lambda.

#+begin_src scheme :exports both :results value scalar code
  <<cont-frac>>
  (+ 2
     (cont-frac
      (lambda (i) 1.0)
      (lambda (i) (if (= (remainder i 3) 2) (+ (* (/ i 3) 2) 2) 1))
      14 ))
#+end_src

#+RESULTS[1ab85e2eb56da31f8968b95ca064d75778e33fcf]:
#+begin_src scheme
2.7947716625369976
#+end_src

*** DONE Exercise 1.39 tan-cf
    CLOSED: [2019-09-04 Wed 12:11]
    :LOGBOOK:

    :END:
#+begin_src scheme :exports both :results output scalar code
  <<cont-frac>>
  (define (tan-cf x k)
    (cont-frac
     (lambda (i)
       (if (= i 1) x (- (* x x))))
     (lambda (i)
       (- (* 2 i) 1))
     k))
  (display (tan 0.1))
  (newline)
  (display(tan-cf 0.1 300))
#+end_src

#+RESULTS[b5ebb9fb759addab970143b19270ee7664d12956]:
#+begin_src scheme
0.10033467208545055
0.10033467208545055
#+end_src

*** DONE Exercise 1.40 newtons-method
    CLOSED: [2019-09-04 Wed 17:06]

#+name: deriv
#+begin_src scheme :exports code :results none
  (define (deriv g)
    (lambda (x) (/ (- (g (+ x dx)) (g x)) dx)))
  (define dx 0.00001)
#+end_src

#+name: newtons-method
#+begin_src scheme :exports code :results none
  (define (newton-transform g)
    (lambda (x) (- x (/ (g x) ((deriv g) x)))))
  (define (newtons-method g guess)
    (fixed-point (newton-transform g) guess))
#+end_src

#+name: square
#+begin_src scheme :exports code :results none
(define (square x)
 (* x x))
#+end_src

#+name: cube
#+begin_src scheme :exports code :results none
(define (cube x)
  (* x x x))
#+end_src

#+name: cubic
#+begin_src scheme :exports code :results none
  (define (cubic a b c)
    (lambda (x) (+ (cube x) (* a (square x)) (* b x) c)))x
#+end_src

#+name: inc
#+begin_src scheme :exports code :results none
(define (inc x) (+ x 1))
#+end_src

#+begin_src scheme :exports both :results output scalar code
<<fixed-point-silent>>
<<cubic>>
<<cube>>
<<square>>
<<deriv>>
<<newtons-method>>

(display (newtons-method (cubic 5 3 1) 1))
#+end_src

#+RESULTS[8ad9c6b9df43b8527f83429c7b88f04d8301deae]:
#+begin_src scheme
-4.365230013406062
#+end_src

Theoretically, a cubic may have up to 3 roots, but to find all of them we
would need to try over all possible ones.

*** DONE Exercise 1.41 double-double
    CLOSED: [2019-09-04 Wed 17:21]

#+name: double-function
#+begin_src scheme :exports code :results none
(define (double fun)
  (lambda (x) (fun (fun x))))
(define (inc x)
  (+ x 1))
#+end_src

#+begin_src scheme :exports both :results value scalar code
<<double-function>>
(((double double) inc) 5)
#+end_src

#+RESULTS[ab989b14f8802aa8caeb28883b13b3321d2ffaa8]:
#+begin_src scheme
9
#+end_src

#+begin_src scheme :exports both :results value scalar code
<<double-function>>
(((double (double double)) inc) 5)
#+end_src

#+RESULTS[09b30d5ddb1c3f8f5f4d093b17f10be745753849]:
#+begin_src scheme
21
#+end_src

\(21 = 5 + 16\)
Double really works as a power of a function. \( 2 \Rightarrow 2^2 \Rightarrow2^{2^2} =
\mbox{inc}^{16} 5 \)
*** DONE Exercise 1.42 compose
    CLOSED: [2019-09-04 Wed 17:27]

#+name: compose
#+begin_src scheme :exports code :results none
(define (compose f g)
  (lambda (x) (f (g x))))
#+end_src

#+begin_src scheme :exports both :results value scalar code
<<compose>>
<<square>>
<<inc>>
((compose square inc) 6)
#+end_src

#+RESULTS[75c48977607e0ea76ac4266e7e0e97c78e96b8bb]:
#+begin_src scheme
49
#+end_src

*** DONE Exercise 1.43 repeated
    CLOSED: [2019-09-04 Wed 17:54]

#+name: repeated
#+begin_src scheme :exports code :results none
  (define (repeated fun n)
    (define (repeat-it n fun combinator)
      (if (= n 1)
	  combinator
	  (repeat-it  (- n 1) fun (lambda (x) (fun (combinator x))))))
      (repeat-it n fun fun))
#+end_src

#+begin_src scheme :exports both :results value scalar code
<<repeated>>
<<square>>

((repeated square 2) 5)
#+end_src

#+RESULTS[9fefef3c72e4956450f471ca00d4367a1e0ad6ee]:
#+begin_src scheme
625
#+end_src

Hm. Managed to do it without the ~compose~ form.

*** DONE Exercise 1.44 smoothing
    CLOSED: [2019-09-04 Wed 20:17]

#+name: smooth
#+begin_src scheme :exports code :results none
  (define dx 0.1)
  (define (smooth f)
    (lambda (x) (/ (+ (f (- x dx))
		 (f x)
		 (f (+ x dx)))
	      3)))
#+end_src

#+name: n-smoothed
#+begin_src scheme :exports code :results none
  (define (n-smoothed fun n)
    ((repeated smooth n) fun))
#+end_src

#+begin_src scheme :exports both :results output scalar code
<<smooth>>
<<n-smoothed>>
<<repeated>>
<<cube>>
(define (ex144-answer x)
  ((n-smoothed cube 3) x))
(display (ex144-answer 10))
#+end_src

#+RESULTS[07b4d49230d34dd4338c9ad781cf828984cb42a6]:
#+begin_src scheme
1000.6
#+end_src

Looks like what we wanted.

*** DONE Exercise 1.45 nth-root
    CLOSED: [2019-09-04 Wed 21:37]

#+name: average
#+begin_src scheme :exports code :results none
(define (average x y)
   (/ (+ x y) 2))
#+end_src

#+name: average-damp
#+begin_src scheme :exports code :results none
(define (average-damp f)
  (lambda (x) (average x (f x))))
#+end_src

#+name: n-average-damp
#+begin_src scheme :exports code :results none
(define (n-average-damped f n)
   ((repeated average-damp n) f))
#+end_src

#+name: better-fixed-point
#+begin_src scheme :exports code :results none
  (define tolerance 0.0001)
  (define (fixed-point f first-guess)
    (define (close-enough? v1 v2)
      (< (abs (- v1 v2))
	 tolerance))
    (define (try guess)
       (let ((next (f guess)))
	(if (close-enough? guess next)
	    next
	    (try next))))
  (try first-guess))
#+end_src

#+name: root-n-x
#+begin_src scheme :exports code :results none
  (define (root n x initial-guess)
    (fixed-point
     (n-average-damped
      (lambda (y) (/ x (pow y (- n 1))))
      n)
      initial-guess))
#+end_src

#+name: pow-recursive
#+begin_src scheme :exports code :results none
(define (pow x n)
 (if (= n 1)
   x
   (* x (pow x (- n 1)))))
#+end_src

#+begin_src scheme :exports both :results output scalar code
<<average>>
<<average-damp>>
<<repeated>>
<<better-fixed-point>>
<<n-average-damp>>
<<pow-recursive>>
<<root-n-x>>
(display (root 4 4 3.0))

#+end_src

#+RESULTS[815559867bae3312052d0ffc8f4b8ddcfc8a3228]:
#+begin_src scheme
1.4144444873765194
#+end_src

The true answer would require to actually estimate the dampening factor, but
we know that *n* is enough, and I am lazy.

*** DONE Exercise 1.46 iterative-improve
    CLOSED: [2019-09-04 Wed 22:25]

#+name: iterative-improve
#+begin_src scheme :exports code :results none
  (define (iterative-improve good-enough? improve)
    (define (improver guess)
      (if (good-enough? guess)
	  guess
	  (improver (improve guess))))
  improver)
#+end_src

**** a. sqrt
     CLOSED: [2019-09-04 Wed 22:24]

#+begin_src scheme :exports both :results value scalar code
    <<square>>
    <<iterative-improve>>
    (define (ex1.46sqrt x)
      (let (
	    (square-improver
	     (iterative-improve
	      (lambda (y) (< (abs (- (square y) x )) 0.01))
	      (lambda (y) (/ (+ y (/ x y)) 2)))
	     )
	    )
	(square-improver 1)))
    (ex1.46sqrt 2.0)
#+end_src

#+RESULTS[cdf4013027e726f34089f4136db715d0cb6b91ac]:
#+begin_src scheme
1.4166666666666665
#+end_src

**** b. fixed-point
     CLOSED: [2019-09-04 Wed 22:25]

#+begin_src scheme :exports both :results value scalar code
    <<square>>
    <<iterative-improve>>
    (define (fixpoint f)
      (let ((fixpoint-improver (iterative-improve
	                          (lambda (y) (< (abs (- (f y) y )) 0.01))
	                          (lambda (y) (/ (+ y (f y)) 2)))))
	(fixpoint-improver 1.0)))
    (fixpoint (lambda (x) (+ 1 (/ 1 x))))
#+end_src

#+RESULTS[baccd7284aabd6dcdf3933ffb034e9b2b6677e57]:
#+begin_src scheme
1.6147785476652068
#+end_src



I have made it. At [2019-09-04 Wed 22:25] I still haven't implemented all the
pictures, but I already can say that I have solved _all_ problems of the
first chapter of SICP. Some macros are wrong, I need to revise them, but that
will be done on the second pass. (Yes, there will be a second [or, rather, third] pass!)

** Chapter 2: Building abstractions with data [98/98]

*** DONE Exercise 2.1 make-rat
    CLOSED: [2019-09-06 Fri 13:00]


In this exercise I will also define the functions presented by Abelson
and Sussman for general reference.
#+name: make-rat
#+begin_src scheme :exports code :results none
  (define (make-rat numerator denominator)
    (let* ((my-gcd (gcd numerator denominator))
	   (numerator (/ numerator my-gcd))
	   (denominator (/ denominator my-gcd))
	   (sign (/ (abs denominator) denominator)))
      (cons (* numerator sign) (* denominator sign))))

  (define (numer x)
    (car x))

  (define (denom x)
    (cdr x))
#+end_src

#+name: 2.2.1-basic-rat
#+begin_src scheme :exports code :results none
  (define (add-rat x y)
    (make-rat (+ (* (numer x) (denom y))
		 (* (numer y) (denom x)))
	      (* (denom x) (denom y))))
  (define (sub-rat x y)
    (make-rat (- (* (numer x) (denom y))
		 (* (numer y) (denom x)))
	      (* (denom x) (denom y))))
  (define (mul-rat x y)
    (make-rat (* (numer x) (numer y))
	      (* (denom x) (denom y))))

  (define (div-rat x y)
    (make-rat (* (numer x) (denom y))
	      (* (denom x) (numer y))))
  (define (equal-rat? x y)
    (= (* (numer x) (denom y))
       (* (numer y) (denom x))))

#+end_src

#+name: print-rat
#+begin_src scheme :exports code :results none
  (define (print-rat x)
    (newline)
    (display (numer x))
    (display "/")
    (display (denom x)))
#+end_src

#+begin_src scheme :exports both :results output scalar code
<<print-rat>>
<<2.2.1-basic-rat>>
<<make-rat>>
(define one-half (make-rat -65 -5))
(print-rat one-half)
#+end_src

#+RESULTS[a46827c8e659ff319fdedfaae1430ef9326e41d3]:
#+begin_src scheme

13/1
#+end_src

*** DONE Exercise 2.2 make-segment
    CLOSED: [2019-09-06 Fri 13:34]

#+name: make-segment
#+begin_src scheme :exports code :results none
  (define (make-segment x1 y1 x2 y2)
    (cons (make-point x1 y1)  (make-point x2 y2)))

  (define (start-segment segment)
    (car segment))

  (define (end-segment segment)
    (cdr segment))

  (define (make-point x y)
    (cons x y))

  (define (x-point point)
    (car point))

  (define (y-point point)
    (cdr point))

  (define (midpoint-segment segment)
    (make-point (/ (+ (x-point (start-segment segment))
		   (x-point (end-segment   segment))) 2)
		(/ (+ (y-point (start-segment segment))
		   (y-point (end-segment   segment))) 2)))

#+end_src

#+name: print-point
#+begin_src scheme :exports code :results none
  (define (print-point p)
    (newline)
    (display "(")
    (display (x-point p))
    (display ",")
    (display (y-point p))
    (display ")"))
#+end_src

#+begin_src scheme :exports both :results output scalar code
<<print-point>>
<<make-segment>>
(print-point (midpoint-segment (make-segment 1 0 0 1)))
#+end_src

#+RESULTS[41bfb4c0a8f5a393b3d977f83d2107d3f8fe60fd]:
#+begin_src scheme

(1/2,1/2)
#+end_src

The task looks pretty straightforward. Just make a cons of points.

*** DONE Exercise 2.3 make-rectangle
    CLOSED: [2019-09-08 Sun 17:58]

I will choose the following two representations:
 - List of points from top left to the right.
 - Two lists of coordinates, x and y.

I will not be using segments from Exercise 2.2, because then I would
have to care about the consistency of the first and the last point in
the four segments.

#+name: rectangle
#+begin_src scheme :exports code :results none
  (define (area rectangle)
    (* (get-height rectangle) (get-width rectangle)))
  (define (perimeter rectangle)
    (* 2 (+ (get-height rectangle) (get-width rectangle))))
  (define (get-height rectangle)
    (dist (nth-point 1 rectangle) (nth-point 2 rectangle)))
  (define (get-width rectangle)
    (dist (nth-point 2 rectangle) (nth-point 3 rectangle)))
  (define (dist point1 point2)
    (+ (square (- (x-point point1) (x-point point2))) (square (- (y-point point1) (y-point point2)))))

#+end_src

#+name: rectangle-point-list
#+begin_src scheme :exports code :results none
  (define (make-rectangle x1 y1 x2 y2 x3 y3 x4 y4)
    (list (make-point x1 y1)
	  (make-point x2 y2)
	  (make-point x3 y3)
	  (make-point x4 y4)))
  (define (nth-point n rectangle)
    (if (= n 1)
	(car rectangle)
	(nth-point (- n 1) (cdr rectangle))))
#+end_src


#+name: rectangle-two-lists
#+begin_src scheme :exports code :results none
  (define (make-rectangle x1 y1 x2 y2 x3 y3 x4 y4)
    (cons (list x1 x2 x3 x4) (list y1 y2 y3 y4)))

  (define (nth-point n rectangle)
    (if (= n 1)
	(make-point (caar rectangle) (cadr rectangle))
	(nth-point (- n 1) (cons (cdar rectangle) (cddr rectangle)))))
#+end_src

#+begin_src scheme :exports both :results output scalar code
  <<rectangle>>
  <<rectangle-point-list>>
  <<make-segment>>
  (let ((test1 (make-rectangle 0 0 0 1 1 1 1 0)))
    (display "Area=")
    (display (area test1))
    (newline)
    (display "Perimeter=")
    (display (perimeter test1))
    (newline))

#+end_src

#+RESULTS[45128b1186dd1260d41e1048600e89a383b35974]:
#+begin_src scheme
Area=1
Perimeter=4
#+end_src


#+begin_src scheme :exports both :results output scalar code
  <<rectangle>>
  <<rectangle-two-lists>>
  <<make-segment>>
  (let ((test1 (make-rectangle 0 0 0 1 1 1 1 0)))
    (display "Area=")
    (display (area test1))
    (newline)
    (display "Perimeter=")
    (display (perimeter test1))
    (newline))

#+end_src

#+RESULTS[df82a886bb364d13d372f714fbcf6717fd6cbb8c]:
#+begin_src scheme
Area=1
Perimeter=4
#+end_src

This is not very efficient, but two implementations were requested --
and they were delivered.

*** DONE Exercise 2.4 cons-lambda
    CLOSED: [2019-09-08 Sun 18:08]

#+begin_src scheme :exports both :results output scalar code
  (define (cons x y)
    (lambda (m) (m x y)))
  (define (car z)
    (z (lambda (p q) p)))
  (define (cdr z)
    (z (lambda (p q) q)))

  (display (car (cons 'a 'b)))
  (newline)
  (display (cdr (cons 'a 'b)))
  (newline)
#+end_src

#+RESULTS[cd11da54ed5728303a8bde3d52336c46450fe34b]:
#+begin_src scheme
a
b
#+end_src

*** DONE Exercise 2.5 cons-pow
    CLOSED: [2019-09-08 Sun 19:07]
    0:00:00 -- 0:56:02

#+name: ex2.5cons
#+begin_src scheme :exports code :results none
(define (cons a b)
  (* (expt 2 a) (expt 3 b)))
#+end_src

#+name: ex2.5car
#+begin_src scheme :exports code :results none
(define (car number)
  (log (gcd (expt 2.0 (floor (log number 2))) number) 2))
(define (cdr number)
  (log (gcd (expt 3.0 (floor (log number 2))) number) 3))
#+end_src


#+begin_src scheme :exports both :results value scalar code
<<ex2.5car>>
<<ex2.5cons>>

(list (car (cons 14 4)) (cdr (cons 14 4)))
#+end_src

#+RESULTS[0d284b015d467230ab38fc8a3b6607388adedbc5]:
#+begin_src scheme
(14.0 4.0)
#+end_src

*** DONE Exercise 2.6 Church Numerals
    CLOSED: [2019-09-08 Sun 19:41]
0:00:00 -- 0:23:58

In the worst case this exercise can be copied literally right from the
Wikipedia article: https://en.wikipedia.org/wiki/Church_encoding

#+name: church-zero
#+begin_src scheme :exports code :results none
  (define identity (lambda (x) x))
  (define zero (lambda (f) identity))
  (define (add-1 n)
    (lambda (f) (lambda (x) (f ((n f) x)))))
#+end_src

#+begin_src scheme :exports code :results none
  <<church-zero>>
  (define one (lambda (f) (lambda (x) (f x))))
  (define two (lambda (f) (lambda (x) (f (f x)))))
  (define (plus a b)
    (lambda (f) (lambda (x) ((a f) ((b f) x)))))
#+end_src


*** DONE Exercise 2.7 make-interval
    CLOSED: [2019-09-08 Sun 20:09]
0:00:00 -- 0:20:09

#+name: make-interval
#+begin_src scheme :exports code :results none
  (define (make-interval a b)
    (cons a b))
  (define (upper-bound interval)
    (max (car interval) (cdr interval)))
  (define (lower-bound interval)
    (min (car interval) (cdr interval)))
#+end_src

#+name: interval-common
#+begin_src scheme :exports code :results none
  (define (add-interval x y)
    (make-interval (+ (lower-bound x) (lower-bound y))
		   (+ (upper-bound x) (upper-bound y))))
#+end_src

#+name: mul-interval-simple
#+begin_src scheme :exports code :results none
  (define (mul-interval x y)
    (let ((p1 (* (lower-bound x) (lower-bound y)))
	  (p2 (* (lower-bound x) (upper-bound y)))
	  (p3 (* (upper-bound x) (lower-bound y)))
	  (p4 (* (upper-bound x) (upper-bound y))))
      (make-interval (min p1 p2 p3 p4)
		     (max p1 p2 p3 p4))))
#+end_src

#+name: div-interval-lame
#+begin_src scheme :exports code :results none
  (define (div-interval x y)
    (mul-interval
     x
     (make-interval (/ 1.0 (upper-bound y))
		    (/ 1.0 (lower-bound y)))))
#+end_src

#+begin_src scheme :exports both :results output scalar code
<<make-interval>>
<<interval-common>>
<<div-interval-lame>>
<<mul-interval-simple>>
(show #t " " (add-interval (make-interval 5 5.6) (make-interval 6 6.1)) "\n")
(show #t " " (mul-interval (make-interval -0.1 0.1) (make-interval 100 110)) "\n")
(show #t " " (div-interval (make-interval -0.1 0.1) (make-interval 100 110)))
#+end_src

#+RESULTS[2f54e2fb17bf05f4ce9fe350338525c225a512e2]:
#+begin_src scheme
 (11.0 . 11.7)
 (-11.0 . 11.0)
 (-0.001 . 0.001)
#+end_src

*** DONE Exercise 2.8 sub-interval
    CLOSED: [2019-09-08 Sun 23:07]

#+name: sub-interval
#+begin_src scheme :exports code :results none
  (define (sub-interval a b)
    (make-interval (- (upper-bound a) (lower-bound b))
		   (- (lower-bound a) (upper-bound b))))
#+end_src

#+begin_src scheme :exports both :results output scalar code
<<make-interval>>
<<sub-interval>>
(show #t " " (sub-interval (make-interval 100 -100) (make-interval -1 101)))
#+end_src

#+RESULTS[1eb5456df153d65d8e8770545ef84d9ce3466ae1]:
#+begin_src scheme
 (101 . -201)
#+end_src

*** DONE Exercise 2.9 interval-width
    CLOSED: [2019-09-08 Sun 23:15]
 0:06:00

#+begin_src scheme :exports code :results none
  (define (width interval)
    (abs (- (upper-bound interval) (lower-bound interval))))
#+end_src

\( a + \Delta a + b + \Delta b = (a+b) + (\Delta a + \Delta b)\)
\((a+\Delta a)\cdot (b+\Delta b) = (a\cdot b) + (a\Delta b + b\Delta a + \Delta a \Delta b)\)

The formulae above should relatively convincingly explain why the
width is not the function of the initial widths only in the case of
multiplication.

*** DONE Exercise 2.10 div-interval-better
    CLOSED: [2019-09-08 Sun 23:30]
0:14:50
The initial Alyssa's construction is:

#+name: div-interval-better
#+begin_src scheme :exports code :results none
  (define (div-interval x y)
    (when (and (< (lower-bound y) 0) (> (upper-bound y) 0))
      (error "Division by zero." (list x y)))
      (mul-interval
       x
       (make-interval (/ 1.0 (upper-bound y))
		      (/ 1.0 (lower-bound y)))))
#+end_src

#+begin_src scheme :exports both :results output scalar code
<<div-interval-better>>
<<make-interval>>
(display (div-interval (make-interval 1 2) (make-interval -1 1)))
#+end_src

#+RESULTS[6f91a411c5cd13546c5e1a3a5bafa36b6b804a2b]:
#+begin_src scheme

Output (exception): {Exception #19 user "Division by zero." (((1 . 2) (-1 . 1))) #f #f} 
Stack trace:
  called from <anonymous> on line 817 of file /usr/lib64/chibi/init-7.scm
  called from <anonymous> on line 280 of file /usr/lib64/chibi/init-7.scm
  called from <anonymous> on line 1206 of file /usr/lib64/chibi/init-7.scm
  called from <anonymous> on line 817 of file /usr/lib64/chibi/init-7.scm
  called from error on line 100 of file /usr/lib64/chibi/init-7.scm
  called from div-interval on line 3
  called from <anonymous> on line 11
  called from <anonymous> on line 817 of file /usr/lib64/chibi/init-7.scm
  called from call-with-current-continuation on line 844 of file /usr/lib64/chibi/init-7.scm
  called from <anonymous> WARNING: reference to undefined variable: mul-interval
on line 817 of file /usr/lib64/chibi/init-7.scm
  called from <anonymous> on line 280 of file /usr/lib64/chibi/init-7.scm
  called from <anonymous> on line 280 of file /usr/lib64/chibi/init-7.scm
  called from <anonymous> on line 817 of file /usr/lib64/chibi/init-7.scm
  called from call-with-current-continuation on line 844 of file /usr/lib64/chibi/init-7.scm
  called from geiser:eval on line 25 of file /usr/lib64/chibi/scheme/misc-macros.scm
#+end_src

*** DONE Exercise 2.11 mul-interval-nine-cases
    CLOSED: [2019-09-09 Mon 00:45]
1:06:58

| number | lower x | upper x | lower y | upper y |
|--------+---------+---------+---------+---------|
|      2 | +       | +       | +       | +       |
|      2 | +       | +       | -       | +       |
|      2 | +       | +       | -       | -       |
|      2 | -       | +       | +       | +       |
|      3 | -       | +       | -       | +       |
|      2 | -       | +       | -       | -       |
|      2 | -       | -       | +       | +       |
|      2 | -       | -       | -       | +       |
|      2 | -       | -       | -       | -       |


#+name: mul-interval
#+begin_src scheme :exports code :results none
  (define (mul-interval x y)
    (let ((x1 (lower-bound x))
	  (x2 (upper-bound x))
	  (y1 (lower-bound y))
	  (y2 (upper-bound y)))
      (cond ((and (> x1 0) (> x2 0) (> y1 0) (> y2 0)) (make-interval (* x1 y1) (* x2 y2)))
	    ((and (> x1 0) (> x2 0) (< y1 0) (> y2 0)) (make-interval (* x2 y1) (* x2 y2)))
	    ((and (> x1 0) (> x2 0) (< y1 0) (< y2 0)) (make-interval (* x2 y1) (* x2 y1)))
	    ((and (< x1 0) (> x2 0) (> y1 0) (> y2 0)) (make-interval (* x1 y2) (* x2 y2)))
	    ((and (< x1 0) (> x2 0) (< y1 0) (> y2 0))
	     (let ((p1 (* (lower-bound x) (lower-bound y)))
		   (p2 (* (lower-bound x) (upper-bound y)))
		   (p3 (* (upper-bound x) (lower-bound y)))
		   (p4 (* (upper-bound x) (upper-bound y))))
	       (make-interval (min p1 p2 p3 p4)
			      (max p1 p2 p3 p4))))
	    ((and (< x1 0) (> x2 0) (< y1 0) (< y2 0)) (make-interval (* x2 y2) (* x2 y1)))
	    ((and (< x1 0) (< x2 0) (> y1 0) (> y2 0)) (make-interval (* x1 y2) (* x2 y1)))
	    ((and (< x1 0) (< x2 0) (< y1 0) (> y2 0)) (make-interval (* x2 y2) (* x1 y1)))
	    ((and (< x1 0) (< x2 0) (< y1 0) (< y2 0)) (make-interval (* x2 y2) (* x1 y1))))))
#+end_src

I don't even want to test it.

#+begin_src scheme :exports both :results output scalar code
<<mul-interval>>
<<make-interval>>
(show #t " " (mul-interval (make-interval -2 2) (make-interval -5 6)))

#+end_src

#+RESULTS[181e5d02e22a74c8a7c6216e5e449e5cd4831e5a]:
#+begin_src scheme
 (-12 . 12)
#+end_src

Marvelous.

*** DONE Exercise 2.12 make-center-percent
    CLOSED: [2019-09-09 Mon 10:11]

#+name: make-center-width
#+begin_src scheme :exports code :results none
  (define (make-center-width c w)
    (make-interval (- c w) (+ c w)))
  (define (center i)
    (/ (+ (lower-bound i) (upper-bound i)) 2))
  (define (width i)
    (/ (- (upper-bound i) (lower-bound i)) 2))
#+end_src

#+name: make-center-precision
#+begin_src scheme :exports code :results none
  (define (make-center-percent center percent)
    (let ((delta (* center (/ percent 100))))
      (make-interval  (+ center delta) (- center delta))))
  (define (relative-precision interval)
    (let* ((center (/ (+ (lower-bound interval) (upper-bound interval))
		     2))
	   (percent (/ (abs (- (lower-bound interval) (upper-bound interval))) 2)))
      (/ percent center)))
#+end_src


#+begin_src scheme :exports both :results output scalar code
<<make-center-width>>
<<make-center-precision>>
<<make-interval>>
  (let ((test-interval (make-center-percent 100 2)))
    (show #t " " test-interval "\n")
    (show #t " " (center test-interval) "\n")
    (show #t " " (relative-precision test-interval)) "\n")
#+end_src

#+RESULTS[615bfdaa243a8823b4c77b2c7788f22a21092655]:
#+begin_src scheme
 (102 . 98)
 100
 1/50
#+end_src

*** DONE Exercise 2.13 formula for tolerance
    CLOSED: [2019-09-09 Mon 10:16]

\((a+\Delta a)\cdot (b+\Delta b) = (a\cdot b) + (a\Delta b + b\Delta a + \Delta a \Delta b)\)
\(\frac{(a+\Delta a)\cdot (b+\Delta b)}{a\cdot b} = \frac{(a\cdot b)}{a\cdot b} + \frac{(a\Delta b +
b\Delta a + \Delta a \Delta b)}{a \cdot b} \approx 1 + \frac{\Delta a}{a} + \frac{\Delta b}{b}\)

*** DONE Exercise 2.14 parallel-resistors
    CLOSED: [2019-09-09 Mon 11:24]
0:37:00 +  0:31:07 = 1:06:07
#+begin_src scheme :exports both :results output scalar code
  <<make-interval>>
  <<div-interval-better>>
  <<mul-interval>>
  <<interval-common>>
  (define (par1 r1 r2)
    (div-interval (mul-interval r1 r2)
		  (add-interval r1 r2)))
  (define (par2 r1 r2)
    (let ((one (make-interval 1 1)))
      (div-interval
       one (add-interval (div-interval one r1)
			 (div-interval one r2)))))

  (show #t " " (par1 (make-interval 4.9 5.1) (make-interval 6.9 7.1)) "\n")
  (show #t " " (par2 (make-interval 4.9 5.1) (make-interval 6.9 7.1)) "\n")
#+end_src

#+RESULTS[2d2b62da993de636b5c8fc252b5cc8b43b6d9145]:
#+begin_src scheme
 (2.7713114754098367 . 3.0686440677966096)
 (2.8652542372881356 . 2.968032786885246)
#+end_src

It is worth noticing that ~par2~ uses more operations than
~par1~. Even if the title problem in the exercise wasn't present, we
would still get a less precise result.

#+begin_src scheme :exports both :results output scalar code
    <<make-interval>>
    <<mul-interval>>
    <<div-interval-better>>
    (let ((one (make-interval 1.0 1.0))
	  (i2 (make-interval 4.9 5.1))
	  (i3 (make-interval 6.9 7.1)))
      (show #t " " (div-interval one one) "\n")
      (show #t " " (div-interval one i2) "\n")
      (show #t " " (div-interval i2 i2) "\n")
      (show #t " " (div-interval i2 i3) "\n")
      (show #t " " (mul-interval  i2 (div-interval one i2)) "\n"))

#+end_src

#+RESULTS[309837c7b08d888b89be92612296100a81762cf9]:
#+begin_src scheme
 (1.0 . 1.0)
 (0.19607843137254904 . 0.2040816326530612)
 (0.9607843137254903 . 1.040816326530612)
 (0.6901408450704226 . 0.7391304347826086)
 (0.9607843137254903 . 1.040816326530612)
#+end_src

The idea here is, in some sense, the non-independence of the random
variables *i2* and *i2*. Regardless of the precision of *i2*, we
_know_ that \(\frac{i_2}{i_2} = 1\).

The center-percent form I implemented is slightly different from the
one Abelson expected, I guess, but still,
\(\frac{1}{1} \approx 1 \pm 2\Delta\). This is too much.

*** DONE Exercise 2.15 better-intervals
    CLOSED: [2019-09-09 Mon 11:34]

I already answered this question in the Exercise 2.14. The problem is
of the potential independence (which may or may not be the case) of
*a* and *b*, but complete dependence of *a* on *a*, which is \(1\)
regardless of whether *a* is even well-defined.

*** DONE Exercise 2.16 interval-arithmetic
    CLOSED: [2019-09-09 Mon 11:37]

To solve this problem in the general case, on would have to build a
probability distribution of the function on the variables, and use
something of a probabilistic reduction on every step. I am not aware
of such systems if they even exist. It would be indispensable for
quantum modelling though.

Hypothetically, if such systems existed, they would do something like
build a distribution on every step of the computation and track every
quantity occurrence in every distribution.

*** Figure 2.2 Box-and-pointer representation of ~(cons 1 2)~. :graphviz:plantuml:tikz:

- https://gitlab.com/graphviz/graphviz/issues/1588
- https://gitlab.com/graphviz/graphviz/issues/1589

10:00:00

[2019-09-10 Tue 10:24] I managed to make pgf work with org-mode, but
didn't manage to  make a picture yet. So far this problem happened to
generalize to the case of drawing arbitrary vector graphics. Graphviz
turned out to be less fit for this problem.

#+begin_src plantuml :exports both :file figure-2-2.png
@startdot
digraph sicp2_2 {
    node [shape=none];
    source [label=""];

    node [shape=plaintext, style="rounded"];
    struct0 [label=<<table BORDER="0" CELLBORDER="1" CELLSPACING="0">
             <tr>
                 <td width="29" height="35" sides="ltrb" port="f1"></td>
                 <td width="29" height="35" sides="lrtb" port="f2"></td>
             </tr>
             </table>>, style="rounded,filled", fillcolor="gray"];
    rankdir=LR;
    node [shape=record, style="rounded"];
    struct2 [label="<f2> 2"];
    struct1 [label="<f1> 1"];
    edge [arrowhead=normal,arrowtail=dot];
    struct0:f2:c -> struct2:f0 [tailclip=false];
    struct0:f1:c -> struct1:f0 [tailclip=false];
    source -> struct0;
  }

@enddot
#+end_src

#+RESULTS[af93a2badd6d6ea4179dd3b5132ed8ce84f69df1]:
[[file:figure-2-2.png]]


#+begin_src plantuml :exports both :file ditaa.png
@startditaa
               +---+---+     +---+---+         +---+---+     +---+
          ---->| * | * |---->| * | * |    ---->| * | * |---->| 4 |
               +- -+---+     +- -+- -+         +-|-+---+     +---+
                 |             |   |             |
                 V             V   V             V
             +---+---+      +---+ +---+      +---+---+     +---+---+
             | * | * |      | 3 | | 4 |      | * | * +---->| * | * |
             +- -+- -+      +---+ +---+      +- -+---+     +- -+- -+
               |   |                           |             |   |
               V   V                           V             V   V
            +---+ +---+                      +---+        +---+ +---+
            | 1 | | 2 |                      | 1 |        | 2 | | 3 |
            +---+ +---+                      +---+        +---+ +---+

@endditaa
#+end_src

#+RESULTS[dbe2875a73facb6d444aacb9236a00a3c94553fd]:
[[file:ditaa.png]]

*** DONE Exercise 2.17 last-pair
    CLOSED: [2019-09-10 Tue 10:48]
0:20:51

#+name: last-pair
#+begin_src scheme :exports code :results none
  (define (last-pair lst)
    (list-tail lst (- (length lst) 1)))
#+end_src

#+begin_src scheme :exports both :results output scalar code
<<last-pair>>
(let ((tmp (last-pair '(1 1))))
(show #t " " (car tmp) " " (cdr tmp)))
#+end_src

#+RESULTS[00a6b99bfff216305143af13a9d14981b3e08317]:
#+begin_src scheme
 1 ()
#+end_src

*** DONE Exercise 2.18 reverse
    CLOSED: [2019-09-10 Tue 10:57]
0:03:56

#+name: reverse-list
#+begin_src scheme :exports code :results none
  (define (reverse lst)
    (define (lst-iter x y)
       (if (null? y)
	   x
	   (lst-iter (cons (car y) x) (cdr y))))
    (lst-iter '() lst))
#+end_src

#+begin_src scheme :exports both :results output scalar code
<<reverse-list>>
(show #t " " (reverse '(1 2 3)))
#+end_src

#+RESULTS[0a0e4b4d4a3500fa8c96accee2d22a19ffa1322f]:
#+begin_src scheme
 (3 2 1)
#+end_src

*** DONE Exercise 2.19 coin-values                                   :unsure:
    CLOSED: [2019-09-10 Tue 11:27]

#+name: coin-values
#+begin_src scheme :exports code :results none
  (define us-coins (list 50 25 10 5 1))
  (define uk-coins (list 100 50 20 10 5 2 1 0.5))
  (define uk-coins-damaged (list 0.50 100 50 20 10 5 2 1))

  (define (cc amount coin-values)
    (cond ((= amount 0) 1)
	  ((or (< amount 0) (no-more? coin-values)) 0)
	  (else
	   (+ (cc amount
		  (except-first-denomination
		   coin-values))
	      (cc (- amount
		     (first-denomination
		      coin-values))
		  coin-values)))))
#+end_src

#+name: first-denomination
#+begin_src scheme :exports code :results none
  (define (first-denomination coin-values)
    (car coin-values))
  (define (except-first-denomination coin-values)
    (cdr coin-values))
  (define (no-more? coin-values)
    (null? coin-values))
#+end_src

*Warning:* the next code is a bit slow (~1 minute).

#+begin_src scheme :exports both :results output scalar code
<<first-denomination>>
<<coin-values>>
(show #t " " (cc 137 us-coins) "\n")
(show #t " " (cc 137 uk-coins) "\n")
#+end_src

#+RESULTS[f3618a82451af30378c72dc5a2fc66ffe5d4809c]:
#+begin_src scheme
 704
 443166
#+end_src

#+begin_src scheme :exports both :results output scalar code
<<first-denomination>>
<<coin-values>>
(show #t " " (cc 137 uk-coins-damaged) "\n")
#+end_src

#+RESULTS[b0f8c86b64320798c63a6ffdf5307d35a2f24c20]:
#+begin_src scheme
 443166
#+end_src

I don't see why the result would depend on the order of the coins. We
don't seem to be using the order anywhere.

*** DONE Exercise 2.20 dotted-tail notation
    CLOSED: [2019-09-10 Tue 18:55]
1:45:10

#+name: same-parity
#+begin_src scheme :exports code :results none
  (define (same-parity . lst)
    (define (iter-parity lst bit accumulator)
      (cond ((null? lst)
	     accumulator)
	    ((= (remainder (car lst) 2) bit)
	     (iter-parity (cdr lst) bit (cons (car lst) accumulator)))
	    (else
	     (iter-parity (cdr lst) bit accumulator))))
   (reverse (iter-parity lst (remainder (car lst) 2) '())))
#+end_src

#+begin_src scheme :exports both :results output scalar code
<<same-parity>>
(show #t " " (same-parity 2 3 4) "\n")
(show #t " " (same-parity 1 2 3 4) "\n")
#+end_src

#+RESULTS[00a8905e20acd8e4af1509c939e8b30610c8eff5]:
#+begin_src scheme
 (2 4)
 (1 3)
#+end_src

*** DONE Exercise 2.21 map-square-list
    CLOSED: [2019-09-10 Tue 19:14]
0:13:23


#+begin_src scheme :exports both :results output scalar code
  (define nil #f)
  (define (square-list items)

  (if (null? items)
	'()
	(cons (* (car items) (car items)) (square-list (cdr items)))))
  (show #t " " (square-list '(1 2 3 4 5)))
#+end_src

#+RESULTS[e67285e74c27bc54511ecacfe79afe04d574c35e]:
#+begin_src scheme
 (1 4 9 16 25)
#+end_src

#+begin_src scheme :exports both :results output
  (define (square-list items)
    (map (lambda (x) (* x x)) items))

  (show #t " " (square-list '(1 2 3 4 5)))
#+end_src

#+RESULTS:
:  (1 4 9 16 25)

One of the peculiar tricks in this equation is that unlike in older
lisps, *#f* is not entirely the same as ~'()~, although they both
evaluate to false.

*** DONE Exercise 2.22 wrong list order
    CLOSED: [2019-09-10 Tue 19:24]
Referring to Exercise 2.20 is highly recommended.

The problem with the first solution is that, indeed, he's ~cons~'ing
the pair in such a way that it would produce the reversed list.

The problem with the second solution is that it IS creating a list-ish
construction that is contains all the elements in the right order, but
stores them in ~cdr~'s, not in ~car~'s.

In lisp without mutations (without ~set-cdr!~ and ~set-car!~), it is
only possible to prepend elements to lists, not really append.

*** DONE Exercise 2.23 for-each
    CLOSED: [2019-09-10 Tue 19:33]
0:04:56

#+begin_src scheme :exports both :results output scalar code
  (define (for-each fun items)
   (unless (null? items)
    (fun (car items))
    (for-each fun (cdr items))))

  (for-each (lambda (x)
	      (newline)
	      (display x))
	    (list 57 321 88))
#+end_src

#+RESULTS[d8d0451b604302ab38ca4a00c254b2138b32f7aa]:
#+begin_src scheme

57
321
88
#+end_src

*** DONE Exercise 2.24 list-plot-result                   :graphviz:plantuml:
    CLOSED: [2019-09-10 Tue 22:13]
0:48:39
The result of the interpreter:

#+begin_src scheme :exports both :results output scalar code
(show #t " " (list 1 (list 2 (list 3 4))))
#+end_src

#+RESULTS[96a5e8b9e1320fc90637b5613c96674c6872928b]:
#+begin_src scheme
 (1 (2 (3 4)))
#+end_src

The box-and-pointer structure:

#+begin_src plantuml :exports both :file exercise-2-24.png
  @startdot
  digraph sicp2_24 {
    node [shape=plaintext, style="rounded"];
    struct1 [label=<<table BORDER="0" CELLBORDER="1" CELLSPACING="0">
             <tr>
                 <td width="29" height="35" sides="ltrb" port="f0">1</td>
                 <td width="29" height="35" sides="lrtb" port="f1"></td>
             </tr>
             </table>>, style="rounded,filled", fillcolor="gray"];
    rankdir=LR;
    edge [arrowhead=normal,arrowtail=dot,tailclip=false, dir=both];
    struct1:f1:c -> struct2 [tailclip=false];

    node [shape=plaintext, style="rounded"];
    struct2 [label=<<table BORDER="0" CELLBORDER="1" CELLSPACING="0">
             <tr>
                 <td width="29" height="35" sides="ltrb" port="f0"></td>
                 <td width="29" height="35" sides="lrtb" port="f1">'()</td>
             </tr>
             </table>>, style="rounded,filled", fillcolor="gray"];

    struct2:f0:c -> struct3 [tailclip=false];

    node [shape=plaintext, style="rounded"];
    struct3 [label=<<table BORDER="0" CELLBORDER="1" CELLSPACING="0">
             <tr>
                 <td width="29" height="35" sides="ltrb" port="f0"></td>
                 <td width="29" height="35" sides="lrtb" port="f1"></td>
             </tr>
             </table>>, style="rounded,filled", fillcolor="gray"];

    node [shape=plaintext, style="rounded"];
    struct4 [label=<<table BORDER="0" CELLBORDER="1" CELLSPACING="0">
             <tr>
                 <td width="29" height="35" sides="ltrb" port="f0"></td>
                 <td width="29" height="35" sides="lrtb" port="f1">'()</td>
             </tr>
             </table>>, style="rounded,filled", fillcolor="gray"];
    struct3_3 [label="2",shape=record];
    struct3:f0:c -> struct3_3 [tailclip=false];

    struct3:f1:c -> struct4 [tailclip=false];

    struct5 [label=<<table BORDER="0" CELLBORDER="1" CELLSPACING="0">
             <tr>
                 <td width="29" height="35" sides="ltrb" port="f0">3</td>
                 <td width="29" height="35" sides="lrtb" port="f1"></td>
             </tr>
             </table>>, style="rounded,filled", fillcolor="gray"];
    struct4:f0:c -> struct5;

    struct6 [label=<<table BORDER="0" CELLBORDER="1" CELLSPACING="0">
             <tr>
                 <td width="29" height="35" sides="ltrb" port="f0">4</td>
                 <td width="29" height="35" sides="lrtb" port="f1">'()</td>
             </tr>
             </table>>, style="rounded,filled", fillcolor="gray"];
    struct5:f1:c -> struct6;

  }

  @enddot
#+end_src

#+RESULTS:
[[file:exercise-2-24.png]]

Tree interpretation:

#+begin_src plantuml :exports both :file exercise-2-24-plant.png
 @startdot
 graph g {
	 node [shape=plaintext];
	 A1 [label="(1 (2 (3 4)))"];

	 B1 [label="1"];
         B2 [label="(2 (3 4))"];

         C1 [label="2"];
         C2 [label="(3 4)"];

         D1 [label="3"];
         D2 [label="4"];


 // edges
	 A1 -- B1;
	 A1 -- B2;

	 B2 -- C1;
	 B2 -- C2;

	 C2 -- D1;
	 C2 -- D2;

	 { rank=same; A1 }
	 { rank=same; B1 B2 }
	 { rank=same; C1 C2 }
	 { rank=same; D1 D2 }
 }
@enddot
#+end_src

#+RESULTS[2b00e5b02b5b88f765783e9d071ed95a20ec5001]:
[[file:exercise-2-24-plant.png]]

*** DONE Exercise 2.25 caddr
    CLOSED: [2019-09-10 Tue 23:07]

#+begin_src scheme :exports both :results value scalar code
(car (cdr (car (cdr (cdr '(1 3 (5 7) 9))))))
#+end_src

#+RESULTS[821d7f7419f77f6ce12a85a9824a6839290a2aa2]:
#+begin_src scheme
7
#+end_src

#+begin_src scheme :exports both :results value scalar code
(caar '((7)))
#+end_src

#+RESULTS[206130fea50422913a8ff6a562ad2aaba3b9a7a0]:
#+begin_src scheme
7
#+end_src

#+begin_src scheme :exports both :results output scalar code
  (show #t " " (car
	       (cdr
		(car
		 (cdr
		  (car
		   (cdr
		    (car
		     (cdr
		      (car
		       (cdr
			(car (cdr '(1 (2 (3 (4 (5 (6 7)))))))))))))))))))
#+end_src

#+RESULTS[d27117176b491f52724a77c668af34be69c184e5]:
#+begin_src scheme
 7
#+end_src

The task was funny.

*** DONE Exercise 2.26 append cons list
    CLOSED: [2019-09-10 Tue 23:23]

#+begin_src scheme :exports both :results output scalar code
(define x (list 1 2 3))
(define y (list 4 5 6))
(show #t " " (append x y) "\n")
(show #t " " (cons x y) "\n")
(show #t " " (list x y) "\n")
#+end_src

#+RESULTS[e1fd1e7397e82ad67d79f5016d17209afcca8152]:
#+begin_src scheme
 (1 2 3 4 5 6)
 ((1 2 3) 4 5 6)
 ((1 2 3) (4 5 6))
#+end_src

*** DONE Exercise 2.27 deep-reverse
    CLOSED: [2019-09-11 Wed 09:47]
0:14:46

#+begin_src scheme :exports both :results output scalar code
  (define (deep-reverse lst)
    (define (iter-reverse lst1 accumulator)
      (if (null? lst1)
	  accumulator
	  (if (pair? (car lst1))
	      (iter-reverse (cdr lst1) (cons (deep-reverse (car lst1)) accumulator))
	      (iter-reverse (cdr lst1) (cons (car lst1) accumulator)))))
    (iter-reverse lst '()))

  (define x (list (list 1 2) (list 3 4)))
  (show #t " " (reverse x) "\n")
  (show #t " " (deep-reverse x))
#+end_src

#+RESULTS[c0618c5a78638a1c33872699cf3a4af1df9745ca]:
#+begin_src scheme
 ((3 4) (1 2))
 ((4 3) (2 1))
#+end_src

*** DONE Exercise 2.28 fringe
    CLOSED: [2019-09-11 Wed 10:24]
0:37:00

#+begin_src scheme :exports both :results output scalar code
      (define (fringe tree)
	(define (fringe-iter tree accumulator)
	  (cond  ((null? tree) '())
		 ((not (pair? tree)) (list tree))
		 (else
		   (append accumulator
			   (fringe-iter (car tree) '())
			   (fringe-iter (cdr tree) '())))))
	(fringe-iter tree '()))
      (define x (list (list 1 2) (list 3 4)))
      (show #t " " (fringe x) "\n")
      (show #t " " (fringe (list x x)) "\n")

#+end_src

#+RESULTS[88a37a8301bd0c54250f7796c61db9b63ef2b559]:
#+begin_src scheme
 (1 2 3 4)
 (1 2 3 4 1 2 3 4)
#+end_src

*** DONE Exercise 2.29 mobile
    CLOSED: [2019-09-11 Wed 11:47]
1:23:0

#+name: mobile
#+begin_src scheme :exports code :results none
  (define (make-mobile left right)
    (list left right))

  (define (make-branch length structure)
    (list length structure))

  (define (left-branch mobile)
    (car mobile))

  (define (right-branch mobile)
    (cadr mobile))

  (define (branch-length branch)
    (car branch))

  (define (branch-structure branch)
    (cadr branch))
#+end_src

#+name: mobile-total-weight
#+begin_src scheme :exports code :results none
  (define (total-weight mobile)
    (if (pair? mobile)
    (+ (if (pair? (branch-structure (left-branch mobile)))
	   (total-weight (branch-structure (left-branch mobile)))
	   (branch-structure (left-branch mobile)))
       (if (pair? (branch-structure (right-branch mobile)))
	   (total-weight (branch-structure (right-branch mobile)))
	   (branch-structure (right-branch mobile))))
    mobile))
#+end_src

#+begin_src scheme :exports both :results value scalar code
  <<mobile>>
  <<mobile-total-weight>>
  (total-weight
   (make-mobile
    (make-branch
     5
     (make-mobile
      (make-branch 1 1)
      (make-branch 2 2)))
    (make-branch 7 2)))
#+end_src

#+RESULTS[71c4d67ec359f55b422d2e5714affbd1b746ae8e]:
#+begin_src scheme
5
#+end_src

#+name: mobile-balanced
#+begin_src scheme :exports code :results none
    (define (balanced? mobile)
      (and
       (=
	(*
	 (branch-length (left-branch mobile))
	 (total-weight (branch-structure (left-branch mobile))))
	(*
	 (branch-length (right-branch mobile))
	 (total-weight (branch-structure (right-branch mobile))))
	)
       (if (pair? (branch-structure (left-branch mobile)))
	   (balanced? (branch-structure (left-branch mobile)))
	   #t)
       (if (pair? (branch-structure (right-branch mobile)))
	   (balanced? (branch-structure (right-branch mobile)))
	   #t)))

#+end_src

#+begin_src scheme :exports both :results output scalar code
<<mobile-balanced>>
<<mobile-total-weight>>
<<mobile>>
  (show #t " " (balanced?
   (make-mobile
    (make-branch
     5
     (make-mobile
      (make-branch 1 1)
      (make-branch 2 2)))
    (make-branch 7 2))) "\n")
  (show #t " " (balanced? (make-mobile (make-branch 5 5) (make-branch 5 5))) "\n")
#+end_src

#+RESULTS[9bb4e5ed41d59cb8c1cc4d47ee13fe872ffef645]:
#+begin_src scheme
 #f
 #t
#+end_src

If we replace lists with ~cons~, the only thing that needs to be
changed is that ~cadr~ should be replaced with ~car~.

*** DONE Exercise 2.30 square-tree
    CLOSED: [2019-09-11 Wed 14:11]
 1. A no-high-level version

#+name: square-tree
#+begin_src scheme :exports code :results none
  (define (square-tree tree)
    (cond ((null? tree) '())
	  ((not (pair? tree)) (square tree))
	  (else (cons (square-tree (car tree))
		      (square-tree (cdr tree))))))
#+end_src


#+begin_src scheme :exports both :results output scalar code
<<square-tree>>
  (show #t " " (square-tree
   (list 1
	 (list 2 (list 3 4) 5)
	 (list 6 7))))
#+end_src

#+RESULTS[d1c774f198c62b14f5dd3b86b843b0bc4433470f]:
#+begin_src scheme
 (1 (4 (9 16) 25) (36 49))
#+end_src


2. High-level version

#+name: square-subtree-map
#+begin_src scheme :exports code :results none
    (define (square-tree tree)
      (map (lambda (sub-tree)
	     (if (pair? sub-tree)
		 (square-tree sub-tree)
		 (square sub-tree)))
	   tree))
#+end_src

#+begin_src scheme :exports both :results output scalar code
<<square-subtree-map>>
  (show #t " " (square-tree
   (list 1
	 (list 2 (list 3 4) 5)
	 (list 6 7))))
#+end_src

#+RESULTS[c6eb92db9a1754a50eec1a1e20ba078d29bba342]:
#+begin_src scheme
 (1 (4 (9 16) 25) (36 49))
#+end_src

Not a very hard problem.

*** DONE Exercise 2.31 tree-map square tree
    CLOSED: [2019-09-11 Wed 14:38]
Not a very hard problem.

#+begin_src scheme :exports both :results output scalar code
  (define (square-tree tree) (tree-map square tree))

  (define (tree-map square tree)
    (map (lambda (sub-tree)
	   (if (pair? sub-tree)
	       (tree-map square sub-tree)
	       (square sub-tree)))
	 tree))
  (show #t " "
	(square-tree
	 (list 1
	       (list 2 (list 3 4) 5)
	       (list 6 7))))

#+end_src

#+RESULTS[55001b9092227eab3a36634e3ea834fd82da8950]:
#+begin_src scheme
 (1 (4 (9 16) 25) (36 49))
#+end_src

*** DONE Exercise 2.32 subsets
    CLOSED: [2019-09-11 Wed 14:53]

#+name: subsets
#+begin_src scheme :exports both :results value scalar code
  (define (subsets s)
    (if (null? s)
	(list '())
	(let ((rest (subsets (cdr s))))
	  (append rest (map (lambda (suffix) (append (list (car s)) suffix)) rest)))))
  (subsets '(1 2 3))
#+end_src

#+RESULTS[8c1561821916ca51a7d5755b897c9124da8ca2b4]: subsets
#+begin_src scheme
(() (3) (2) (2 3) (1) (1 3) (1 2) (1 2 3))
#+end_src

The explanation is easy. The subsets can be constructed by taking any
element, say, the first, and appending it to every subset of the rest
of the set. That is if we already have a set of subsets of some set
*S*, and we are adding some element *a*, then it may or may not be in
every subset of the enlarged set *S+a*.

*** DONE Exercise 2.33 map-append-length
    CLOSED: [2019-09-11 Wed 23:53]

#+name: filter
#+begin_src scheme :exports code :results none
  (define (filter predicate sequence)
    (cond ((null? sequence) '())
	  ((predicate (car sequence))
	   (cons (car sequence)
		 (filter predicate (cdr sequence))))
	  (else (filter predicate (cdr sequence)))))
#+end_src

#+name: accumulate
#+begin_src scheme :exports code :results none
  (define (accumulate op initial sequence)
    (if (null? sequence)
	initial
	(op (car sequence)
	    (accumulate op initial (cdr sequence)))))
#+end_src

#+name: enumerate-interval
#+begin_src scheme :exports code :results none
  (define (enumerate-interval low high)
    (if (> low high)
	'()
	(cons low (enumerate-interval (+ low 1) high))))
#+end_src

#+name: enumerate-tree
#+begin_src scheme :exports code :results none
  (define (enumerate-tree tree)
    (cond ((null? tree) '())
	   ((not (pair? tree)) (list tree))
	   (else (append (enumerate-tree (car tree))
			 (enumerate-tree (cdr tree))))))
#+end_src

#+name: map-append-length
#+begin_src scheme :exports code :results none
  (define (map p sequence)
    (accumulate (lambda (x y) (cons (p x) y)) '() sequence))
  (define (append seq1 seq2)
    (accumulate cons seq2 seq1))
  (define (length sequence)
    (accumulate (lambda (x y) (+ 1 y)) 0 sequence))
#+end_src

#+begin_src scheme :exports both :results output scalar code
<<accumulate>>
<<map-append-length>>

(show #t  (pretty (length (make-list 100 34)))
 (pretty (append '(1 2 3 4) '(5 6 7 8))))
(display (map (lambda (x) x) '(1 2 3 4)))
#+end_src

#+RESULTS[9beabbb51bc972a2385a9e7851a35f3487ac2383]:
#+begin_src scheme
100
(1 2 3 4 5 6 7 8)
(1 2 3 4)
#+end_src


*** DONE Exercise 2.34 horners-rule
    CLOSED: [2019-09-12 Thu 00:01]

#+begin_src scheme :exports both :results value scalar code
<<accumulate>>
  (define (horner-eval x coefficient-sequence)
    (accumulate (lambda (this-coeff higher-terms) (+ this-coeff (* x higher-terms)))
		0
		coefficient-sequence))
  (horner-eval 2 (list 1 3 0 5 0 1))
#+end_src

#+RESULTS[b92dbc0b679b0fdfc34e91e759ea9f7e27ae82dc]:
#+begin_src scheme
79
#+end_src

*** DONE Exercise 2.35 count-leaves-accumulate
    CLOSED: [2019-09-12 Thu 00:17]
#+begin_src scheme :exports both :results value scalar code
<<accumulate>>
  (define (count-leaves t)
    (accumulate + 0 (map (lambda (x) (if (pair? x)
				    (count-leaves x)
				    1)) t)))
  (count-leaves (list 1 2 3))
#+end_src

#+RESULTS[0eeaeb452b550a82e5f1789c4de71bf5a59e6d7e]:
#+begin_src scheme
3
#+end_src

*** DONE Exercise 2.36 accumulate-n
    CLOSED: [2019-09-12 Thu 00:26]

#+name: accumulate-n
#+begin_src scheme :exports code :results none
<<accumulate>>
  (define (accumulate-n op init seqs)
    (if (null? (car seqs))
	'()
	(cons (accumulate op init (map car seqs))
              (accumulate-n op init (map cdr seqs)))))
#+end_src

#+begin_src scheme :exports both :results value scalar code
<<accumulate-n>>
  (accumulate-n + 0 '((1 2 3) (4 5 6) (7 8 9) (10 11 12)))
#+end_src

#+RESULTS[1cc1e24633ce4bb6138cdc950281db4217e1f84e]:
#+begin_src scheme
(22 26 30)
#+end_src

*** DONE Exercise 2.37 matrix-*-vector
    CLOSED: [2019-09-12 Thu 00:50]

#+name: dot-product
#+begin_src scheme :exports code :results none
  (define (dot-product v w)
    (accumulate + 0 (map * v w)))
#+end_src

#+name: matrix-operations
#+begin_src scheme :exports code :results none
  (define (matrix-*-vector m v)
    (map (lambda (x) (dot-product v x)) m))
  (define (transpose mat)
    (accumulate-n cons '() mat))
  (define (matrix-*-matrix m n)
    (let ((cols (transpose n)))
      (map (lambda (x) (matrix-*-vector m x)) n)))
#+end_src

#+begin_src scheme :exports both :results output scalar code
<<accumulate>>
<<accumulate-n>>
<<dot-product>>
<<matrix-operations>>
(show #t " " (matrix-*-vector '((1 2 3 4) (4 5 6 6) (6 7 8 9)) '(1 2 3 4)) "\n")
(show #t " " (transpose '((1 2 3 4) (4 5 6 6) (6 7 8 9))) "\n")
(show #t " " (matrix-*-matrix
               '((1 2 3 4) (4 5 6 6) (6 7 8 9))
               '((1 2 3 4) (4 5 6 6) (6 7 8 9)) ) "\n")
#+end_src

#+RESULTS[bf5aabf436bdab0be11bddd92614fcd2f78f7e3f]:
#+begin_src scheme
 (30 56 80)
 ((1 4 6) (2 5 7) (3 6 8) (4 6 9))
 ((30 56 80) (56 113 161) (80 161 230))
#+end_src

*** DONE Exercise 2.38 fold-left
    CLOSED: [2019-09-12 Thu 09:45]

#+name: fold-left
#+begin_src scheme :exports code :results none
  (define (fold-left op initial sequence)
    (define (iter result rest)
      (if (null? rest)
	  result
	  (iter (op result (car rest))
		(cdr rest))))
    (iter initial sequence))
#+end_src

#+begin_src scheme :exports both :results output scalar code
<<accumulate>>
<<fold-left>>
(show #t " " (accumulate / 1 (list 1 2 3)) "\n")
(show #t " " (fold-left / 1 (list 1 2 3)) "\n")
(show #t " " (accumulate list '() (list 1 2 3)) "\n")
(show #t " " (fold-left list '() (list 1 2 3)) "\n")
(show #t " " (fold-left + 0 (list 1 2 3)) "\n")
(show #t " " (accumulate + 0 (list 1 2 3)) "\n")
#+end_src

#+RESULTS[ebdadc478ac489f34601de0d121b94d8e358364a]:
#+begin_src scheme
 3/2
 1/6
 (1 (2 (3 ())))
 (((() 1) 2) 3)
 6
 6
#+end_src

Well, it seems that commutative operations, that is the ones for which
\(a+b = b+a\).

*** DONE Exercise 2.39 reverse fold-right fold-left
    CLOSED: [2019-09-12 Thu 09:52]

#+begin_src scheme :exports both :results output scalar code
<<accumulate>>
<<fold-left>>
  (define (reverse sequence)
    (accumulate (lambda (x y) (cons x y)) '() sequence))
  (show #t " " (reverse (list 1 2 3)) "\n")
  (define (reverse sequence)
    (fold-left  (lambda (x y) (cons y x)) '() sequence))
  (show #t " " (reverse (list 1 2 3)))
#+end_src

#+RESULTS[5a7002bef41ae8f766c529d43004cfe05e38d50d]:
#+begin_src scheme
 (1 2 3)
 (3 2 1)
#+end_src

*** DONE Exercise 2.40 unique-pairs
    CLOSED: [2019-09-12 Thu 10:34]
0:42:00

#+name: flatmap
#+begin_src scheme :exports code :results none
  (define (flatmap proc seq)
    (accumulate append '() (map proc seq)))
#+end_src

#+name: prime-sum
#+begin_src scheme :exports code :results none
  (define (prime-sum? pair)
    (prime? (+ (car pair) (cadr pair))))
#+end_src

#+name: make-pair-sum
#+begin_src scheme :exports code :results none
(define (make-pair-sum pair)
    (list (car pair) (cadr pair) (+ (car pair) (cadr pair))))
#+end_src

#+name: prime-sum-pairs
#+begin_src scheme :exports code :results none
  (define (prime-sum-pairs n)
    (map make-pair-sum
	  (filter prime-sum? (flatmap
			      (lambda (i)
				(map (lambda (j) (list i j))
				     (enumerate-interval 1 (- i 1))))
			      (enumerate-interval 1 n)))))
#+end_src

#+begin_src scheme :exports both :results output scalar code
<<prime-sum-pairs>>
<<enumerate-interval>>
<<flatmap>>
<<accumulate>>
<<prime-sum>>
<<filter>>
<<fast-prime>>
<<fermat-primetest>>
<<expmod-miller-rabin>>
<<make-pair-sum>>
<<map-append-length>>
(show #t " " (pretty (prime-sum-pairs 30)))
#+end_src

#+RESULTS[d6d098d55654fa45d8173de5db045c36a2484f90]:
#+begin_src scheme
 ((2 1 3)    (3 2 5)    (4 1 5)    (4 3 7)    (5 2 7)    (6 1 7)    (6 5 11)
  (7 4 11)   (7 6 13)   (8 3 11)   (8 5 13)   (9 2 11)   (9 4 13)   (9 8 17)
  (10 1 11)  (10 3 13)  (10 7 17)  (10 9 19)  (11 2 13)  (11 6 17)  (11 8 19)
  (12 1 13)  (12 5 17)  (12 7 19)  (12 11 23) (13 4 17)  (13 6 19)  (13 10 23)
  (14 3 17)  (14 5 19)  (14 9 23)  (15 2 17)  (15 4 19)  (15 8 23)  (15 14 29)
  (16 1 17)  (16 3 19)  (16 7 23)  (16 13 29) (16 15 31) (17 2 19)  (17 6 23)
  (17 12 29) (17 14 31) (18 1 19)  (18 5 23)  (18 11 29) (18 13 31) (19 4 23)
  (19 10 29) (19 12 31) (19 18 37) (20 3 23)  (20 9 29)  (20 11 31) (20 17 37)
  (21 2 23)  (21 8 29)  (21 10 31) (21 16 37) (21 20 41) (22 1 23)  (22 7 29)
  (22 9 31)  (22 15 37) (22 19 41) (22 21 43) (23 6 29)  (23 8 31)  (23 14 37)
  (23 18 41) (23 20 43) (24 5 29)  (24 7 31)  (24 13 37) (24 17 41) (24 19 43)
  (24 23 47) (25 4 29)  (25 6 31)  (25 12 37) (25 16 41) (25 18 43) (25 22 47)
  (26 3 29)  (26 5 31)  (26 11 37) (26 15 41) (26 17 43) (26 21 47) (27 2 29)
  (27 4 31)  (27 10 37) (27 14 41) (27 16 43) (27 20 47) (27 26 53) (28 1 29)
  (28 3 31)  (28 9 37)  (28 13 41) (28 15 43) (28 19 47) (28 25 53) (29 2 31)
  (29 8 37)  (29 12 41) (29 14 43) (29 18 47) (29 24 53) (30 1 31)  (30 7 37)
  (30 11 41) (30 13 43) (30 17 47) (30 23 53) (30 29 59))
#+end_src

#+name: unique-pairs
#+begin_src scheme :exports code :results none
  (define (unique-pairs n)
    (flatmap
     (lambda (i)
       (map (lambda (j) (list i j))
	    (enumerate-interval 1 (- i 1))))
     (enumerate-interval 1 n)))
#+end_src

#+begin_src scheme :exports both :results value scalar code
  <<unique-pairs>>
  <<flatmap>>
  <<enumerate-interval>>
  <<accumulate>>
  (unique-pairs 3)
#+end_src

#+RESULTS[dc0a921aeb52d4154d0dd9c0280c302776d6a05d]:
#+begin_src scheme
((2 1) (3 1) (3 2))
#+end_src

#+name: prime-sum-pairs-unique-pairs
#+begin_src scheme :exports code :results none
  (define (prime-sum-pairs n)
    (map make-pair-sum
	  (filter prime-sum? (unique-pairs n))))
#+end_src

#+begin_src scheme :exports both :results value scalar code
<<unique-pairs>>
<<prime-sum-pairs-unique-pairs>>
<<enumerate-interval>>
<<flatmap>>
<<accumulate>>
<<prime-sum>>
<<filter>>
<<fast-prime>>
<<fermat-primetest>>
<<expmod-miller-rabin>>
<<make-pair-sum>>
<<map-append-length>>
(prime-sum-pairs 10)
#+end_src

#+RESULTS[1034a5a78ff02012ba0389c36dc076a0d1e59d65]:
#+begin_src scheme
((2 1 3) (3 2 5) (4 1 5) (4 3 7) (5 2 7) (6 1 7) (6 5 11) (7 4 11) (7 6 13) (8 3 11) (8 5 13) (9 2 11) (9 4 13) (9 8 17) (10 1 11) (10 3 13) (10 7 17) (10 9 19))
#+end_src

I have to note that this deceiptively simple task involves reusing
results of 12 other problems.

*** DONE Exercise 2.41 triple-sum
    CLOSED: [2019-09-14 Sat 15:15]
     *Exercise 2.41:* Write a procedure to find all ordered triples of
     distinct positive integers i, j, and k less than or equal to a
     given integer n that sum to a given integer s.

#+name: unique-triples
#+begin_src scheme :exports code :results none
    (define (unique-triples n)
      (flatmap
       (lambda (i)
	 (flatmap (lambda (j)
		(map (lambda (k) (list i j k))
		     (enumerate-interval 1 (- j 1))))
	      (enumerate-interval 1 (- i 1))))
       (enumerate-interval 1 n)))

#+end_src

#+begin_src scheme :exports both :results output scalar code
<<accumulate>>
<<enumerate-interval>>
<<flatmap>>
<<unique-triples>>
(show #t " " (unique-triples 5) "\n")
#+end_src

#+RESULTS[b52989df4ca42ec42c46545ebd1639544c42f1f7]:
#+begin_src scheme
 ((3 2 1) (4 2 1) (4 3 1) (4 3 2) (5 2 1) (5 3 1) (5 3 2) (5 4 1) (5 4 2) (5 4 3))
#+end_src


#+name: sum-equal-s
#+begin_src scheme :exports code :results none
  (define (sum-equal-s? s tuple)
    (if (= s  (accumulate + 0 tuple))
	#t
	#f))
#+end_src

#+begin_src scheme :exports both :results value scalar code
<<sum-equal-s>>
<<accumulate>>
(and (sum-equal-s? 30 (list 10 5 5 9 1)) (not (sum-equal-s? 10 (list 3 3 3))))
#+end_src

#+RESULTS[46e4d795cfbc72bbf203d16b8ceff400c3e83943]:
#+begin_src scheme
#t
#+end_src

#+name: sum-equal-s-triples
#+begin_src scheme :exports code :results none
  (define (sum-equal-s-triples s n)
    (filter (lambda (x) (sum-equal-s? s x)) (unique-triples n)))
#+end_src

#+begin_src scheme :exports both :results value scalar code
<<enumerate-interval>>
<<flatmap>>
<<sum-equal-s-triples>>
<<accumulate>>
<<sum-equal-s>>
<<filter>>
<<unique-triples>>
(sum-equal-s-triples 15 30)
#+end_src

#+RESULTS[98a71e0924c776a97bbbc34eed4ce1a6730f542f]:
#+begin_src scheme
((6 5 4) (7 5 3) (7 6 2) (8 4 3) (8 5 2) (8 6 1) (9 4 2) (9 5 1) (10 3 2) (10 4 1) (11 3 1) (12 2 1))
#+end_src

*** DONE Figure 2.8 A solution to the eight-queens puzzle.
    CLOSED: [2019-09-14 Sat 15:17]
# 2019-09-14 15:17:06.618032485 +0800

#+begin_src plantuml :exports both :file figure-2-8.png
@startditaa
          +---+---+---+---+---+---+---+---+
          |   |   |   |   |   | Q |   |   |
          +---+---+---+---+---+---+---+---+
          |   |   | Q |   |   |   |   |   |
          +---+---+---+---+---+---+---+---+
          | Q |   |   |   |   |   |   |   |
          +---+---+---+---+---+---+---+---+
          |   |   |   |   |   |   | Q |   |
          +---+---+---+---+---+---+---+---+
          |   |   |   |   | Q |   |   |   |
          +---+---+---+---+---+---+---+---+
          |   |   |   |   |   |   |   | Q |
          +---+---+---+---+---+---+---+---+
          |   | Q |   |   |   |   |   |   |
          +---+---+---+---+---+---+---+---+
          |   |   |   | Q |   |   |   |   |
          +---+---+---+---+---+---+---+---+
@endditaa
#+end_src

#+RESULTS:
[[file:figure-2-8.png]]

*** DONE Exercise 2.42 k-queens
    CLOSED: [2019-09-17 Tue 22:27]
3:00:00 + 2:00:00 + 1:00:00 = 6:00:00
The commentary to this problem is bad. Firstly, it is *NOT* obvious
that it is even possible to place a queen into every column and every
row. Indeed, in the solution above, this happens to be the case, but
this is by no means obvious.

The second thought: since the algorithm is expected to provide *all*
possible solutions, it should be required have a list of lists... sort
of, to represent the multitude. So ~queens~ should return a list of
lists.

Secondly, the code given by the authors is totally moronic in at least
two places:
 1. rest-of-queens? Seriously? Why not "world of queens", or
    "suffix-queens", to make it even more obscure? It should have been
    called "prefix-queens", or, better "queens-already-on-board". We
    are not short of bytes, are we?
 2. who on Earth would call a procedure "queen-cols"? What does it
even mean? Descriptive names -- zero.

The third thought: anyone who wants to solve this puzzle, must at
least know what it is for a queen to be "safe". That is, if a queen
number A has a position b_1 then our new queen's B position b_2 must
satisfy : 1) b_2 \neq b_1 2)|b_2 - b_1| \ne B - A. And this must be true
\forall A < B.

The fourth thought: it is *NOT* obvious, but the "rest of queens"
contains the list of queens _in the reversed order_. So ~car~'ing
anything with it represents attaching the queen _to the end_ of the
list. This is why we have *k* supplied as an argument to the ~safe?~
procedure.

#+name: k-queens
#+begin_src scheme :exports code :results none
  (define (queens board-size)
    (define (queen-cols k)
      (if (= k 0)
	  (list empty-board)
	  (filter
	   (lambda (positions) (safe? k positions))
	   (flatmap
	    (lambda (rest-of-queens)
	      (map (lambda (new-row)
		     (adjoin-position new-row k rest-of-queens))
		   (enumerate-interval 1 board-size)))
	    (queen-cols (- k 1))))))
    (queen-cols board-size))

#+end_src

#+name: empty-board-adjoin-position-safe
#+begin_src scheme :exports code :results none
  (define empty-board '())
  (define (adjoin-position new-row k rest-of-queens)
    (cons (cons k new-row) rest-of-queens))
  (define (safe? k positions)
    (cond ((null? (cdr positions)) #t)
	  ((= k 1) #t)
	  ((= (cdar positions) (cdadr positions)) #f)
	  ((= (abs (- (cdar positions) (cdadr positions))) (abs (- (caar positions) (caadr positions)))) #f)
	  (else (safe? k (cons (car positions) (cddr positions))))))
#+end_src

#+begin_src scheme :exports both :results output scalar code
<<k-queens>>
<<flatmap>>
<<enumerate-interval>>
<<accumulate>>
<<filter>>
<<empty-board-adjoin-position-safe>>
(map (lambda (x) (show #t " " x "\n")) (queens 8))
#+end_src

#+RESULTS[2a2f6f5000977d52d8be789fa244708a4ecb5e43]:
#+begin_src scheme
 ((8 . 4) (7 . 2) (6 . 7) (5 . 3) (4 . 6) (3 . 8) (2 . 5) (1 . 1))
 ((8 . 5) (7 . 2) (6 . 4) (5 . 7) (4 . 3) (3 . 8) (2 . 6) (1 . 1))
 ((8 . 3) (7 . 5) (6 . 2) (5 . 8) (4 . 6) (3 . 4) (2 . 7) (1 . 1))
 ((8 . 3) (7 . 6) (6 . 4) (5 . 2) (4 . 8) (3 . 5) (2 . 7) (1 . 1))
 ((8 . 5) (7 . 7) (6 . 1) (5 . 3) (4 . 8) (3 . 6) (2 . 4) (1 . 2))
 ((8 . 4) (7 . 6) (6 . 8) (5 . 3) (4 . 1) (3 . 7) (2 . 5) (1 . 2))
 ((8 . 3) (7 . 6) (6 . 8) (5 . 1) (4 . 4) (3 . 7) (2 . 5) (1 . 2))
 ((8 . 5) (7 . 3) (6 . 8) (5 . 4) (4 . 7) (3 . 1) (2 . 6) (1 . 2))
 ((8 . 5) (7 . 7) (6 . 4) (5 . 1) (4 . 3) (3 . 8) (2 . 6) (1 . 2))
 ((8 . 4) (7 . 1) (6 . 5) (5 . 8) (4 . 6) (3 . 3) (2 . 7) (1 . 2))
 ((8 . 3) (7 . 6) (6 . 4) (5 . 1) (4 . 8) (3 . 5) (2 . 7) (1 . 2))
 ((8 . 4) (7 . 7) (6 . 5) (5 . 3) (4 . 1) (3 . 6) (2 . 8) (1 . 2))
 ((8 . 6) (7 . 4) (6 . 2) (5 . 8) (4 . 5) (3 . 7) (2 . 1) (1 . 3))
 ((8 . 6) (7 . 4) (6 . 7) (5 . 1) (4 . 8) (3 . 2) (2 . 5) (1 . 3))
 ((8 . 1) (7 . 7) (6 . 4) (5 . 6) (4 . 8) (3 . 2) (2 . 5) (1 . 3))
 ((8 . 6) (7 . 8) (6 . 2) (5 . 4) (4 . 1) (3 . 7) (2 . 5) (1 . 3))
 ((8 . 6) (7 . 2) (6 . 7) (5 . 1) (4 . 4) (3 . 8) (2 . 5) (1 . 3))
 ((8 . 4) (7 . 7) (6 . 1) (5 . 8) (4 . 5) (3 . 2) (2 . 6) (1 . 3))
 ((8 . 5) (7 . 8) (6 . 4) (5 . 1) (4 . 7) (3 . 2) (2 . 6) (1 . 3))
 ((8 . 4) (7 . 8) (6 . 1) (5 . 5) (4 . 7) (3 . 2) (2 . 6) (1 . 3))
 ((8 . 2) (7 . 7) (6 . 5) (5 . 8) (4 . 1) (3 . 4) (2 . 6) (1 . 3))
 ((8 . 1) (7 . 7) (6 . 5) (5 . 8) (4 . 2) (3 . 4) (2 . 6) (1 . 3))
 ((8 . 2) (7 . 5) (6 . 7) (5 . 4) (4 . 1) (3 . 8) (2 . 6) (1 . 3))
 ((8 . 4) (7 . 2) (6 . 7) (5 . 5) (4 . 1) (3 . 8) (2 . 6) (1 . 3))
 ((8 . 5) (7 . 7) (6 . 1) (5 . 4) (4 . 2) (3 . 8) (2 . 6) (1 . 3))
 ((8 . 6) (7 . 4) (6 . 1) (5 . 5) (4 . 8) (3 . 2) (2 . 7) (1 . 3))
 ((8 . 5) (7 . 1) (6 . 4) (5 . 6) (4 . 8) (3 . 2) (2 . 7) (1 . 3))
 ((8 . 5) (7 . 2) (6 . 6) (5 . 1) (4 . 7) (3 . 4) (2 . 8) (1 . 3))
 ((8 . 6) (7 . 3) (6 . 7) (5 . 2) (4 . 8) (3 . 5) (2 . 1) (1 . 4))
 ((8 . 2) (7 . 7) (6 . 3) (5 . 6) (4 . 8) (3 . 5) (2 . 1) (1 . 4))
 ((8 . 7) (7 . 3) (6 . 1) (5 . 6) (4 . 8) (3 . 5) (2 . 2) (1 . 4))
 ((8 . 5) (7 . 1) (6 . 8) (5 . 6) (4 . 3) (3 . 7) (2 . 2) (1 . 4))
 ((8 . 1) (7 . 5) (6 . 8) (5 . 6) (4 . 3) (3 . 7) (2 . 2) (1 . 4))
 ((8 . 3) (7 . 6) (6 . 8) (5 . 1) (4 . 5) (3 . 7) (2 . 2) (1 . 4))
 ((8 . 6) (7 . 3) (6 . 1) (5 . 7) (4 . 5) (3 . 8) (2 . 2) (1 . 4))
 ((8 . 7) (7 . 5) (6 . 3) (5 . 1) (4 . 6) (3 . 8) (2 . 2) (1 . 4))
 ((8 . 7) (7 . 3) (6 . 8) (5 . 2) (4 . 5) (3 . 1) (2 . 6) (1 . 4))
 ((8 . 5) (7 . 3) (6 . 1) (5 . 7) (4 . 2) (3 . 8) (2 . 6) (1 . 4))
 ((8 . 2) (7 . 5) (6 . 7) (5 . 1) (4 . 3) (3 . 8) (2 . 6) (1 . 4))
 ((8 . 3) (7 . 6) (6 . 2) (5 . 5) (4 . 8) (3 . 1) (2 . 7) (1 . 4))
 ((8 . 6) (7 . 1) (6 . 5) (5 . 2) (4 . 8) (3 . 3) (2 . 7) (1 . 4))
 ((8 . 8) (7 . 3) (6 . 1) (5 . 6) (4 . 2) (3 . 5) (2 . 7) (1 . 4))
 ((8 . 2) (7 . 8) (6 . 6) (5 . 1) (4 . 3) (3 . 5) (2 . 7) (1 . 4))
 ((8 . 5) (7 . 7) (6 . 2) (5 . 6) (4 . 3) (3 . 1) (2 . 8) (1 . 4))
 ((8 . 3) (7 . 6) (6 . 2) (5 . 7) (4 . 5) (3 . 1) (2 . 8) (1 . 4))
 ((8 . 6) (7 . 2) (6 . 7) (5 . 1) (4 . 3) (3 . 5) (2 . 8) (1 . 4))
 ((8 . 3) (7 . 7) (6 . 2) (5 . 8) (4 . 6) (3 . 4) (2 . 1) (1 . 5))
 ((8 . 6) (7 . 3) (6 . 7) (5 . 2) (4 . 4) (3 . 8) (2 . 1) (1 . 5))
 ((8 . 4) (7 . 2) (6 . 7) (5 . 3) (4 . 6) (3 . 8) (2 . 1) (1 . 5))
 ((8 . 7) (7 . 1) (6 . 3) (5 . 8) (4 . 6) (3 . 4) (2 . 2) (1 . 5))
 ((8 . 1) (7 . 6) (6 . 8) (5 . 3) (4 . 7) (3 . 4) (2 . 2) (1 . 5))
 ((8 . 3) (7 . 8) (6 . 4) (5 . 7) (4 . 1) (3 . 6) (2 . 2) (1 . 5))
 ((8 . 6) (7 . 3) (6 . 7) (5 . 4) (4 . 1) (3 . 8) (2 . 2) (1 . 5))
 ((8 . 7) (7 . 4) (6 . 2) (5 . 8) (4 . 6) (3 . 1) (2 . 3) (1 . 5))
 ((8 . 4) (7 . 6) (6 . 8) (5 . 2) (4 . 7) (3 . 1) (2 . 3) (1 . 5))
 ((8 . 2) (7 . 6) (6 . 1) (5 . 7) (4 . 4) (3 . 8) (2 . 3) (1 . 5))
 ((8 . 2) (7 . 4) (6 . 6) (5 . 8) (4 . 3) (3 . 1) (2 . 7) (1 . 5))
 ((8 . 3) (7 . 6) (6 . 8) (5 . 2) (4 . 4) (3 . 1) (2 . 7) (1 . 5))
 ((8 . 6) (7 . 3) (6 . 1) (5 . 8) (4 . 4) (3 . 2) (2 . 7) (1 . 5))
 ((8 . 8) (7 . 4) (6 . 1) (5 . 3) (4 . 6) (3 . 2) (2 . 7) (1 . 5))
 ((8 . 4) (7 . 8) (6 . 1) (5 . 3) (4 . 6) (3 . 2) (2 . 7) (1 . 5))
 ((8 . 2) (7 . 6) (6 . 8) (5 . 3) (4 . 1) (3 . 4) (2 . 7) (1 . 5))
 ((8 . 7) (7 . 2) (6 . 6) (5 . 3) (4 . 1) (3 . 4) (2 . 8) (1 . 5))
 ((8 . 3) (7 . 6) (6 . 2) (5 . 7) (4 . 1) (3 . 4) (2 . 8) (1 . 5))
 ((8 . 4) (7 . 7) (6 . 3) (5 . 8) (4 . 2) (3 . 5) (2 . 1) (1 . 6))
 ((8 . 4) (7 . 8) (6 . 5) (5 . 3) (4 . 1) (3 . 7) (2 . 2) (1 . 6))
 ((8 . 3) (7 . 5) (6 . 8) (5 . 4) (4 . 1) (3 . 7) (2 . 2) (1 . 6))
 ((8 . 4) (7 . 2) (6 . 8) (5 . 5) (4 . 7) (3 . 1) (2 . 3) (1 . 6))
 ((8 . 5) (7 . 7) (6 . 2) (5 . 4) (4 . 8) (3 . 1) (2 . 3) (1 . 6))
 ((8 . 7) (7 . 4) (6 . 2) (5 . 5) (4 . 8) (3 . 1) (2 . 3) (1 . 6))
 ((8 . 8) (7 . 2) (6 . 4) (5 . 1) (4 . 7) (3 . 5) (2 . 3) (1 . 6))
 ((8 . 7) (7 . 2) (6 . 4) (5 . 1) (4 . 8) (3 . 5) (2 . 3) (1 . 6))
 ((8 . 5) (7 . 1) (6 . 8) (5 . 4) (4 . 2) (3 . 7) (2 . 3) (1 . 6))
 ((8 . 4) (7 . 1) (6 . 5) (5 . 8) (4 . 2) (3 . 7) (2 . 3) (1 . 6))
 ((8 . 5) (7 . 2) (6 . 8) (5 . 1) (4 . 4) (3 . 7) (2 . 3) (1 . 6))
 ((8 . 3) (7 . 7) (6 . 2) (5 . 8) (4 . 5) (3 . 1) (2 . 4) (1 . 6))
 ((8 . 3) (7 . 1) (6 . 7) (5 . 5) (4 . 8) (3 . 2) (2 . 4) (1 . 6))
 ((8 . 8) (7 . 2) (6 . 5) (5 . 3) (4 . 1) (3 . 7) (2 . 4) (1 . 6))
 ((8 . 3) (7 . 5) (6 . 2) (5 . 8) (4 . 1) (3 . 7) (2 . 4) (1 . 6))
 ((8 . 3) (7 . 5) (6 . 7) (5 . 1) (4 . 4) (3 . 2) (2 . 8) (1 . 6))
 ((8 . 5) (7 . 2) (6 . 4) (5 . 6) (4 . 8) (3 . 3) (2 . 1) (1 . 7))
 ((8 . 6) (7 . 3) (6 . 5) (5 . 8) (4 . 1) (3 . 4) (2 . 2) (1 . 7))
 ((8 . 5) (7 . 8) (6 . 4) (5 . 1) (4 . 3) (3 . 6) (2 . 2) (1 . 7))
 ((8 . 4) (7 . 2) (6 . 5) (5 . 8) (4 . 6) (3 . 1) (2 . 3) (1 . 7))
 ((8 . 4) (7 . 6) (6 . 1) (5 . 5) (4 . 2) (3 . 8) (2 . 3) (1 . 7))
 ((8 . 6) (7 . 3) (6 . 1) (5 . 8) (4 . 5) (3 . 2) (2 . 4) (1 . 7))
 ((8 . 5) (7 . 3) (6 . 1) (5 . 6) (4 . 8) (3 . 2) (2 . 4) (1 . 7))
 ((8 . 4) (7 . 2) (6 . 8) (5 . 6) (4 . 1) (3 . 3) (2 . 5) (1 . 7))
 ((8 . 6) (7 . 3) (6 . 5) (5 . 7) (4 . 1) (3 . 4) (2 . 2) (1 . 8))
 ((8 . 6) (7 . 4) (6 . 7) (5 . 1) (4 . 3) (3 . 5) (2 . 2) (1 . 8))
 ((8 . 4) (7 . 7) (6 . 5) (5 . 2) (4 . 6) (3 . 1) (2 . 3) (1 . 8))
 ((8 . 5) (7 . 7) (6 . 2) (5 . 6) (4 . 3) (3 . 1) (2 . 4) (1 . 8))
#+end_src

Because of really terrible introduction, this exercise took me 6 times
more than it's worth.

*** DONE Exercise 2.43 slow k-queens
    CLOSED: [2019-09-17 Tue 22:55]

To answer this exercise, we need to estimate the complexity of the
canonical solution and Louis' solution.

For the canonical solution, we can safely assume that the ~safe?~
procedure filters out no sequences at all (this would only worsen our
estimate). Therefore, every additional column would multiply the total
computation needed by the size of the column. Roughly speaking, this
would be \(k^k \approx 2^k \rightarrow 2^6 = 64\).

For the Louis's solution, however, the ~(queen-cols (- k 1))~ is
solved for every value of ~k~ from scratch, which is not necessary,
and adds an additional multiplicand of \(k^{k-1}\) for every
~k~. Roughly speaking, this adds an additional power of \(k-1\) to the
solution time. \( (k\cdot T)^k \approx 2^{6k}\rightarrow 2^{36}\). A little bit too much.

*** Remark. Now we are starting the "picture language" chapter.
It may (and will) require extensive modification to the standard
working environment, because I am not using the most default nowadays
Racket. In this subsection I will implement the required subroutines.

SICP is incredibly confusing in this chapter.

The following is one of the most prominent examples:

#+begin_src scheme :exports code :results none
(define (segments->painter segment-list)
       (lambda (frame)
         (for-each
          (lambda (segment)
            (draw-line
             ((frame-coord-map frame) (start-segment segment))
             ((frame-coord-map frame) (end-segment segment))))
          segment-list)))
#+end_src

#+name: draw-line
#+begin_src scheme :exports code :results none
  (define canvas-size
    (make-parameter
     200
     (lambda (size)
       (if (and (exact-integer? size) (<= 2 size 1000))
	   size
	   (error "invalid canvas size")))))
  (define canvas-file-name
     (make-parameter
        (string-append "./" (substring (process->string "uuidgen") 0 36) ".png")
	(lambda (name)
	  (if (string? name)
	      name
	      (error "invalid canvas file name")))))
  (define (canvas-reset)
    (system "rm" (canvas-file-name))
    (system "convert" "xc:white"
	    "-scale" (string-append
		      (number->string (canvas-size))
		      "x"
		      (number->string (canvas-size)))
	    (canvas-file-name)))
  (define (canvas-refresh)
    (string-append "[[" (canvas-file-name) "]]"))
  (canvas-reset)
  (define (draw-line point1 point2)
    (system "mogrify"
	    "-fill" "black"
	    "-draw" (string-append "line "
				   (number->string (* (canvas-size) (car point1)))
				   ","
				   (number->string (* (canvas-size) (cadr point1)))
				   " "
				   (number->string (* (canvas-size) (car point2)))
				   ","
				   (number->string (* (canvas-size) (cadr point2))))
	    (canvas-file-name))
    #;(display (string-append "[[" (canvas-file-name) "]]"))
    (string-append "[[" (canvas-file-name) "]]"))
#+end_src

#+begin_src scheme :exports both :results raw value
  <<draw-line>>
  (draw-line (list 0 0) (list 1 1))
  (draw-line (list 0 1) (list 1 0))
#+end_src

#+RESULTS[58e8f3db651ba35bfae8622038f7da35dcea9667]:
"[[./4fa2a366-f75c-40b2-ad02-5df855a77c92.png]]"

#+name: pict-frame
#+begin_src scheme :exports code :results none
  (define (frame-coord-map frame)
    (lambda (v)
     (add-vect
       (origin-frame frame)
              (add-vect (scale-vect (xcor-vect v) (edge1-frame frame))
		 (scale-vect (ycor-vect v) (edge2-frame frame))))))
#+end_src

#+begin_src scheme :exports both :results value scalar code
  <<make-frame>>
  <<pict-frame>>
  <<pict-vect>>
  ((frame-coord-map
	   (make-frame
	    (make-vect 0.1 0.2)
	    (make-vect 1.0 1.0)
	    (make-vect 1.0 1.0))) (make-vect 0 0))
#+end_src

#+RESULTS[0de43669bdb0125295eb64d5b1a56f3fb7e10054]:
#+begin_src scheme
(0.1 0.2)
#+end_src

#+name: segments-painter
#+begin_src scheme :exports code :results none
  (define (segments->painter segment-list)
    (lambda (frame)
      (for-each
       (lambda (segment)
	 (draw-line
	  ((frame-coord-map frame)
	   (start-segment segment))
	  ((frame-coord-map frame)
	   (end-segment segment))))
       segment-list)))
#+end_src

The next is the "rogers" painter. As usual with SICP, fighting with
the programming system takes more time than actually solving anything.
Took me 3 hours. (3:00:00)

Asked a question here: https://www.imagemagick.org/discourse-server/viewtopic.php?f=1&t=36770

#+name: magick-vect
#+begin_src scheme :exports code :results none
    (define (pict-vect->magick-vect vector separator)
      (string-append
       (number->string (+ 1 (* (canvas-size) (xcor-vect vector))))
       separator
       (number->string (+ 1 (* (canvas-size) (ycor-vect vector))))))
#+end_src

#+name: rogers
#+begin_src scheme :exports code :results none
  (define (rogers frame)
    (system "convert"
             (canvas-file-name)
             "("
	     "+distort" "affine"
	     (string-append
		"1,1 "    "1,1"
		" 149,1 "   (pict-vect->magick-vect (edge1-frame  frame) ",")
                " 1,180 "  (pict-vect->magick-vect (edge2-frame  frame) ","))
             "-background" "transparent"
	     "-splice" (pict-vect->magick-vect
			(origin-frame frame) "x")
             "./assets/rogers.png" ")"
             "-composite"
             (canvas-file-name)))
#+end_src

#+begin_src scheme :exports code :results raw value
<<pict-vect>>
<<pict-frame>>
<<make-frame>>
<<magick-vect>>
<<rogers>>
<<draw-line>>
(rogers (make-frame (make-vect 0 0) (make-vect 1 0) (make-vect 0 1)))
(canvas-refresh)
#+end_src

#+RESULTS[6fb88d5be0447ac0898ff2a253b096706fa082fc]:
"[[./dbec2aad-a826-48a9-8983-d77c340b2774.png]]"


#+name: wave-bitmap
#+begin_src scheme :exports code :results none
  (define (wave frame)
    (system "convert"
	     (canvas-file-name)
	     "("
	     "-alpha" "set" "-virtual-pixel" "transparent"
	     "+distort" "affine"
	     (string-append
		"1,1 "    "1,1"
		" 152,1 "   (pict-vect->magick-vect
			      (edge1-frame  frame) ",")
		" 1,184 "   (pict-vect->magick-vect
			      (edge2-frame  frame) ","))
	     "-background" "transparent"
	     "-splice" (pict-vect->magick-vect
			(origin-frame frame) "x")
	     "./assets/wave.png" ")"
	     "-composite"
	     (canvas-file-name)))
#+end_src


*** DONE Exercise 2.44 up-split
    CLOSED: [2019-09-23 Mon 22:54]

#+name: up-split
#+begin_src scheme :exports code :results none
  (define (up-split painter n)
    (if (= n 0)
	painter
	(let ((smaller (up-split painter (- n 1))))
	  (below painter (beside smaller smaller)))))
#+end_src

#+begin_src scheme :exports both :results raw value
<<pict-vect>>
<<make-frame>>
<<pict-segment>>
<<segments-painter>>
<<wave-segment>>
<<transform-painter>>
<<pict-frame>>
<<draw-line>>
<<beside>>
<<below-beside>>
<<rotate270>>
<<rotate90>>
<<up-split>>
((up-split wave 1) (make-frame (make-vect 0.0 1.0) (make-vect 1.0 0.0) (make-vect 0.0 -1.0)))
(canvas-refresh)
#+end_src

#+RESULTS[37bd0ae6e97f7b7021e3023f30ffeb5621bf0734]:
"[[./dcf8fa6e-0eac-4a3e-85bf-173d87362489.png]]"

*** DONE Exercise 2.45 split
    CLOSED: [2019-09-24 Tue 01:37]

#+name: split
#+begin_src scheme :exports code :results none
  (define (split op1 op2)
    (define (split-inner painter n)
      (if (= n 0)
      painter
      (let ((smaller (split-inner painter (- n 1))))
	(op2 painter (op1 smaller smaller)))))
    (lambda (painter n)
      (split-inner painter n)))
  (define up-split (split beside below))
  (define right-split (split below beside))
#+end_src

#+begin_src scheme :exports both :results raw value
<<pict-vect>>
<<make-frame>>
<<pict-segment>>
<<segments-painter>>
<<wave-segment>>
<<transform-painter>>
<<pict-frame>>
<<draw-line>>
<<beside>>
<<below-beside>>
<<rotate270>>
<<rotate90>>
<<split>>
((up-split wave 1) (make-frame (make-vect 0.0 1.0) (make-vect 1.0 0.0) (make-vect 0.0 -1.0)))
(canvas-refresh)
#+end_src

#+RESULTS[13ca098e543bfafd40c109ff39561cbbba7212e3]:
"[[./76d387ef-4d82-4e48-a57f-1fdddb5ef64d.png]]"

#+begin_src scheme :exports both :results raw value
<<pict-vect>>
<<make-frame>>
<<pict-segment>>
<<segments-painter>>
<<wave-segment>>
<<transform-painter>>
<<pict-frame>>
<<draw-line>>
<<beside>>
<<below-beside>>
<<rotate270>>
<<rotate90>>
<<split>>
((right-split wave 1) (make-frame (make-vect 0.0 1.0) (make-vect 1.0 0.0) (make-vect 0.0 -1.0)))
(canvas-refresh)
#+end_src

#+RESULTS[8b3a1eebed3612f9d92a263f6d24cf040d2fe64a]:
"[[./b46f3717-7716-40ea-b88b-7dbdb1a258aa.png]]"

*** DONE Exercise 2.46 make-vect
    CLOSED: [2019-09-20 Fri 12:48]

#+name: pict-vect
#+begin_src scheme :exports code :results none
  (define (make-vect xcor ycor . o)
    (append (list xcor) (list ycor) o))
  (define (xcor-vect vect)
    (car vect))
  (define (ycor-vect vect)
    (cadr vect))
  (define (scale-vect scale vect)
    (map (lambda (x) (* x scale)) vect))
  (define (add-vect vec1 vec2)
    (map (lambda (cor1 cor2) (+ cor1 cor2)) vec1 vec2))
  (define (sub-vect vec1 vec2)
    (map (lambda (cor1 cor2) (- cor1 cor2)) vec1 vec2))
#+end_src


#+begin_src scheme :exports both :results output scalar code
<<pict-vect>>
(show #t (make-vect 1 2 3) "\n")
(show #t (xcor-vect (make-vect 1 2 3)) "\n")
(show #t (ycor-vect (make-vect 1 2 3)) "\n")
(show #t (scale-vect 2 (make-vect 1 2 3)) "\n")
(show #t (add-vect (make-vect 1 2 3) (make-vect 1 2 3)) "\n")
(show #t (sub-vect (make-vect 1 2 3) (make-vect 1 2 3)) "\n")
#+end_src

#+RESULTS[5c83c786c5d0b9466d7164c0041429bcbcbcf93d]:
#+begin_src scheme
(1 2 3)
1
2
(2 4 6)
(2 4 6)
(0 0 0)
#+end_src

*** DONE Exercise 2.47 make-frame
    CLOSED: [2019-09-20 Fri 14:48]

#+name: make-frame
#+begin_src scheme :exports code :results none
(define (make-frame origin edge1 edge2)
  (list origin edge1 edge2))
(define (origin-frame frame)
  (car frame))
(define (edge1-frame frame)
  (cadr frame))
(define (edge2-frame frame)
  (caddr frame))
#+end_src


#+begin_src scheme :exports both :results output scalar code
<<make-frame>>
<<pict-vect>>
(make-frame (make-vect 0.1 0.2) 
            (make-vect 0.1 0.2)
            (make-vect 0.0 0.3))
(display (origin-frame 
           (make-frame (make-vect 0.1 0.2) 
                       (make-vect 0.1 0.2)
                       (make-vect 0.0 0.3))))
(display (edge1-frame  
           (make-frame (make-vect 0.1 0.2)
                       (make-vect 0.1 0.2)
                       (make-vect 0.0 0.3))))
(display (edge2-frame  
           (make-frame
                       (make-vect 0.1 0.2)
                       (make-vect 0.1 0.2)
                       (make-vect 0.0 0.3))))
#+end_src

#+RESULTS[b08f68cf9b03d619928cae5c2266a7b215401bab]:
#+begin_src scheme
(0.1 0.2)(0.1 0.2)(0.0 0.3)
#+end_src


#+begin_src scheme :exports both :results output scalar code
<<pict-vect>>
  (define (make-frame origin edge1 edge2)
    (cons origin (cons edge1 edge2)))
  (define (origin-frame frame)
    (car frame))
  (define (edge1-frame frame)
    (cadr frame))
  (define (edge2-frame frame)
    (cddr frame))
  (show #t (origin-frame (make-frame (make-vect 0.1 0.2) (make-vect 0.1 0.2) (make-vect 0.0 0.3))) "\n")
  (show #t (edge1-frame (make-frame (make-vect 0.1 0.2) (make-vect 0.1 0.2) (make-vect 0.0 0.3))) "\n")
  (show #t (edge2-frame (make-frame (make-vect 0.1 0.2) (make-vect 0.1 0.2) (make-vect 0.0 0.3))) "\n")
#+end_src

#+RESULTS[ba0cf6ab7a080e30b63b9ca5affce02dee81eba9]:
#+begin_src scheme
(0.1 0.2)
(0.1 0.2)
(0.0 0.3)
#+end_src

*** DONE Exercise 2.48 make-segment
    CLOSED: [2019-09-20 Fri 16:06]

#+name: pict-segment
#+begin_src scheme :exports code :results none
  (define (make-segment start-vector end-vector)
    (list start-vector end-vector))
  (define (start-segment segment)
    (car segment))
  (define (end-segment segment)
    (cadr segment))
#+end_src

#+begin_src scheme :exports both :results raw value
  <<draw-line>>
  <<pict-segment>>
  <<segments-painter>>
  <<pict-vect>>
  <<make-frame>>
  <<pict-frame>>
  ((segments->painter
    (list
     (make-segment (make-vect 0 0) (make-vect 1 1))
     (make-segment (make-vect 0 1) (make-vect 1 0))))
   (make-frame (make-vect 0 0) (make-vect 0 1) (make-vect 1 0)))
  (canvas-refresh)
#+end_src

#+RESULTS[c795dea74854efbd6932b070a3763fa13516e927]:
"[[./c39f243e-97f7-4346-9f09-2beb35c48ace.png]]"

*** DONE Exercise 2.49 segments->painter applications
    CLOSED: [2019-09-20 Fri 23:10]

#+name: x-painter
#+begin_src scheme :exports code :results none
(define x-painter
  (segments->painter
    (list
     (make-segment (make-vect 0 0) (make-vect 1 1))
     (make-segment (make-vect 0 1) (make-vect 1 0)))))
#+end_src

#+begin_src scheme :exports both :results raw value
  <<draw-line>>
  <<pict-segment>>
  <<segments-painter>>
  <<pict-vect>>
  <<make-frame>>
  <<pict-frame>>
  <<x-painter>>
  (x-painter
   (make-frame (make-vect 0 0) (make-vect 0 1) (make-vect 1 0)))
  (canvas-refresh)
#+end_src

#+RESULTS[a9a26a6b1223b8fb25b751290ab6e52285db5a37]:
"[[./0d165d33-0c97-42b1-832d-a8068a3e081d.png]]"

This painter is not entirely accurate, because my background is black,
so the lines would coalesce with it. I therefore just moved the lines
a little bit inside.

#+name: frame-boundary-painter
#+begin_src scheme :exports code :results none
(define frame-boundary-painter
  (segments->painter
    (list
     (make-segment (make-vect 0.01 0.01) (make-vect 0.01 0.99))
     (make-segment (make-vect 0.01 0.99) (make-vect 0.99 0.99))
     (make-segment (make-vect 0.99 0.99) (make-vect 0.99 0.01))
     (make-segment (make-vect 0.99 0.01) (make-vect 0.01 0.01)))))
#+end_src

#+begin_src scheme :exports both :results raw value
  <<draw-line>>
  <<pict-segment>>
  <<segments-painter>>
  <<pict-vect>>
  <<make-frame>>
  <<pict-frame>>
  <<frame-boundary-painter>>

  (frame-boundary-painter
   (make-frame (make-vect 0.1 0.1) (make-vect 0.1 0.05) (make-vect 0.5 0)))
  (canvas-refresh)
#+end_src

#+RESULTS[f4a8838ec1734baa9c267f973f6292381ea534d5]:
"[[./b1d124ff-ff14-4093-b121-450a6011b4a8.png]]"

#+name: diamond-painter
#+begin_src scheme :exports code :results none
(define diamond-painter
  (segments->painter
    (list
     (make-segment (make-vect 0.01 0.5) (make-vect 0.5 0.99))
     (make-segment (make-vect 0.5 0.99) (make-vect 0.99 0.5))
     (make-segment (make-vect 0.99 0.5) (make-vect 0.5 0.01))
     (make-segment (make-vect 0.5 0.01) (make-vect 0.01 0.5)))))
#+end_src

#+begin_src scheme :exports both :results raw value
  <<draw-line>>
  <<pict-segment>>
  <<segments-painter>>
  <<pict-vect>>
  <<make-frame>>
  <<pict-frame>>
  <<diamond-painter>>

  (diamond-painter
   (make-frame (make-vect 0 0) (make-vect 0 1) (make-vect 1 0)))
  (canvas-refresh)
#+end_src

#+RESULTS[d2ea4f98530fd963e20566c9c9a58152f86eb63c]:
"[[./41a12375-a844-455d-a3d5-f25c4cff9f4c.png]]"

Remark: the exercise 2.49d is ambiguous. The "Unofficial Texinfo Version"
differs with the official paper version in this respect, since in the paper
version the waving figurine is drawn with segments, whereas the UTF uses a
bitmap.
This is the rough solution to the "segment-based" version.

#+name: wave-segment
#+begin_src scheme :exports code :results none
(define wave
   (segments->painter
        (list
               (make-segment (make-vect .25 0) (make-vect .35 .5))
               (make-segment (make-vect .35 .5) (make-vect .3 .6))
               (make-segment (make-vect .3 .6) (make-vect .15 .4))
               (make-segment (make-vect .15 .4) (make-vect 0 .65))
               (make-segment (make-vect 0 .65) (make-vect 0 .85))
               (make-segment (make-vect 0 .85) (make-vect .15 .6))
               (make-segment (make-vect .15 .6) (make-vect .3 .65))
               (make-segment (make-vect .3 .65) (make-vect .4 .65))
               (make-segment (make-vect .4 .65) (make-vect .35 .85))
               (make-segment (make-vect .35 .85) (make-vect .4 1))
               (make-segment (make-vect .4 1) (make-vect .6 1))
               (make-segment (make-vect .6 1) (make-vect .65 .85))
               (make-segment (make-vect .65 .85) (make-vect .6 .65))
               (make-segment (make-vect .6 .65) (make-vect .75 .65))
               (make-segment (make-vect .75 .65) (make-vect 1 .35))
               (make-segment (make-vect 1 .35) (make-vect 1 .15))
               (make-segment (make-vect 1 .15) (make-vect .6 .45))
               (make-segment (make-vect .6 .45) (make-vect .75 0))
               (make-segment (make-vect .75 0) (make-vect .6 0))
               (make-segment (make-vect .6 0) (make-vect .5 .3))
               (make-segment (make-vect .5 .3) (make-vect .4 0))
               (make-segment (make-vect .4 0) (make-vect .25 0))
        )
   )
)
#+end_src


#+begin_src scheme :exports both :results raw value
<<pict-vect>>
<<pict-frame>>
<<magick-vect>>
<<make-frame>>
<<pict-segment>>
<<segments-painter>>
<<wave-segment>>
<<draw-line>>
(wave (make-frame (make-vect 0.0 0.9) (make-vect 0.7 0) (make-vect 0 -0.7)))
(canvas-refresh)
#+end_src

#+RESULTS[8fd65c9991a3563f07f0fc6d5b381adfa2f0e456]:
"[[./e1a0a51a-e4d2-4301-a917-d1b33a9d4417.png]]"

*** DONE Exercise 2.50 flip-horiz and rotate270 and rotate180
    CLOSED: [2019-09-20 Fri 23:37]
0:27:00

#+name: transform-painter
#+begin_src scheme :exports code :results none
  (define (transform-painter painter origin corner1 corner2)
    (lambda (frame)
      (let ((m (frame-coord-map frame)))
	(let ((new-origin (m origin)))
	  (painter (make-frame
		    new-origin
		    (sub-vect (m corner1) new-origin)
		    (sub-vect (m corner2) new-origin)))))))
#+end_src

#+name: flip-horiz
#+begin_src scheme :exports code :results none
  (define (flip-horiz painter)
    (transform-painter painter
		       (make-vect 1.0 0.0)
		       (make-vect 0.0 0.0)
		       (make-vect 1.0 1.0)))
#+end_src

#+begin_src scheme :exports both :results raw value
<<flip-horiz>>
<<pict-vect>>
<<pict-segment>>
<<segments-painter>>
<<transform-painter>>
<<make-frame>>
<<pict-frame>>
<<draw-line>>
<<wave-segment>>
(define bltr-line-painter
  (segments->painter
    (list
     (make-segment (make-vect 0.0 0.00) (make-vect 1 1.0)))))
((flip-horiz wave) (make-frame (make-vect 0 1) (make-vect 1 0) (make-vect 0 -1)))
(canvas-refresh)
#+end_src

#+RESULTS[ac22c61a03f3e87e4d9be787920a771c91fa9564]:
"[[./7c14f125-1bd3-415c-8bbd-5d81ada396d3.png]]"

#+name: rotate180
#+begin_src scheme :exports code :results none
  (define (rotate180 painter)
    (transform-painter painter
		       (make-vect 1.0 1.0)
		       (make-vect 0.0 1.0)
		       (make-vect 1.0 0.0)))
#+end_src

#+begin_src scheme :exports both :results raw value
<<rotate180>>
<<pict-vect>>
<<pict-segment>>
<<segments-painter>>
<<transform-painter>>
<<make-frame>>
<<pict-frame>>
<<draw-line>>
<<wave-segment>>
(define ne-arrow-painter
  (segments->painter
    (list
     (make-segment (make-vect 0.0 0.00) (make-vect 0.9 0.9))
     (make-segment (make-vect 0.9 0.9) (make-vect 0.9 0.7))
     (make-segment (make-vect 0.9 0.9) (make-vect 0.7 0.9)))))
#;(ne-arrow-painter (make-frame (make-vect 0 0) (make-vect 0 1) (make-vect 1 0)))
((rotate180 wave) (make-frame (make-vect 0 1) (make-vect 1 0) (make-vect 0 -1)))
(canvas-refresh)
#+end_src

#+RESULTS[a3facbd9c060dbb4529efe2afff9a3e92caf86d7]:
"[[./99cf81ef-1871-4a4c-9aeb-6939f1e4d7f1.png]]"

#+name: rotate270
#+begin_src scheme :exports code :results none
  (define (rotate270 painter)
    (transform-painter painter
		       (make-vect 0.0 1.0)
		       (make-vect 0.0 0.0)
		       (make-vect 1.0 1.0)))
#+end_src


#+begin_src scheme :exports both :results raw value
<<pict-vect>>
<<make-frame>>
<<rogers>>
<<transform-painter>>
<<pict-frame>>
<<draw-line>>
<<beside>>
<<below-beside>>
<<rotate270>>
<<pict-segment>>
<<segments-painter>>
<<wave-segment>>
#;((below rogers wave) (make-frame (make-vect 0.0 0.0) (make-vect 1.0 0.0) (make-vect 0.0 1.0)))
((rotate270 wave) (make-frame (make-vect 0.0 1.0) (make-vect 1.0 0.0) (make-vect 0.0 -1.0)))
(canvas-refresh)
#+end_src

#+RESULTS[6ca6c9efedc498c76c27a790b7a66ae130804eec]:
"[[./e5dd0e8c-280b-4e3e-9240-e0f904679b7d.png]]"

*** DONE Exercise 2.51 below
    CLOSED: [2019-09-22 Sun 18:50]

#+name: beside
#+begin_src scheme :exports code :results none
  (define (beside painter1 painter2)
    (let ((split-point (make-vect 0.5 0.0)))
      (let ((paint-left
	     (transform-painter
	      painter1
	      (make-vect 0.0 0.0)
	      split-point
	      (make-vect 0.0 1.0)))
	    (paint-right
	     (transform-painter
	      painter2
	      split-point
	      (make-vect 1.0 0.0)
	      (make-vect 0.5 1.0))))
	(lambda (frame)
	  (paint-left frame)
	  (paint-right frame)))))
#+end_src

#+name: below
#+begin_src scheme :exports code :results none
  (define (below painter1 painter2)
    (let ((split-point (make-vect 0.0 0.5)))
      (let ((paint-bottom
	     (transform-painter
	      painter1
	      (make-vect 0.0 0.5)
	      (make-vect 1.0 0.5)
	      (make-vect 0.0 1.0)))
	    (paint-top
	     (transform-painter
	      painter2
	      (make-vect 0.0 0.0)
	      (make-vect 1.0 0.0)
	      split-point)))
	(lambda (frame)
	  (paint-top frame)
	  (paint-bottom frame)))))

#+end_src

#+begin_src scheme :exports both :results raw value
<<pict-vect>>
<<pict-segment>>
<<segments-painter>>
<<make-frame>>
<<wave-segment>>
<<rogers>>
<<below>>
<<transform-painter>>
<<pict-frame>>
<<draw-line>>
((below wave wave) (make-frame (make-vect 0.0 0.0) (make-vect 1.0 0.0) (make-vect 0.0 1.0)))
(canvas-refresh)
#+end_src

#+RESULTS[0047e845455c69fa2bda52e5334fa7655fe9dfdc]:
"[[./188e073a-ffd6-4eee-b7e1-a53891c16326.png]]"

#+name: below-beside
#+begin_src scheme :exports code :results none
  (define (below painter1 painter2)
    (rotate90 (beside (rotate270 painter1) (rotate270 painter2))))
#+end_src

#+name: rotate90
#+begin_src scheme :exports code :results none
  (define (rotate90 painter)
    (transform-painter painter
		       (make-vect 1.0 0.0)
		       (make-vect 1.0 1.0)
		       (make-vect 0.0 0.0)))
#+end_src

#+begin_src scheme :exports both :results raw value
<<pict-vect>>
<<make-frame>>
<<pict-segment>>
<<segments-painter>>
<<wave-segment>>
<<transform-painter>>
<<pict-frame>>
<<draw-line>>
<<magick-vect>>
<<beside>>
<<below-beside>>
<<rotate270>>
<<rotate90>>
((below wave wave) (make-frame (make-vect 0.0 1.0) (make-vect 1.0 0.0) (make-vect 0.0 -1.0)))
#;((rotate270 rogers) (make-frame (make-vect 0.0 0.0) (make-vect 1.0 0.0) (make-vect 0.0 1.0)))
(canvas-refresh)
#+end_src

#+RESULTS[597493a3c23c5be3ed29dc0959f427994d2bf44a]:
"[[./422bb814-5765-4dc1-a9d9-592f15fcf8fc.png]]"


Remark: imagemagick is a horrible piece of software, even though we have
nothing better.

*** DONE Exercise 2.52 modify square-limit
    CLOSED: [2019-09-24 Tue 12:25]

To complete this exercise, we would first need to implement the square limit.

#+name: square-limit
#+begin_src scheme :exports code :results none
    (define (square-limit painter n)
      (let ((combine4 (square-of-four flip-horiz identity
				      rotate180 flip-vert)))
	(combine4 (corner-split painter n))))

    (define (square-of-four tl tr bl br)
      (lambda (painter)
	(let ((top (beside (tl painter) (tr painter)))
	      (bottom (beside (bl painter) (br painter))))
	  (below bottom top))))

    (define (corner-split painter n)
      (if (= n 0)
	  painter
	  (let ((up (up-split painter (- n 1)))
		(right (right-split painter (- n 1))))
	    (let ((top-left (beside up up))
		  (bottom-right (below right right))
		  (corner (corner-split painter (- n 1))))
	      (beside (below painter top-left)
		      (below bottom-right corner))))))
  (define (flip-vert painter)
    (transform-painter painter
		       (make-vect 0.0 1.0)
		       (make-vect 1.0 1.0)
		       (make-vect 0.0 0.0)))
  (define (identity x)
    x)
#+end_src

Because the exercise requires modification of the existing functions (and I
don't want to advise them), I'd just splice all the source code into one block.

#+begin_src scheme :exports both :results raw value
    (define (square-limit painter n)
      (let ((combine4 (square-of-four flip-horiz identity
				      rotate180 flip-vert)))
	(combine4 (corner-split painter n))))

    (define (square-of-four tl tr bl br)
      (lambda (painter)
	(let ((top (beside (flip-horiz (tl painter)) (tr painter)))
	      (bottom (beside (bl painter) (br painter))))
	  (below bottom top))))

    (define (corner-split painter n)
      (if (= n 0)
	  painter
	  (let ((up (up-split painter (- n 1)))
		(right (right-split painter (- n 1))))
	    (let ((top-left (beside up up))
		  (bottom-right (below right right))
		  (corner (corner-split painter (- n 1))))
	      (below (below painter top-left)
		      (below bottom-right corner))))))
  (define (flip-vert painter)
    (transform-painter painter
		       (make-vect 0.0 1.0)
		       (make-vect 1.0 1.0)
		       (make-vect 0.0 0.0)))
  (define (identity x)
    x)
  (define (make-vect xcor ycor . o)
    (append (list xcor) (list ycor) o))
  (define (xcor-vect vect)
    (car vect))
  (define (ycor-vect vect)
    (cadr vect))
  (define (scale-vect scale vect)
    (map (lambda (x) (* x scale)) vect))
  (define (add-vect vec1 vec2)
    (map (lambda (cor1 cor2) (+ cor1 cor2)) vec1 vec2))
  (define (sub-vect vec1 vec2)
    (map (lambda (cor1 cor2) (- cor1 cor2)) vec1 vec2))
  (define (make-frame origin edge1 edge2)
    (list origin edge1 edge2))
  (define (origin-frame frame)
    (car frame))
  (define (edge1-frame frame)
    (cadr frame))
  (define (edge2-frame frame)
    (caddr frame))
  (define (make-segment start-vector end-vector)
    (list start-vector end-vector))
  (define (start-segment segment)
    (car segment))
  (define (end-segment segment)
    (cadr segment))
  (define (segments->painter segment-list)
    (lambda (frame)
      (for-each
       (lambda (segment)
	 (draw-line
	  ((frame-coord-map frame)
	   (start-segment segment))
	  ((frame-coord-map frame)
	   (end-segment segment))))
       segment-list)))
  (define wave
     (segments->painter
	  (list
		 (make-segment (make-vect .25 0) (make-vect .35 .5))
		 (make-segment (make-vect .35 .5) (make-vect .3 .6))
		 (make-segment (make-vect .3 .6) (make-vect .15 .4))
		 (make-segment (make-vect .15 .4) (make-vect 0 .65))
		 (make-segment (make-vect 0 .65) (make-vect 0 .85))
		 (make-segment (make-vect 0 .85) (make-vect .15 .6))
		 (make-segment (make-vect .15 .6) (make-vect .3 .65))
		 (make-segment (make-vect .3 .65) (make-vect .4 .65))
		 (make-segment (make-vect .4 .65) (make-vect .35 .85))
		 (make-segment (make-vect .35 .85) (make-vect .4 1))
		 (make-segment (make-vect .4 1) (make-vect .6 1))
		 (make-segment (make-vect .6 1) (make-vect .65 .85))
		 (make-segment (make-vect .65 .85) (make-vect .6 .65))
		 (make-segment (make-vect .6 .65) (make-vect .75 .65))
		 (make-segment (make-vect .75 .65) (make-vect 1 .35))
		 (make-segment (make-vect 1 .35) (make-vect 1 .15))
		 (make-segment (make-vect 1 .15) (make-vect .6 .45))
		 (make-segment (make-vect .6 .45) (make-vect .75 0))
		 (make-segment (make-vect .75 0) (make-vect .6 0))
		 (make-segment (make-vect .6 0) (make-vect .5 .3))
		 (make-segment (make-vect .5 .3) (make-vect .4 0))
		 (make-segment (make-vect .4 0) (make-vect .25 0))
                 (make-segment (make-vect 0.45 0.5) (make-vect 0.50 0.45))
                 (make-segment (make-vect 0.5 0.45) (make-vect 0.55 0.50))
	  )
     )
  )
  (define (transform-painter painter origin corner1 corner2)
    (lambda (frame)
      (let ((m (frame-coord-map frame)))
	(let ((new-origin (m origin)))
	  (painter (make-frame
		    new-origin
		    (sub-vect (m corner1) new-origin)
		    (sub-vect (m corner2) new-origin)))))))
  (define (frame-coord-map frame)
    (lambda (v)
     (add-vect
       (origin-frame frame)
	      (add-vect (scale-vect (xcor-vect v) (edge1-frame frame))
		 (scale-vect (ycor-vect v) (edge2-frame frame))))))
  (define canvas-size
    (make-parameter
     200
     (lambda (size)
       (if (and (exact-integer? size) (<= 2 size 1000))
	   size
	   (error "invalid canvas size")))))
  (define canvas-file-name
     (make-parameter
	(string-append "./" (substring (process->string "uuidgen") 0 36) ".png")
	(lambda (name)
	  (if (string? name)
	      name
	      (error "invalid canvas file name")))))
  (define (canvas-reset)
    (system "rm" (canvas-file-name))
    (system "convert" "xc:white"
	    "-scale" (string-append
		      (number->string (canvas-size))
		      "x"
		      (number->string (canvas-size)))
	    (canvas-file-name)))
  (define (canvas-refresh)
    (string-append "[[" (canvas-file-name) "]]"))
  (canvas-reset)
  (define (draw-line point1 point2)
    (system "mogrify"
	    "-fill" "black"
	    "-draw" (string-append "line "
				   (number->string (* (canvas-size) (car point1)))
				   ","
				   (number->string (* (canvas-size) (cadr point1)))
				   " "
				   (number->string (* (canvas-size) (car point2)))
				   ","
				   (number->string (* (canvas-size) (cadr point2))))
	    (canvas-file-name))
    (string-append "[[" (canvas-file-name) "]]"))
  (define (beside painter1 painter2)
    (let ((split-point (make-vect 0.5 0.0)))
      (let ((paint-left
	     (transform-painter
	      painter1
	      (make-vect 0.0 0.0)
	      split-point
	      (make-vect 0.0 1.0)))
	    (paint-right
	     (transform-painter
	      painter2
	      split-point
	      (make-vect 1.0 0.0)
	      (make-vect 0.5 1.0))))
	(lambda (frame)
	  (paint-left frame)
	  (paint-right frame)))))
  (define (below painter1 painter2)
    (rotate90 (beside (rotate270 painter1) (rotate270 painter2))))
  (define (rotate270 painter)
    (transform-painter painter
		       (make-vect 0.0 1.0)
		       (make-vect 0.0 0.0)
		       (make-vect 1.0 1.0)))
  (define (rotate90 painter)
    (transform-painter painter
		       (make-vect 1.0 0.0)
		       (make-vect 1.0 1.0)
		       (make-vect 0.0 0.0)))

  (define (rotate180 painter)
    (transform-painter painter
		       (make-vect 1.0 1.0)
		       (make-vect 0.0 1.0)
		       (make-vect 1.0 0.0)))
  (define (split op1 op2)
    (define (split-inner painter n)
      (if (= n 0)
      painter
      (let ((smaller (split-inner painter (- n 1))))
	(op2 painter (op1 smaller smaller)))))
    (lambda (painter n)
      (split-inner painter n)))
  (define up-split (split beside below))
  (define right-split (split below beside))
  (define (flip-horiz painter)
    (transform-painter painter
		       (make-vect 1.0 0.0)
		       (make-vect 0.0 0.0)
		       (make-vect 1.0 1.0)))
  ((square-limit wave 1) (make-frame (make-vect 0.0 1.0) (make-vect 1.0 0.0) (make-vect 0.0 -1.0)))
  (canvas-refresh)
#+end_src

#+RESULTS[71941c22252179af16f14f225e7e2ee92636a1e6]:
"[[./ec49df07-4440-4509-9275-f50dbb2d5d55.png]]"

 a. I added a check-mark at the segments->painter level.
 b. Replaced the last ~beside~ with ~below~ at the lowest level.
 c. Added a ~flip-horiz~ at the level of the ~square-of-four~.

*** Remark. Here the picture language chapter stops
The bitmap loader used by the ~rogers~ painter is not very reliable, so it
will not probably be able to replicate the full ~square-limit~. You can try
though.
*** DONE Exercise 2.53 quote introduction
    CLOSED: [2019-09-24 Tue 12:36]

#+begin_src scheme :exports both :results output scalar code
(show #t (list 'a 'b 'c) "\n")
(show #t (list (list 'george)) "\n")
(show #t (cdr '((x1 x2) (y1 y2))) "\n")
(show #t (cadr '((x1 x2) (y1 y2))) "\n")
(show #t (pair? (car '(a short list))) "\n")
(show #t (memq 'red '((red shoes) (blue socks))) "\n")
(show #t (memq 'red '(red shoes blue socks)) "\n")
#+end_src

#+RESULTS[825e4f2c4c1226d589f639bed9e88c80795d1c1d]:
#+begin_src scheme
(a b c)
((george))
((y1 y2))
(y1 y2)
#f
#f
(red shoes blue socks)
#+end_src

*** DONE Exercise 2.54 equal? implementation
    CLOSED: [2019-09-24 Tue 13:48]

#+name: equal-implementation
#+begin_src scheme :exports code :results none
  (define (equal? o1 o2)
    (cond ((eq? o1 o2) #t)
	  ((and (list? o1) (list? o2))     (accumulate (lambda (x y) (and x y)) #t (map equal? o1 o2)))
	  ((and (number? o1) (number? o2)) (= o1 o2))
	  (else #f)))
#+end_src

#+RESULTS:


#+begin_src scheme :exports both :results output scalar code
<<accumulate>>
<<equal-implementation>>

(show #t (equal? '(this is a list) '(this is a list)) "\n")
(show #t (equal? '(this is a list) '(this (is a) list)) "\n")
#+end_src

#+RESULTS[a406fdc7069f361155db8e54c6d5af4bb831454d]:
#+begin_src scheme
#t
#f
#+end_src

*** DONE Exercise 2.55 quote quote
    CLOSED: [2019-09-24 Tue 13:48]
This is really easy.
~(car ''abracadabra)~ is in reality ~(car (quote (quote abracadabra)))~. The
second ~'~ gets automatically translated into a ~quote~ and is not interpreted.
*** DONE Exercise 2.56 differentiation-exponentiation
    CLOSED: [2019-09-24 Tue 23:14]

#+name: deriv-basic
#+begin_src scheme :exports code :results none
  (define (deriv exp var)
    (cond ((number? exp) 0)
	  ((variable? exp) (if (same-variable? exp var) 1 0))
	  ((sum? exp) (make-sum (deriv (addend exp) var)
				(deriv (augend exp) var)))
	  ((product? exp)
	   (make-sum
	    (make-product (multiplier exp)
			  (deriv (multiplicand exp) var))
	    (make-product (deriv (multiplier exp) var)
			  (multiplicand exp))))
	  (else
	   (error "unknown expression type: DERIV" exp))))
#+end_src

#+name: deriv-components
#+begin_src scheme :exports code :results none
  (define (variable? x) (symbol? x))
  (define (same-variable? v1 v2)
    (and (variable? v1) (variable? v2) (eq? v1 v2)))
  (define (=number? exp num)
    (and (number? exp) (= exp num)))
#+end_src

#+name: deriv-operations
#+begin_src scheme :exports code :results none
  (define (make-sum a1 a2 . rest)
    (cond ((=number? a1 0) a2)
	  ((=number? a2 0) a1)
	  ((and (number? a1) (number? a2))
	   (+ a1 a2))
	  (else (list '+ a1 a2))))
  (define (make-product m1 m2)
    (cond ((or (=number? m1 0) (=number? m2 0)) 0)
	  ((=number? m1 1) m2)
	  ((=number? m2 1) m1)
	  ((and (number? m1) (number? m2)) (* m1 m2))
	  (else (list '* m1 m2))))
  (define (sum? x) (and (pair? x) (eq? (car x) '+)))
  (define (addend s) (cadr s))
  (define (augend s) (caddr s))
  (define (product? x) (and (pair? x) (eq? (car x) '*)))
  (define (multiplier p) (cadr p))
  (define (multiplicand p) (caddr p))

#+end_src

#+begin_src scheme :exports both :results output scalar code
<<deriv-basic>>
<<deriv-components>>
<<deriv-operations>>
(show #t (deriv '(+ x 3) 'x) "\n")
(show #t (deriv '(* x y) 'x) "\n")
(show #t (deriv '(* (* x y) (+ x 3)) 'x) "\n")
#+end_src

#+RESULTS[c0e5986458fa582196dfdeda864767bf880b0857]:
#+begin_src scheme
1
y
(+ (* x y) (* y (+ x 3)))
#+end_src

#+name: deriv-and-exponent
#+begin_src scheme :exports code :results none
  (define (deriv exp var)
    (cond ((number? exp) 0)
	  ((variable? exp) (if (same-variable? exp var) 1 0))
	  ((sum? exp) (make-sum (deriv (addend exp) var)
				(deriv (augend exp) var)))
	  ((product? exp)
	   (make-sum
	    (make-product
	     (multiplier exp)
	     (deriv
	      (multiplicand exp)
	      var))
	    (make-product
	     (deriv
	      (multiplier exp)
	      var)
	     (multiplicand exp))))
	  ((exponentiation? exp)
	   (make-product (exponent exp)
			 (make-product
			  (make-exponentiation
			   (base exp)
			   (make-sum (exponent exp) -1))
			  (deriv (base exp) var))))
	  (else
	   (error "unknown expression type: DERIV" exp))))

  (define (make-exponentiation base power)
    (cond ((=number? power 0) 1)
	  ((=number? power 1) base)
	  ((and (number? base) (number? power))
	   (expt base power))
	  (else (list '** base power))))
  (define (exponentiation? x) (and (pair? x) (eq? (car x) '**)))
  (define (base s) (cadr s))
  (define (exponent s) (caddr s))

#+end_src


#+begin_src scheme :exports both :results output scalar code
<<deriv-and-exponent>>
<<deriv-components>>
<<deriv-operations>>
(show #t (deriv '(** x 3) 'x) "\n")
(show #t (deriv '(** (* (* x y) (+ x 3)) 5) 'x) "\n")
#+end_src

#+RESULTS[c8bbc768ee41fd073f0ce4a845bffdada5342a5b]:
#+begin_src scheme
(* 3 (** x 2))
(* 5 (* (** (* (* x y) (+ x 3)) 4) (+ (* x y) (* y (+ x 3)))))
#+end_src

*** DONE Exercise 2.57 differentiate-three-sum
    CLOSED: [2019-09-25 Wed 12:40]

#+name: deriv-operations-three
#+begin_src scheme :exports code :results none
  (define (make-sum a1 a2 . rest)
    (if (null? rest)
	(cond ((=number? a1 0) a2)
	      ((=number? a2 0) a1)
	      ((and (number? a1) (number? a2))
	       (+ a1 a2))
	      (else (list '+ a1 a2)))
	(make-sum a1 (apply make-sum a2 (car rest) (cdr rest)))))
  (define (make-product m1 m2 . rest)
    (if (null? rest)
	(cond ((or (=number? m1 0) (=number? m2 0)) 0)
	  ((=number? m1 1) m2)
	  ((=number? m2 1) m1)
	  ((and (number? m1) (number? m2)) (* m1 m2))
	  (else (list '* m1 m2)))
	(make-product m1 (apply make-product m2 (car rest) (cdr rest)))))
  (define (sum? x) (and (pair? x) (eq? (car x) '+)))
  (define (addend s) (cadr s))
  (define (augend s)
    (if (null? (cdddr s))
	(caddr s)
	(apply make-sum (cddr s))))
  (define (product? x) (and (pair? x) (eq? (car x) '*)))
  (define (multiplier p) (cadr p))
  (define (multiplicand p)
    (if (null? (cdddr p))
	(caddr p)
	(apply make-product (cddr p))))

#+end_src

#+begin_src scheme :exports both :results output scalar code
<<deriv-and-exponent>>
<<deriv-components>>
<<deriv-operations-three>>
(show #t (deriv '(** x 3) 'x) "\n")
(show #t (deriv '(* x y z) 'y) "\n")
(show #t (deriv '(** (* (* x y z) (+ x 3)) 5) 'x) "\n")
#+end_src

#+RESULTS[00ba3ae80473417b0d87363359eed5139c4f2252]:
#+begin_src scheme
(* 3 (** x 2))
(* x z)
(* 5 (* (** (* (* x y z) (+ x 3)) 4) (+ (* x y z) (* (* y z) (+ x 3)))))
#+end_src

*** DONE Exercise 2.58 infix-notation
    CLOSED: [2019-09-25 Wed 15:21]

This solution is copied from http://community.schemewiki.org/?sicp-ex-2.58
almost verbatim. Courtesy of sgm.


#+begin_src scheme :exports both :results output scalar code
<<deriv-components>>
<<deriv-and-exponent>>
<<accumulate>>

(define (singleton? lst)
  (= 1 (length lst)))
(define (sum? expr)
   (eq? '+ (smallest-op expr)))

 (define (product? expr)
   (eq? '* (smallest-op expr)))
(define (smallest-op expr)
   (accumulate (lambda (b a)
                 (if (operator? b)
                     (min-precedence a b)
                     a))
               'maxop
               expr))
(define *precedence-table*
   '( (maxop . 10000)
      (minop . -10000)
      (+ . 0)
      (* . 1) ))

 (define (operator? x)
   (define (loop op-pair)
     (cond ((null? op-pair) #f)
           ((eq? x (caar op-pair)) #t)
           (else (loop (cdr op-pair)))))
   (loop *precedence-table*))
 (define (min-precedence a b)
   (if (precedence<? a b)
       a
       b))
 (define (precedence<? a b)
   (< (precedence a) (precedence b)))
 (define (precedence op)
   (define (loop op-pair)
     (cond ((null? op-pair)
            (error "Operator not defined -- PRECEDENCE:" op))
           ((eq? op (caar op-pair))
            (cdar op-pair))
           (else
            (loop (cdr op-pair)))))
   (loop *precedence-table*))
(define (augend expr)
   (let ((a (cdr (memq '+ expr))))
     (if (singleton? a)
         (car a)
         a)))

(define (prefix sym list)
   (if (or (null? list) (eq? sym (car list)))
       '()
       (cons (car list) (prefix sym (cdr list)))))

 (define (addend expr)
   (let ((a (prefix '+ expr)))
     (if (singleton? a)
         (car a)
         a)))
(define (make-sum a1 a2)
   (cond ((=number? a1 0) a2)
         ((=number? a2 0) a1)
         ((and (number? a1) (number? a2))
          (+ a1 a2))
         (else (list a1 '+ a2))))
(define (multiplier expr)
   (let ((m (prefix '* expr)))
     (if (singleton? m)
         (car m)
         m)))

 (define (multiplicand expr)
   (let ((m (cdr (memq '* expr))))
     (if (singleton? m)
         (car m)
         m)))

 (define (make-product m1 m2)
   (cond ((=number? m1 1)  m2)
         ((=number? m2 1)  m1)
         ((or (=number? m1 0) (=number? m2 0))  0)
         ((and (number? m1) (number? m2))
          (* m1 m2))
         (else (list m1 '* m2))))


(show #t "Smallest-op:" (smallest-op '(t + 3)) "\n")
(show #t "Singleton" (singleton? '(3)) "\n")
(show #t "Operator?" (operator? '(3))  "\n")
(show #t "Operator?" (operator? 3)  "\n")
(show #t "Sum?" (sum? '(x + 3)) "\n" )
(show #t "Smalles-op" (smallest-op '(x + 3)) "\n" )
(show #t (deriv '(x + 3) 'x) "\n")
(show #t (deriv '(x * y * (x + 3)) 'x) "\n")
(show #t (deriv '((x * y) * (x + 3)) 'x) "\n")
(show #t (deriv '(x * (y * (x + 3))) 'x) "\n")

#+end_src

#+RESULTS[9a12cc4a2c9e5f427bfdc9727d887f65eae7378b]:
#+begin_src scheme
Smallest-op:+
Singleton#t
Operator?#f
Operator?#f
Sum?#t
Smalles-op+
1
((x * y) + (y * (x + 3)))
((x * y) + (y * (x + 3)))
((x * y) + (y * (x + 3)))
#+end_src


As a side-note: sometimes people say that copying other people's code
prevents us from learning. I disagree. Only copying sgm's code allowed me to
find a serious bug in my implementation of "accumulate".

*** DONE Exercise 2.59 union-set
    CLOSED: [2019-09-25 Wed 22:00]

#+name: element-of-set
#+begin_src scheme :exports code :results none
  (define (element-of-set? x set)
    (cond ((null? set) false)
	  ((equal? x (car set)) true)
	  (else (element-of-set? x (cdr set)))))
#+end_src

#+name: union-set
#+begin_src scheme :exports code :results none
<<element-of-set>>
  (define (union-set set1 set2)
    (append set1 (filter (lambda (x) (not (element-of-set? x set1))) set2)))

  (define true #t)
  (define false #f)
#+end_src


#+begin_src scheme :exports both :results output scalar code
<<union-set>>
<<filter>>
(show #t " " (union-set '(1 2 3 4) '(3 4 5 6)))
#+end_src

#+RESULTS[91848fcc6d00324b5378419ab2929329866fd475]:
#+begin_src scheme
 (1 2 3 4 5 6)
#+end_src

*** DONE Exercise 2.60 duplicate-set
    CLOSED: [2019-09-25 Wed 22:17]

#+begin_src scheme :exports both :results output scalar code
  (define (element-of-set? x set)
    (cond ((null? set) false)
	  ((equal? x (car set)) true)
	  (else (element-of-set? x (cdr set)))))
  #;(The element-of-set? predicate stays the same)
  (define (adjoin x set)
    (cons x set))

  (define (intersection-set set1 set2)
    (cond ((or (null? set1) (null? set2)) '())
	  ((element-of-set? (car set1) set2)
	   (cons (car set1) (intersection-set (cdr set1) set2)))
	  (else (intersection-set (cdr set1) set2))))
  #;(The intersection-set stays the same, moreover, every time it is called,
  the duplicates are removed.)

  (define (union-set set1 set2)
    (append set1 set2))
  (define true #t)
  (define false #f)

  (show #t " " (element-of-set? 2 '(1 2 3)) "\n")
  (show #t " " (adjoin 2 '(1 2)) "\n")
  (show #t " " (intersection-set '(1 2 3 4 5) '(2 2 2 2 2)) "\n")
  (show #t " " (union-set '(1 2 3 4 5) '(1 2 2 2 2 3 4)) "\n")
#+end_src

#+RESULTS[2b5443123f0acffa871c4541e9f452202288eddf]:
#+begin_src scheme
 #t
 (2 1 2)
 (2)
 (1 2 3 4 5 1 2 2 2 2 3 4)
#+end_src

The efficiency of ~element-of-set?~ is still O(n), although on average sets
would be larger. ~adjoin~ takes O(1), instead of O(n). ~intersection-set~
takes the same \(O(n^2)\), although again, the sets may be larger. ~union-set~
takes \(O(1)\) instead of \(O(n^2)\), which sounds even too good to be true.

Well, if the amount of calls to ~intersection-set~ is big enough, I think
that this representation would be good enough, or even faster.

*** DONE Exercise 2.61 sets as ordered lists
    CLOSED: [2019-09-26 Thu 21:44]

#+begin_src scheme :exports both :results value scalar code
  (define (adjoin-set x set)
    (cond ((null? set) x)
	  ((= x (car set)) set)
	  ((< x (car set)) (cons x set))
	  (else (cons (car set) (adjoin-set x (cdr set))))))
  (adjoin-set 3 '(1 2 4 5))
#+end_src

#+RESULTS[f73284bb5f60f130ba94560aa4779945407129f6]:
#+begin_src scheme
(1 2 3 4 5)
#+end_src

*** DONE Exercise 2.62 ordered-union-set (ordered list)
    CLOSED: [2019-09-26 Thu 21:38]

#+name: ordered-set
#+begin_src scheme :exports code :results none
  (define (element-of-set? x set)
    (cond ((null? set) false)
	  ((= x (car set)) true)
	  ((< x (car set)) false)
	  (else (element-of-set? x (cdr set)))))
  (define (intersection-set set1 set2)
    (if (or (null? set1) (null? set2))
	'()
	(let ((x1 (car set1)) (x2 (car set2)))
	  (cond ((= x1 x2)
		 (cons x1
		       (intersection-set (cdr set1)
					 (cdr set2))))
		((< x1 x2)
		 (intersection-set (cdr set1) set2))
		((< x2 x1)
		 (intersection-set set1 (cdr set2)))))))

  (define (remove-duplicates-set set)
    (define (r-d-iter set accumulator)
      (cond ((null? set) accumulator)
	    ((null? accumulator) (r-d-iter (cdr set) (cons (car set) accumulator)))
	    ((= (car set) (car accumulator)) (r-d-iter (cdr set) accumulator))
	    (else (r-d-iter (cdr set) (cons (car set) accumulator)))))
    (reverse (r-d-iter set '())))


  (define (union-set set1 set2)
    (define (union-iter set1 set2 result)
      (cond ((null? set1) (append (reverse result) set2))
	    ((null? set2) (append (reverse result) set1))
	    ((<= (car set1) (car set2)) (union-iter (cdr set1) set2 (cons (car set1) result)))
	    ((<= (car set2) (car set1)) (union-iter set1 (cdr set2) (cons (car set2) result)))))
    (remove-duplicates-set (union-iter set1 set2 '())))
#+end_src

#+begin_src scheme :exports both :results value scalar code
<<ordered-set>>
(cons (union-set '(1 3 10) '(1 2 4 5))
(intersection-set '(1 3 10) '(1 2 4 5)))
#+end_src

#+RESULTS[c60bbd2727a01611a6d2b6410d4b73a2908fdcf0]:
#+begin_src scheme
((1 2 3 4 5 10) 1)
#+end_src

*** DONE Exercise 2.63 tree->list (binary search tree)
    CLOSED: [2019-09-26 Thu 23:37]

Let me copy the two code pieces here, I will need them later.

#+begin_src scheme :exports code :results none
  (define (tree->list-1 tree)
    (if (null? tree)
	'()
	(append (tree->list-1 (left-branch tree))
		(cons (entry tree)
		      (tree->list-1 (right-branch tree))))))
#+end_src

#+name: tree-list
#+begin_src scheme :exports code :results none
  (define (tree->list-2 tree)
    (define (copy-to-list tree result-list)
      (if (null? tree)
	  result-list
	  (copy-to-list (left-branch tree)
			(cons (entry tree)
			      (copy-to-list (right-branch tree)
					    result-list)))))
    (copy-to-list tree '()))
#+end_src


 a. The difference between the two functions is the order of traversing the
 tree. The function ~tree->list-1~ traverses the tree from the left, whereas
 the function ~tree->list-2~ does it from the right. The outcome would be the
 same, and for the trees on the figure 2.16 would give the same answer:
 ~'(1 2 3 4 5 6 7 8 9 10 11)~.
 b. The difference in performance would be significant. The function 2 uses
 ~cons~, which uses O(1) operations, so the opppprder of growth is ~O(n)~ in
 total. ~append~ in the function 1 takes O(n) operations in the worst case,
 which would make the total complexity \(O(n^2)\).p
*** DONE Exercise 2.64 balanced-tree
    CLOSED: [2019-09-29 Sun 17:22]

Firstly, I want to see what it is exactly that the function outputs.

#+name: list-tree
#+begin_src scheme :exports code :results none
     (define (entry tree) (car tree))

     (define (left-branch tree) (cadr tree))

     (define (right-branch tree) (caddr tree))

     (define (make-tree entry left right)
       (list entry left right))


  (define (list->tree elements)
    (car (partial-tree elements (length elements))))

  (define (partial-tree elts n)
    (if (= n 0)
	(cons '() elts)
	(let ((left-size (quotient (- n 1) 2)))
	  (let ((left-result (partial-tree elts left-size)))
	    (let ((left-tree (car left-result))
		  (non-left-elts (cdr left-result))
		  (right-size (- n (+ left-size 1))))
	      (let ((this-entry (car non-left-elts))
		    (right-result (partial-tree (cdr non-left-elts)
						right-size)))
		(let ((right-tree (car right-result))
		      (remaining-elts (cdr right-result)))
		  (cons (make-tree this-entry left-tree right-tree)
			remaining-elts))))))))
#+end_src

#+begin_src scheme :exports both :results output scalar code
<<list-tree>>
(show #t " " (pretty (list->tree '(1 3 5 7 9 11))))
#+end_src

#+RESULTS[c8c97f9af2f66620678be5db952a975b3afbb867]:
#+begin_src scheme
 (5 (1 () (3 () ())) (9 (7 () ()) (11 () ())))
#+end_src

Since I already got the result, I will just draw it.

#+begin_src plantuml :exports both :file exercise-2-63-dot.png
@startdot
graph g {
	 node [shape=plaintext];
	 A1 [label="5"];

	 B1 [label="1"];

	 B3 [label="9"];

	 C1 [label="7"];
	 C2 [label="11"];
         C0 [label="'()"];
         C3 [label="3 "]

 // edges
	 A1 -- B1;
	 A1 -- B3;

         B1 -- C0;
         B1 -- C3;


	 B3 -- C1;
	 B3 -- C2;

	 { rank=same; A1 }
	 { rank=same; B1 B3 }
	 { rank=same; C1 C2 C3 }
 } 
@enddot
#+end_src
#+attr_latex: :width 224pt
#+RESULTS[d70d1d487c7a52b9bdc27bbc93b474e58e67aa61]:
[[file:exercise-2-63-dot.png]]

   a. How exactly did this tree appear? The algorithm given by Abelson
and Sussman is actually quite straightforward: divide a list into two
roughly equal parts, separated by the middle element, make the element into a
node, and attach the right and the left sub-lists of the list as its left and
right children.

   b. The function ~partial-tree~ doesn't contain any full passes through the list,
works in constant time, and is evaluated once per node. Therefore the
complexity is O(1).

*** DONE Exercise 2.65 tree-union-set
    CLOSED: [2019-10-09 Wed 12:13]
Well, I am required to make a union-set and an intersection-set.
So far, we have the operations tree->list, which works in O(n); list->tree,
which works as O(n) too, and union-set and intersection-set for list-based
set implementations, which both work in O(n). The solution then seems
straightforward.


#+name: set-tree
#+begin_src scheme :exports both :results none
  (define (union-set-tree set1 set2)
    (list->tree (union-set (tree->list-2 set1) (tree->list-2 set2))))

  (define (intersection-set-tree set1 set2)
    (list->tree (intersection-set (tree->list-2 set1) (tree->list-2 set2))))
#+end_src


#+begin_src scheme :exports both :results output scalar code
<<list-tree>>
<<tree-list>>
<<ordered-set>>
<<set-tree>>

(show #t (union-set-tree (list->tree '(1 3 10)) (list->tree '(1 2 4 5))) "\n")
(show #t (intersection-set-tree (list->tree '(1 3 10)) (list->tree '(1 2 4 5))) "\n")

#+end_src

#+RESULTS[9c18ce471819d2789b5d5f43e9b760196837c339]:
#+begin_src scheme
(3 (1 () (2 () ())) (5 (4 () ()) (10 () ())))
(1 () ())
#+end_src

*** DONE Exercise 2.66 tree-lookup
    CLOSED: [2019-10-09 Wed 13:03]

The excellent property of the ~list->tree~ procedure is that is asserts that
the list given as an argument is already sorted in some way appropriate for
this represented data. Therefore we can use the function verbatim.

#+name: tree-lookup
#+begin_src scheme :exports code :results none
  (define-record-type dict-entry-type
  (dict-entry x y)
  dict-entry?
  (x entry-key)
  (y entry-value))

  (define (tree-lookup key dictionary)
    (cond ((null? dictionary) #f)
	  ((= (entry-key (entry dictionary)) key) (entry dictionary))
	  ((<= key (entry-key (entry dictionary))) (tree-lookup key (left-branch dictionary)))
	  ((>= key (entry-key (entry dictionary))) (tree-lookup key (right-branch dictionary)))
	  (else (error "Corrupt dictionary"))))

#+end_src


#+begin_src scheme :exports both :results output scalar code
<<list-tree>>
<<tree-lookup>>
(show #t " " (pretty (list->tree (list (dict-entry 1 'John)
                                      (dict-entry 2 'James)
                                      (dict-entry 3 'Baloo)
                                      (dict-entry 4 'Carry)))) "\n")
(show #t " " (pretty (tree-lookup
                        3
                        (list->tree (list (dict-entry 1 'John)
                                          (dict-entry 2 'James)
                                          (dict-entry 3 'Baloo)
                                          (dict-entry 4 'Carry))))) "\n")
#+end_src

#+RESULTS[e5eedf2173844414dd06c1f837137e52efa915ee]:
#+begin_src scheme
 ({dict-entry-type #65 2 James}
  ({dict-entry-type #65 1 John} () ())
  ({dict-entry-type #65 3 Baloo} () ({dict-entry-type #65 4 Carry} () ())))

 {dict-entry-type #65 3 Baloo}

#+end_src

This exercise used the r7rs ~define-record-type~. It is not strictly
necessary here, but I used it do add more "encapsulation" to the data base.
*** DONE Exercise 2.67 Huffman decode a simple message
    CLOSED: [2019-10-09 Wed 20:20]

#+name: huffman-base
#+begin_src scheme :exports code :results none
     (define (make-leaf symbol weight)
       (list 'leaf symbol weight))

     (define (leaf? object)
       (eq? (car object) 'leaf))

     (define (symbol-leaf x) (cadr x))

     (define (weight-leaf x) (caddr x))

     (define (make-code-tree left right)
       (list left
             right
             (append (symbols left) (symbols right))
             (+ (weight left) (weight right))))
     (define (left-branch tree) (car tree))

     (define (right-branch tree) (cadr tree))

     (define (symbols tree)
       (if (leaf? tree)
           (list (symbol-leaf tree))
           (caddr tree)))

     (define (weight tree)
       (if (leaf? tree)
           (weight-leaf tree)
           (cadddr tree)))
     (define (decode bits tree)
       (define (decode-1 bits current-branch)
         (if (null? bits)
             '()
             (let ((next-branch
                    (choose-branch (car bits) current-branch)))
               (if (leaf? next-branch)
                   (cons (symbol-leaf next-branch)
                         (decode-1 (cdr bits) tree))
                   (decode-1 (cdr bits) next-branch)))))
       (decode-1 bits tree))

     (define (choose-branch bit branch)
       (cond ((= bit 0) (left-branch branch))
             ((= bit 1) (right-branch branch))
             (else (error "bad bit -- CHOOSE-BRANCH" bit))))
     (define (adjoin-set x set)
       (cond ((null? set) (list x))
             ((< (weight x) (weight (car set))) (cons x set))
             (else (cons (car set)
                         (adjoin-set x (cdr set))))))
     (define (make-leaf-set pairs)
       (if (null? pairs)
           '()
           (let ((pair (car pairs)))
             (adjoin-set (make-leaf (car pair)    #;(symbol)
                                    (cadr pair))  #;(frequency)
                         (make-leaf-set (cdr pairs))))))

#+end_src

#+name:  huffman-sample-tree
#+begin_src scheme :exports code :results none
  (define sample-tree
    (make-code-tree (make-leaf 'A 4)
		    (make-code-tree
		     (make-leaf 'B 2)
		     (make-code-tree (make-leaf 'D 1)
				     (make-leaf 'C 1)))))
  (define sample-message '(0 1 1 0 0 1 0 1 0 1 1 1 0))

#+end_src


#+begin_src scheme :exports both :results value scalar code
<<huffman-base>>
<<huffman-sample-tree>>
  (decode sample-message sample-tree)
#+end_src

#+RESULTS[849bd8493d964748ad37dea74baa891ec51626a3]:
#+begin_src scheme
(A D A B B C A)
#+end_src

This is a rather easy exercise, who's main goal is to make us test that the
chapter code is actually working.

*** DONE Exercise 2.68 Huffman encode a simple message
    CLOSED: [2019-10-09 Wed 20:53]

#+name: huffman-encode
#+begin_src scheme :exports code :results none
	(define (encode message tree)
	  (if (null? message)
	      '()
	      (append (encode-symbol (car message) tree)
		      (encode (cdr message) tree))))
	(define (encode-symbol symbol tree)
	  (cond ((not (element-of-set? symbol (symbols tree)))
		 (error "Error: Huffman tree does not support encoding symbol" symbol))
		((leaf? tree) '())
		((element-of-set? symbol (symbols (left-branch tree))) (cons 0 (encode-symbol symbol (left-branch tree))))
		((element-of-set? symbol (symbols (right-branch tree))) (cons 1 (encode-symbol symbol (right-branch tree))))))

#+end_src

#+begin_src scheme :exports both :results value scalar code
(define true #t)
(define false #f)
<<huffman-base>>
<<huffman-encode>>
<<element-of-set>>
<<huffman-sample-tree>>
(encode (list 'A  'D  'A  'B  'B  'C  'A) sample-tree)
#+end_src

#+RESULTS[da7daba534a43a35838696c66de769599deb4228]:
#+begin_src scheme
(0 1 1 0 0 1 0 1 0 1 1 1 0)
#+end_src

My implementation of encode-symbol is not iterative, but for educational
purposes it should be enough.

*** DONE Exercise 2.69 Generate Huffman tree
    CLOSED: [2019-10-10 Thu 11:28]

I spent an hour trying to debug why my code doesn't work, and it turns out
that although Abelson and Sussman use the word "pair" for the (symbol,
weight) tuples, they are actually lists.

#+name: huffman-generate-tree
#+begin_src scheme :exports code :results none
     (define (generate-huffman-tree pairs)
       (successive-merge (make-leaf-set pairs)))
     #;(leaf-set is sorted by weight)
     (define (successive-merge leaf-set)
       (cond ((null? leaf-set) '())
	     ((null? (cdr leaf-set)) (car leaf-set))
	     (else (successive-merge (adjoin-set
				      (make-code-tree
				       (car leaf-set)
				       (cadr leaf-set))
				      (cddr leaf-set))))))
#+end_src


#+begin_src scheme :exports both :results output scalar code scalar code
(define true #t)
(define false #f)
<<huffman-base>>
<<huffman-encode>>
<<element-of-set>>
<<huffman-sample-tree>>
<<huffman-generate-tree>>
(define pairs (list (list 'A 4) (list 'B 2) (list 'C 1) (list 'D 1)))
#;(generate-huffman-tree (list (cons 'A 4) (cons 'B 2) (cons 'C 1) (cons 'D 1)))
#;(make-leaf-set pairs)
(show #t  "Sample-tree:" (pretty (generate-huffman-tree pairs)) "\n")
(show #t  "Our tree   :" (pretty sample-tree) "\n")
#+end_src

#+RESULTS[999f217e2b38c63406af6e403dda90a365e998cf]:
#+begin_src scheme
Sample-tree:((leaf A 4)
             ((leaf B 2) ((leaf D 1) (leaf C 1) (D C) 2) (B D C) 4)
             (A B D C)
             8)

Our tree   :((leaf A 4)
             ((leaf B 2) ((leaf D 1) (leaf C 1) (D C) 2) (B D C) 4)
             (A B D C)
             8)

#+end_src

*** DONE Exercise 2.70 Generate a tree and encode a song
    CLOSED: [2019-10-10 Thu 13:11]
This exercise has a small caveat. The scheme used to create examples for SICP
back when it was written, had a case-independent reader, therefore the text
of the book ignores the case difference between, say, 'Sha, 'SHA, and 'sha.
Luckily, in the given song, there are no instances of the same symbol
consisting of letters of different cases, so to make the code work, the only
thing needed is to correct the case in the dictionary.

Let's generate a tree first:

#+begin_src scheme :exports both :results output scalar code
  (define true #t)
  (define false #f)
  <<huffman-base>>
  <<huffman-encode>>
  <<element-of-set>>
  <<huffman-sample-tree>>
  <<huffman-generate-tree>>
  (define pairs
    (list
     (list 'a 4) (list 'Get 2) (list 'Sha 1) (list 'Wah 1)
     (list 'boom 1) (list 'job 2) (list 'na 16) (list 'yip 9)))
  (define coding-tree (generate-huffman-tree pairs))
  (show #t  "Tree:" (pretty coding-tree) "\n")
  (define song '(
		     Get a job
		     Sha na na na na na na na na
		     Get a job
		     Sha na na na na na na na na
		     Wah yip yip yip yip yip yip yip yip yip
		     Sha boom
		     ))
  (define encoded-song (encode song coding-tree))
  (show #t (pretty encoded-song) "\n")
  (show #t (pretty (decode encoded-song coding-tree)) "\n")
#+end_src

#+RESULTS[3b03980b00fdec47fdc592aa0b5e52387e0f4679]:
#+begin_src scheme
Tree:((leaf na 16)
      ((leaf yip 9)
       (((leaf Get 2) ((leaf boom 1) (leaf Wah 1) (boom Wah) 2)
                      (Get boom Wah)
                      4)
        (((leaf Sha 1) (leaf job 2) (Sha job) 3) (leaf a 4) (Sha job a) 7)
        (Get boom Wah Sha job a)
        11)
       (yip Get boom Wah Sha job a)
       20)
      (na yip Get boom Wah Sha job a)
      36)

(1 1 0 0 1 1 1 1 1 1 1 0 1 1 1 1 0 0 0 0 0 0 0 0 0 0 1 1 0 0 1 1 1 1 1 1 1 0 1
 1 1 1 0 0 0 0 0 0 0 0 0 0 1 1 0 1 1 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 1 1
 0 0 1 1 0 1 0)

(Get a
     job
     Sha
     na
     na
     na
     na
     na
     na
     na
     na
     Get
     a
     job
     Sha
     na
     na
     na
     na
     na
     na
     na
     na
     Wah
     yip
     yip
     yip
     yip
     yip
     yip
     yip
     yip
     yip
     Sha
     boom)

#+end_src

*** DONE Exercise 2.71 Huffman tree for frequencies 5 and 10
    CLOSED: [2019-10-10 Thu 19:22]

#+begin_src scheme :exports both :results output scalar code
  (define true #t)
  (define false #f)
  <<huffman-base>>
  <<huffman-encode>>
  <<element-of-set>>
  <<huffman-sample-tree>>
  <<huffman-generate-tree>>
  (define pairs
    (list
     (list 'a 1) (list 'b 2) (list 'c 4) (list 'd 8)))
  (define coding-tree (generate-huffman-tree pairs))
  (show #t  "Tree:" (pretty coding-tree) "\n")

#+end_src

#+RESULTS[3015285bdbefc6dc224a164f6e0c08f3f41a2845]:
#+begin_src scheme
Tree:((((leaf a 1) (leaf b 2) (a b) 3) (leaf c 4) (a b c) 7) (leaf d 8)
                                                             (a b c d)
                                                             15)

#+end_src

#+begin_src plantuml :exports both :file Exercise-2.71-1.png
@startmindmap
skinparam monochrome true
+_ ((((leaf a 1)\n (leaf b 2) (a b) 3)\n (leaf c 4) (a b c) 7)\n (leaf d 8) (a b c d) 15)
++_ (leaf d 8)
++_ (((leaf a 1)\n (leaf b 2) (a b) 3) \n(leaf c 4) (a b c) 7)
+++_ (leaf c 4)
+++_ ((leaf a 1) \n(leaf b 2) (a b) 3)
++++_ (leaf b 2)
++++_ (leaf a 1)
@endmindmap
#+end_src

#+RESULTS[83bd7586691968a1c36152f709b55729d04bb749]:
[[file:Exercise-2.71.png]]



#+begin_src scheme :exports both :results output scalar code
  (define true #t)
  (define false #f)
  <<huffman-base>>
  <<huffman-encode>>
  <<element-of-set>>
  <<huffman-sample-tree>>
  <<huffman-generate-tree>>
  (define pairs
    (list
     (list 'a 1) (list 'b 2) (list 'c 4) (list 'd 8)
     (list 'e 16) (list 'f 32) (list 'g 64) (list 'h 128) (list 'j 256)))
  (define coding-tree (generate-huffman-tree pairs))
  (show #t  "Tree:" (pretty coding-tree) "\n")

#+end_src

#+RESULTS[d328a170b305040a56bf70a219f839160283319f]:
#+begin_src scheme
Tree:(((((((((leaf a 1) (leaf b 2) (a b) 3) (leaf c 4) (a b c) 7) (leaf d 8)
                                                                  (a b c d)
                                                                  15)
          (leaf e 16)
          (a b c d e)
          31) (leaf f 32)
              (a b c d e f)
              63) (leaf g 64)
                  (a b c d e f g)
                  127) (leaf h 128)
                       (a b c d e f g h)
                       255) (leaf j 256)
                            (a b c d e f g h j)
                            511)

#+end_src

#+begin_src plantuml :exports both :file Exercise-2.71-2.png
@startmindmap
skinparam monochrome true
+_ (a b c d e f g h j) 511
++_ (leaf j 256)
++_ (a b c d e f g h) 255
+++_ (leaf h 128)
+++_ (a b c d e f g) 127
++++_ (a b c d e f) 63
++++_ (leaf g 64)
+++++_ (a b c d e) 31
+++++_ (leaf f 32)
++++++_ (a b c d) 15
++++++_ (leaf e 16)
+++++++_ (a b c) 7
+++++++_ (leaf d 8)
++++++++_ (a b) 3
++++++++_ (leaf c 4)
+++++++++_ (leaf a 1)
+++++++++_ (leaf b 2)
@endmindmap
#+end_src

#+RESULTS[0d1af02ba31ebcebc41d6c80b6dec913a04734ce]:
[[file:Exercise-2.71-2.png]]

We can clearly see that if the probabilities decrease exponentially, the
length of the tree is n. So to encode the most frequent symbol we would need
just one bit, and the least frequent would require 8 bit.

*** DONE Exercise 2.72 Huffman order of growth
    CLOSED: [2019-10-10 Thu 20:34]

If we consider Exercise 2.71, we'll see that the amount of elements mentioned
at every level of k the tree is n-k.  Therefore, if we want to encode the most
frequent element, we would need to perform O(n-k) operations on every level
of the tree. Since we would need to eventually reach the bottom-most level,
the total number of operations would be \(\sum_1^n (n-k) = O(n^2)\).

The most frequent element is always on
level 1, so to encode it we would need O(1) operations, and we don't even
need to go through the list.

*** Remark Complex packages

The following several exercises can only be considered "functional"
loosely.

In this subsection I will copy the source of the two complex packages given
as examples.

#+begin_src scheme :exports code :results none
     (define (install-rectangular-package)
       ;; internal procedures
       (define (real-part z) (car z))
       (define (imag-part z) (cdr z))
       (define (make-from-real-imag x y) (cons x y))
       (define (magnitude z)
         (sqrt (+ (square (real-part z))
                  (square (imag-part z)))))
       (define (angle z)
         (atan (imag-part z) (real-part z)))
       (define (make-from-mag-ang r a)
         (cons (* r (cos a)) (* r (sin a))))

       ;; interface to the rest of the system
       (define (tag x) (attach-tag 'rectangular x))
       (put 'real-part '(rectangular) real-part)
       (put 'imag-part '(rectangular) imag-part)
       (put 'magnitude '(rectangular) magnitude)
       (put 'angle '(rectangular) angle)
       (put 'make-from-real-imag 'rectangular
            (lambda (x y) (tag (make-from-real-imag x y))))
       (put 'make-from-mag-ang 'rectangular
            (lambda (r a) (tag (make-from-mag-ang r a))))
       'done)

#+end_src


#+begin_src scheme :exports code :results none
     (define (install-polar-package)
       ;; internal procedures
       (define (magnitude z) (car z))
       (define (angle z) (cdr z))
       (define (make-from-mag-ang r a) (cons r a))
       (define (real-part z)
         (* (magnitude z) (cos (angle z))))
       (define (imag-part z)
         (* (magnitude z) (sin (angle z))))
       (define (make-from-real-imag x y)
         (cons (sqrt (+ (square x) (square y)))
               (atan y x)))

       ;; interface to the rest of the system
       (define (tag x) (attach-tag 'polar x))
       (put 'real-part '(polar) real-part)
       (put 'imag-part '(polar) imag-part)
       (put 'magnitude '(polar) magnitude)
       (put 'angle '(polar) angle)
       (put 'make-from-real-imag 'polar
            (lambda (x y) (tag (make-from-real-imag x y))))
       (put 'make-from-mag-ang 'polar
            (lambda (r a) (tag (make-from-mag-ang r a))))
       'done)
#+end_src


*** Remark Reference to the put and get functions
~put~ and ~get~ functions are defined later, however, you can use them if
tangling in the block called: <<put-and-get>>. It is a stateful block, so be
sure to include it first.

*** DONE Exercise 2.73 data-driven-deriv
    CLOSED: [2019-10-11 Fri 11:05]

#+name: data-driven-deriv
#+begin_src scheme :exports code :results none
          (define (deriv exp var)
             (cond ((number? exp) 0)
                   ((variable? exp) (if (same-variable? exp var) 1 0))
                   (else ((get 'deriv (operator exp)) (operands exp)
                                                      var))))
          (define (operator exp) (car exp))
          (define (operands exp) (cdr exp))
#+end_src

**** a
     CLOSED: [2019-10-11 Fri 10:29]
 We replaced the fixed ~product?~ and ~sum?~ predicate functions with the
ones dispatched on the table. Both of these predicates require their tested
variable to be a ~cons~. This is why ~number?~ and ~variable?~ cannot be
replaced with a dispatched version − they are not a pair.

**** b
Surprise-surprise, the prototype of the two ~deriv~ functions we are
supposed to write is incompatible with the derivatives we had to write in the Exercise-2.56.

#+name: data-driven-sum-mul
#+begin_src scheme :exports code :results none
  (define (differentiate-sum operands var)
    (make-sum (deriv (car  operands) var)
	      (deriv (cadr operands) var)))
  (define (differentiate-multiplication operands var)
    (make-sum
     (make-product (car  operands)
		   (deriv (cadr operands) var))
     (make-product (deriv (car  operands) var)
		   (cadr operands))))
  (put 'deriv '+ differentiate-sum)
  (put 'deriv '* differentiate-multiplication)
#+end_src

#+begin_src scheme :exports both :results output scalar code
<<put-and-get>>
<<deriv-components>>
<<deriv-operations>>
<<data-driven-deriv>>
<<data-driven-sum-mul>>
(show #t "Test:" (deriv '(+ a (* b a)) 'a) "\n")
#+end_src

#+RESULTS[d0ebb2eecdef37ee4aba4564d9211d8b5db089f1]:
#+begin_src scheme
Test:(+ 1 b)
#+end_src

**** c
     CLOSED: [2019-10-11 Fri 11:03]

#+name: data-driven-exponentiation
#+begin_src scheme :exports code :results none
(define (make-exponentiation base power)
    (cond ((=number? power 0) 1)
	  ((=number? power 1) base)
	  ((and (number? base) (number? power))
	   (expt base power))
	  (else (list '** base power))))

(define (differentiate-exponentiation exp var)
	   (make-product (cadr exp)
			 (make-product
			  (make-exponentiation
			   (car exp)
			   (make-sum (cadr exp) -1))
			  (deriv (car exp) var))))

(put 'deriv '** differentiate-exponentiation)
#+end_src


#+begin_src scheme :exports both :results output scalar code
(define false #f)
<<put-and-get>>
<<deriv-components>>
<<deriv-operations>>
<<data-driven-deriv>>
<<data-driven-sum-mul>>
<<data-driven-exponentiation>>
(show #t "Test:" (deriv '(+ a (* b (** a c))) 'a) "\n")

#;(show #t "Test:" (deriv '(** a b) 'a) "\n")
#+end_src

#+RESULTS[cd95541f6c370504e4b37bd2a38569a2a37e751f]:
#+begin_src scheme
Test:(+ 1 (* b (* c (** a (+ c -1)))))
#+end_src

**** d
     CLOSED: [2019-10-11 Fri 11:05]

The only change needed is to change the order of parameters in ~put~ just as
it is changed in ~get~. The rest should be absolutely the same.

*** DONE Exercise 2.74 Insatiable Enterprises
    CLOSED: [2019-10-11 Fri 20:56]

This task is a bit weird and too vaguely formulated. For the start, let's
assume that the company only has two divisions.

#+name: insatiable-enterprises-data
#+begin_src scheme :exports code :results none
  (define division-1-set-of-records
     (cons 'division-1 (list (list 'Jack (cons 'salary 100) (cons 'address #f)) (list 'Jill (cons 'salary 200) '(address #t)))))
  (define (division-1-get-record record-set key)
    (define (crawler records key)
      (cond ((null? records) '())
	    ((eq? key (caar records)) (car records))
	    (else (crawler (cdr records) key))))
    (crawler (cdr record-set) key))

  (define (division-1-get-salary record)
     (cdr (list-ref record 1)))

  (define division-2-set-of-records
    (cons 'division-2 (list (list 'placeholder 'WangYi 'salary 100 'address 'neverland)
 (list 'placeholder 'ZhangEr 'salary 200 'address 'this-world))))

  (define (division-2-get-record record-set key)
    (define (crawler records key)
      (cond ((null? records) '())
	    ((eq? key (list-ref (car records) 1)) (car records))
	    (else (crawler (cdr records) key))))
    (crawler (cdr record-set) key))
  (define (division-2-get-salary record)
     (list-ref record 3))

(put 'get-record 'division-1 division-1-get-record)
(put 'get-record 'division-2 division-2-get-record)
(put 'get-salary 'division-1 division-1-get-salary)
(put 'get-salary 'division-2 division-2-get-salary)



#+end_src


#+begin_src scheme :exports both :results output scalar code
<<put-and-get>>
<<insatiable-enterprises-data>>

(show #t "Division-1: " (division-1-get-record division-1-set-of-records 'Jack) "\n")
(show #t "Division-2: " (division-2-get-record division-2-set-of-records 'WangYi) "\n")
(show #t "Division-2: " (division-2-get-record division-2-set-of-records 'ZhangEr) "\n")
(show #t "Salary-1:   " (division-1-get-salary (division-1-get-record division-1-set-of-records 'Jill)) "\n")
(show #t "Salary-2:   " (division-2-get-salary (division-2-get-record division-2-set-of-records 'WangYi)) "\n")
(show #t "Division-1: " ((get 'get-record 'division-1) division-1-set-of-records 'Jack) "\n")
(show #t "Division-2: " ((get 'get-record 'division-2) division-2-set-of-records 'WangYi) "\n")
(show #t "Division-1: " ((get 'get-salary 'division-1) (division-1-get-record division-1-set-of-records 'Jill)) "\n")
(show #t "Division-2: " ((get 'get-salary 'division-2) (division-2-get-record division-2-set-of-records 'WangYi)) "\n")

#+end_src

#+RESULTS[f074813acd0f661729d42da7a193da04d52995c9]:
#+begin_src scheme
Division-1: (Jack (salary . 100) (address . #f))
Division-2: (placeholder WangYi salary 100 address neverland)
Division-2: (placeholder ZhangEr salary 200 address this-world)
Salary-1:   200
Salary-2:   100
Division-1: (Jack (salary . 100) (address . #f))
Division-2: (placeholder WangYi salary 100 address neverland)
Division-1: 200
Division-2: 100
#+end_src

**** a
     CLOSED: [2019-10-11 Fri 18:39]

The key thing in our implementation of the two datasets is that we have a
department tag at the beginning. This lets us dispatch on the origin of the
data.

#+name: insatiable-a
#+begin_src scheme :exports code :results none
(define (get-record dataset key)
   ((get 'get-record (car dataset)) dataset key))
#+end_src

#+begin_src scheme :exports both :results output scalar code
<<put-and-get>>
<<insatiable-enterprises-data>>
<<insatiable-a>>

(show #t (get-record division-1-set-of-records 'Jill) "\n")
(show #t (get-record division-2-set-of-records 'ZhangEr) "\n")
#+end_src

#+RESULTS[a0d592196770691163980786e59ee8a81146c861]:
#+begin_src scheme
(Jill (salary . 200) (address #t))
(placeholder ZhangEr salary 200 address this-world)
#+end_src

**** b
     CLOSED: [2019-10-11 Fri 20:22]

#+name: insatiable-b
#+begin_src scheme :exports code :results none
  (define (get-salary records key)
    (let ((record (get-record records key)))
      (if record
	  ((get 'get-salary (car records)) record)
	  #f)))
#+end_src


#+begin_src scheme :exports both :results output scalar code
<<put-and-get>>
<<insatiable-enterprises-data>>
<<insatiable-a>>
<<insatiable-b>>
(guard (err 
          (else (begin (display "Expected exception") (newline))))
(show #t "Salary wrong  : " (get-salary division-2-set-of-records 'Jill) "\n"))
(show #t "Salary correct: " (get-salary division-1-set-of-records 'Jill) "\n")
#+end_src

#+RESULTS[120cdc198fccad32ef4bc50ebd8514b2d418e5f4]:
#+begin_src scheme
Expected exception
Salary correct: 200
#+end_src

Because all the dispatch is organized on a tag in the file records, there is
no specific requirements to the record structure.

**** c
     CLOSED: [2019-10-11 Fri 20:54]

#+name: insatiable-find-employee-record
#+begin_src scheme :exports code :results none
    <<accumulate>>
      (define (find-employee-record key . record-files)
	(car (accumulate
	      append
	      '()
	      (map (lambda (x)
		     (list (get-record x key))) record-files))))
#+end_src

#+begin_src scheme :exports both :results output scalar code
<<put-and-get>>
<<insatiable-enterprises-data>>
<<insatiable-a>>
<<insatiable-b>>
<<insatiable-find-employee-record>>
(show #t "Result: " (find-employee-record 'Jill division-1-set-of-records division-2-set-of-records) "\n")
#+end_src

#+RESULTS[ea334781cc9d86acea23af0bc32d3ba31eb94db8]:
#+begin_src scheme
Result: (Jill (salary . 200) (address #t))
#+end_src

**** d
     CLOSED: [2019-10-11 Fri 20:56]
The new company would need to prepend their files with ~('companyname)~, and
their functions ~get-record~ and ~get-salary~ need to be registered with the
new the function table.

*** DONE Exercise 2.75 make-from-mag-ang message passing
    CLOSED: [2019-10-11 Fri 21:24]

#+name: message-mag-angle
#+begin_src scheme :exports code :results none
     (define (make-from-mag-angle mag angle)
       (define (dispatch op)
         (cond ((eq? op 'real-part) (* mag (cos angle)))
               ((eq? op 'imag-part) (* mag (sin angle)))
               ((eq? op 'magnitude) mag)
               ((eq? op 'angle) angle)
               (else
                (error "Unknown op -- MAKE-FROM-REAL-IMAG" op))))
       dispatch)
#+end_src

#+begin_src scheme :exports both :results output scalar code
<<message-mag-angle>>
(show #t "Magnitude: " ((make-from-mag-angle 1 1) 'magnitude) "\n")
(show #t "Angle    : " ((make-from-mag-angle 1 1) 'angle    ) "\n")
(show #t "Real-part: " ((make-from-mag-angle 1 1) 'real-part) "\n")
(show #t "Imag-part: " ((make-from-mag-angle 1 1) 'imag-part) "\n")
#+end_src

#+RESULTS[65d3682b63c4e1ca9d57aabb53130baa4ce56000]:
#+begin_src scheme
Magnitude: 1
Angle    : 1
Real-part: 0.5403023058681398
Imag-part: 0.8414709848078965
#+end_src

*** DONE Exercise 2.76 types or functions?
    CLOSED: [2019-10-11 Fri 21:29]

Dispatching on the types seems more appropriate for the case when there are
more operations that types. This way there is no need to adjust types when
new operations are created. Just add new operations to the table.

The message-passing style seems more appropriate for the situations when
new operations are relatively rare, but new types appear often. Existing
operations would work with the new types, if the types satisfy some contract.

*** Remark Three arithmetic packages

#+name: generic-arithmetic-packages
#+begin_src scheme :exports code :results none
     (define (add x y) (apply-generic 'add x y))
     (define (sub x y) (apply-generic 'sub x y))
     (define (mul x y) (apply-generic 'mul x y))
     (define (div x y) (apply-generic 'div x y))

     (define (install-scheme-number-package)
       (define (tag x)
         (attach-tag 'scheme-number x))
       (put 'add '(scheme-number scheme-number)
            (lambda (x y) (tag (+ x y))))
       (put 'sub '(scheme-number scheme-number)
            (lambda (x y) (tag (- x y))))
       (put 'mul '(scheme-number scheme-number)
            (lambda (x y) (tag (* x y))))
       (put 'div '(scheme-number scheme-number)
            (lambda (x y) (tag (/ x y))))
       (put 'make 'scheme-number
            (lambda (x) (tag x)))
       'done)

     (define (make-scheme-number n)
       ((get 'make 'scheme-number) n))

     (define (install-rational-package)
       (define (numer x) (car x))
       (define (denom x) (cdr x))
       (define (make-rat n d)
         (let ((g (gcd n d)))
           (cons (/ n g) (/ d g))))
       (define (add-rat x y)
         (make-rat (+ (* (numer x) (denom y))
                      (* (numer y) (denom x)))
                   (* (denom x) (denom y))))
       (define (sub-rat x y)
         (make-rat (- (* (numer x) (denom y))
                      (* (numer y) (denom x)))
                   (* (denom x) (denom y))))
       (define (mul-rat x y)
         (make-rat (* (numer x) (numer y))
                   (* (denom x) (denom y))))
       (define (div-rat x y)
         (make-rat (* (numer x) (denom y))
                   (* (denom x) (numer y))))

       (define (tag x) (attach-tag 'rational x))
       (put 'add '(rational rational)
            (lambda (x y) (tag (add-rat x y))))
       (put 'sub '(rational rational)
            (lambda (x y) (tag (sub-rat x y))))
       (put 'mul '(rational rational)
            (lambda (x y) (tag (mul-rat x y))))
       (put 'div '(rational rational)
            (lambda (x y) (tag (div-rat x y))))

       (put 'make 'rational
            (lambda (n d) (tag (make-rat n d))))
       'done)

     (define (make-rational n d)
       ((get 'make 'rational) n d))

     (define (install-rectangular-package)

       (define (real-part z) (car z))
       (define (imag-part z) (cdr z))
       (define (make-from-real-imag x y) (cons x y))
       (define (magnitude z)
         (sqrt (+ (square (real-part z))
                  (square (imag-part z)))))
       (define (angle z)
         (atan (imag-part z) (real-part z)))
       (define (make-from-mag-ang r a)
         (cons (* r (cos a)) (* r (sin a))))

       (define (tag x) (attach-tag 'rectangular x))
       (put 'real-part '(rectangular) real-part)
       (put 'imag-part '(rectangular) imag-part)
       (put 'magnitude '(rectangular) magnitude)
       (put 'angle '(rectangular) angle)
       (put 'make-from-real-imag 'rectangular
            (lambda (x y) (tag (make-from-real-imag x y))))
       (put 'make-from-mag-ang 'rectangular
            (lambda (r a) (tag (make-from-mag-ang r a))))
       'done)

     (define (install-polar-package)

       (define (magnitude z) (car z))
       (define (angle z) (cdr z))
       (define (make-from-mag-ang r a) (cons r a))
       (define (real-part z)
         (* (magnitude z) (cos (angle z))))
       (define (imag-part z)
         (* (magnitude z) (sin (angle z))))
       (define (make-from-real-imag x y)
         (cons (sqrt (+ (square x) (square y)))
               (atan y x)))

       (define (tag x) (attach-tag 'polar x))
       (put 'real-part '(polar) real-part)
       (put 'imag-part '(polar) imag-part)
       (put 'magnitude '(polar) magnitude)
       (put 'angle '(polar) angle)
       (put 'make-from-real-imag 'polar
            (lambda (x y) (tag (make-from-real-imag x y))))
       (put 'make-from-mag-ang 'polar
            (lambda (r a) (tag (make-from-mag-ang r a))))
       'done)

     (define (install-complex-package)
       (define (make-from-real-imag x y)
         ((get 'make-from-real-imag 'rectangular) x y))
       (define (make-from-mag-ang r a)
         ((get 'make-from-mag-ang 'polar) r a))
       (define (add-complex z1 z2)
         (make-from-real-imag (+ (real-part z1) (real-part z2))
                              (+ (imag-part z1) (imag-part z2))))
       (define (sub-complex z1 z2)
         (make-from-real-imag (- (real-part z1) (real-part z2))
                              (- (imag-part z1) (imag-part z2))))
       (define (mul-complex z1 z2)
         (make-from-mag-ang (* (magnitude z1) (magnitude z2))
                            (+ (angle z1) (angle z2))))
       (define (div-complex z1 z2)
         (make-from-mag-ang (/ (magnitude z1) (magnitude z2))
                            (- (angle z1) (angle z2))))
       (define (tag z) (attach-tag 'complex z))
       (put 'add '(complex complex)
            (lambda (z1 z2) (tag (add-complex z1 z2))))
       (put 'sub '(complex complex)
            (lambda (z1 z2) (tag (sub-complex z1 z2))))
       (put 'mul '(complex complex)
            (lambda (z1 z2) (tag (mul-complex z1 z2))))
       (put 'div '(complex complex)
            (lambda (z1 z2) (tag (div-complex z1 z2))))
       (put 'make-from-real-imag 'complex
            (lambda (x y) (tag (make-from-real-imag x y))))
       (put 'make-from-mag-ang 'complex
            (lambda (r a) (tag (make-from-mag-ang r a))))
       'done)

     (define (make-complex-from-real-imag x y)
       ((get 'make-from-real-imag 'complex) x y))

     (define (make-complex-from-mag-ang r a)
       ((get 'make-from-mag-ang 'complex) r a))


#+end_src


#+name: apply-generic
#+begin_src scheme :exports code :results none
     (define (attach-tag type-tag contents)
       (cons type-tag contents))

     (define (type-tag datum)
       (if (pair? datum)
           (car datum)
           (error "Bad tagged datum -- TYPE-TAG" datum)))

     (define (contents datum)
       (if (pair? datum)
           (cdr datum)
           (error "Bad tagged datum -- CONTENTS" datum)))

     (define (rectangular? z)
       (eq? (type-tag z) 'rectangular))

     (define (polar? z)
       (eq? (type-tag z) 'polar))

     (define (apply-generic op . args)
       (let ((type-tags (map type-tag args)))
         (let ((proc (get op type-tags)))
           (if proc
               (apply proc (map contents args))
               (error
                 "No method for these types -- APPLY-GENERIC"
                 (list op type-tags))))))

     (define (real-part z) (apply-generic 'real-part z))
     (define (imag-part z) (apply-generic 'imag-part z))
     (define (magnitude z) (apply-generic 'magnitude z))
     (define (angle z) (apply-generic 'angle z))

#+end_src

*** DONE Exercise 2.77 generic-algebra-magnitude
    CLOSED: [2019-10-12 Sat 16:01]
Yeah, great, Dr. Abelson. You're casually referring to the ~apply-generic~,
not really specifying which one to use. Also, I never had to use the
~type-tag~ and ~contents~, which suddenly appear here.

#+name: alyssa-complex-suggestion
#+begin_src scheme :exports code :results none
          (put 'real-part '(complex) real-part)
          (put 'imag-part '(complex) imag-part)
          (put 'magnitude '(complex) magnitude)
          (put 'angle '(complex) angle)
#+end_src

#+begin_src scheme :exports both :results output scalar code
(define false #f)
(define true  #t)
<<put-and-get>>
<<apply-generic>>
<<generic-arithmetic-packages>>
(install-rectangular-package)
(install-complex-package)
<<alyssa-complex-suggestion>>
(show #t "Louis's result: " (magnitude (make-complex-from-real-imag 3 4)) "\n")

#+end_src

#+RESULTS[d12a7f5cedd4e3a4014a32766cd3e98923cfef03]:
#+begin_src scheme
Louis's result: 5
#+end_src

This example illustrates what can, perhaps, be called "double
dispatch". Indeed,  our "complex" implementation still keeps the 'rectangular
and 'polar tags, so the only thing that the complex ~magnitude~ should do is
to call (through the dispatch table) the old function ~magnitude~, which
will, by itself, dispatch on the old tags. ~apply-generic~ is called twice,
first for a 'complex tag, an later for the 'polar tag.

Remark: this "easy" exercise took more than 4 hours to debug and consists of
227 lines of code.

*** DONE Exercise 2.78 Ordinary numbers for scheme
    CLOSED: [2019-10-12 Sat 21:06]

#+name: simplified-scheme-number
#+begin_src scheme :exports code :results none
     (define (add x y) (apply-generic 'add x y))
     (define (sub x y) (apply-generic 'sub x y))
     (define (mul x y) (apply-generic 'mul x y))
     (define (div x y) (apply-generic 'div x y))
     (define (attach-tag type-tag contents)
       (if (eq? type-tag 'scheme-number)
           contents
           (cons type-tag contents)))

     (define (type-tag datum)
       (cond ((pair? datum) (car datum))
             ((number? datum) 'scheme-number)
             (else (error "Bad tagged datum -- TYPE-TAG" datum))))

     (define (contents datum)
       (cond ((pair? datum) (cdr datum))
             ((number? datum) datum)
             (else (error "Bad tagged datum -- CONTENTS" datum))))

     (define (apply-generic op . args)
       (let ((type-tags (map type-tag args)))
         (let ((proc (get op type-tags)))
           (if proc
               (apply proc (map contents args))
               (error
                 "No method for these types -- APPLY-GENERIC"
                 (list op type-tags))))))

     (define (install-scheme-number-package)
       (define (tag x)
         (attach-tag 'scheme-number x))
       (put 'add '(scheme-number scheme-number)
            (lambda (x y) (tag (+ x y))))
       (put 'sub '(scheme-number scheme-number)
            (lambda (x y) (tag (- x y))))
       (put 'mul '(scheme-number scheme-number)
            (lambda (x y) (tag (* x y))))
       (put 'div '(scheme-number scheme-number)
            (lambda (x y) (tag (/ x y))))
       (put 'make 'scheme-number
            (lambda (x) (tag x)))
       'done)

     (define (make-scheme-number n)
       ((get 'make 'scheme-number) n))
#+end_src

#+begin_src scheme :exports both :results output scalar code
<<put-and-get>>
<<simplified-scheme-number>>
(install-scheme-number-package)
(show #t "Adding: (+ 1 2) : " (add (make-scheme-number 1) (make-scheme-number 2)) "\n")
#+end_src

#+RESULTS[ad26c29e1ee12969e992ff4055dae2e4f2e68f9e]:
#+begin_src scheme
Adding: (+ 1 2) : 3
#+end_src

The task is to "Modify the definitions of `type-tag', `contents', and
`attach-tag'", therefore (as this doesn't seem really useful), I am only
copying those functions for modification in this particular exercise.

*** DONE Exercise 2.79 generic-equality
    CLOSED: [2019-10-14 Mon 15:58]

In this exercise I am copying the whole package again, as due to the poor
architecture of the algebra system, adding such a tiny feature is not additive.

#+begin_src scheme :exports both :results output scalar code

  (define false #f)
  (define true  #t)
  (define (make-table)
    (let ((local-table (list '*table*)))
      (define (lookup key-1 key-2)
	(let ((subtable (assoc key-1 (cdr local-table))))
	  (if subtable
	      (let ((record (assoc key-2 (cdr subtable))))
		(if record
		    (cdr record)
		    false))
	      false)))
      (define (insert! key-1 key-2 value)
	(let ((subtable (assoc key-1 (cdr local-table))))
	  (if subtable
	      (let ((record (assoc key-2 (cdr subtable))))
		(if record
		    (set-cdr! record value)
		    (set-cdr! subtable
			      (cons (cons key-2 value)
				    (cdr subtable)))))
	      (set-cdr! local-table
			(cons (list key-1
				    (cons key-2 value))
			      (cdr local-table)))))
	'ok)
      (define (dispatch m)
	(cond ((eq? m 'lookup-proc) lookup)
	      ((eq? m 'insert-proc!) insert!)
	      (else (error "Unknown operation -- TABLE" m))))
      dispatch))

  (define operation-table (make-table))
  (define get (operation-table 'lookup-proc))
  (define put (operation-table 'insert-proc!))
  (define (attach-tag type-tag contents)
    (cons type-tag contents))

  (define (type-tag datum)
    (if (pair? datum)
	(car datum)
	(error "Bad tagged datum -- TYPE-TAG" datum)))

  (define (contents datum)
    (if (pair? datum)
	(cdr datum)
	(error "Bad tagged datum -- CONTENTS" datum)))

  (define (rectangular? z)
    (eq? (type-tag z) 'rectangular))

  (define (polar? z)
    (eq? (type-tag z) 'polar))

  (define (apply-generic op . args)
    (let ((type-tags (map type-tag args)))
      (let ((proc (get op type-tags)))
	(if proc
	    (apply proc (map contents args))
	    (error
	      "No method for these types -- APPLY-GENERIC"
	      (list op type-tags))))))

  (define (real-part z) (apply-generic 'real-part z))
  (define (imag-part z) (apply-generic 'imag-part z))
  (define (magnitude z) (apply-generic 'magnitude z))
  (define (angle z) (apply-generic 'angle z))

  (define (add x y) (apply-generic 'add x y))
  (define (sub x y) (apply-generic 'sub x y))
  (define (mul x y) (apply-generic 'mul x y))
  (define (div x y) (apply-generic 'div x y))

  (define (equ? x y) (apply-generic 'equ? x y))

  (define (install-scheme-number-package)
    (define (tag x)
      (attach-tag 'scheme-number x))
    (put 'add '(scheme-number scheme-number)
	 (lambda (x y) (tag (+ x y))))
    (put 'sub '(scheme-number scheme-number)
	 (lambda (x y) (tag (- x y))))
    (put 'mul '(scheme-number scheme-number)
	 (lambda (x y) (tag (* x y))))
    (put 'div '(scheme-number scheme-number)
	 (lambda (x y) (tag (/ x y))))
    (put 'make 'scheme-number
	 (lambda (x) (tag x)))
    (put 'equ? '(scheme-number scheme-number)
         (lambda (x y) (= x y)))
    'done)

  (define (make-scheme-number n)
    ((get 'make 'scheme-number) n))

  (define (install-rational-package)
    (define (numer x) (car x))
    (define (denom x) (cdr x))
    (define (make-rat n d)
      (let ((g (gcd n d)))
	(cons (/ n g) (/ d g))))
    (define (add-rat x y)
      (make-rat (+ (* (numer x) (denom y))
		   (* (numer y) (denom x)))
		(* (denom x) (denom y))))
    (define (sub-rat x y)
      (make-rat (- (* (numer x) (denom y))
		   (* (numer y) (denom x)))
		(* (denom x) (denom y))))
    (define (mul-rat x y)
      (make-rat (* (numer x) (numer y))
		(* (denom x) (denom y))))
    (define (div-rat x y)
      (make-rat (* (numer x) (denom y))
		(* (denom x) (numer y))))

    (define (tag x) (attach-tag 'rational x))
    (put 'add '(rational rational)
	 (lambda (x y) (tag (add-rat x y))))
    (put 'sub '(rational rational)
	 (lambda (x y) (tag (sub-rat x y))))
    (put 'mul '(rational rational)
	 (lambda (x y) (tag (mul-rat x y))))
    (put 'div '(rational rational)
	 (lambda (x y) (tag (div-rat x y))))

    (put 'make 'rational
	 (lambda (n d) (tag (make-rat n d))))
    (put 'equ? '(rational rational)
         (lambda (x y) (= 0 (numer (sub-rat x y)))))
    'done)

  (define (make-rational n d)
    ((get 'make 'rational) n d))

  (define (install-rectangular-package)

    (define (real-part z) (car z))
    (define (imag-part z) (cdr z))
    (define (make-from-real-imag x y) (cons x y))
    (define (magnitude z)
      (sqrt (+ (square (real-part z))
	       (square (imag-part z)))))
    (define (angle z)
      (atan (imag-part z) (real-part z)))
    (define (make-from-mag-ang r a)
      (cons (* r (cos a)) (* r (sin a))))

    (define (tag x) (attach-tag 'rectangular x))
    (put 'real-part '(rectangular) real-part)
    (put 'imag-part '(rectangular) imag-part)
    (put 'magnitude '(rectangular) magnitude)
    (put 'angle '(rectangular) angle)
    (put 'make-from-real-imag 'rectangular
	 (lambda (x y) (tag (make-from-real-imag x y))))
    (put 'make-from-mag-ang 'rectangular
	 (lambda (r a) (tag (make-from-mag-ang r a))))
    'done)

  (define (install-polar-package)

    (define (magnitude z) (car z))
    (define (angle z) (cdr z))
    (define (make-from-mag-ang r a) (cons r a))
    (define (real-part z)
      (* (magnitude z) (cos (angle z))))
    (define (imag-part z)
      (* (magnitude z) (sin (angle z))))
    (define (make-from-real-imag x y)
      (cons (sqrt (+ (square x) (square y)))
	    (atan y x)))

    (define (tag x) (attach-tag 'polar x))
    (put 'real-part '(polar) real-part)
    (put 'imag-part '(polar) imag-part)
    (put 'magnitude '(polar) magnitude)
    (put 'angle '(polar) angle)
    (put 'make-from-real-imag 'polar
	 (lambda (x y) (tag (make-from-real-imag x y))))
    (put 'make-from-mag-ang 'polar
	 (lambda (r a) (tag (make-from-mag-ang r a))))
    'done)

  (define (install-complex-package)
    (define (make-from-real-imag x y)
      ((get 'make-from-real-imag 'rectangular) x y))
    (define (make-from-mag-ang r a)
      ((get 'make-from-mag-ang 'polar) r a))
    (define (add-complex z1 z2)
      (make-from-real-imag (+ (real-part z1) (real-part z2))
			   (+ (imag-part z1) (imag-part z2))))
    (define (sub-complex z1 z2)
      (make-from-real-imag (- (real-part z1) (real-part z2))
			   (- (imag-part z1) (imag-part z2))))
    (define (mul-complex z1 z2)
      (make-from-mag-ang (* (magnitude z1) (magnitude z2))
			 (+ (angle z1) (angle z2))))
    (define (div-complex z1 z2)
      (make-from-mag-ang (/ (magnitude z1) (magnitude z2))
			 (- (angle z1) (angle z2))))
    (define (tag z) (attach-tag 'complex z))
    (put 'add '(complex complex)
	 (lambda (z1 z2) (tag (add-complex z1 z2))))
    (put 'sub '(complex complex)
	 (lambda (z1 z2) (tag (sub-complex z1 z2))))
    (put 'mul '(complex complex)
	 (lambda (z1 z2) (tag (mul-complex z1 z2))))
    (put 'div '(complex complex)
	 (lambda (z1 z2) (tag (div-complex z1 z2))))
    (put 'make-from-real-imag 'complex
	 (lambda (x y) (tag (make-from-real-imag x y))))
    (put 'make-from-mag-ang 'complex
	 (lambda (r a) (tag (make-from-mag-ang r a))))
    (put 'equ? '(complex complex)
         (lambda (x y) (and (= 0 (real-part (sub-complex x y)))
                      (= 0 (imag-part (sub-complex x y))))))
    'done)

  (define (make-complex-from-real-imag x y)
    ((get 'make-from-real-imag 'complex) x y))

  (define (make-complex-from-mag-ang r a)
    ((get 'make-from-mag-ang 'complex) r a))



  (install-rectangular-package)
  (install-polar-package)
  (install-rational-package)
  (install-scheme-number-package)
  (install-complex-package)

  (show #t "Scheme-number: " (equ? (make-scheme-number 1) (make-scheme-number 2)) "\n")
  (show #t "Rational: " (equ? (make-rational 1 2) (make-rational 2 4)) "\n")
  (show #t "Complex: " (equ? (make-complex-from-mag-ang 1 0)
                             (make-complex-from-real-imag 1 0)) "\n")
#+end_src

#+RESULTS[da543803cedad76c1b3c74ecec5f979fc8a167aa]:
#+begin_src scheme
Scheme-number: #f
Rational: #t
Complex: #t
#+end_src

*** DONE Exercise 2.80 Generic arithmetic zero?
    CLOSED: [2019-10-14 Mon 17:18]

#+begin_src scheme :exports both :results output scalar code

  (define false #f)
  (define true  #t)
  (define (make-table)
    (let ((local-table (list '*table*)))
      (define (lookup key-1 key-2)
	(let ((subtable (assoc key-1 (cdr local-table))))
	  (if subtable
	      (let ((record (assoc key-2 (cdr subtable))))
		(if record
		    (cdr record)
		    false))
	      false)))
      (define (insert! key-1 key-2 value)
	(let ((subtable (assoc key-1 (cdr local-table))))
	  (if subtable
	      (let ((record (assoc key-2 (cdr subtable))))
		(if record
		    (set-cdr! record value)
		    (set-cdr! subtable
			      (cons (cons key-2 value)
				    (cdr subtable)))))
	      (set-cdr! local-table
			(cons (list key-1
				    (cons key-2 value))
			      (cdr local-table)))))
	'ok)
      (define (dispatch m)
	(cond ((eq? m 'lookup-proc) lookup)
	      ((eq? m 'insert-proc!) insert!)
	      (else (error "Unknown operation -- TABLE" m))))
      dispatch))

  (define operation-table (make-table))
  (define get (operation-table 'lookup-proc))
  (define put (operation-table 'insert-proc!))
  (define (attach-tag type-tag contents)
    (cons type-tag contents))

  (define (type-tag datum)
    (if (pair? datum)
	(car datum)
	(error "Bad tagged datum -- TYPE-TAG" datum)))

  (define (contents datum)
    (if (pair? datum)
	(cdr datum)
	(error "Bad tagged datum -- CONTENTS" datum)))

  (define (rectangular? z)
    (eq? (type-tag z) 'rectangular))

  (define (polar? z)
    (eq? (type-tag z) 'polar))

  (define (apply-generic op . args)
    (let ((type-tags (map type-tag args)))
      (let ((proc (get op type-tags)))
	(if proc
	    (apply proc (map contents args))
	    (error
	      "No method for these types -- APPLY-GENERIC"
	      (list op type-tags))))))

  (define (real-part z) (apply-generic 'real-part z))
  (define (imag-part z) (apply-generic 'imag-part z))
  (define (magnitude z) (apply-generic 'magnitude z))
  (define (angle z) (apply-generic 'angle z))

  (define (add x y) (apply-generic 'add x y))
  (define (sub x y) (apply-generic 'sub x y))
  (define (mul x y) (apply-generic 'mul x y))
  (define (div x y) (apply-generic 'div x y))

  (define (equ? x y) (apply-generic 'equ? x y))
  (define (zero? x) (apply-generic 'zero? x))

  (define (install-scheme-number-package)
    (define (tag x)
      (attach-tag 'scheme-number x))
    (put 'add '(scheme-number scheme-number)
	 (lambda (x y) (tag (+ x y))))
    (put 'sub '(scheme-number scheme-number)
	 (lambda (x y) (tag (- x y))))
    (put 'mul '(scheme-number scheme-number)
	 (lambda (x y) (tag (* x y))))
    (put 'div '(scheme-number scheme-number)
	 (lambda (x y) (tag (/ x y))))
    (put 'make 'scheme-number
	 (lambda (x) (tag x)))
    (put 'equ? '(scheme-number scheme-number)
	 (lambda (x y) (= x y)))
    (put 'zero? '(scheme-number)
	  (lambda (x) (= 0 x)))
    'done)

  (define (make-scheme-number n)
    ((get 'make 'scheme-number) n))

  (define (install-rational-package)
    (define (numer x) (car x))
    (define (denom x) (cdr x))
    (define (make-rat n d)
      (let ((g (gcd n d)))
	(cons (/ n g) (/ d g))))
    (define (add-rat x y)
      (make-rat (+ (* (numer x) (denom y))
		   (* (numer y) (denom x)))
		(* (denom x) (denom y))))
    (define (sub-rat x y)
      (make-rat (- (* (numer x) (denom y))
		   (* (numer y) (denom x)))
		(* (denom x) (denom y))))
    (define (mul-rat x y)
      (make-rat (* (numer x) (numer y))
		(* (denom x) (denom y))))
    (define (div-rat x y)
      (make-rat (* (numer x) (denom y))
		(* (denom x) (numer y))))

    (define (tag x) (attach-tag 'rational x))
    (put 'add '(rational rational)
	 (lambda (x y) (tag (add-rat x y))))
    (put 'sub '(rational rational)
	 (lambda (x y) (tag (sub-rat x y))))
    (put 'mul '(rational rational)
	 (lambda (x y) (tag (mul-rat x y))))
    (put 'div '(rational rational)
	 (lambda (x y) (tag (div-rat x y))))

    (put 'make 'rational
	 (lambda (n d) (tag (make-rat n d))))
    (put 'equ? '(rational rational)
	 (lambda (x y) (= 0 (numer (sub-rat x y)))))
    (put 'zero? '(rational) (lambda (x) (= 0 (numer x))))
    'done)

  (define (make-rational n d)
    ((get 'make 'rational) n d))

  (define (install-rectangular-package)

    (define (real-part z) (car z))
    (define (imag-part z) (cdr z))
    (define (make-from-real-imag x y) (cons x y))
    (define (magnitude z)
      (sqrt (+ (square (real-part z))
	       (square (imag-part z)))))
    (define (angle z)
      (atan (imag-part z) (real-part z)))
    (define (make-from-mag-ang r a)
      (cons (* r (cos a)) (* r (sin a))))

    (define (tag x) (attach-tag 'rectangular x))
    (put 'real-part '(rectangular) real-part)
    (put 'imag-part '(rectangular) imag-part)
    (put 'magnitude '(rectangular) magnitude)
    (put 'angle '(rectangular) angle)
    (put 'make-from-real-imag 'rectangular
	 (lambda (x y) (tag (make-from-real-imag x y))))
    (put 'make-from-mag-ang 'rectangular
	 (lambda (r a) (tag (make-from-mag-ang r a))))
    'done)

  (define (install-polar-package)

    (define (magnitude z) (car z))
    (define (angle z) (cdr z))
    (define (make-from-mag-ang r a) (cons r a))
    (define (real-part z)
      (* (magnitude z) (cos (angle z))))
    (define (imag-part z)
      (* (magnitude z) (sin (angle z))))
    (define (make-from-real-imag x y)
      (cons (sqrt (+ (square x) (square y)))
	    (atan y x)))

    (define (tag x) (attach-tag 'polar x))
    (put 'real-part '(polar) real-part)
    (put 'imag-part '(polar) imag-part)
    (put 'magnitude '(polar) magnitude)
    (put 'angle '(polar) angle)
    (put 'make-from-real-imag 'polar
	 (lambda (x y) (tag (make-from-real-imag x y))))
    (put 'make-from-mag-ang 'polar
	 (lambda (r a) (tag (make-from-mag-ang r a))))
    'done)

  (define (install-complex-package)
    (define (make-from-real-imag x y)
      ((get 'make-from-real-imag 'rectangular) x y))
    (define (make-from-mag-ang r a)
      ((get 'make-from-mag-ang 'polar) r a))
    (define (add-complex z1 z2)
      (make-from-real-imag (+ (real-part z1) (real-part z2))
			   (+ (imag-part z1) (imag-part z2))))
    (define (sub-complex z1 z2)
      (make-from-real-imag (- (real-part z1) (real-part z2))
			   (- (imag-part z1) (imag-part z2))))
    (define (mul-complex z1 z2)
      (make-from-mag-ang (* (magnitude z1) (magnitude z2))
			 (+ (angle z1) (angle z2))))
    (define (div-complex z1 z2)
      (make-from-mag-ang (/ (magnitude z1) (magnitude z2))
			 (- (angle z1) (angle z2))))
    (define (tag z) (attach-tag 'complex z))
    (put 'add '(complex complex)
	 (lambda (z1 z2) (tag (add-complex z1 z2))))
    (put 'sub '(complex complex)
	 (lambda (z1 z2) (tag (sub-complex z1 z2))))
    (put 'mul '(complex complex)
	 (lambda (z1 z2) (tag (mul-complex z1 z2))))
    (put 'div '(complex complex)
	 (lambda (z1 z2) (tag (div-complex z1 z2))))
    (put 'make-from-real-imag 'complex
	 (lambda (x y) (tag (make-from-real-imag x y))))
    (put 'make-from-mag-ang 'complex
	 (lambda (r a) (tag (make-from-mag-ang r a))))
    (put 'equ? '(complex complex)
	 (lambda (x y) (and (= 0 (real-part (sub-complex x y)))
		      (= 0 (imag-part (sub-complex x y))))))
    (put 'equ? '(rectangular polar) equ?)
    (put 'equ? '(polar rectangular) equ?)
    (put 'zero? '(complex)
	 (lambda (x) (equ? (tag x) (tag (make-from-real-imag 0 0)))))
    'done)

  (define (make-complex-from-real-imag x y)
    ((get 'make-from-real-imag 'complex) x y))

  (define (make-complex-from-mag-ang r a)
    ((get 'make-from-mag-ang 'complex) r a))



  (install-rectangular-package)
  (install-polar-package)
  (install-rational-package)
  (install-scheme-number-package)
  (install-complex-package)

  (show #t "Scheme-number: " (zero? (make-scheme-number 0)) "\n")
  (show #t "Rational: " (zero? (make-rational 0 2)) "\n")
  (show #t "Complex: " (zero? (make-complex-from-mag-ang 0 0)) "\n")
#+end_src

#+RESULTS[7b84d93ee2ba1f0f448832f1adef564f55ddb141]:
#+begin_src scheme
Scheme-number: #t
Rational: #t
Complex: #t
#+end_src

*** Snippet put-coercion
I added the ~put-coercion~ and ~get-coercion~ procedures to the
<<put-and-get>> noweb fragment. This doesn't seem to be much of a problem,
because these operations are not used before this point.
*** Snippet coercion procedures

We are modifying ~apply-generic~ in this snippet, which means that we may
need to do a lot of copying of the old code in order to make it work with the
new code.

#+name: coercion-procedures-apply-generic
#+begin_src scheme :exports code :results none
  (define (scheme-number->complex n)
    (make-complex-from-real-imag (contents n) 0))
  (put-coercion 'scheme-number
		'complex
		scheme-number->complex)

  (define (apply-generic op . args)
    (let ((type-tags (map type-tag args)))
      (let ((proc (get op type-tags)))
	(if proc
	    (apply proc (map contents args))
	    (if (= (length args) 2)
		(let ((type1 (car type-tags))
		      (type2 (cadr type-tags))
		      (a1 (car args))
		      (a2 (cadr args)))
		  (let ((t1->t2 (get-coercion type1 type2))
			(t2->t1 (get-coercion type2 type1)))
		    (cond (t1->t2
			   (apply-generic op (t1->t2 a1) a2))
			  (t2->t1
			   (apply-generic op a1 (t2->t1 a2)))
			  (else
			   (error "No method for these types"
				  (list op type-tags))))))
		(error "No method for these types"
		       (list op type-tags)))))))


#+end_src


*** DONE Exercise 2.81 coercion to-itself
    CLOSED: [2019-10-15 Tue 11:16]
Another extremely ill-defined problem.
Let us try to do some mind-reading to understand which parts of code we need
to tangle to solve it letter by letter.

**** a

I will tangle in the version of the algebra package from the Exercise-2.80,
but I will replace the ~apply-generic~ with a coercing version.

#+begin_src scheme :exports both :results output scalar code
  (define false #f)
  (define true  #t)
  (define (make-table)
    (let ((local-table (list '*table*)))
      (define (lookup key-1 key-2)
	(let ((subtable (assoc key-1 (cdr local-table))))
	  (if subtable
	      (let ((record (assoc key-2 (cdr subtable))))
		(if record
		    (cdr record)
		    false))
	      false)))
      (define (insert! key-1 key-2 value)
	(let ((subtable (assoc key-1 (cdr local-table))))
	  (if subtable
	      (let ((record (assoc key-2 (cdr subtable))))
		(if record
		    (set-cdr! record value)
		    (set-cdr! subtable
			      (cons (cons key-2 value)
				    (cdr subtable)))))
	      (set-cdr! local-table
			(cons (list key-1
				    (cons key-2 value))
			      (cdr local-table)))))
	'ok)
      (define (dispatch m)
	(cond ((eq? m 'lookup-proc) lookup)
	      ((eq? m 'insert-proc!) insert!)
	      (else (error "Unknown operation -- TABLE" m))))
      dispatch))

  (define operation-table (make-table))
  (define get (operation-table 'lookup-proc))
  (define put (operation-table 'insert-proc!))

  (define coercion-table (make-table))
  (define get-coercion (coercion-table 'lookup-proc))
  (define put-coercion (coercion-table 'insert-proc!))

  (define (attach-tag type-tag contents)
    (cons type-tag contents))

  (define (type-tag datum)
    (if (pair? datum)
	(car datum)
	(error "Bad tagged datum -- TYPE-TAG" datum)))

  (define (contents datum)
    (if (pair? datum)
	(cdr datum)
	(error "Bad tagged datum -- CONTENTS" datum)))

  (define (rectangular? z)
    (eq? (type-tag z) 'rectangular))

  (define (polar? z)
    (eq? (type-tag z) 'polar))

  (define (apply-generic op . args)
    (let ((type-tags (map type-tag args)))
	 (let ((proc (get op type-tags)))
	   (if proc
	       (apply proc (map contents args))
	       (if (= (length args) 2)
		   (let ((type1 (car type-tags))
			 (type2 (cadr type-tags))
			 (a1 (car args))
			 (a2 (cadr args)))
		     (let ((t1->t2 (get-coercion type1 type2))
			   (t2->t1 (get-coercion type2 type1)))
		       (cond (t1->t2
			      (apply-generic op (t1->t2 a1) a2))
			     (t2->t1
			      (apply-generic op a1 (t2->t1 a2)))
			     (else
			      (error "No method for these types"
				     (list op type-tags))))))
		   (error "No method for these types"
			  (list op type-tags)))))))


  (define (real-part z) (apply-generic 'real-part z))
  (define (imag-part z) (apply-generic 'imag-part z))
  (define (magnitude z) (apply-generic 'magnitude z))
  (define (angle z) (apply-generic 'angle z))

  (define (add x y) (apply-generic 'add x y))
  (define (sub x y) (apply-generic 'sub x y))
  (define (mul x y) (apply-generic 'mul x y))
  (define (div x y) (apply-generic 'div x y))

  (define (equ? x y) (apply-generic 'equ? x y))
  (define (zero? x) (apply-generic 'zero? x))

  (define (exp x y) (apply-generic 'exp x y))

  (define (install-scheme-number-package)
    (define (tag x)
      (attach-tag 'scheme-number x))
    (put 'add '(scheme-number scheme-number)
	 (lambda (x y) (tag (+ x y))))
    (put 'sub '(scheme-number scheme-number)
	 (lambda (x y) (tag (- x y))))
    (put 'mul '(scheme-number scheme-number)
	 (lambda (x y) (tag (* x y))))
    (put 'div '(scheme-number scheme-number)
	 (lambda (x y) (tag (/ x y))))
    (put 'make 'scheme-number
	 (lambda (x) (tag x)))
    (put 'equ? '(scheme-number scheme-number)
	 (lambda (x y) (= x y)))
    (put 'zero? '(scheme-number)
	  (lambda (x) (= 0 x)))
    (put 'exp '(scheme-number scheme-number)
	  (lambda (x y) (tag (expt x y))))

    'done)

  (define (make-scheme-number n)
    ((get 'make 'scheme-number) n))

  (define (install-rational-package)
    (define (numer x) (car x))
    (define (denom x) (cdr x))
    (define (make-rat n d)
      (let ((g (gcd n d)))
	(cons (/ n g) (/ d g))))
    (define (add-rat x y)
      (make-rat (+ (* (numer x) (denom y))
		   (* (numer y) (denom x)))
		(* (denom x) (denom y))))
    (define (sub-rat x y)
      (make-rat (- (* (numer x) (denom y))
		   (* (numer y) (denom x)))
		(* (denom x) (denom y))))
    (define (mul-rat x y)
      (make-rat (* (numer x) (numer y))
		(* (denom x) (denom y))))
    (define (div-rat x y)
      (make-rat (* (numer x) (denom y))
		(* (denom x) (numer y))))

    (define (tag x) (attach-tag 'rational x))
    (put 'add '(rational rational)
	 (lambda (x y) (tag (add-rat x y))))
    (put 'sub '(rational rational)
	 (lambda (x y) (tag (sub-rat x y))))
    (put 'mul '(rational rational)
	 (lambda (x y) (tag (mul-rat x y))))
    (put 'div '(rational rational)
	 (lambda (x y) (tag (div-rat x y))))

    (put 'make 'rational
	 (lambda (n d) (tag (make-rat n d))))
    (put 'equ? '(rational rational)
	 (lambda (x y) (= 0 (numer (sub-rat x y)))))
    (put 'zero? '(rational) (lambda (x) (= 0 (numer x))))
    'done)

  (define (make-rational n d)
    ((get 'make 'rational) n d))

  (define (install-rectangular-package)

    (define (real-part z) (car z))
    (define (imag-part z) (cdr z))
    (define (make-from-real-imag x y) (cons x y))
    (define (magnitude z)
      (sqrt (+ (square (real-part z))
	       (square (imag-part z)))))
    (define (angle z)
      (atan (imag-part z) (real-part z)))
    (define (make-from-mag-ang r a)
      (cons (* r (cos a)) (* r (sin a))))

    (define (tag x) (attach-tag 'rectangular x))
    (put 'real-part '(rectangular) real-part)
    (put 'imag-part '(rectangular) imag-part)
    (put 'magnitude '(rectangular) magnitude)
    (put 'angle '(rectangular) angle)
    (put 'make-from-real-imag 'rectangular
	 (lambda (x y) (tag (make-from-real-imag x y))))
    (put 'make-from-mag-ang 'rectangular
	 (lambda (r a) (tag (make-from-mag-ang r a))))
    'done)

  (define (install-polar-package)

    (define (magnitude z) (car z))
    (define (angle z) (cdr z))
    (define (make-from-mag-ang r a) (cons r a))
    (define (real-part z)
      (* (magnitude z) (cos (angle z))))
    (define (imag-part z)
      (* (magnitude z) (sin (angle z))))
    (define (make-from-real-imag x y)
      (cons (sqrt (+ (square x) (square y)))
	    (atan y x)))

    (define (tag x) (attach-tag 'polar x))
    (put 'real-part '(polar) real-part)
    (put 'imag-part '(polar) imag-part)
    (put 'magnitude '(polar) magnitude)
    (put 'angle '(polar) angle)
    (put 'make-from-real-imag 'polar
	 (lambda (x y) (tag (make-from-real-imag x y))))
    (put 'make-from-mag-ang 'polar
	 (lambda (r a) (tag (make-from-mag-ang r a))))
    'done)

  (define (install-complex-package)
    (define (make-from-real-imag x y)
      ((get 'make-from-real-imag 'rectangular) x y))
    (define (make-from-mag-ang r a)
      ((get 'make-from-mag-ang 'polar) r a))
    (define (add-complex z1 z2)
      (make-from-real-imag (+ (real-part z1) (real-part z2))
			   (+ (imag-part z1) (imag-part z2))))
    (define (sub-complex z1 z2)
      (make-from-real-imag (- (real-part z1) (real-part z2))
			   (- (imag-part z1) (imag-part z2))))
    (define (mul-complex z1 z2)
      (make-from-mag-ang (* (magnitude z1) (magnitude z2))
			 (+ (angle z1) (angle z2))))
    (define (div-complex z1 z2)
      (make-from-mag-ang (/ (magnitude z1) (magnitude z2))
			 (- (angle z1) (angle z2))))
    (define (tag z) (attach-tag 'complex z))
    (put 'add '(complex complex)
	 (lambda (z1 z2) (tag (add-complex z1 z2))))
    (put 'sub '(complex complex)
	 (lambda (z1 z2) (tag (sub-complex z1 z2))))
    (put 'mul '(complex complex)
	 (lambda (z1 z2) (tag (mul-complex z1 z2))))
    (put 'div '(complex complex)
	 (lambda (z1 z2) (tag (div-complex z1 z2))))
    (put 'make-from-real-imag 'complex
	 (lambda (x y) (tag (make-from-real-imag x y))))
    (put 'make-from-mag-ang 'complex
	 (lambda (r a) (tag (make-from-mag-ang r a))))
    (put 'equ? '(complex complex)
	 (lambda (x y) (and (= 0 (real-part (sub-complex x y)))
		      (= 0 (imag-part (sub-complex x y))))))
    (put 'equ? '(rectangular polar) equ?)
    (put 'equ? '(polar rectangular) equ?)
    (put 'zero? '(complex)
	 (lambda (x) (equ? (tag x) (tag (make-from-real-imag 0 0)))))
    'done)

  (define (make-complex-from-real-imag x y)
    ((get 'make-from-real-imag 'complex) x y))

  (define (make-complex-from-mag-ang r a)
    ((get 'make-from-mag-ang 'complex) r a))



  (install-rectangular-package)
  (install-polar-package)
  (install-rational-package)
  (install-scheme-number-package)
  (install-complex-package)

  (define (scheme-number->scheme-number n) n)
  (define (complex->complex z) z)
  (put-coercion 'scheme-number 'scheme-number
                 scheme-number->scheme-number)
  (put-coercion 'complex 'complex complex->complex)

(show #t (displayed (exp (make-complex-from-mag-ang 2 0) (make-complex-from-mag-ang 2 0))))

#+end_src

#+RESULTS[59c726db117f5910df5818034548bd1e5bc2316a]:
#+begin_src scheme
#+end_src

We can see that this code doesn't work as expected. Why?
The answer is because the new version of ~apply-generic~ only checks if the
coercions exist, not whether the function on the new coerced types exists.

This seems like making sense, as in order to "find a common denominator",
more than one coercion may be needed, but the result is not good in the sense
that if the final function doesn't exist, ~apply-generic~ ends up applying
itself over and over. So the strategy proposed by Louis is not very good.

**** b

#+begin_src scheme :exports both :results output scalar code
  (define false #f)
  (define true  #t)
  (define (make-table)
    (let ((local-table (list '*table*)))
      (define (lookup key-1 key-2)
	(let ((subtable (assoc key-1 (cdr local-table))))
	  (if subtable
	      (let ((record (assoc key-2 (cdr subtable))))
		(if record
		    (cdr record)
		    false))
	      false)))
      (define (insert! key-1 key-2 value)
	(let ((subtable (assoc key-1 (cdr local-table))))
	  (if subtable
	      (let ((record (assoc key-2 (cdr subtable))))
		(if record
		    (set-cdr! record value)
		    (set-cdr! subtable
			      (cons (cons key-2 value)
				    (cdr subtable)))))
	      (set-cdr! local-table
			(cons (list key-1
				    (cons key-2 value))
			      (cdr local-table)))))
	'ok)
      (define (dispatch m)
	(cond ((eq? m 'lookup-proc) lookup)
	      ((eq? m 'insert-proc!) insert!)
	      (else (error "Unknown operation -- TABLE" m))))
      dispatch))

  (define operation-table (make-table))
  (define get (operation-table 'lookup-proc))
  (define put (operation-table 'insert-proc!))

  (define coercion-table (make-table))
  (define get-coercion (coercion-table 'lookup-proc))
  (define put-coercion (coercion-table 'insert-proc!))

  (define (attach-tag type-tag contents)
    (cons type-tag contents))

  (define (type-tag datum)
    (if (pair? datum)
	(car datum)
	(error "Bad tagged datum -- TYPE-TAG" datum)))

  (define (contents datum)
    (if (pair? datum)
	(cdr datum)
	(error "Bad tagged datum -- CONTENTS" datum)))

  (define (rectangular? z)
    (eq? (type-tag z) 'rectangular))

  (define (polar? z)
    (eq? (type-tag z) 'polar))

  (define (apply-generic op . args)
    (let ((type-tags (map type-tag args)))
	 (let ((proc (get op type-tags)))
	   (if proc
	       (apply proc (map contents args))
	       (if (= (length args) 2)
		   (let ((type1 (car type-tags))
			 (type2 (cadr type-tags))
			 (a1 (car args))
			 (a2 (cadr args)))
		     (let ((t1->t2 (get-coercion type1 type2))
			   (t2->t1 (get-coercion type2 type1)))
		       (cond (t1->t2
			      (apply-generic op (t1->t2 a1) a2))
			     (t2->t1
			      (apply-generic op a1 (t2->t1 a2)))
			     (else
			      (error "No method for these types"
				     (list op type-tags))))))
		   (error "No method for these types"
			  (list op type-tags)))))))


  (define (real-part z) (apply-generic 'real-part z))
  (define (imag-part z) (apply-generic 'imag-part z))
  (define (magnitude z) (apply-generic 'magnitude z))
  (define (angle z) (apply-generic 'angle z))

  (define (add x y) (apply-generic 'add x y))
  (define (sub x y) (apply-generic 'sub x y))
  (define (mul x y) (apply-generic 'mul x y))
  (define (div x y) (apply-generic 'div x y))

  (define (equ? x y) (apply-generic 'equ? x y))
  (define (zero? x) (apply-generic 'zero? x))

  (define (exp x y) (apply-generic 'exp x y))

  (define (install-scheme-number-package)
    (define (tag x)
      (attach-tag 'scheme-number x))
    (put 'add '(scheme-number scheme-number)
	 (lambda (x y) (tag (+ x y))))
    (put 'sub '(scheme-number scheme-number)
	 (lambda (x y) (tag (- x y))))
    (put 'mul '(scheme-number scheme-number)
	 (lambda (x y) (tag (* x y))))
    (put 'div '(scheme-number scheme-number)
	 (lambda (x y) (tag (/ x y))))
    (put 'make 'scheme-number
	 (lambda (x) (tag x)))
    (put 'equ? '(scheme-number scheme-number)
	 (lambda (x y) (= x y)))
    (put 'zero? '(scheme-number)
	  (lambda (x) (= 0 x)))
    (put 'exp '(scheme-number scheme-number)
	  (lambda (x y) (tag (expt x y))))

    'done)

  (define (make-scheme-number n)
    ((get 'make 'scheme-number) n))

  (define (install-rational-package)
    (define (numer x) (car x))
    (define (denom x) (cdr x))
    (define (make-rat n d)
      (let ((g (gcd n d)))
	(cons (/ n g) (/ d g))))
    (define (add-rat x y)
      (make-rat (+ (* (numer x) (denom y))
		   (* (numer y) (denom x)))
		(* (denom x) (denom y))))
    (define (sub-rat x y)
      (make-rat (- (* (numer x) (denom y))
		   (* (numer y) (denom x)))
		(* (denom x) (denom y))))
    (define (mul-rat x y)
      (make-rat (* (numer x) (numer y))
		(* (denom x) (denom y))))
    (define (div-rat x y)
      (make-rat (* (numer x) (denom y))
		(* (denom x) (numer y))))

    (define (tag x) (attach-tag 'rational x))
    (put 'add '(rational rational)
	 (lambda (x y) (tag (add-rat x y))))
    (put 'sub '(rational rational)
	 (lambda (x y) (tag (sub-rat x y))))
    (put 'mul '(rational rational)
	 (lambda (x y) (tag (mul-rat x y))))
    (put 'div '(rational rational)
	 (lambda (x y) (tag (div-rat x y))))

    (put 'make 'rational
	 (lambda (n d) (tag (make-rat n d))))
    (put 'equ? '(rational rational)
	 (lambda (x y) (= 0 (numer (sub-rat x y)))))
    (put 'zero? '(rational) (lambda (x) (= 0 (numer x))))
    'done)

  (define (make-rational n d)
    ((get 'make 'rational) n d))

  (define (install-rectangular-package)

    (define (real-part z) (car z))
    (define (imag-part z) (cdr z))
    (define (make-from-real-imag x y) (cons x y))
    (define (magnitude z)
      (sqrt (+ (square (real-part z))
	       (square (imag-part z)))))
    (define (angle z)
      (atan (imag-part z) (real-part z)))
    (define (make-from-mag-ang r a)
      (cons (* r (cos a)) (* r (sin a))))

    (define (tag x) (attach-tag 'rectangular x))
    (put 'real-part '(rectangular) real-part)
    (put 'imag-part '(rectangular) imag-part)
    (put 'magnitude '(rectangular) magnitude)
    (put 'angle '(rectangular) angle)
    (put 'make-from-real-imag 'rectangular
	 (lambda (x y) (tag (make-from-real-imag x y))))
    (put 'make-from-mag-ang 'rectangular
	 (lambda (r a) (tag (make-from-mag-ang r a))))
    'done)

  (define (install-polar-package)

    (define (magnitude z) (car z))
    (define (angle z) (cdr z))
    (define (make-from-mag-ang r a) (cons r a))
    (define (real-part z)
      (* (magnitude z) (cos (angle z))))
    (define (imag-part z)
      (* (magnitude z) (sin (angle z))))
    (define (make-from-real-imag x y)
      (cons (sqrt (+ (square x) (square y)))
	    (atan y x)))

    (define (tag x) (attach-tag 'polar x))
    (put 'real-part '(polar) real-part)
    (put 'imag-part '(polar) imag-part)
    (put 'magnitude '(polar) magnitude)
    (put 'angle '(polar) angle)
    (put 'make-from-real-imag 'polar
	 (lambda (x y) (tag (make-from-real-imag x y))))
    (put 'make-from-mag-ang 'polar
	 (lambda (r a) (tag (make-from-mag-ang r a))))
    'done)

  (define (install-complex-package)
    (define (make-from-real-imag x y)
      ((get 'make-from-real-imag 'rectangular) x y))
    (define (make-from-mag-ang r a)
      ((get 'make-from-mag-ang 'polar) r a))
    (define (add-complex z1 z2)
      (make-from-real-imag (+ (real-part z1) (real-part z2))
			   (+ (imag-part z1) (imag-part z2))))
    (define (sub-complex z1 z2)
      (make-from-real-imag (- (real-part z1) (real-part z2))
			   (- (imag-part z1) (imag-part z2))))
    (define (mul-complex z1 z2)
      (make-from-mag-ang (* (magnitude z1) (magnitude z2))
			 (+ (angle z1) (angle z2))))
    (define (div-complex z1 z2)
      (make-from-mag-ang (/ (magnitude z1) (magnitude z2))
			 (- (angle z1) (angle z2))))
    (define (tag z) (attach-tag 'complex z))
    (put 'add '(complex complex)
	 (lambda (z1 z2) (tag (add-complex z1 z2))))
    (put 'sub '(complex complex)
	 (lambda (z1 z2) (tag (sub-complex z1 z2))))
    (put 'mul '(complex complex)
	 (lambda (z1 z2) (tag (mul-complex z1 z2))))
    (put 'div '(complex complex)
	 (lambda (z1 z2) (tag (div-complex z1 z2))))
    (put 'make-from-real-imag 'complex
	 (lambda (x y) (tag (make-from-real-imag x y))))
    (put 'make-from-mag-ang 'complex
	 (lambda (r a) (tag (make-from-mag-ang r a))))
    (put 'equ? '(complex complex)
	 (lambda (x y) (and (= 0 (real-part (sub-complex x y)))
		      (= 0 (imag-part (sub-complex x y))))))
    (put 'equ? '(rectangular polar) equ?)
    (put 'equ? '(polar rectangular) equ?)
    (put 'zero? '(complex)
	 (lambda (x) (equ? (tag x) (tag (make-from-real-imag 0 0)))))
    'done)

  (define (make-complex-from-real-imag x y)
    ((get 'make-from-real-imag 'complex) x y))

  (define (make-complex-from-mag-ang r a)
    ((get 'make-from-mag-ang 'complex) r a))



  (install-rectangular-package)
  (install-polar-package)
  (install-rational-package)
  (install-scheme-number-package)
  (install-complex-package)

(show #t " " (displayed (exp (make-scheme-number 2) (make-scheme-number 2))) "\n")
(show #t " " (displayed (exp (make-complex-from-mag-ang 2 0)
                             (make-complex-from-mag-ang 2 0))))
#+end_src

#+RESULTS[9fe0a3a9728841583ab88e8ad406524315e4263b]:
#+begin_src scheme
 (scheme-number . 4)

Output (exception): {Exception #19 user "No method for these types" ((exp (complex complex))) #f #f} 
Stack trace:
  called from <anonymous> on line 817 of file /usr/lib64/chibi/init-7.scm
  called from <anonymous> on line 280 of file /usr/lib64/chibi/init-7.scm
  called from <anonymous> on line 1206 of file /usr/lib64/chibi/init-7.scm
  called from <anonymous> on line 817 of file /usr/lib64/chibi/init-7.scm
  called from error on line 100 of file /usr/lib64/chibi/init-7.scm
  called from <anonymous> on line 4
  called from <anonymous> on line 817 of file /usr/lib64/chibi/init-7.scm
  called from call-with-current-continuation on line 844 of file /usr/lib64/chibi/init-7.scm
  called from <anonymous> on line 817 of file /usr/lib64/chibi/init-7.scm
  called from <anonymous> on line 280 of file /usr/lib64/chibi/init-7.scm
  called from <anonymous> on line 280 of file /usr/lib64/chibi/init-7.scm
  called from <anonymous> on line 817 of file /usr/lib64/chibi/init-7.scm
  called from call-with-current-continuation on line 844 of file /usr/lib64/chibi/init-7.scm
  called from geiser:eval on line 25 of file /usr/lib64/chibi/scheme/misc-macros.scm
#+end_src

This seems correct. There may be a problem when the function is actually
defined for some types that the given ones are coerce-able to, but the system
doesn't try that.

**** c

#+begin_src scheme :exports both :results output scalar code
  (define false #f)
  (define true  #t)
  (define (make-table)
    (let ((local-table (list '*table*)))
      (define (lookup key-1 key-2)
	(let ((subtable (assoc key-1 (cdr local-table))))
	  (if subtable
	      (let ((record (assoc key-2 (cdr subtable))))
		(if record
		    (cdr record)
		    false))
	      false)))
      (define (insert! key-1 key-2 value)
	(let ((subtable (assoc key-1 (cdr local-table))))
	  (if subtable
	      (let ((record (assoc key-2 (cdr subtable))))
		(if record
		    (set-cdr! record value)
		    (set-cdr! subtable
			      (cons (cons key-2 value)
				    (cdr subtable)))))
	      (set-cdr! local-table
			(cons (list key-1
				    (cons key-2 value))
			      (cdr local-table)))))
	'ok)
      (define (dispatch m)
	(cond ((eq? m 'lookup-proc) lookup)
	      ((eq? m 'insert-proc!) insert!)
	      (else (error "Unknown operation -- TABLE" m))))
      dispatch))

  (define operation-table (make-table))
  (define get (operation-table 'lookup-proc))
  (define put (operation-table 'insert-proc!))

  (define coercion-table (make-table))
  (define get-coercion (coercion-table 'lookup-proc))
  (define put-coercion (coercion-table 'insert-proc!))

  (define (attach-tag type-tag contents)
    (cons type-tag contents))

  (define (type-tag datum)
    (if (pair? datum)
	(car datum)
	(error "Bad tagged datum -- TYPE-TAG" datum)))

  (define (contents datum)
    (if (pair? datum)
	(cdr datum)
	(error "Bad tagged datum -- CONTENTS" datum)))

  (define (rectangular? z)
    (eq? (type-tag z) 'rectangular))

  (define (polar? z)
    (eq? (type-tag z) 'polar))

  (define (apply-generic op . args)
    (let ((type-tags (map type-tag args)))
	 (let ((proc (get op type-tags)))
	   (if proc
	       (apply proc (map contents args))
	       (if (and (= (length args) 2) (not (eq? (car type-tags) (cadr type-tags))))
		   (let ((type1 (car type-tags))
			 (type2 (cadr type-tags))
			 (a1 (car args))
			 (a2 (cadr args)))
		     (let ((t1->t2 (get-coercion type1 type2))
			   (t2->t1 (get-coercion type2 type1)))
		       (cond (t1->t2
			      (apply-generic op (t1->t2 a1) a2))
			     (t2->t1
			      (apply-generic op a1 (t2->t1 a2)))
			     (else
			      (error "No method for these types"
				     (list op type-tags))))))
		   (error "No method for these types"
			  (list op type-tags)))))))


  (define (real-part z) (apply-generic 'real-part z))
  (define (imag-part z) (apply-generic 'imag-part z))
  (define (magnitude z) (apply-generic 'magnitude z))
  (define (angle z) (apply-generic 'angle z))

  (define (add x y) (apply-generic 'add x y))
  (define (sub x y) (apply-generic 'sub x y))
  (define (mul x y) (apply-generic 'mul x y))
  (define (div x y) (apply-generic 'div x y))

  (define (equ? x y) (apply-generic 'equ? x y))
  (define (zero? x) (apply-generic 'zero? x))

  (define (exp x y) (apply-generic 'exp x y))

  (define (install-scheme-number-package)
    (define (tag x)
      (attach-tag 'scheme-number x))
    (put 'add '(scheme-number scheme-number)
	 (lambda (x y) (tag (+ x y))))
    (put 'sub '(scheme-number scheme-number)
	 (lambda (x y) (tag (- x y))))
    (put 'mul '(scheme-number scheme-number)
	 (lambda (x y) (tag (* x y))))
    (put 'div '(scheme-number scheme-number)
	 (lambda (x y) (tag (/ x y))))
    (put 'make 'scheme-number
	 (lambda (x) (tag x)))
    (put 'equ? '(scheme-number scheme-number)
	 (lambda (x y) (= x y)))
    (put 'zero? '(scheme-number)
	  (lambda (x) (= 0 x)))
    (put 'exp '(scheme-number scheme-number)
	  (lambda (x y) (tag (expt x y))))

    'done)

  (define (make-scheme-number n)
    ((get 'make 'scheme-number) n))

  (define (install-rational-package)
    (define (numer x) (car x))
    (define (denom x) (cdr x))
    (define (make-rat n d)
      (let ((g (gcd n d)))
	(cons (/ n g) (/ d g))))
    (define (add-rat x y)
      (make-rat (+ (* (numer x) (denom y))
		   (* (numer y) (denom x)))
		(* (denom x) (denom y))))
    (define (sub-rat x y)
      (make-rat (- (* (numer x) (denom y))
		   (* (numer y) (denom x)))
		(* (denom x) (denom y))))
    (define (mul-rat x y)
      (make-rat (* (numer x) (numer y))
		(* (denom x) (denom y))))
    (define (div-rat x y)
      (make-rat (* (numer x) (denom y))
		(* (denom x) (numer y))))

    (define (tag x) (attach-tag 'rational x))
    (put 'add '(rational rational)
	 (lambda (x y) (tag (add-rat x y))))
    (put 'sub '(rational rational)
	 (lambda (x y) (tag (sub-rat x y))))
    (put 'mul '(rational rational)
	 (lambda (x y) (tag (mul-rat x y))))
    (put 'div '(rational rational)
	 (lambda (x y) (tag (div-rat x y))))

    (put 'make 'rational
	 (lambda (n d) (tag (make-rat n d))))
    (put 'equ? '(rational rational)
	 (lambda (x y) (= 0 (numer (sub-rat x y)))))
    (put 'zero? '(rational) (lambda (x) (= 0 (numer x))))
    'done)

  (define (make-rational n d)
    ((get 'make 'rational) n d))

  (define (install-rectangular-package)

    (define (real-part z) (car z))
    (define (imag-part z) (cdr z))
    (define (make-from-real-imag x y) (cons x y))
    (define (magnitude z)
      (sqrt (+ (square (real-part z))
	       (square (imag-part z)))))
    (define (angle z)
      (atan (imag-part z) (real-part z)))
    (define (make-from-mag-ang r a)
      (cons (* r (cos a)) (* r (sin a))))

    (define (tag x) (attach-tag 'rectangular x))
    (put 'real-part '(rectangular) real-part)
    (put 'imag-part '(rectangular) imag-part)
    (put 'magnitude '(rectangular) magnitude)
    (put 'angle '(rectangular) angle)
    (put 'make-from-real-imag 'rectangular
	 (lambda (x y) (tag (make-from-real-imag x y))))
    (put 'make-from-mag-ang 'rectangular
	 (lambda (r a) (tag (make-from-mag-ang r a))))
    'done)

  (define (install-polar-package)

    (define (magnitude z) (car z))
    (define (angle z) (cdr z))
    (define (make-from-mag-ang r a) (cons r a))
    (define (real-part z)
      (* (magnitude z) (cos (angle z))))
    (define (imag-part z)
      (* (magnitude z) (sin (angle z))))
    (define (make-from-real-imag x y)
      (cons (sqrt (+ (square x) (square y)))
	    (atan y x)))

    (define (tag x) (attach-tag 'polar x))
    (put 'real-part '(polar) real-part)
    (put 'imag-part '(polar) imag-part)
    (put 'magnitude '(polar) magnitude)
    (put 'angle '(polar) angle)
    (put 'make-from-real-imag 'polar
	 (lambda (x y) (tag (make-from-real-imag x y))))
    (put 'make-from-mag-ang 'polar
	 (lambda (r a) (tag (make-from-mag-ang r a))))
    'done)

  (define (install-complex-package)
    (define (make-from-real-imag x y)
      ((get 'make-from-real-imag 'rectangular) x y))
    (define (make-from-mag-ang r a)
      ((get 'make-from-mag-ang 'polar) r a))
    (define (add-complex z1 z2)
      (make-from-real-imag (+ (real-part z1) (real-part z2))
			   (+ (imag-part z1) (imag-part z2))))
    (define (sub-complex z1 z2)
      (make-from-real-imag (- (real-part z1) (real-part z2))
			   (- (imag-part z1) (imag-part z2))))
    (define (mul-complex z1 z2)
      (make-from-mag-ang (* (magnitude z1) (magnitude z2))
			 (+ (angle z1) (angle z2))))
    (define (div-complex z1 z2)
      (make-from-mag-ang (/ (magnitude z1) (magnitude z2))
			 (- (angle z1) (angle z2))))
    (define (tag z) (attach-tag 'complex z))
    (put 'add '(complex complex)
	 (lambda (z1 z2) (tag (add-complex z1 z2))))
    (put 'sub '(complex complex)
	 (lambda (z1 z2) (tag (sub-complex z1 z2))))
    (put 'mul '(complex complex)
	 (lambda (z1 z2) (tag (mul-complex z1 z2))))
    (put 'div '(complex complex)
	 (lambda (z1 z2) (tag (div-complex z1 z2))))
    (put 'make-from-real-imag 'complex
	 (lambda (x y) (tag (make-from-real-imag x y))))
    (put 'make-from-mag-ang 'complex
	 (lambda (r a) (tag (make-from-mag-ang r a))))
    (put 'equ? '(complex complex)
	 (lambda (x y) (and (= 0 (real-part (sub-complex x y)))
		      (= 0 (imag-part (sub-complex x y))))))
    (put 'equ? '(rectangular polar) equ?)
    (put 'equ? '(polar rectangular) equ?)
    (put 'zero? '(complex)
	 (lambda (x) (equ? (tag x) (tag (make-from-real-imag 0 0)))))
    'done)

  (define (make-complex-from-real-imag x y)
    ((get 'make-from-real-imag 'complex) x y))

  (define (make-complex-from-mag-ang r a)
    ((get 'make-from-mag-ang 'complex) r a))



  (install-rectangular-package)
  (install-polar-package)
  (install-rational-package)
  (install-scheme-number-package)
  (install-complex-package)

(show #t " " (displayed (exp (make-scheme-number 2) (make-scheme-number 2))))


#+end_src

#+RESULTS[f8960cb4e8727a1706c70164ba61f36c1699b9ff]:
#+begin_src scheme
 (scheme-number . 4)
#+end_src

*** DONE Exercise 2.82 three-argument-coercion
    CLOSED: [2019-10-15 Tue 21:40]
I am copying the whole "algebra" mess, because I already lost track of which
functions are needed for the tests to work. Bad practice, don't do so.

#+name: generic-arithmetic-packages-multidispatch
#+begin_src scheme :exports code :results none
  (define false #f)
  (define true  #t)
  (define (make-table)
    (let ((local-table (list '*table*)))
      (define (lookup key-1 key-2)
	(let ((subtable (assoc key-1 (cdr local-table))))
	  (if subtable
	      (let ((record (assoc key-2 (cdr subtable))))
		(if record
		    (cdr record)
		    false))
	      false)))
      (define (insert! key-1 key-2 value)
	(let ((subtable (assoc key-1 (cdr local-table))))
	  (if subtable
	      (let ((record (assoc key-2 (cdr subtable))))
		(if record
		    (set-cdr! record value)
		    (set-cdr! subtable
			      (cons (cons key-2 value)
				    (cdr subtable)))))
	      (set-cdr! local-table
			(cons (list key-1
				    (cons key-2 value))
			      (cdr local-table)))))
	'ok)
      (define (dispatch m)
	(cond ((eq? m 'lookup-proc) lookup)
	      ((eq? m 'insert-proc!) insert!)
	      (else (error "Unknown operation -- TABLE" m))))
      dispatch))

  (define operation-table (make-table))
  (define get (operation-table 'lookup-proc))
  (define put (operation-table 'insert-proc!))

  (define coercion-table (make-table))
  (define get-coercion (coercion-table 'lookup-proc))
  (define put-coercion (coercion-table 'insert-proc!))

  (define (attach-tag type-tag contents)
    (cons type-tag contents))

  (define (type-tag datum)
    (if (pair? datum)
	(car datum)
	(error "Bad tagged datum -- TYPE-TAG" datum)))

  (define (contents datum)
    (if (pair? datum)
	(cdr datum)
	(error "Bad tagged datum -- CONTENTS" datum)))

  (define (rectangular? z)
    (eq? (type-tag z) 'rectangular))

  (define (polar? z)
    (eq? (type-tag z) 'polar))


  (define (real-part z) (apply-generic 'real-part z))
  (define (imag-part z) (apply-generic 'imag-part z))
  (define (magnitude z) (apply-generic 'magnitude z))
  (define (angle z) (apply-generic 'angle z))

  (define (add x y) (apply-generic 'add x y))
  (define (sub x y) (apply-generic 'sub x y))
  (define (mul x y) (apply-generic 'mul x y))
  (define (div x y) (apply-generic 'div x y))

  (define (equ? x y) (apply-generic 'equ? x y))
  (define (zero? x) (apply-generic 'zero? x))

  (define (exp x y) (apply-generic 'exp x y))

  (define (install-scheme-number-package)
    (define (tag x)
      (attach-tag 'scheme-number x))
    (put 'add '(scheme-number scheme-number)
	 (lambda (x y) (tag (+ x y))))
    (put 'sub '(scheme-number scheme-number)
	 (lambda (x y) (tag (- x y))))
    (put 'mul '(scheme-number scheme-number)
	 (lambda (x y) (tag (* x y))))
    (put 'div '(scheme-number scheme-number)
	 (lambda (x y) (tag (/ x y))))
    (put 'make 'scheme-number
	 (lambda (x) (tag x)))
    (put 'equ? '(scheme-number scheme-number)
	 (lambda (x y) (= x y)))
    (put 'zero? '(scheme-number)
	  (lambda (x) (= 0 x)))
    (put 'exp '(scheme-number scheme-number)
	  (lambda (x y) (tag (expt x y))))

    'done)

  (define (make-scheme-number n)
    ((get 'make 'scheme-number) n))

  (define (install-rational-package)
    (define (numer x) (car x))
    (define (denom x) (cdr x))
    (define (make-rat n d)
      (let ((g (gcd n d)))
	(cons (/ n g) (/ d g))))
    (define (add-rat x y)
      (make-rat (+ (* (numer x) (denom y))
		   (* (numer y) (denom x)))
		(* (denom x) (denom y))))
    (define (sub-rat x y)
      (make-rat (- (* (numer x) (denom y))
		   (* (numer y) (denom x)))
		(* (denom x) (denom y))))
    (define (mul-rat x y)
      (make-rat (* (numer x) (numer y))
		(* (denom x) (denom y))))
    (define (div-rat x y)
      (make-rat (* (numer x) (denom y))
		(* (denom x) (numer y))))

    (define (tag x) (attach-tag 'rational x))
    (put 'add '(rational rational)
	 (lambda (x y) (tag (add-rat x y))))
    (put 'sub '(rational rational)
	 (lambda (x y) (tag (sub-rat x y))))
    (put 'mul '(rational rational)
	 (lambda (x y) (tag (mul-rat x y))))
    (put 'div '(rational rational)
	 (lambda (x y) (tag (div-rat x y))))

    (put 'make 'rational
	 (lambda (n d) (tag (make-rat n d))))
    (put 'equ? '(rational rational)
	 (lambda (x y) (= 0 (numer (sub-rat x y)))))
    (put 'zero? '(rational) (lambda (x) (= 0 (numer x))))
    'done)

  (define (make-rational n d)
    ((get 'make 'rational) n d))

  (define (install-rectangular-package)

    (define (real-part z) (car z))
    (define (imag-part z) (cdr z))
    (define (make-from-real-imag x y) (cons x y))
    (define (magnitude z)
      (sqrt (+ (square (real-part z))
	       (square (imag-part z)))))
    (define (angle z)
      (atan (imag-part z) (real-part z)))
    (define (make-from-mag-ang r a)
      (cons (* r (cos a)) (* r (sin a))))

    (define (tag x) (attach-tag 'rectangular x))
    (put 'real-part '(rectangular) real-part)
    (put 'imag-part '(rectangular) imag-part)
    (put 'magnitude '(rectangular) magnitude)
    (put 'angle '(rectangular) angle)
    (put 'make-from-real-imag 'rectangular
	 (lambda (x y) (tag (make-from-real-imag x y))))
    (put 'make-from-mag-ang 'rectangular
	 (lambda (r a) (tag (make-from-mag-ang r a))))
    'done)

  (define (install-polar-package)

    (define (magnitude z) (car z))
    (define (angle z) (cdr z))
    (define (make-from-mag-ang r a) (cons r a))
    (define (real-part z)
      (* (magnitude z) (cos (angle z))))
    (define (imag-part z)
      (* (magnitude z) (sin (angle z))))
    (define (make-from-real-imag x y)
      (cons (sqrt (+ (square x) (square y)))
	    (atan y x)))

    (define (tag x) (attach-tag 'polar x))
    (put 'real-part '(polar) real-part)
    (put 'imag-part '(polar) imag-part)
    (put 'magnitude '(polar) magnitude)
    (put 'angle '(polar) angle)
    (put 'make-from-real-imag 'polar
	 (lambda (x y) (tag (make-from-real-imag x y))))
    (put 'make-from-mag-ang 'polar
	 (lambda (r a) (tag (make-from-mag-ang r a))))
    'done)

  (define (install-complex-package)
    (define (make-from-real-imag x y)
      ((get 'make-from-real-imag 'rectangular) x y))
    (define (make-from-mag-ang r a)
      ((get 'make-from-mag-ang 'polar) r a))
    (define (add-complex z1 z2)
      (make-from-real-imag (+ (real-part z1) (real-part z2))
			   (+ (imag-part z1) (imag-part z2))))
    (define (sub-complex z1 z2)
      (make-from-real-imag (- (real-part z1) (real-part z2))
			   (- (imag-part z1) (imag-part z2))))
    (define (mul-complex z1 z2)
      (make-from-mag-ang (* (magnitude z1) (magnitude z2))
			 (+ (angle z1) (angle z2))))
    (define (div-complex z1 z2)
      (make-from-mag-ang (/ (magnitude z1) (magnitude z2))
			 (- (angle z1) (angle z2))))
    (define (tag z) (attach-tag 'complex z))
    (put 'add '(complex complex)
	 (lambda (z1 z2) (tag (add-complex z1 z2))))
    (put 'sub '(complex complex)
	 (lambda (z1 z2) (tag (sub-complex z1 z2))))
    (put 'mul '(complex complex)
	 (lambda (z1 z2) (tag (mul-complex z1 z2))))
    (put 'div '(complex complex)
	 (lambda (z1 z2) (tag (div-complex z1 z2))))
    (put 'make-from-real-imag 'complex
	 (lambda (x y) (tag (make-from-real-imag x y))))
    (put 'make-from-mag-ang 'complex
	 (lambda (r a) (tag (make-from-mag-ang r a))))
    (put 'equ? '(complex complex)
	 (lambda (x y) (and (= 0 (real-part (sub-complex x y)))
		      (= 0 (imag-part (sub-complex x y))))))
    (put 'equ? '(rectangular polar) equ?)
    (put 'equ? '(polar rectangular) equ?)
    (put 'zero? '(complex)
	 (lambda (x) (equ? (tag x) (tag (make-from-real-imag 0 0)))))
    'done)

  (define (make-complex-from-real-imag x y)
    ((get 'make-from-real-imag 'complex) x y))

  (define (make-complex-from-mag-ang r a)
    ((get 'make-from-mag-ang 'complex) r a))

  (install-rectangular-package)
  (install-polar-package)
  (install-rational-package)
  (install-scheme-number-package)
  (install-complex-package)

#+end_src


#+name: apply-generic-many-args
#+begin_src scheme :exports code :results none
  (define (apply-generic op . args)
    (define (all-argtypes-same? . args)
      (let ((type (type-tag (car args))))
	(accumulate (lambda (x y) (and x y)) #t (map (lambda (x) (eq? type x)) args))))
    (define (coercion-if-exists? type arg-tags)
      (let ((coercion-list (map (lambda (x)
                             (if (eq? type x)
                                 identity
                                 (get-coercion x type))) arg-tags)))
	(if (accumulate (lambda (x y) (and x y)) #t coercion-list)
	    coercion-list
	    #f)))
    (let ((type-tags (map type-tag args)))
	 (let ((proc (get op type-tags)))
	   (if proc
	       (apply proc (map contents args))
	       (if (and (>= (length args) 2) (not (all-argtypes-same? args)))
		   (let types-loop ((types type-tags))
		     (let ((list-of-coercion-functions
			    (coercion-if-exists? (car types) type-tags)))
		       (if list-of-coercion-functions
			   (apply apply-generic (cons op (map (lambda (fun arg) (fun arg))
						  list-of-coercion-functions
						  args)))
		       (if (not (null? (cdr types)))
                           (types-loop (cdr types))
                           (error "Even coercions failed. No method for these types.")))))
		   (error "No method for these types"
			  (list op type-tags)))))))
(define (scheme-number->complex n)
    (make-complex-from-real-imag (contents n) 0))
  (put-coercion 'scheme-number
		'complex
		scheme-number->complex)

(put 'max3-magnitude '(complex complex complex) (lambda (z1 z2 z3)
   (max (magnitude z1) (magnitude z2) (magnitude z3))))
(define (max3-magnitude x1 x2 x3) (apply-generic 'max3-magnitude x1 x2 x3))
(define (identity x) x)
#+end_src


#+begin_src scheme :exports both :results output scalar code
<<accumulate>>
<<generic-arithmetic-packages-multidispatch>>
<<alyssa-complex-suggestion>>
<<apply-generic-many-args>>
(show #t " " (displayed
               (max3-magnitude
                  (make-scheme-number 1)
                  (make-scheme-number 2)
                  (make-complex-from-real-imag 3 0))))
#+end_src

#+RESULTS[04e85d66c4f33a374442ad0fe227ea254f7216a5]:
#+begin_src scheme
 3
#+end_src

Well, this solution works, but is not perfect. Indeed, we can promote the
numbers to one of the arguments, but this implementation would fail if the
types are coerce-able, but the operation is not implemented.

*** DONE Exercise 2.83 Numeric Tower and (raise)
    CLOSED: [2019-10-16 Wed 14:53]

This exercise has a problem: the name of the ~(raise)~ function coincides
with the R7RS' built-in name for an operation to raise exceptions. Therefore,
I have to name my operation ~raise-type~.

#+begin_src scheme :exports code :results none
(define numeric-tower (list 'integer 'rational 'scheme-number 'complex))

(define (higher-type x)
   (define (find-higher-type x types)
      (cond ((or (null? types) (null? (cdr types))) (error "No type higher than given" x))
            ((eq? x (car types)) (cadr types))
            (else (find-higher-type x (cdr types))))))

(define (integer->rational x)
  (make-rational integer 1))

(define (rational->scheme-number x)
  (/ (numer x) (denom x)))
(put-coercion 'integer 'rational integer->rational)
(put-coercion 'rational 'scheme-number rational->scheme-number)

(define (raise-type x) ((get-coercion (type-tag x) (higher-type (type-tag x))) x))

#+end_src


*** DONE Exercise 2.84 Using ~raise~ (~raise-type~) in ~apply-generic~
    CLOSED: [2019-10-17 Thu 11:39]

This exercise is also extremely confusing. Scheme-number, I guess, can
effectively be considered "real", so "rational" numbers should be lower in
the hierarchy than "scheme-number"s. But what about integers? We never had
any operations concerning integers.

In this exercise I will try to implement the following strategy:
 1. Modify ~type-tag~ to return ~'integer~ for scheme integers.
 2. Will not implement any operations for ~'integer~'s, because those will be
    covered by the ~'rational~ class.

#+begin_src scheme :exports both :results output scalar code
  (define (accumulate op initial sequence)
    (if (null? sequence)
	initial
	(accumulate op (op initial (car sequence)) (cdr sequence))))
  (define false #f)
  (define true  #t)
  (define (make-table)
    (let ((local-table (list '*table*)))
      (define (lookup key-1 key-2)
	(let ((subtable (assoc key-1 (cdr local-table))))
	  (if subtable
	      (let ((record (assoc key-2 (cdr subtable))))
		(if record
		    (cdr record)
		    false))
	      false)))
      (define (insert! key-1 key-2 value)
	(let ((subtable (assoc key-1 (cdr local-table))))
	  (if subtable
	      (let ((record (assoc key-2 (cdr subtable))))
		(if record
		    (set-cdr! record value)
		    (set-cdr! subtable
			      (cons (cons key-2 value)
				    (cdr subtable)))))
	      (set-cdr! local-table
			(cons (list key-1
				    (cons key-2 value))
			      (cdr local-table)))))
	'ok)
      (define (dispatch m)
	(cond ((eq? m 'lookup-proc) lookup)
	      ((eq? m 'insert-proc!) insert!)
	      (else (error "Unknown operation -- TABLE" m))))
      dispatch))

  (define operation-table (make-table))
  (define get (operation-table 'lookup-proc))
  (define put (operation-table 'insert-proc!))

  (define coercion-table (make-table))
  (define get-coercion (coercion-table 'lookup-proc))
  (define put-coercion (coercion-table 'insert-proc!))

  (define (attach-tag type-tag contents)
    (cons type-tag contents))

  (define (type-tag datum)
    (cond ((pair? datum) (car datum))
	  ((exact-integer? datum) 'integer)
	  (error "Bad tagged datum -- TYPE-TAG" datum)))

  (define (contents datum)
    (cond ((pair? datum) (cdr datum))
	  ((integer? datum) datum)
	  (else (error "Bad tagged datum -- CONTENTS" datum))))

  (define (integer? x)
    (eq? (type-tag x) 'integer))
  (define (rectangular? z)
    (eq? (type-tag z) 'rectangular))

  (define (polar? z)
    (eq? (type-tag z) 'polar))


  (define (real-part z) (apply-generic 'real-part z))
  (define (imag-part z) (apply-generic 'imag-part z))
  (define (magnitude z) (apply-generic 'magnitude z))
  (define (angle z) (apply-generic 'angle z))

  (define (add x y) (apply-generic 'add x y))
  (define (sub x y) (apply-generic 'sub x y))
  (define (mul x y) (apply-generic 'mul x y))
  (define (div x y) (apply-generic 'div x y))

  (define (equ? x y) (apply-generic 'equ? x y))
  (define (zero? x) (apply-generic 'zero? x))

  (define (exp x y) (apply-generic 'exp x y))

  (define (install-scheme-number-package)
    (define (tag x)
      (attach-tag 'scheme-number x))
    (put 'add '(scheme-number scheme-number)
	 (lambda (x y) (tag (+ x y))))
    (put 'sub '(scheme-number scheme-number)
	 (lambda (x y) (tag (- x y))))
    (put 'mul '(scheme-number scheme-number)
	 (lambda (x y) (tag (* x y))))
    (put 'div '(scheme-number scheme-number)
	 (lambda (x y) (tag (/ x y))))
    (put 'make 'scheme-number
	 (lambda (x) (tag x)))
    (put 'equ? '(scheme-number scheme-number)
	 (lambda (x y) (= x y)))
    (put 'zero? '(scheme-number)
	 (lambda (x) (= 0 x)))
    (put 'exp '(scheme-number scheme-number)
	 (lambda (x y) (tag (expt x y))))

    'done)

  (define (make-scheme-number n)
    ((get 'make 'scheme-number) n))

  (define (install-rational-package)
    (define (numer x) (car x))
    (define (denom x) (cdr x))
    (define (make-rat n d)
      (let ((g (gcd n d)))
	(cons (/ n g) (/ d g))))
    (define (add-rat x y)
      (make-rat (+ (* (numer x) (denom y))
		   (* (numer y) (denom x)))
		(* (denom x) (denom y))))
    (define (sub-rat x y)
      (make-rat (- (* (numer x) (denom y))
		   (* (numer y) (denom x)))
		(* (denom x) (denom y))))
    (define (mul-rat x y)
      (make-rat (* (numer x) (numer y))
		(* (denom x) (denom y))))
    (define (div-rat x y)
      (make-rat (* (numer x) (denom y))
		(* (denom x) (numer y))))

    (define (tag x) (attach-tag 'rational x))
    (put 'add '(rational rational)
	 (lambda (x y) (tag (add-rat x y))))
    (put 'sub '(rational rational)
	 (lambda (x y) (tag (sub-rat x y))))
    (put 'mul '(rational rational)
	 (lambda (x y) (tag (mul-rat x y))))
    (put 'div '(rational rational)
	 (lambda (x y) (tag (div-rat x y))))

    (put 'make 'rational
	 (lambda (n d) (tag (make-rat n d))))
    (put 'equ? '(rational rational)
	 (lambda (x y) (= 0 (numer (sub-rat x y)))))
    (put 'zero? '(rational) (lambda (x) (= 0 (numer x))))
    (put 'to-real '(rational) (lambda (x) (/ (numer x) (denom x))))
    'done)

  (define (make-rational n d)
    ((get 'make 'rational) n d))

  (define (install-rectangular-package)

    (define (real-part z) (car z))
    (define (imag-part z) (cdr z))
    (define (make-from-real-imag x y) (cons x y))
    (define (magnitude z)
      (sqrt (+ (square (real-part z))
	       (square (imag-part z)))))
    (define (angle z)
      (atan (imag-part z) (real-part z)))
    (define (make-from-mag-ang r a)
      (cons (* r (cos a)) (* r (sin a))))

    (define (tag x) (attach-tag 'rectangular x))
    (put 'real-part '(rectangular) real-part)
    (put 'imag-part '(rectangular) imag-part)
    (put 'magnitude '(rectangular) magnitude)
    (put 'angle '(rectangular) angle)
    (put 'make-from-real-imag 'rectangular
	 (lambda (x y) (tag (make-from-real-imag x y))))
    (put 'make-from-mag-ang 'rectangular
	 (lambda (r a) (tag (make-from-mag-ang r a))))
    'done)

  (define (install-polar-package)

    (define (magnitude z) (car z))
    (define (angle z) (cdr z))
    (define (make-from-mag-ang r a) (cons r a))
    (define (real-part z)
      (* (magnitude z) (cos (angle z))))
    (define (imag-part z)
      (* (magnitude z) (sin (angle z))))
    (define (make-from-real-imag x y)
      (cons (sqrt (+ (square x) (square y)))
	    (atan y x)))

    (define (tag x) (attach-tag 'polar x))
    (put 'real-part '(polar) real-part)
    (put 'imag-part '(polar) imag-part)
    (put 'magnitude '(polar) magnitude)
    (put 'angle '(polar) angle)
    (put 'make-from-real-imag 'polar
	 (lambda (x y) (tag (make-from-real-imag x y))))
    (put 'make-from-mag-ang 'polar
	 (lambda (r a) (tag (make-from-mag-ang r a))))
    'done)

  (define (install-complex-package)
    (define (make-from-real-imag x y)
      ((get 'make-from-real-imag 'rectangular) x y))
    (define (make-from-mag-ang r a)
      ((get 'make-from-mag-ang 'polar) r a))
    (define (add-complex z1 z2)
      (make-from-real-imag (+ (real-part z1) (real-part z2))
			   (+ (imag-part z1) (imag-part z2))))
    (define (sub-complex z1 z2)
      (make-from-real-imag (- (real-part z1) (real-part z2))
			   (- (imag-part z1) (imag-part z2))))
    (define (mul-complex z1 z2)
      (make-from-mag-ang (* (magnitude z1) (magnitude z2))
			 (+ (angle z1) (angle z2))))
    (define (div-complex z1 z2)
      (make-from-mag-ang (/ (magnitude z1) (magnitude z2))
			 (- (angle z1) (angle z2))))
    (define (tag z) (attach-tag 'complex z))
    (put 'add '(complex complex)
	 (lambda (z1 z2) (tag (add-complex z1 z2))))
    (put 'sub '(complex complex)
	 (lambda (z1 z2) (tag (sub-complex z1 z2))))
    (put 'mul '(complex complex)
	 (lambda (z1 z2) (tag (mul-complex z1 z2))))
    (put 'div '(complex complex)
	 (lambda (z1 z2) (tag (div-complex z1 z2))))
    (put 'make-from-real-imag 'complex
	 (lambda (x y) (tag (make-from-real-imag x y))))
    (put 'make-from-mag-ang 'complex
	 (lambda (r a) (tag (make-from-mag-ang r a))))
    (put 'equ? '(complex complex)
	 (lambda (x y) (and (= 0 (real-part (sub-complex x y)))
			    (= 0 (imag-part (sub-complex x y))))))
    (put 'equ? '(rectangular polar) equ?)
    (put 'equ? '(polar rectangular) equ?)
    (put 'zero? '(complex)
	 (lambda (x) (equ? (tag x) (tag (make-from-real-imag 0 0)))))
    'done)

  (define (make-complex-from-real-imag x y)
    ((get 'make-from-real-imag 'complex) x y))

  (define (make-complex-from-mag-ang r a)
    ((get 'make-from-mag-ang 'complex) r a))

  (install-rectangular-package)
  (install-polar-package)
  (install-rational-package)
  (install-scheme-number-package)
  (install-complex-package)

  (put 'real-part '(complex) real-part)
  (put 'imag-part '(complex) imag-part)
  (put 'magnitude '(complex) magnitude)
  (put 'angle '(complex) angle)
  (define (apply-generic op . args)
    (define (all-argtypes-same? . args)
      (let ((type (type-tag (car args))))
	(accumulate (lambda (x y) (and x y)) #t (map (lambda (x) (eq? type x)) args))))
    (define (coercion-if-exists? type arg-tags)
      (let ((coercion-list (map (lambda (x)
				  (if (eq? type x)
				      identity
				      (get-coercion x type))) arg-tags)))
	(if (accumulate (lambda (x y) (and x y)) #t coercion-list)
	    coercion-list
	    #f)))
    (let* ((type-tags (map type-tag args))
	   (proc (get op type-tags)))
      (cond (proc (apply proc (map contents args)))
	    ((= 2 (length args))
	     (if (type1<=type2? (car type-tags) (cadr type-tags))
		 (apply-generic op (raise-type (car args)) (cadr args))
		 (apply-generic op (car args)  (raise-type (cadr args)))))
	    ((and (>= (length args) 2) (not (all-argtypes-same? args)))
	     (let types-loop ((types type-tags))
	       (let ((list-of-coercion-functions
		      (coercion-if-exists? (car types) type-tags)))
		 (if list-of-coercion-functions
		     (apply apply-generic (cons op (map (lambda (fun arg) (fun arg))
							list-of-coercion-functions
							args)))
		     (if (not (null? (cdr types)))
			 (types-loop (cdr types))
			 (error "Even coercions failed. No method for these types."))))))
	    (else (error "No method for these types"
			 (list op type-tags))))))
  (define (scheme-number->complex n)
    (make-complex-from-real-imag (contents n) 0))
  (put-coercion 'scheme-number
		'complex
		scheme-number->complex)

  (put 'max3-magnitude '(complex complex complex)
       (lambda (z1 z2 z3)
	 (max (magnitude z1) (magnitude z2) (magnitude z3))))
  (define (max3-magnitude x1 x2 x3) (apply-generic 'max3-magnitude x1 x2 x3))
  (define (identity x) x)

  (define numeric-tower (list 'integer 'rational 'scheme-number 'complex))

  (define (higher-type x)
    (define (find-higher-type x types)
      (cond ((or (null? types) (null? (cdr types))) (error "No type higher than given" x))
	    ((eq? x (car types)) (cadr types))
	    (else (find-higher-type x (cdr types)))))
    (find-higher-type x numeric-tower))

  (define (type1<=type2? type1 type2)
    (if (not (memq type1 numeric-tower))
	(error "Type 1 not in the numeric tower"))
    (if (not (memq type2 numeric-tower))
	(error "Type 2 not in the numeric tower"))
    (let loop ((types numeric-tower))
      (cond ((null? types) (error "Type 1 and type 2 are incomparable" type1 type2))
	    ((eq? (car types) type1) #t)
	    ((eq? (car types) type2) #f)
	    (else (loop (cdr types))))))

  (define (integer->rational x)
    (make-rational x 1))

  (define (rational->scheme-number x)
    (make-scheme-number ((get 'to-real 'rational) x)))
  (put-coercion 'integer 'rational integer->rational)
  (put-coercion 'rational 'scheme-number rational->scheme-number)

  (define (raise-type x)
    (let ((converter (get-coercion (type-tag x) (higher-type (type-tag x)))))
      (if converter
	  (converter x)
	  (error "No coercion found for x" (type-tag x) x))))


  (define (remainder-integer a b)
    (when (or (not (integer? a)) (not (integer? b)))
      (error "Arguments must be integers" a b))
    (remainder a b))

  (put 'remainder '(integer integer) remainder-integer)
  (define (remainder-generalized a b) (apply-generic 'remainder a b))


  (show #t "Remainder-integer            : " (remainder-generalized 4 2) "\n")
  (show #t "Adding (coercion to rational): " (add 5 6))
#+end_src

#+RESULTS[8ea5add6746bf0ba9d59e535ca541bb7b79a298b]:
#+begin_src scheme
Remainder-integer            : 0
Adding (coercion to rational): (rational 11 . 1)
#+end_src

This seems to do the job.

*** DONE Exercise 2.85 Dropping a type
    CLOSED: [2019-10-20 Sun 13:47]

(I didn't count the time spent on every exercise individually (although it
can be deduced from the total time spent between the CLOSED operations.), but
this exercise took me a lot of time.)

In this exercise I will use the r7rs standard library procedures ~numerator~
and ~denominator~ in order to project numbers from ~'scheme-number~ to
~'rational~.

Once again, it tangling doesn't help much in dealing with packages, so I will
copy the whole source code again.

In this exercise, I spent quite a lot of time debugging the ~(project)~,
which is how your life in programming will be any way. You spend most of your
time debugging seemingly obvious things and finding bugs in the code you
believed to be working fine. It turns out that I had to fix several bugs in
the coercion functions from the previous exercises. I am not describing those
fixed explicitly, but you may get them by comparing the code.


#+begin_src scheme :exports both :results output scalar code
  (define (project obj) (apply-generic 'project obj))
  (define (droppable? obj)
    (cond ((not (memq (type-tag obj) numeric-tower)) #f)
	  ((eq? (type-tag obj) (car numeric-tower)) #f)
	  ((equ? obj (raise-type (project obj))) #t)
	  (else #f)))
  (define (drop obj)
    (if (droppable? obj)
	(drop (project obj))
	obj))

  (define (accumulate op initial sequence)
    (if (null? sequence)
	initial
	(accumulate op (op initial (car sequence)) (cdr sequence))))
  (define false #f)
  (define true  #t)
  (define (make-table)
    (let ((local-table (list '*table*)))
      (define (lookup key-1 key-2)
	(let ((subtable (assoc key-1 (cdr local-table))))
	  (if subtable
	      (let ((record (assoc key-2 (cdr subtable))))
		(if record
		    (cdr record)
		    false))
	      false)))
      (define (insert! key-1 key-2 value)
	(let ((subtable (assoc key-1 (cdr local-table))))
	  (if subtable
	      (let ((record (assoc key-2 (cdr subtable))))
		(if record
		    (set-cdr! record value)
		    (set-cdr! subtable
			      (cons (cons key-2 value)
				    (cdr subtable)))))
	      (set-cdr! local-table
			(cons (list key-1
				    (cons key-2 value))
			      (cdr local-table)))))
	'ok)
      (define (dispatch m)
	(cond ((eq? m 'lookup-proc) lookup)
	      ((eq? m 'insert-proc!) insert!)
	      (else (error "Unknown operation -- TABLE" m))))
      dispatch))

  (define operation-table (make-table))
  (define get (operation-table 'lookup-proc))
  (define put (operation-table 'insert-proc!))

  (define coercion-table (make-table))
  (define get-coercion (coercion-table 'lookup-proc))
  (define put-coercion (coercion-table 'insert-proc!))

  (define (attach-tag type-tag contents)
    (cons type-tag contents))

  (define (type-tag datum)
    (cond ((pair? datum) (car datum))
	  ((exact-integer? datum) 'integer)
	  (error "Bad tagged datum -- TYPE-TAG" datum)))

  (define (contents datum)
    (cond ((pair? datum) (cdr datum))
	  ((integer? datum) datum)
	  (else (error "Bad tagged datum -- CONTENTS" datum))))

  (define (integer? x)
    (eq? (type-tag x) 'integer))
  (define (rectangular? z)
    (eq? (type-tag z) 'rectangular))

  (define (polar? z)
    (eq? (type-tag z) 'polar))


  (define (real-part z) (apply-generic 'real-part z))
  (define (imag-part z) (apply-generic 'imag-part z))
  (define (magnitude z) (apply-generic 'magnitude z))
  (define (angle z) (apply-generic 'angle z))

  (define (add x y) (apply-generic 'add x y))
  (define (sub x y) (apply-generic 'sub x y))
  (define (mul x y) (apply-generic 'mul x y))
  (define (div x y) (apply-generic 'div x y))

  (define (equ? x y)
    (apply-generic 'equ? x y))
  (define (zero? x) (apply-generic 'zero? x))

  (define (exp x y) (apply-generic 'exp x y))

  (define (install-scheme-number-package)
    (define (tag x)
      (attach-tag 'scheme-number x))
    (put 'add '(scheme-number scheme-number)
	 (lambda (x y) (tag (+ x y))))
    (put 'sub '(scheme-number scheme-number)
	 (lambda (x y) (tag (- x y))))
    (put 'mul '(scheme-number scheme-number)
	 (lambda (x y) (tag (* x y))))
    (put 'div '(scheme-number scheme-number)
	 (lambda (x y) (tag (/ x y))))
    (put 'make 'scheme-number
	 (lambda (x) (tag x)))
    (put 'equ? '(scheme-number scheme-number)
	 (lambda (x y) (= x y)))
    (put 'zero? '(scheme-number)
	 (lambda (x) (= 0 x)))
    (put 'exp '(scheme-number scheme-number)
	 (lambda (x y) (tag (expt x y))))
    (put 'project '(scheme-number)
	 (lambda (x)
	   (make-rational
	    (exact (numerator x))
	    (exact (denominator x)))))
    'done)

  (define (make-scheme-number n)
    ((get 'make 'scheme-number) n))

  (define (install-rational-package)
    (define (numer x) (car x))
    (define (denom x) (cdr x))
    (define (make-rat n d)
      (let ((g (gcd n d)))
	(cons (/ n g) (/ d g))))
    (define (add-rat x y)
      (make-rat (+ (* (numer x) (denom y))
		   (* (numer y) (denom x)))
		(* (denom x) (denom y))))
    (define (sub-rat x y)
      (make-rat (- (* (numer x) (denom y))
		   (* (numer y) (denom x)))
		(* (denom x) (denom y))))
    (define (mul-rat x y)
      (make-rat (* (numer x) (numer y))
		(* (denom x) (denom y))))
    (define (div-rat x y)
      (make-rat (* (numer x) (denom y))
		(* (denom x) (numer y))))

    (define (tag x) (attach-tag 'rational x))
    (put 'add '(rational rational)
	 (lambda (x y) (tag (add-rat x y))))
    (put 'sub '(rational rational)
	 (lambda (x y) (tag (sub-rat x y))))
    (put 'mul '(rational rational)
	 (lambda (x y) (tag (mul-rat x y))))
    (put 'div '(rational rational)
	 (lambda (x y) (tag (div-rat x y))))

    (put 'make 'rational
	 (lambda (n d) (tag (make-rat n d))))
    (put 'equ? '(rational rational)
	 (lambda (x y) (= 0 (numer (sub-rat x y)))))
    (put 'zero? '(rational) (lambda (x) (= 0 (numer x))))
    (put 'project '(rational) (lambda (x) (exact (truncate (/ (numer x) (denom x))))))
    (put 'to-real '(rational) (lambda (x) (/ (numer (contents x)) (denom (contents x)))))
    'done)

  (define (make-rational n d)
    ((get 'make 'rational) n d))

  (define (install-rectangular-package)

    (define (real-part z) (car z))
    (define (imag-part z) (cdr z))
    (define (make-from-real-imag x y) (cons x y))
    (define (magnitude z)
      (sqrt (+ (square (real-part z))
	       (square (imag-part z)))))
    (define (angle z)
      (atan (imag-part z) (real-part z)))
    (define (make-from-mag-ang r a)
      (cons (* r (cos a)) (* r (sin a))))

    (define (tag x) (attach-tag 'rectangular x))
    (put 'real-part '(rectangular) real-part)
    (put 'imag-part '(rectangular) imag-part)
    (put 'magnitude '(rectangular) magnitude)
    (put 'angle '(rectangular) angle)
    (put 'make-from-real-imag 'rectangular
	 (lambda (x y) (tag (make-from-real-imag x y))))
    (put 'make-from-mag-ang 'rectangular
	 (lambda (r a) (tag (make-from-mag-ang r a))))
    'done)

  (define (install-polar-package)

    (define (magnitude z) (car z))
    (define (angle z) (cdr z))
    (define (make-from-mag-ang r a) (cons r a))
    (define (real-part z)
      (* (magnitude z) (cos (angle z))))
    (define (imag-part z)
      (* (magnitude z) (sin (angle z))))
    (define (make-from-real-imag x y)
      (cons (sqrt (+ (square x) (square y)))
	    (atan y x)))

    (define (tag x) (attach-tag 'polar x))
    (put 'real-part '(polar) real-part)
    (put 'imag-part '(polar) imag-part)
    (put 'magnitude '(polar) magnitude)
    (put 'angle '(polar) angle)
    (put 'make-from-real-imag 'polar
	 (lambda (x y) (tag (make-from-real-imag x y))))
    (put 'make-from-mag-ang 'polar
	 (lambda (r a) (tag (make-from-mag-ang r a))))
    'done)

  (define (install-complex-package)
    (define (make-from-real-imag x y)
      ((get 'make-from-real-imag 'rectangular) x y))
    (define (make-from-mag-ang r a)
      ((get 'make-from-mag-ang 'polar) r a))
    (define (add-complex z1 z2)
      (make-from-real-imag (+ (real-part z1) (real-part z2))
			   (+ (imag-part z1) (imag-part z2))))
    (define (sub-complex z1 z2)
      (make-from-real-imag (- (real-part z1) (real-part z2))
			   (- (imag-part z1) (imag-part z2))))
    (define (mul-complex z1 z2)
      (make-from-mag-ang (* (magnitude z1) (magnitude z2))
			 (+ (angle z1) (angle z2))))
    (define (div-complex z1 z2)
      (make-from-mag-ang (/ (magnitude z1) (magnitude z2))
			 (- (angle z1) (angle z2))))
    (define (tag z) (attach-tag 'complex z))
    (put 'add '(complex complex)
	 (lambda (z1 z2) (tag (add-complex z1 z2))))
    (put 'sub '(complex complex)
	 (lambda (z1 z2) (tag (sub-complex z1 z2))))
    (put 'mul '(complex complex)
	 (lambda (z1 z2) (tag (mul-complex z1 z2))))
    (put 'div '(complex complex)
	 (lambda (z1 z2) (tag (div-complex z1 z2))))
    (put 'make-from-real-imag 'complex
	 (lambda (x y) (tag (make-from-real-imag x y))))
    (put 'make-from-mag-ang 'complex
	 (lambda (r a) (tag (make-from-mag-ang r a))))
    (put 'equ? '(complex complex)
	 (lambda (x y) (and (= 0 (real-part (sub-complex x y)))
			    (= 0 (imag-part (sub-complex x y))))))
    (put 'equ? '(rectangular polar) equ?)
    (put 'equ? '(polar rectangular) equ?)
    (put 'zero? '(complex)
	 (lambda (x) (equ? (tag x) (tag (make-from-real-imag 0 0)))))
    (put 'project '(complex) (lambda (z) (make-scheme-number (real-part z))))
    'done)

  (define (make-complex-from-real-imag x y)
    ((get 'make-from-real-imag 'complex) x y))

  (define (make-complex-from-mag-ang r a)
    ((get 'make-from-mag-ang 'complex) r a))

  (install-rectangular-package)
  (install-polar-package)
  (install-rational-package)
  (install-scheme-number-package)
  (install-complex-package)

  (put 'real-part '(complex) real-part)
  (put 'imag-part '(complex) imag-part)
  (put 'magnitude '(complex) magnitude)
  (put 'angle '(complex) angle)

  (define (apply-generic op . args)
    (define (all-argtypes-same? . args)
      (let ((type (type-tag (car args))))
	(accumulate (lambda (x y) (and x y)) #t (map (lambda (x) (eq? type x)) args))))
    (define (coercion-if-exists? type arg-tags)
      (let ((coercion-list (map (lambda (x)
				  (if (eq? type x)
				      identity
				      (get-coercion x type))) arg-tags)))
	(if (accumulate (lambda (x y) (and x y)) #t coercion-list)
	    coercion-list
	    #f)))
    (let ((application-result (let* ((type-tags (map type-tag args))
		 (proc (get op type-tags)))
	    (cond (proc (apply proc (map contents args)))
		  ((= 2 (length args))
		   (if (type1<=type2? (car type-tags) (cadr type-tags))
		       (apply-generic op (raise-type (car args)) (cadr args))
		       (apply-generic op (car args)  (raise-type (cadr args)))))
		  ((and (>= (length args) 2) (not (all-argtypes-same? args)))
		   (let types-loop ((types type-tags))
		     (let ((list-of-coercion-functions
			    (coercion-if-exists? (car types) type-tags)))
		       (if list-of-coercion-functions
			   (apply apply-generic (cons op (map (lambda (fun arg) (fun arg))
							      list-of-coercion-functions
							      args)))
			   (if (not (null? (cdr types)))
			       (types-loop (cdr types))
			       (error "apply-generic:Even coercions failed. No method for these types."))))))
		  (else (error "apply-generic:No method for these types"
			       (list op type-tags)))))))
            #;(show #t "Application result: " (pretty application-result))
            (drop application-result)))
  (define (scheme-number->complex n)
    (make-complex-from-real-imag (contents n) 0))
  (put-coercion 'scheme-number
		'complex
		scheme-number->complex)

  (put 'max3-magnitude '(complex complex complex) (lambda (z1 z2 z3)
						    (max (magnitude z1) (magnitude z2) (magnitude z3))))
  (define (max3-magnitude x1 x2 x3) (apply-generic 'max3-magnitude x1 x2 x3))
  (define (identity x) x)

  (define numeric-tower (list 'integer 'rational 'scheme-number 'complex))

  (define (higher-type x)
    (define (find-higher-type x types)
      (cond ((or (null? types) (null? (cdr types))) (error "No type higher than given" x))
	    ((eq? x (car types)) (cadr types))
	    (else (find-higher-type x (cdr types)))))
    (find-higher-type x numeric-tower))

  (define (type1<=type2? type1 type2)
    (if (not (memq type1 numeric-tower))
	(error "Type 1 not in the numeric tower"))
    (if (not (memq type2 numeric-tower))
	(error "Type 2 not in the numeric tower"))
    (let loop ((types numeric-tower))
      (cond ((null? types) (error "Type 1 and type 2 are incomparable" type1 type2))
	    ((eq? (car types) type1) #t)
	    ((eq? (car types) type2) #f)
	    (else (loop (cdr types))))))

  (define (integer->rational x)
    (make-rational x 1))

  (define (rational->scheme-number x)
    (make-scheme-number ((get 'to-real '(rational)) x)))
  (put-coercion 'integer 'rational integer->rational)
  (put-coercion 'rational 'scheme-number rational->scheme-number)

  (define (raise-type x)
    (let ((converter (get-coercion (type-tag x) (higher-type (type-tag x)))))
      (if converter
	  (converter x)
	  (error "No coercion found for x" (type-tag x) x))))


  (define (remainder-integer a b)
    (when (or (not (integer? a)) (not (integer? b)))
      (error "Arguments must be integers" a b))
    (remainder a b))

  (put 'remainder '(integer integer) remainder-integer)
  (define (remainder-generalized a b) (apply-generic 'remainder a b))


  (show #t "Test: " (make-complex-from-real-imag 1 0) "\n")
  (show #t "Test: " (droppable? (make-complex-from-real-imag 1 0)) "\n")
  (show #t "Test: " (droppable? 1) "\n")
  
  #;(show #t "Test 2: projecting a 'scheme-number: " (displayed (project (make-scheme-number 1))) "\n")
  #;(show #t "Test 3:" (drop (make-complex-from-real-imag 1 0)) "\n")
  (show #t "Subtracting complex numbers: "
	(sub
	 (make-complex-from-real-imag 1 2)
	 (make-complex-from-real-imag 0 2)) "\n")
  #;(show #t "Dropping #t: " (drop #t) "\n")
  #;(show #t "Dropping #f: " (drop #f) "\n")
  #;(show #t
  "(equ? (raise-type (project '(complex rectangular 1 0))) '(complex rectangular 1 0))"
  (equ? (raise-type (project '(complex rectangular 1 0))) '(complex rectangular 1 0)))
  #;(show #t (drop '(complex rectangular 1 0)) "\n")
  #;(show #t "Testing project: " (displayed (project (make-complex-from-real-imag 1 0))) "\n")
  #;(show #t "Testing: " (displayed (equ? (make-complex-from-real-imag 2 0) (raise-type (project (make-complex-from-real-imag 2 1))))) "\n")
#+end_src

#+RESULTS[f80e462b0d543d6d00502c95f6441fbc90bde6bb]:
#+begin_src scheme
Test: (complex rectangular 1 . 0)
Test: #t
Test: #f
Subtracting complex numbers: 1
#+end_src

*** DONE Exercise 2.86 Compound complex numbers
    CLOSED: [2019-10-20 Sun 20:22]

At the moment, our complex numbers are pairs of two built-in real numbers. We
need to be able to build them from rational and integer numbers too.

Again, since the changes we are doing here are not additive, I will just copy
the whole system in one block.

It seems that implementing sines and cosines over 'scheme-number's is enough,
because the other types should be covered by coercion.

#+begin_src scheme :exports both :results output scalar code
  (define (project obj)
    (show #t "Project function: " obj "\n")
    (apply-generic 'project obj))
  (define (droppable? obj)
    (cond ((not (memq (type-tag obj) numeric-tower)) #f)
	  ((eq? (type-tag obj) (car numeric-tower)) #f)
	  ((equ? obj (raise-type (project obj))) #t)
	  (else #f)))
  (define (drop obj)
       (if (droppable? obj)
	   (drop (project obj))
	   obj))
    (define (accumulate op initial sequence)
      (if (null? sequence)
	  initial
	  (accumulate op (op initial (car sequence)) (cdr sequence))))
    (define false #f)
    (define true  #t)
    (define (make-table)
      (let ((local-table (list '*table*)))
	(define (lookup key-1 key-2)
	  (let ((subtable (assoc key-1 (cdr local-table))))
	    (if subtable
		(let ((record (assoc key-2 (cdr subtable))))
		  (if record
		      (cdr record)
		      false))
		false)))
	(define (insert! key-1 key-2 value)
	  (let ((subtable (assoc key-1 (cdr local-table))))
	    (if subtable
		(let ((record (assoc key-2 (cdr subtable))))
		  (if record
		      (set-cdr! record value)
		      (set-cdr! subtable
				(cons (cons key-2 value)
				      (cdr subtable)))))
		(set-cdr! local-table
			  (cons (list key-1
				      (cons key-2 value))
				(cdr local-table)))))
	  'ok)
	(define (dispatch m)
	  (cond ((eq? m 'lookup-proc) lookup)
		((eq? m 'insert-proc!) insert!)
		(else (error "Unknown operation -- TABLE" m))))
	dispatch))

    (define operation-table (make-table))
    (define get (operation-table 'lookup-proc))
    (define put (operation-table 'insert-proc!))

    (define coercion-table (make-table))
    (define get-coercion (coercion-table 'lookup-proc))
    (define put-coercion (coercion-table 'insert-proc!))

    (define (attach-tag type-tag contents)
      (cons type-tag contents))

    (define (type-tag datum)
      (cond ((pair? datum) (car datum))
	    ((exact-integer? datum) 'integer)
	    ((real? datum) 'scheme-number)
	    (error "Bad tagged datum -- TYPE-TAG" datum)))

    (define (contents datum)
      (cond ((pair? datum) (cdr datum))
	    ((integer? datum) datum)
	    ((real? datum) datum)
	    (else (error "Bad tagged datum -- CONTENTS" datum))))

    (define (integer? x)
      (eq? (type-tag x) 'integer))
    (define (rectangular? z)
      (eq? (type-tag z) 'rectangular))

    (define (polar? z)
      (eq? (type-tag z) 'polar))


    (define (real-part z) (apply-generic 'real-part z))
    (define (imag-part z) (apply-generic 'imag-part z))
    (define (magnitude z) (apply-generic 'magnitude z))
    (define (angle z) (apply-generic 'angle z))

    (define (add x y) (apply-generic 'add x y))
    (define (sub x y) (apply-generic 'sub x y))
    (define (mul x y) (apply-generic 'mul x y))
    (define (div x y) (apply-generic 'div x y))

    (define (equ? x y)
      (apply-generic 'equ? x y))
    (define (zero? x) (apply-generic 'zero? x))

    (define (exp x y) (apply-generic 'exp x y))

    (define (install-scheme-number-package)
      (define (tag x)
	(attach-tag 'scheme-number x))
      (put 'add '(scheme-number scheme-number)
	   (lambda (x y) (tag (+ x y))))
      (put 'sub '(scheme-number scheme-number)
	   (lambda (x y) (tag (- x y))))
      (put 'mul '(scheme-number scheme-number)
	   (lambda (x y) (tag (* x y))))
      (put 'div '(scheme-number scheme-number)
	   (lambda (x y) (tag (/ x y))))
      (put 'make 'scheme-number
	   (lambda (x) (tag x)))
      (put 'equ? '(scheme-number scheme-number)
	   (lambda (x y) (= x y)))
      (put 'zero? '(scheme-number)
	   (lambda (x) (= 0 x)))
      (put 'exp '(scheme-number scheme-number)
	   (lambda (x y) (tag (expt x y))))
      (put 'project '(scheme-number)
	   (lambda (x)
	     (show #t "Calling project 'scheme-number\n")
	     (make-rational
	      (exact (numerator x))
	      (exact (denominator x)))))
      (put 'sine '(scheme-number) sin)
      (put 'cosine '(scheme-number) cos)
      (put 'square-root '(scheme-number) sqrt)
      (put 'arctangent '(schemer-number) atan)
      'done)

  (define (sine x) (apply-generic 'sine x))
  (define (cosine x) (apply-generic 'cosine x))
  (define (square-root x) (apply-generic 'square-root x))
  (define (arctangent x) (apply-generic 'arctangent x))

    (define (make-scheme-number n)
      ((get 'make 'scheme-number) n))

    (define (install-rational-package)
      (define (numer x) (car x))
      (define (denom x) (cdr x))
      (define (make-rat n d)
	(let ((g (gcd n d)))
	  (cons (/ n g) (/ d g))))
      (define (add-rat x y)
	(make-rat (+ (* (numer x) (denom y))
		     (* (numer y) (denom x)))
		  (* (denom x) (denom y))))
      (define (sub-rat x y)
	(make-rat (- (* (numer x) (denom y))
		     (* (numer y) (denom x)))
		  (* (denom x) (denom y))))
      (define (mul-rat x y)
	(make-rat (* (numer x) (numer y))
		  (* (denom x) (denom y))))
      (define (div-rat x y)
	(make-rat (* (numer x) (denom y))
		  (* (denom x) (numer y))))

      (define (tag x) (attach-tag 'rational x))
      (put 'add '(rational rational)
	   (lambda (x y) (tag (add-rat x y))))
      (put 'sub '(rational rational)
	   (lambda (x y) (tag (sub-rat x y))))
      (put 'mul '(rational rational)
	   (lambda (x y) (tag (mul-rat x y))))
      (put 'div '(rational rational)
	   (lambda (x y) (tag (div-rat x y))))

      (put 'make 'rational
	   (lambda (n d) (tag (make-rat n d))))
      (put 'equ? '(rational rational)
	   (lambda (x y) (= 0 (numer (sub-rat x y)))))
      (put 'zero? '(rational) (lambda (x) (= 0 (numer x))))
      (put 'project '(rational) (lambda (x) (show #t "Calling project rational, x=" x "\n")
				   (exact (truncate (/ (numer x) (denom x))))))
      (put 'to-real '(rational) (lambda (x) (/ (numer (contents x)) (denom (contents x)))))
      'done)

    (define (make-rational n d)
      ((get 'make 'rational) n d))

    (define (install-rectangular-package)

      (define (real-part z) (car z))
      (define (imag-part z) (cdr z))
      (define (make-from-real-imag x y) (cons x y))
      (define (magnitude z)
	(square-root (add (square (real-part z))
			  (square (imag-part z)))))
      (define (angle z)
	(arctangent (imag-part z) (real-part z)))
      (define (make-from-mag-ang r a)
	(cons (mul r (cosine a)) (mul r (sine a))))

      (define (tag x) (attach-tag 'rectangular x))
      (put 'real-part '(rectangular) real-part)
      (put 'imag-part '(rectangular) imag-part)
      (put 'magnitude '(rectangular) magnitude)
      (put 'angle '(rectangular) angle)
      (put 'make-from-real-imag 'rectangular
	   (lambda (x y) (tag (make-from-real-imag x y))))
      (put 'make-from-mag-ang 'rectangular
	   (lambda (r a) (tag (make-from-mag-ang r a))))
      'done)

    (define (install-polar-package)

      (define (magnitude z) (car z))
      (define (angle z) (cdr z))
      (define (make-from-mag-ang r a) (cons r a))
      (define (real-part z)
	(mul (magnitude z) (cosine (angle z))))
      (define (imag-part z)
	(mul (magnitude z) (sine (angle z))))
      (define (make-from-real-imag x y)
	(cons (square-root (add (square x) (square y)))
	      (arctangent y x)))

      (define (tag x) (attach-tag 'polar x))
      (put 'real-part '(polar) real-part)
      (put 'imag-part '(polar) imag-part)
      (put 'magnitude '(polar) magnitude)
      (put 'angle '(polar) angle)
      (put 'make-from-real-imag 'polar
	   (lambda (x y) (tag (make-from-real-imag x y))))
      (put 'make-from-mag-ang 'polar
	   (lambda (r a) (tag (make-from-mag-ang r a))))
      'done)

    (define (install-complex-package)
      (define (make-from-real-imag x y)
	((get 'make-from-real-imag 'rectangular) x y))
      (define (make-from-mag-ang r a)
	((get 'make-from-mag-ang 'polar) r a))
      (define (add-complex z1 z2)
	(make-from-real-imag (add (real-part z1) (real-part z2))
			     (add (imag-part z1) (imag-part z2))))
      (define (sub-complex z1 z2)
	(make-from-real-imag (sub (real-part z1) (real-part z2))
			     (sub (imag-part z1) (imag-part z2))))
      (define (mul-complex z1 z2)
	(make-from-mag-ang (mul (magnitude z1) (magnitude z2))
			   (add (angle z1) (angle z2))))
      (define (div-complex z1 z2)
	(make-from-mag-ang (div (magnitude z1) (magnitude z2))
			   (sub (angle z1) (angle z2))))
      (define (tag z) (attach-tag 'complex z))
      (put 'add '(complex complex)
	   (lambda (z1 z2) (tag (add-complex z1 z2))))
      (put 'sub '(complex complex)
	   (lambda (z1 z2) (tag (sub-complex z1 z2))))
      (put 'mul '(complex complex)
	   (lambda (z1 z2) (tag (mul-complex z1 z2))))
      (put 'div '(complex complex)
	   (lambda (z1 z2) (tag (div-complex z1 z2))))
      (put 'make-from-real-imag 'complex
	   (lambda (x y) (tag (make-from-real-imag x y))))
      (put 'make-from-mag-ang 'complex
	   (lambda (r a) (tag (make-from-mag-ang r a))))
      (put 'equ? '(complex complex)
	   (lambda (x y) (and (= 0 (real-part (sub-complex x y)))
			      (= 0 (imag-part (sub-complex x y))))))
      (put 'equ? '(rectangular polar) equ?)
      (put 'equ? '(polar rectangular) equ?)
      (put 'zero? '(complex)
	   (lambda (x) (equ? (tag x) (tag (make-from-real-imag 0 0)))))
      (put 'project '(complex) (lambda (z) (real-part z)))
      'done)

    (define (make-complex-from-real-imag x y)
      ((get 'make-from-real-imag 'complex) x y))

    (define (make-complex-from-mag-ang r a)
      ((get 'make-from-mag-ang 'complex) r a))

    (install-rectangular-package)
    (install-polar-package)
    (install-rational-package)
    (install-scheme-number-package)
    (install-complex-package)

    (put 'real-part '(complex) real-part)
    (put 'imag-part '(complex) imag-part)
    (put 'magnitude '(complex) magnitude)
    (put 'angle '(complex) angle)

    (define (apply-generic op . args)
      (define (all-argtypes-same? . args)
	(let ((type (type-tag (car args))))
	  (accumulate (lambda (x y) (and x y)) #t (map (lambda (x) (eq? type x)) args))))
      (define (coercion-if-exists? type arg-tags)
	(let ((coercion-list (map (lambda (x)
				    (if (eq? type x)
					identity
					(get-coercion x type))) arg-tags)))
	  (if (accumulate (lambda (x y) (and x y)) #t coercion-list)
	      coercion-list
	      #f)))
      (drop (let* ((type-tags (map type-tag args))
		   (proc (get op type-tags)))
	      (cond (proc (apply proc (map contents args)))
		    ((= 1 (length args))
		     (apply-generic op (raise-type (car args))))
		    ((= 2 (length args))
		     (if (type1<=type2? (car type-tags) (cadr type-tags))
			 (apply-generic op (raise-type (car args)) (cadr args))
			 (apply-generic op (car args)  (raise-type (cadr args)))))
		    ((and (>= (length args) 2) (not (all-argtypes-same? args)))
		     (let types-loop ((types type-tags))
		       (let ((list-of-coercion-functions
			      (coercion-if-exists? (car types) type-tags)))
			 (if list-of-coercion-functions
			     (apply apply-generic (cons op (map (lambda (fun arg) (fun arg))
								list-of-coercion-functions
								args)))
			     (if (not (null? (cdr types)))
				 (types-loop (cdr types))
				 (error "apply-generic:Even coercions failed. No method for these types."))))))
		    (else (error "apply-generic:No method for these types"
				 (list op type-tags)))))))
    (define (scheme-number->complex n)
      (make-complex-from-real-imag (contents n) 0))
    (put-coercion 'scheme-number
		  'complex
		  scheme-number->complex)

    (put 'max3-magnitude '(complex complex complex) (lambda (z1 z2 z3)
						      (max (magnitude z1) (magnitude z2) (magnitude z3))))
    (define (max3-magnitude x1 x2 x3) (apply-generic 'max3-magnitude x1 x2 x3))
    (define (identity x) x)

    (define numeric-tower (list 'integer 'rational 'scheme-number 'complex))

    (define (higher-type x)
      (define (find-higher-type x types)
	(cond ((or (null? types) (null? (cdr types))) (error "No type higher than given" x))
	      ((eq? x (car types)) (cadr types))
	      (else (find-higher-type x (cdr types)))))
      (find-higher-type x numeric-tower))

    (define (type1<=type2? type1 type2)
      (if (not (memq type1 numeric-tower))
	  (error "Type 1 not in the numeric tower"))
      (if (not (memq type2 numeric-tower))
	  (error "Type 2 not in the numeric tower"))
      (let loop ((types numeric-tower))
	(cond ((null? types) (error "Type 1 and type 2 are incomparable" type1 type2))
	      ((eq? (car types) type1) #t)
	      ((eq? (car types) type2) #f)
	      (else (loop (cdr types))))))

    (define (integer->rational x)
      (make-rational x 1))

    (define (rational->scheme-number x)
      (make-scheme-number ((get 'to-real '(rational)) x)))
    (put-coercion 'integer 'rational integer->rational)
    (put-coercion 'rational 'scheme-number rational->scheme-number)

    (define (raise-type x)
      (let ((converter (get-coercion (type-tag x) (higher-type (type-tag x)))))
	(if converter
	    (converter x)
	    (error "No coercion found for x" (type-tag x) x))))


    (define (remainder-integer a b)
      (when (or (not (integer? a)) (not (integer? b)))
	(error "Arguments must be integers" a b))
      (remainder a b))

    (put 'remainder '(integer integer) remainder-integer)
    (define (remainder-generalized a b) (apply-generic 'remainder a b))



    (show #t "Subtracting complex numbers: "
	  (sub
	   (make-complex-from-real-imag 1.1 2)
	   (make-complex-from-real-imag 0 2)) "\n")

#+end_src

#+RESULTS[98ce38e9eab43d5cfb31e52122d20933ed898526]:
#+begin_src scheme
Project function: (rational 0 . 1)
Calling project rational, x=(0 . 1)
Project function: (rational 0 . 1)
Calling project rational, x=(0 . 1)
Project function: 1.1
Calling project 'scheme-number
Project function: (rational 2476979795053773 . 2251799813685248)
Calling project rational, x=(2476979795053773 . 2251799813685248)
Project function: 1.1
Calling project 'scheme-number
Project function: (rational 2476979795053773 . 2251799813685248)
Calling project rational, x=(2476979795053773 . 2251799813685248)
Project function: (rational 2476979795053773 . 2251799813685248)
Calling project rational, x=(2476979795053773 . 2251799813685248)
Project function: (rational 2476979795053773 . 2251799813685248)
Calling project rational, x=(2476979795053773 . 2251799813685248)
Project function: (rational 2476979795053773 . 2251799813685248)
Calling project rational, x=(2476979795053773 . 2251799813685248)
Project function: (complex rectangular (rational 2476979795053773 . 2251799813685248) . 0)
Project function: (rational 2476979795053773 . 2251799813685248)
Calling project rational, x=(2476979795053773 . 2251799813685248)
Project function: (rational 2476979795053773 . 2251799813685248)
Calling project rational, x=(2476979795053773 . 2251799813685248)
Project function: (rational 0 . 1)
Calling project rational, x=(0 . 1)
Project function: (rational 0 . 1)
Calling project rational, x=(0 . 1)
Project function: 2476979795053773/2251799813685248
Calling project 'scheme-number
Project function: (rational 2476979795053773 . 2251799813685248)
Calling project rational, x=(2476979795053773 . 2251799813685248)
Project function: 2476979795053773/2251799813685248
Calling project 'scheme-number
Project function: (rational 2476979795053773 . 2251799813685248)
Calling project rational, x=(2476979795053773 . 2251799813685248)
Project function: (rational 2476979795053773 . 2251799813685248)
Calling project rational, x=(2476979795053773 . 2251799813685248)
Project function: (rational 2476979795053773 . 2251799813685248)
Calling project rational, x=(2476979795053773 . 2251799813685248)
Project function: (rational 0 . 1)
Calling project rational, x=(0 . 1)
Project function: (rational 0 . 1)
Calling project rational, x=(0 . 1)
Project function: (rational 0 . 1)
Calling project rational, x=(0 . 1)
Project function: (rational 0 . 1)
Calling project rational, x=(0 . 1)
Project function: 2476979795053773/2251799813685248
Calling project 'scheme-number
Project function: (rational 2476979795053773 . 2251799813685248)
Calling project rational, x=(2476979795053773 . 2251799813685248)
Project function: 2476979795053773/2251799813685248
Calling project 'scheme-number
Project function: (rational 2476979795053773 . 2251799813685248)
Calling project rational, x=(2476979795053773 . 2251799813685248)
Project function: (rational 2476979795053773 . 2251799813685248)
Calling project rational, x=(2476979795053773 . 2251799813685248)
Project function: (rational 2476979795053773 . 2251799813685248)
Calling project rational, x=(2476979795053773 . 2251799813685248)
Project function: (rational 0 . 1)
Calling project rational, x=(0 . 1)
Project function: (rational 0 . 1)
Calling project rational, x=(0 . 1)
Project function: (complex rectangular (rational 2476979795053773 . 2251799813685248) . 0)
Project function: (rational 2476979795053773 . 2251799813685248)
Calling project rational, x=(2476979795053773 . 2251799813685248)
Project function: (rational 2476979795053773 . 2251799813685248)
Calling project rational, x=(2476979795053773 . 2251799813685248)
Project function: (rational 2476979795053773 . 2251799813685248)
Calling project rational, x=(2476979795053773 . 2251799813685248)
Subtracting complex numbers: (rational 2476979795053773 . 2251799813685248)
#+end_src

All right, this seems super fragile, but somehow works.


This piece will probably also be quite hairy, so it probably will be a good
idea to write down the code examples.

#+name: polynomial-package
#+begin_src scheme :exports code :results none
  (define (install-polynomial-package)
    #;(internal procedures)
    #;(representation of poly)
    (define (make-poly variable term-list)
      (cons variable term-list))
    (define (variable p) (car p))
    (define (term-list p) (cdr p))

    (define (variable? x) (symbol? x))
    (define (same-variable? v1 v2)
      (and (variable? v1) (variable? v2) (eq? v1 v2)))
    (define (=number? exp num)
      (and (number? exp) (= exp num)))

    #;(representation of terms and term lists)

    (define (adjoin-term term term-list)
      (if (=zero? (coeff term))
	  term-list
	  (cons term term-list)))

    (define (the-empty-termlist) '())
    (define (first-term term-list) (car term-list))
    (define (rest-terms term-list) (cdr term-list))
    (define (empty-termlist? term-list) (null? term-list))

    (define (make-term order coeff) (list order coeff))
    (define (order term) (car term))
    (define (coeff term) (cadr term))

    #;(continued on next page)

    (define (add-poly p1 p2)
      (if (same-variable? (variable p1) (variable p2))
	  (make-poly (variable p1)
		     (add-terms (term-list p1)
				(term-list p2)))
	  (error "Polys not in same var -- ADD-POLY"
		 (list p1 p2))))

    (define (mul-poly p1 p2)
      (if (same-variable? (variable p1) (variable p2))
	  (make-poly (variable p1)
		     (mul-terms (term-list p1)
				(term-list p2)))
	  (error "Polys not in same var -- MUL-POLY"
		 (list p1 p2))))

    #;(interface to rest of the system)
    (define (tag p) (attach-tag 'polynomial p))
    (put 'add '(polynomial polynomial)
	 (lambda (p1 p2) (tag (add-poly p1 p2))))
    (put 'mul '(polynomial polynomial)
	 (lambda (p1 p2) (tag (mul-poly p1 p2))))
    (put 'make 'polynomial
	 (lambda (var terms) (tag (make-poly var terms))))
    'done)

  (define (add-terms L1 L2)
    (cond ((empty-termlist? L1) L2)
	  ((empty-termlist? L2) L1)
	  (else
	   (let ((t1 (first-term L1)) (t2 (first-term L2)))
	     (cond ((> (order t1) (order t2))
		    (adjoin-term
		     t1 (add-terms (rest-terms L1) L2)))
		   ((< (order t1) (order t2))
		    (adjoin-term
		     t2 (add-terms L1 (rest-terms L2))))
		   (else
		    (adjoin-term
		     (make-term (order t1)
				(add (coeff t1) (coeff t2)))
		     (add-terms (rest-terms L1)
				(rest-terms L2)))))))))
  (define (mul-terms L1 L2)
    (if (empty-termlist? L1)
	(the-empty-termlist)
	(add-terms (mul-term-by-all-terms (first-term L1) L2)
		   (mul-terms (rest-terms L1) L2))))

  (define (mul-term-by-all-terms t1 L)
    (if (empty-termlist? L)
	(the-empty-termlist)
	(let ((t2 (first-term L)))
	  (adjoin-term
	   (make-term (+ (order t1) (order t2))
		      (mul (coeff t1) (coeff t2)))
	   (mul-term-by-all-terms t1 (rest-terms L))))))

  (define (make-polynomial var terms)
    ((get 'make 'polynomial) var terms))

#+end_src

*** DONE Exercise 2.87 Generalized zero?
    CLOSED: [2019-10-21 Mon 18:25]

Remark 1: Even before I started solving anything, it required me 2.5 hours in
order to just make the examples run and add a couple of simple polynomials.


#+begin_src scheme :exports both :results output scalar code
      (define (project obj)
	(apply-generic 'project obj))
      (define (droppable? obj)
	(cond ((not (memq (type-tag obj) numeric-tower)) #f)
	      ((eq? (type-tag obj) (car numeric-tower)) #f)
	      ((equ? obj (raise-type (project obj))) #t)
	      (else #f)))
      (define (drop obj)
	   (if (droppable? obj)
	       (drop (project obj))
	       obj))

	(define (accumulate op initial sequence)
	  (if (null? sequence)
	      initial
	      (accumulate op (op initial (car sequence)) (cdr sequence))))
	(define false #f)
	(define true  #t)
	(define (make-table)
	  (let ((local-table (list '*table*)))
	    (define (lookup key-1 key-2)
	      (let ((subtable (assoc key-1 (cdr local-table))))
		(if subtable
		    (let ((record (assoc key-2 (cdr subtable))))
		      (if record
			  (cdr record)
			  false))
		    false)))
	    (define (insert! key-1 key-2 value)
	      (let ((subtable (assoc key-1 (cdr local-table))))
		(if subtable
		    (let ((record (assoc key-2 (cdr subtable))))
		      (if record
			  (set-cdr! record value)
			  (set-cdr! subtable
				    (cons (cons key-2 value)
					  (cdr subtable)))))
		    (set-cdr! local-table
			      (cons (list key-1
					  (cons key-2 value))
				    (cdr local-table)))))
	      'ok)
	    (define (dispatch m)
	      (cond ((eq? m 'lookup-proc) lookup)
		    ((eq? m 'insert-proc!) insert!)
		    (else (error "Unknown operation -- TABLE" m))))
	    dispatch))

	(define operation-table (make-table))
	(define get (operation-table 'lookup-proc))
	(define put (operation-table 'insert-proc!))

	(define coercion-table (make-table))
	(define get-coercion (coercion-table 'lookup-proc))
	(define put-coercion (coercion-table 'insert-proc!))

	(define (attach-tag type-tag contents)
	  (cons type-tag contents))

	(define (type-tag datum)
	  (cond ((pair? datum) (car datum))
		((exact-integer? datum) 'integer)
		((real? datum) 'scheme-number)
		(error "Bad tagged datum -- TYPE-TAG" datum)))

	(define (contents datum)
	  (cond ((pair? datum) (cdr datum))
		((integer? datum) datum)
		((real? datum) datum)
		(else (error "Bad tagged datum -- CONTENTS" datum))))

	(define (integer? x)
	  (eq? (type-tag x) 'integer))
	(define (rectangular? z)
	  (eq? (type-tag z) 'rectangular))

	(define (polar? z)
	  (eq? (type-tag z) 'polar))


	(define (real-part z) (apply-generic 'real-part z))
	(define (imag-part z) (apply-generic 'imag-part z))
	(define (magnitude z) (apply-generic 'magnitude z))
	(define (angle z) (apply-generic 'angle z))

	(define (add x y) (apply-generic 'add x y))
	(define (sub x y) (apply-generic 'sub x y))
	(define (mul x y) (apply-generic 'mul x y))
	(define (div x y) (apply-generic 'div x y))

	(define (equ? x y)
	  (apply-generic 'equ? x y))
	(define (zero? x) (apply-generic 'zero? x))

	(define (exp x y) (apply-generic 'exp x y))

	(define (install-scheme-number-package)
	  (define (tag x)
	    (attach-tag 'scheme-number x))
	  (put 'add '(scheme-number scheme-number)
	       (lambda (x y) (tag (+ x y))))
	  (put 'sub '(scheme-number scheme-number)
	       (lambda (x y) (tag (- x y))))
	  (put 'mul '(scheme-number scheme-number)
	       (lambda (x y) (tag (* x y))))
	  (put 'div '(scheme-number scheme-number)
	       (lambda (x y) (tag (/ x y))))
	  (put 'make 'scheme-number
	       (lambda (x) (tag x)))
	  (put 'equ? '(scheme-number scheme-number)
	       (lambda (x y) (= x y)))
	  (put 'zero? '(scheme-number)
	       (lambda (x) (= 0 x)))
	  (put 'exp '(scheme-number scheme-number)
	       (lambda (x y) (tag (expt x y))))
	  (put 'project '(scheme-number)
	       (lambda (x)
		 (make-rational
		  (exact (numerator x))
		  (exact (denominator x)))))
	  (put 'sine '(scheme-number) sin)
	  (put 'cosine '(scheme-number) cos)
	  (put 'square-root '(scheme-number) sqrt)
	  (put 'arctangent '(schemer-number) atan)
	  'done)

      (define (sine x) (apply-generic 'sine x))
      (define (cosine x) (apply-generic 'cosine x))
      (define (square-root x) (apply-generic 'square-root x))
      (define (arctangent x) (apply-generic 'arctangent x))

	(define (make-scheme-number n)
	  ((get 'make 'scheme-number) n))

	(define (install-rational-package)
	  (define (numer x) (car x))
	  (define (denom x) (cdr x))
	  (define (make-rat n d)
	    (let ((g (gcd n d)))
	      (cons (/ n g) (/ d g))))
	  (define (add-rat x y)
	    (make-rat (+ (* (numer x) (denom y))
			 (* (numer y) (denom x)))
		      (* (denom x) (denom y))))
	  (define (sub-rat x y)
	    (make-rat (- (* (numer x) (denom y))
			 (* (numer y) (denom x)))
		      (* (denom x) (denom y))))
	  (define (mul-rat x y)
	    (make-rat (* (numer x) (numer y))
		      (* (denom x) (denom y))))
	  (define (div-rat x y)
	    (make-rat (* (numer x) (denom y))
		      (* (denom x) (numer y))))

	  (define (tag x) (attach-tag 'rational x))
	  (put 'add '(rational rational)
	       (lambda (x y) (tag (add-rat x y))))
	  (put 'sub '(rational rational)
	       (lambda (x y) (tag (sub-rat x y))))
	  (put 'mul '(rational rational)
	       (lambda (x y) (tag (mul-rat x y))))
	  (put 'div '(rational rational)
	       (lambda (x y) (tag (div-rat x y))))

	  (put 'make 'rational
	       (lambda (n d) (tag (make-rat n d))))
	  (put 'equ? '(rational rational)
	       (lambda (x y) (= 0 (numer (sub-rat x y)))))
	  (put 'zero? '(rational) (lambda (x) (= 0 (numer x))))
	  (put 'project '(rational) (lambda (x)
				       (exact (truncate (/ (numer x) (denom x))))))
	  (put 'to-real '(rational) (lambda (x) (/ (numer (contents x)) (denom (contents x)))))
	  'done)

	(define (make-rational n d)
	  ((get 'make 'rational) n d))

	(define (install-rectangular-package)

	  (define (real-part z) (car z))
	  (define (imag-part z) (cdr z))
	  (define (make-from-real-imag x y) (cons x y))
	  (define (magnitude z)
	    (square-root (add (square (real-part z))
			      (square (imag-part z)))))
	  (define (angle z)
	    (arctangent (imag-part z) (real-part z)))
	  (define (make-from-mag-ang r a)
	    (cons (mul r (cosine a)) (mul r (sine a))))

	  (define (tag x) (attach-tag 'rectangular x))
	  (put 'real-part '(rectangular) real-part)
	  (put 'imag-part '(rectangular) imag-part)
	  (put 'magnitude '(rectangular) magnitude)
	  (put 'angle '(rectangular) angle)
	  (put 'make-from-real-imag 'rectangular
	       (lambda (x y) (tag (make-from-real-imag x y))))
	  (put 'make-from-mag-ang 'rectangular
	       (lambda (r a) (tag (make-from-mag-ang r a))))
	  'done)

	(define (install-polar-package)

	  (define (magnitude z) (car z))
	  (define (angle z) (cdr z))
	  (define (make-from-mag-ang r a) (cons r a))
	  (define (real-part z)
	    (mul (magnitude z) (cosine (angle z))))
	  (define (imag-part z)
	    (mul (magnitude z) (sine (angle z))))
	  (define (make-from-real-imag x y)
	    (cons (square-root (add (square x) (square y)))
		  (arctangent y x)))

	  (define (tag x) (attach-tag 'polar x))
	  (put 'real-part '(polar) real-part)
	  (put 'imag-part '(polar) imag-part)
	  (put 'magnitude '(polar) magnitude)
	  (put 'angle '(polar) angle)
	  (put 'make-from-real-imag 'polar
	       (lambda (x y) (tag (make-from-real-imag x y))))
	  (put 'make-from-mag-ang 'polar
	       (lambda (r a) (tag (make-from-mag-ang r a))))
	  'done)

	(define (install-complex-package)
	  (define (make-from-real-imag x y)
	    ((get 'make-from-real-imag 'rectangular) x y))
	  (define (make-from-mag-ang r a)
	    ((get 'make-from-mag-ang 'polar) r a))
	  (define (add-complex z1 z2)
	    (make-from-real-imag (add (real-part z1) (real-part z2))
				 (add (imag-part z1) (imag-part z2))))
	  (define (sub-complex z1 z2)
	    (make-from-real-imag (sub (real-part z1) (real-part z2))
				 (sub (imag-part z1) (imag-part z2))))
	  (define (mul-complex z1 z2)
	    (make-from-mag-ang (mul (magnitude z1) (magnitude z2))
			       (add (angle z1) (angle z2))))
	  (define (div-complex z1 z2)
	    (make-from-mag-ang (div (magnitude z1) (magnitude z2))
			       (sub (angle z1) (angle z2))))
	  (define (tag z) (attach-tag 'complex z))
	  (put 'add '(complex complex)
	       (lambda (z1 z2) (tag (add-complex z1 z2))))
	  (put 'sub '(complex complex)
	       (lambda (z1 z2) (tag (sub-complex z1 z2))))
	  (put 'mul '(complex complex)
	       (lambda (z1 z2) (tag (mul-complex z1 z2))))
	  (put 'div '(complex complex)
	       (lambda (z1 z2) (tag (div-complex z1 z2))))
	  (put 'make-from-real-imag 'complex
	       (lambda (x y) (tag (make-from-real-imag x y))))
	  (put 'make-from-mag-ang 'complex
	       (lambda (r a) (tag (make-from-mag-ang r a))))
	  (put 'equ? '(complex complex)
	       (lambda (x y) (and (= 0 (real-part (sub-complex x y)))
				  (= 0 (imag-part (sub-complex x y))))))
	  (put 'equ? '(rectangular polar) equ?)
	  (put 'equ? '(polar rectangular) equ?)
	  (put 'zero? '(complex)
	       (lambda (x) (equ? (tag x) (tag (make-from-real-imag 0 0)))))
	  (put 'project '(complex) (lambda (z) (real-part z)))
	  'done)

	(define (make-complex-from-real-imag x y)
	  ((get 'make-from-real-imag 'complex) x y))

	(define (make-complex-from-mag-ang r a)
	  ((get 'make-from-mag-ang 'complex) r a))

	(install-rectangular-package)
	(install-polar-package)
	(install-rational-package)
	(install-scheme-number-package)
	(install-complex-package)

	(put 'real-part '(complex) real-part)
	(put 'imag-part '(complex) imag-part)
	(put 'magnitude '(complex) magnitude)
	(put 'angle '(complex) angle)

	(define (apply-generic op . args)
	  (define (all-argtypes-same? . args)
	    (let ((type (type-tag (car args))))
	      (accumulate (lambda (x y) (and x y)) #t (map (lambda (x) (eq? type x)) args))))
	  (define (coercion-if-exists? type arg-tags)
	    (let ((coercion-list (map (lambda (x)
					(if (eq? type x)
					    identity
					    (get-coercion x type))) arg-tags)))
	      (if (accumulate (lambda (x y) (and x y)) #t coercion-list)
		  coercion-list
		  #f)))
	  (drop (let* ((type-tags (map type-tag args))
		       (proc (get op type-tags)))
		  (cond (proc (apply proc (map contents args)))
			((= 1 (length args))
			 (show #t "No proc found for op=" op ", type-tags=" type-tags "\n")
			 (apply-generic op (raise-type (car args))))
			((= 2 (length args))
			 (if (type1<=type2? (car type-tags) (cadr type-tags))
			     (apply-generic op (raise-type (car args)) (cadr args))
			     (apply-generic op (car args)  (raise-type (cadr args)))))
			((and (>= (length args) 2) (not (all-argtypes-same? args)))
			 (let types-loop ((types type-tags))
			   (let ((list-of-coercion-functions
				  (coercion-if-exists? (car types) type-tags)))
			     (if list-of-coercion-functions
				 (apply apply-generic (cons op (map (lambda (fun arg) (fun arg))
								    list-of-coercion-functions
								    args)))
				 (if (not (null? (cdr types)))
				     (types-loop (cdr types))
				     (error "apply-generic:Even coercions failed. No method for these types."))))))
			(else (error "apply-generic:No method for these types"
				     (list op type-tags)))))))
	(define (scheme-number->complex n)
	  (make-complex-from-real-imag (contents n) 0))
	(put-coercion 'scheme-number
		      'complex
		      scheme-number->complex)

	(put 'max3-magnitude '(complex complex complex) (lambda (z1 z2 z3)
							  (max (magnitude z1) (magnitude z2) (magnitude z3))))
	(define (max3-magnitude x1 x2 x3) (apply-generic 'max3-magnitude x1 x2 x3))
	(define (identity x) x)

	(define numeric-tower (list 'integer 'rational 'scheme-number 'complex))

	(define (higher-type x)
	  (define (find-higher-type x types)
	    (cond ((or (null? types) (null? (cdr types))) (error "No type higher than given" x))
		  ((eq? x (car types)) (cadr types))
		  (else (find-higher-type x (cdr types)))))
	  (find-higher-type x numeric-tower))

	(define (type1<=type2? type1 type2)
	  (if (not (memq type1 numeric-tower))
	      (error "Type 1 not in the numeric tower"))
	  (if (not (memq type2 numeric-tower))
	      (error "Type 2 not in the numeric tower"))
	  (let loop ((types numeric-tower))
	    (cond ((null? types) (error "Type 1 and type 2 are incomparable" type1 type2))
		  ((eq? (car types) type1) #t)
		  ((eq? (car types) type2) #f)
		  (else (loop (cdr types))))))

	(define (integer->rational x)
	  (make-rational x 1))

	(define (rational->scheme-number x)
	  (make-scheme-number ((get 'to-real '(rational)) x)))
	(put-coercion 'integer 'rational integer->rational)
	(put-coercion 'rational 'scheme-number rational->scheme-number)

	(define (raise-type x)
	  (let ((converter (get-coercion (type-tag x) (higher-type (type-tag x)))))
	    (if converter
		(converter x)
		(error "No coercion found for x" (type-tag x) x))))


	(define (remainder-integer a b)
	  (when (or (not (integer? a)) (not (integer? b)))
	    (error "Arguments must be integers" a b))
	  (remainder a b))

	(put 'remainder '(integer integer) remainder-integer)
	(define (remainder-generalized a b) (apply-generic 'remainder a b))



	(show #t "Test 1: Subtracting complex numbers: "
	      (sub
	       (make-complex-from-real-imag 1.1 2)
	       (make-complex-from-real-imag 0 2)) "\n")


	(define (install-polynomial-package)
	  #;(internal procedures)
	  #;(representation of poly)
	  (define (make-poly variable term-list)
	    (cons variable term-list))
	  (define (variable p) (car p))
	  (define (term-list p)
	    (cdr p))

	  (define (variable? x) (symbol? x))
	  (define (same-variable? v1 v2)
	    (and (variable? v1) (variable? v2) (eq? v1 v2)))
	  (define (=number? exp num)
	    (and (number? exp) (= exp num)))

	  #;(representation of terms and term lists)

	   (define (adjoin-term term term-list)
	     (if (zero? (coeff term))
		 term-list
		 (cons term term-list)))

	   (define (the-empty-termlist) '())
	   (define (first-term term-list) (car term-list))
	   (define (rest-terms term-list) (cdr term-list))
	   (define (empty-termlist? term-list) (null? term-list))

	   (define (make-term order coeff) (list order coeff))
	   (define (order term) (car term))
	   (define (coeff term) (cadr term))

	  #;(continued on next page)

	   (define (add-poly p1 p2)
	     (if (same-variable? (variable p1) (variable p2))
		 (make-poly (variable p1)
			    (add-terms (term-list p1)
				       (term-list p2)))
		 (error "Polys not in same var -- ADD-POLY"
			(list p1 p2))))
	   (define (add-terms L1 L2)
	     (cond ((empty-termlist? L1) L2)
		   ((empty-termlist? L2) L1)
		   (else
		    (let ((t1 (first-term L1)) (t2 (first-term L2)))
		      (cond ((> (order t1) (order t2))
			     (adjoin-term
			      t1 (add-terms (rest-terms L1) L2)))
			    ((< (order t1) (order t2))
			     (adjoin-term
			      t2 (add-terms L1 (rest-terms L2))))
			    (else
			     (adjoin-term
			      (make-term (order t1)
					 (add (coeff t1) (coeff t2)))
			      (add-terms (rest-terms L1)
					 (rest-terms L2)))))))))

	   (define (mul-poly p1 p2)
	     (if (same-variable? (variable p1) (variable p2))
		 (make-poly (variable p1)
			    (mul-terms (term-list p1)
				       (term-list p2)))
		 (error "Polys not in same var -- MUL-POLY"
			(list p1 p2))))
	   (define (mul-terms L1 L2)
	     (if (empty-termlist? L1)
		 (the-empty-termlist)
		 (add-terms (mul-term-by-all-terms (first-term L1) L2)
			    (mul-terms (rest-terms L1) L2))))

	   (define (mul-term-by-all-terms t1 L)
	     (if (empty-termlist? L)
		 (the-empty-termlist)
		 (let ((t2 (first-term L)))
		   (adjoin-term
		    (make-term (+ (order t1) (order t2))
			       (mul (coeff t1) (coeff t2)))
		    (mul-term-by-all-terms t1 (rest-terms L))))))
	  (define (zero-poly? poly)
	    (show #t "zero-poly?: poly=" poly "\n")
	    (cond ((empty-termlist? (term-list poly)) #t)
		  ((every (lambda (x) (apply-generic 'zero? (coeff x))) (term-list poly)) #t)
		  (else #f)))
	  #;(interface to rest of the system)
	  (define (tag p) (attach-tag 'polynomial p))
	  (put 'add '(polynomial polynomial)
	       (lambda (p1 p2) (tag (add-poly p1 p2))))
	  (put 'mul '(polynomial polynomial)
	       (lambda (p1 p2) (tag (mul-poly p1 p2))))
	  (put 'make 'polynomial
	       (lambda (var terms) (tag (make-poly var terms))))
	  (put 'zero? '(polynomial) zero-poly?)
	  'done)
    (install-polynomial-package)

	   (define (make-polynomial var terms)
	     ((get 'make 'polynomial) var terms))
      (show #t "Test 2: Making polynomials: "
	    (make-polynomial 'x (list (list 5 1) (list 4 2))) "\n")
      (show #t "Test 3: Adding polynomials: "
	    (add (make-polynomial 'x '((5 1) (4 2) (0 1)))
		 (make-polynomial 'x '((5 1)))) "\n")
      (show #t "Test 4: Zero?: " (zero? (make-polynomial 'x '((5 0) (3 1)))) "\n")
#+end_src

#+RESULTS[974eab85c3ef897d59ad5b5ac51dc03cefadae5a]:
#+begin_src scheme
Test 1: Subtracting complex numbers: (rational 2476979795053773 . 2251799813685248)
Test 2: Making polynomials: (polynomial x (5 1) (4 2))
No proc found for op=zero?, type-tags=(integer)
Test 3: Adding polynomials: (polynomial x (5 2) (4 2) (0 1))
zero-poly?: poly=(x (5 0) (3 1))
No proc found for op=zero?, type-tags=(integer)
No proc found for op=zero?, type-tags=(integer)
Test 4: Zero?: #f
#+end_src

Even though making the example code turned out to be a huge pain, actually
solving the puzzle wasn't that hard. Just added a predicate to check if every
coefficient of a polynomial is zero.

*** DONE Exercise 2.88 Subtraction of polynomials
    CLOSED: [2019-10-22 Tue 09:55]

I am copying the code again. We would need to implement a generalized
subtraction function.

This task turned out to be super-easy.

#+begin_src scheme :exports both :results output scalar code
  (define (project obj)
    (apply-generic 'project obj))
  (define (droppable? obj)
    (cond ((not (memq (type-tag obj) numeric-tower)) #f)
	  ((eq? (type-tag obj) (car numeric-tower)) #f)
	  ((equ? obj (raise-type (project obj))) #t)
	  (else #f)))
  (define (drop obj)
    (if (droppable? obj)
	(drop (project obj))
	obj))

  (define (accumulate op initial sequence)
    (if (null? sequence)
	initial
	(accumulate op (op initial (car sequence)) (cdr sequence))))
  (define false #f)
  (define true  #t)
  (define (make-table)
    (let ((local-table (list '*table*)))
      (define (lookup key-1 key-2)
	(let ((subtable (assoc key-1 (cdr local-table))))
	  (if subtable
	      (let ((record (assoc key-2 (cdr subtable))))
		(if record
		    (cdr record)
		    false))
	      false)))
      (define (insert! key-1 key-2 value)
	(let ((subtable (assoc key-1 (cdr local-table))))
	  (if subtable
	      (let ((record (assoc key-2 (cdr subtable))))
		(if record
		    (set-cdr! record value)
		    (set-cdr! subtable
			      (cons (cons key-2 value)
				    (cdr subtable)))))
	      (set-cdr! local-table
			(cons (list key-1
				    (cons key-2 value))
			      (cdr local-table)))))
	'ok)
      (define (dispatch m)
	(cond ((eq? m 'lookup-proc) lookup)
	      ((eq? m 'insert-proc!) insert!)
	      (else (error "Unknown operation -- TABLE" m))))
      dispatch))

  (define operation-table (make-table))
  (define get (operation-table 'lookup-proc))
  (define put (operation-table 'insert-proc!))

  (define coercion-table (make-table))
  (define get-coercion (coercion-table 'lookup-proc))
  (define put-coercion (coercion-table 'insert-proc!))

  (define (attach-tag type-tag contents)
    (cons type-tag contents))

  (define (type-tag datum)
    (cond ((pair? datum) (car datum))
	  ((exact-integer? datum) 'integer)
	  ((real? datum) 'scheme-number)
	  (error "Bad tagged datum -- TYPE-TAG" datum)))

  (define (contents datum)
    (cond ((pair? datum) (cdr datum))
	  ((integer? datum) datum)
	  ((real? datum) datum)
	  (else (error "Bad tagged datum -- CONTENTS" datum))))

  (define (integer? x)
    (eq? (type-tag x) 'integer))
  (define (rectangular? z)
    (eq? (type-tag z) 'rectangular))

  (define (polar? z)
    (eq? (type-tag z) 'polar))


  (define (real-part z) (apply-generic 'real-part z))
  (define (imag-part z) (apply-generic 'imag-part z))
  (define (magnitude z) (apply-generic 'magnitude z))
  (define (angle z) (apply-generic 'angle z))

  (define (add x y) (apply-generic 'add x y))
  (define (sub x y) (apply-generic 'sub x y))
  (define (mul x y) (apply-generic 'mul x y))
  (define (div x y) (apply-generic 'div x y))

  (define (equ? x y)
    (apply-generic 'equ? x y))
  (define (zero? x) (apply-generic 'zero? x))

  (define (exp x y) (apply-generic 'exp x y))

  (define (install-scheme-number-package)
    (define (tag x)
      (attach-tag 'scheme-number x))
    (put 'add '(scheme-number scheme-number)
	 (lambda (x y) (tag (+ x y))))
    (put 'sub '(scheme-number scheme-number)
	 (lambda (x y) (tag (- x y))))
    (put 'mul '(scheme-number scheme-number)
	 (lambda (x y) (tag (* x y))))
    (put 'div '(scheme-number scheme-number)
	 (lambda (x y) (tag (/ x y))))
    (put 'make 'scheme-number
	 (lambda (x) (tag x)))
    (put 'equ? '(scheme-number scheme-number)
	 (lambda (x y) (= x y)))
    (put 'zero? '(scheme-number)
	 (lambda (x) (= 0 x)))
    (put 'exp '(scheme-number scheme-number)
	 (lambda (x y) (tag (expt x y))))
    (put 'project '(scheme-number)
	 (lambda (x)
	   (make-rational
	    (exact (numerator x))
	    (exact (denominator x)))))
    (put 'sine '(scheme-number) sin)
    (put 'cosine '(scheme-number) cos)
    (put 'square-root '(scheme-number) sqrt)
    (put 'arctangent '(schemer-number) atan)
    'done)

  (define (sine x) (apply-generic 'sine x))
  (define (cosine x) (apply-generic 'cosine x))
  (define (square-root x) (apply-generic 'square-root x))
  (define (arctangent x) (apply-generic 'arctangent x))

  (define (make-scheme-number n)
    ((get 'make 'scheme-number) n))

  (define (install-rational-package)
    (define (numer x) (car x))
    (define (denom x) (cdr x))
    (define (make-rat n d)
      (let ((g (gcd n d)))
	(cons (/ n g) (/ d g))))
    (define (add-rat x y)
      (make-rat (+ (* (numer x) (denom y))
		   (* (numer y) (denom x)))
		(* (denom x) (denom y))))
    (define (sub-rat x y)
      (make-rat (- (* (numer x) (denom y))
		   (* (numer y) (denom x)))
		(* (denom x) (denom y))))
    (define (mul-rat x y)
      (make-rat (* (numer x) (numer y))
		(* (denom x) (denom y))))
    (define (div-rat x y)
      (make-rat (* (numer x) (denom y))
		(* (denom x) (numer y))))

    (define (tag x) (attach-tag 'rational x))
    (put 'add '(rational rational)
	 (lambda (x y) (tag (add-rat x y))))
    (put 'sub '(rational rational)
	 (lambda (x y) (tag (sub-rat x y))))
    (put 'mul '(rational rational)
	 (lambda (x y) (tag (mul-rat x y))))
    (put 'div '(rational rational)
	 (lambda (x y) (tag (div-rat x y))))

    (put 'make 'rational
	 (lambda (n d) (tag (make-rat n d))))
    (put 'equ? '(rational rational)
	 (lambda (x y) (= 0 (numer (sub-rat x y)))))
    (put 'zero? '(rational) (lambda (x) (= 0 (numer x))))
    (put 'project '(rational) (lambda (x)
				(exact (truncate (/ (numer x) (denom x))))))
    (put 'to-real '(rational) (lambda (x) (/ (numer (contents x)) (denom (contents x)))))
    'done)

  (define (make-rational n d)
    ((get 'make 'rational) n d))

  (define (install-rectangular-package)

    (define (real-part z) (car z))
    (define (imag-part z) (cdr z))
    (define (make-from-real-imag x y) (cons x y))
    (define (magnitude z)
      (square-root (add (square (real-part z))
			(square (imag-part z)))))
    (define (angle z)
      (arctangent (imag-part z) (real-part z)))
    (define (make-from-mag-ang r a)
      (cons (mul r (cosine a)) (mul r (sine a))))

    (define (tag x) (attach-tag 'rectangular x))
    (put 'real-part '(rectangular) real-part)
    (put 'imag-part '(rectangular) imag-part)
    (put 'magnitude '(rectangular) magnitude)
    (put 'angle '(rectangular) angle)
    (put 'make-from-real-imag 'rectangular
	 (lambda (x y) (tag (make-from-real-imag x y))))
    (put 'make-from-mag-ang 'rectangular
	 (lambda (r a) (tag (make-from-mag-ang r a))))
    'done)

  (define (install-polar-package)

    (define (magnitude z) (car z))
    (define (angle z) (cdr z))
    (define (make-from-mag-ang r a) (cons r a))
    (define (real-part z)
      (mul (magnitude z) (cosine (angle z))))
    (define (imag-part z)
      (mul (magnitude z) (sine (angle z))))
    (define (make-from-real-imag x y)
      (cons (square-root (add (square x) (square y)))
	    (arctangent y x)))

    (define (tag x) (attach-tag 'polar x))
    (put 'real-part '(polar) real-part)
    (put 'imag-part '(polar) imag-part)
    (put 'magnitude '(polar) magnitude)
    (put 'angle '(polar) angle)
    (put 'make-from-real-imag 'polar
	 (lambda (x y) (tag (make-from-real-imag x y))))
    (put 'make-from-mag-ang 'polar
	 (lambda (r a) (tag (make-from-mag-ang r a))))
    'done)

  (define (install-complex-package)
    (define (make-from-real-imag x y)
      ((get 'make-from-real-imag 'rectangular) x y))
    (define (make-from-mag-ang r a)
      ((get 'make-from-mag-ang 'polar) r a))
    (define (add-complex z1 z2)
      (make-from-real-imag (add (real-part z1) (real-part z2))
			   (add (imag-part z1) (imag-part z2))))
    (define (sub-complex z1 z2)
      (make-from-real-imag (sub (real-part z1) (real-part z2))
			   (sub (imag-part z1) (imag-part z2))))
    (define (mul-complex z1 z2)
      (make-from-mag-ang (mul (magnitude z1) (magnitude z2))
			 (add (angle z1) (angle z2))))
    (define (div-complex z1 z2)
      (make-from-mag-ang (div (magnitude z1) (magnitude z2))
			 (sub (angle z1) (angle z2))))
    (define (tag z) (attach-tag 'complex z))
    (put 'add '(complex complex)
	 (lambda (z1 z2) (tag (add-complex z1 z2))))
    (put 'sub '(complex complex)
	 (lambda (z1 z2) (tag (sub-complex z1 z2))))
    (put 'mul '(complex complex)
	 (lambda (z1 z2) (tag (mul-complex z1 z2))))
    (put 'div '(complex complex)
	 (lambda (z1 z2) (tag (div-complex z1 z2))))
    (put 'make-from-real-imag 'complex
	 (lambda (x y) (tag (make-from-real-imag x y))))
    (put 'make-from-mag-ang 'complex
	 (lambda (r a) (tag (make-from-mag-ang r a))))
    (put 'equ? '(complex complex)
	 (lambda (x y) (and (= 0 (real-part (sub-complex x y)))
			    (= 0 (imag-part (sub-complex x y))))))
    (put 'equ? '(rectangular polar) equ?)
    (put 'equ? '(polar rectangular) equ?)
    (put 'zero? '(complex)
	 (lambda (x) (equ? (tag x) (tag (make-from-real-imag 0 0)))))
    (put 'project '(complex) (lambda (z) (real-part z)))
    'done)

  (define (make-complex-from-real-imag x y)
    ((get 'make-from-real-imag 'complex) x y))

  (define (make-complex-from-mag-ang r a)
    ((get 'make-from-mag-ang 'complex) r a))

  (install-rectangular-package)
  (install-polar-package)
  (install-rational-package)
  (install-scheme-number-package)
  (install-complex-package)

  (put 'real-part '(complex) real-part)
  (put 'imag-part '(complex) imag-part)
  (put 'magnitude '(complex) magnitude)
  (put 'angle '(complex) angle)

  (define (apply-generic op . args)
    (define (all-argtypes-same? . args)
      (let ((type (type-tag (car args))))
	(accumulate (lambda (x y) (and x y)) #t (map (lambda (x) (eq? type x)) args))))
    (define (coercion-if-exists? type arg-tags)
      (let ((coercion-list (map (lambda (x)
				  (if (eq? type x)
				      identity
				      (get-coercion x type))) arg-tags)))
	(if (accumulate (lambda (x y) (and x y)) #t coercion-list)
	    coercion-list
	    #f)))
    (drop (let* ((type-tags (map type-tag args))
		 (proc (get op type-tags)))
	    (cond (proc (apply proc (map contents args)))
		  ((= 1 (length args))
		   #;(show #t "No proc found for op=" op ", type-tags=" type-tags "\n")
		   (apply-generic op (raise-type (car args))))
		  ((= 2 (length args))
		   (if (type1<=type2? (car type-tags) (cadr type-tags))
		       (apply-generic op (raise-type (car args)) (cadr args))
		       (apply-generic op (car args)  (raise-type (cadr args)))))
		  ((and (>= (length args) 2) (not (all-argtypes-same? args)))
		   (let types-loop ((types type-tags))
		     (let ((list-of-coercion-functions
			    (coercion-if-exists? (car types) type-tags)))
		       (if list-of-coercion-functions
			   (apply apply-generic (cons op (map (lambda (fun arg) (fun arg))
							      list-of-coercion-functions
							      args)))
			   (if (not (null? (cdr types)))
			       (types-loop (cdr types))
			       (error "apply-generic:Even coercions failed. No method for these types."))))))
		  (else (error "apply-generic:No method for these types"
			       (list op type-tags)))))))
  (define (scheme-number->complex n)
    (make-complex-from-real-imag (contents n) 0))
  (put-coercion 'scheme-number
		'complex
		scheme-number->complex)

  (put 'max3-magnitude '(complex complex complex) (lambda (z1 z2 z3)
						    (max (magnitude z1) (magnitude z2) (magnitude z3))))
  (define (max3-magnitude x1 x2 x3) (apply-generic 'max3-magnitude x1 x2 x3))
  (define (identity x) x)

  (define numeric-tower (list 'integer 'rational 'scheme-number 'complex))

  (define (higher-type x)
    (define (find-higher-type x types)
      (cond ((or (null? types) (null? (cdr types))) (error "No type higher than given" x))
	    ((eq? x (car types)) (cadr types))
	    (else (find-higher-type x (cdr types)))))
    (find-higher-type x numeric-tower))

  (define (type1<=type2? type1 type2)
    (if (not (memq type1 numeric-tower))
	(error "Type 1 not in the numeric tower"))
    (if (not (memq type2 numeric-tower))
	(error "Type 2 not in the numeric tower"))
    (let loop ((types numeric-tower))
      (cond ((null? types) (error "Type 1 and type 2 are incomparable" type1 type2))
	    ((eq? (car types) type1) #t)
	    ((eq? (car types) type2) #f)
	    (else (loop (cdr types))))))

  (define (integer->rational x)
    (make-rational x 1))

  (define (rational->scheme-number x)
    (make-scheme-number ((get 'to-real '(rational)) x)))
  (put-coercion 'integer 'rational integer->rational)
  (put-coercion 'rational 'scheme-number rational->scheme-number)

  (define (raise-type x)
    (let ((converter (get-coercion (type-tag x) (higher-type (type-tag x)))))
      (if converter
	  (converter x)
	  (error "No coercion found for x" (type-tag x) x))))


  (define (remainder-integer a b)
    (when (or (not (integer? a)) (not (integer? b)))
      (error "Arguments must be integers" a b))
    (remainder a b))

  (put 'remainder '(integer integer) remainder-integer)
  (define (remainder-generalized a b) (apply-generic 'remainder a b))


  (show #t "Test 1: Subtracting complex numbers: "
	(sub
	 (make-complex-from-real-imag 1.1 2)
	 (make-complex-from-real-imag 0 2)) "\n")


  (define (install-polynomial-package)
    #;(internal procedures)
    #;(representation of poly)
    (define (make-poly variable term-list)
      (cons variable term-list))
    (define (variable p) (car p))
    (define (term-list p)
      (cdr p))

    (define (variable? x) (symbol? x))
    (define (same-variable? v1 v2)
      (and (variable? v1) (variable? v2) (eq? v1 v2)))
    (define (=number? exp num)
      (and (number? exp) (= exp num)))

    #;(representation of terms and term lists)

    (define (adjoin-term term term-list)
      (if (zero? (coeff term))
	  term-list
	  (cons term term-list)))

    (define (the-empty-termlist) '())
    (define (first-term term-list) (car term-list))
    (define (rest-terms term-list) (cdr term-list))
    (define (empty-termlist? term-list) (null? term-list))

    (define (make-term order coeff) (list order coeff))
    (define (order term) (car term))
    (define (coeff term) (cadr term))

    #;(continued on next page)

    (define (add-poly p1 p2)
      (if (same-variable? (variable p1) (variable p2))
	  (make-poly (variable p1)
		     (add-terms (term-list p1)
				(term-list p2)))
	  (error "Polys not in same var -- ADD-POLY"
		 (list p1 p2))))
    (define (sub-poly p1 p2)
      (add-poly p1 (mul-poly p2 (make-poly (variable p2) (list (make-term 0 -1))))))
    (define (add-terms L1 L2)
      (cond ((empty-termlist? L1) L2)
	    ((empty-termlist? L2) L1)
	    (else
	     (let ((t1 (first-term L1)) (t2 (first-term L2)))
	       (cond ((> (order t1) (order t2))
		      (adjoin-term
		       t1 (add-terms (rest-terms L1) L2)))
		     ((< (order t1) (order t2))
		      (adjoin-term
		       t2 (add-terms L1 (rest-terms L2))))
		     (else
		      (adjoin-term
		       (make-term (order t1)
				  (add (coeff t1) (coeff t2)))
		       (add-terms (rest-terms L1)
				  (rest-terms L2)))))))))


    (define (mul-poly p1 p2)
      (if (same-variable? (variable p1) (variable p2))
	  (make-poly (variable p1)
		     (mul-terms (term-list p1)
				(term-list p2)))
	  (error "Polys not in same var -- MUL-POLY"
		 (list p1 p2))))
    (define (mul-terms L1 L2)
      (if (empty-termlist? L1)
	  (the-empty-termlist)
	  (add-terms (mul-term-by-all-terms (first-term L1) L2)
		     (mul-terms (rest-terms L1) L2))))

    (define (mul-term-by-all-terms t1 L)
      (if (empty-termlist? L)
	  (the-empty-termlist)
	  (let ((t2 (first-term L)))
	    (adjoin-term
	     (make-term (+ (order t1) (order t2))
			(mul (coeff t1) (coeff t2)))
	     (mul-term-by-all-terms t1 (rest-terms L))))))
    (define (zero-poly? poly)
      (show #t "zero-poly?: poly=" poly "\n")
      (cond ((empty-termlist? (term-list poly)) #t)
	    ((every (lambda (x) (apply-generic 'zero? (coeff x))) (term-list poly)) #t)
	    (else #f)))
    #;(interface to rest of the system)
    (define (tag p) (attach-tag 'polynomial p))
    (put 'add '(polynomial polynomial)
	 (lambda (p1 p2) (tag (add-poly p1 p2))))
    (put 'mul '(polynomial polynomial)
	 (lambda (p1 p2) (tag (mul-poly p1 p2))))
    (put 'sub '(polynomial polynomial)
	 (lambda (p1 p2) (tag (sub-poly p1 p2))))
    (put 'make 'polynomial
	 (lambda (var terms) (tag (make-poly var terms))))
    (put 'zero? '(polynomial) zero-poly?)
    'done)
  (install-polynomial-package)

  (define (make-polynomial var terms)
    ((get 'make 'polynomial) var terms))
  (show #t "Test 2: Making polynomials: "
	(make-polynomial 'x (list (list 5 1) (list 4 2))) "\n")
  (show #t "Test 3: Adding polynomials: "
	(add (make-polynomial 'x '((5 1) (4 2) (0 1)))
	     (make-polynomial 'x '((5 1)))) "\n")
  (show #t "Test 4: Zero?: " (zero? (make-polynomial 'x '((5 0) (3 1)))) "\n")

  (show #t "Test 5: Subtracting polynomials: "
	(sub (make-polynomial 'x '((5 1) (4 2) (0 1)))
	     (make-polynomial 'x '((0 1)))) "\n")
#+end_src

#+RESULTS[b354c709c0fb26659a7c6a58241a7c4d1fefcd54]:
#+begin_src scheme
Test 1: Subtracting complex numbers: (rational 2476979795053773 . 2251799813685248)
Test 2: Making polynomials: (polynomial x (5 1) (4 2))
Test 3: Adding polynomials: (polynomial x (5 2) (4 2) (0 1))
zero-poly?: poly=(x (5 0) (3 1))
Test 4: Zero?: #f
Test 5: Subtracting polynomials: (polynomial x (5 1) (4 2))
#+end_src

*** DONE Exercise 2.89 Dense term-lists
    CLOSED: [2019-10-22 Tue 11:55]

This is a contrived exercise, frankly. It's purpose, I guess, is to just
prepare the reader for the next exercise, which would be too big
otherwise. The functions we are going to write here will serve as a basis for
the Exercise 2.90, where we will pack them into a separate package.

This exercise is also easy, the main trick is to understand that a term and a
term-list are two separate things and that the latter is not necessarily the
set of the former.

The sparse list-based ~adjoin-term~ seems to be only adjoining higher terms, not
lower, so my dense list-based only supports that too. In any case, adding the
option to adjoin smaller terms seems to be possible if needed.

#+begin_src scheme :exports both :results output scalar code
    (define (adjoin-term term term-list)
      (if (zero? (coeff term))
	  term-list
	  (if (> (order term) (length term-list))
	      (append (list (coeff term))
		      (make-list (- (order term) (length term-list)) 0)
		      term-list)
	      (error "adjoin-term:Appending a smaller order term. Recheck."))))

    (define (the-empty-termlist) '())
    (define (first-term term-list) (make-term (car term-list)) (length (cdr term-list)))
    (define (rest-terms term-list) (cdr term-list))
    (define (empty-termlist? term-list) (null? term-list))

    (define (make-term order coeff) (list order coeff))
    (define (order term) (car term))
    (define (coeff term) (cadr term))


(show #t "Test 1: appending zero: " (adjoin-term (make-term 100 0) (the-empty-termlist)) "\n")
(show #t "Test 2: appending zero: " (adjoin-term (make-term 100 0) '(1)) "\n")
(show #t "Test 2: appending zero: " (adjoin-term (make-term 10 1) '(1)) "\n")

#+end_src

#+RESULTS[6af2197ea0139c79c1817783da8f3341fe9fe06d]:
#+begin_src scheme
Test 1: appending zero: ()
Test 2: appending zero: (1)
Test 2: appending zero: (1 0 0 0 0 0 0 0 0 0 1)
#+end_src

*** DONE Exercise 2.90 Implementing dense polynomials as a separate package
    CLOSED: [2019-10-22 Tue 21:31]

Again, since implementing the new package will require a major rewrite of the
system, it's better to copy the code rather than tangle.


#+begin_src scheme :exports both :results output scalar code
  (define (project obj)
    (apply-generic 'project obj))
  (define (droppable? obj)
    (cond ((not (memq (type-tag obj) numeric-tower)) #f)
	  ((eq? (type-tag obj) (car numeric-tower)) #f)
	  ((equ? obj (raise-type (project obj))) #t)
	  (else #f)))
  (define (drop obj)
    (if (droppable? obj)
	(drop (project obj))
	obj))

  (define (accumulate op initial sequence)
    (if (null? sequence)
	initial
	(accumulate op (op initial (car sequence)) (cdr sequence))))
  (define false #f)
  (define true  #t)
  (define (make-table)
    (let ((local-table (list '*table*)))
      (define (lookup key-1 key-2)
	(let ((subtable (assoc key-1 (cdr local-table))))
	  (if subtable
	      (let ((record (assoc key-2 (cdr subtable))))
		(if record
		    (cdr record)
		    false))
	      false)))
      (define (insert! key-1 key-2 value)
	(let ((subtable (assoc key-1 (cdr local-table))))
	  (if subtable
	      (let ((record (assoc key-2 (cdr subtable))))
		(if record
		    (set-cdr! record value)
		    (set-cdr! subtable
			      (cons (cons key-2 value)
				    (cdr subtable)))))
	      (set-cdr! local-table
			(cons (list key-1
				    (cons key-2 value))
			      (cdr local-table)))))
	'ok)
      (define (dispatch m)
	(cond ((eq? m 'lookup-proc) lookup)
	      ((eq? m 'insert-proc!) insert!)
	      (else (error "Unknown operation -- TABLE" m))))
      dispatch))

  (define operation-table (make-table))
  (define get (operation-table 'lookup-proc))
  (define put (operation-table 'insert-proc!))

  (define coercion-table (make-table))
  (define get-coercion (coercion-table 'lookup-proc))
  (define put-coercion (coercion-table 'insert-proc!))

  (define (attach-tag type-tag contents)
    (cons type-tag contents))

  (define (type-tag datum)
    (cond ((pair? datum) (car datum))
	  ((exact-integer? datum) 'integer)
	  ((real? datum) 'scheme-number)
	  (error "Bad tagged datum -- TYPE-TAG" datum)))

  (define (contents datum)
    (cond ((pair? datum) (cdr datum))
	  ((integer? datum) datum)
	  ((real? datum) datum)
	  (else (error "Bad tagged datum -- CONTENTS" datum))))

  (define (integer? x)
    (eq? (type-tag x) 'integer))
  (define (rectangular? z)
    (eq? (type-tag z) 'rectangular))

  (define (polar? z)
    (eq? (type-tag z) 'polar))


  (define (real-part z) (apply-generic 'real-part z))
  (define (imag-part z) (apply-generic 'imag-part z))
  (define (magnitude z) (apply-generic 'magnitude z))
  (define (angle z) (apply-generic 'angle z))

  (define (add x y) (apply-generic 'add x y))
  (define (sub x y) (apply-generic 'sub x y))
  (define (mul x y) (apply-generic 'mul x y))
  (define (div x y) (apply-generic 'div x y))

  (define (equ? x y)
    (apply-generic 'equ? x y))
  (define (zero? x) (apply-generic 'zero? x))

  (define (exp x y) (apply-generic 'exp x y))

  (define (install-scheme-number-package)
    (define (tag x)
      (attach-tag 'scheme-number x))
    (put 'add '(scheme-number scheme-number)
	 (lambda (x y) (tag (+ x y))))
    (put 'sub '(scheme-number scheme-number)
	 (lambda (x y) (tag (- x y))))
    (put 'mul '(scheme-number scheme-number)
	 (lambda (x y) (tag (* x y))))
    (put 'div '(scheme-number scheme-number)
	 (lambda (x y) (tag (/ x y))))
    (put 'make 'scheme-number
	 (lambda (x) (tag x)))
    (put 'equ? '(scheme-number scheme-number)
	 (lambda (x y) (= x y)))
    (put 'zero? '(scheme-number)
	 (lambda (x) (= 0 x)))
    (put 'exp '(scheme-number scheme-number)
	 (lambda (x y) (tag (expt x y))))
    (put 'project '(scheme-number)
	 (lambda (x)
	   (make-rational
	    (exact (numerator x))
	    (exact (denominator x)))))
    (put 'sine '(scheme-number) sin)
    (put 'cosine '(scheme-number) cos)
    (put 'square-root '(scheme-number) sqrt)
    (put 'arctangent '(schemer-number) atan)
    'done)

  (define (sine x) (apply-generic 'sine x))
  (define (cosine x) (apply-generic 'cosine x))
  (define (square-root x) (apply-generic 'square-root x))
  (define (arctangent x) (apply-generic 'arctangent x))

  (define (make-scheme-number n)
    ((get 'make 'scheme-number) n))

  (define (install-rational-package)
    (define (numer x) (car x))
    (define (denom x) (cdr x))
    (define (make-rat n d)
      (let ((g (gcd n d)))
	(cons (/ n g) (/ d g))))
    (define (add-rat x y)
      (make-rat (+ (* (numer x) (denom y))
		   (* (numer y) (denom x)))
		(* (denom x) (denom y))))
    (define (sub-rat x y)
      (make-rat (- (* (numer x) (denom y))
		   (* (numer y) (denom x)))
		(* (denom x) (denom y))))
    (define (mul-rat x y)
      (make-rat (* (numer x) (numer y))
		(* (denom x) (denom y))))
    (define (div-rat x y)
      (make-rat (* (numer x) (denom y))
		(* (denom x) (numer y))))

    (define (tag x) (attach-tag 'rational x))
    (put 'add '(rational rational)
	 (lambda (x y) (tag (add-rat x y))))
    (put 'sub '(rational rational)
	 (lambda (x y) (tag (sub-rat x y))))
    (put 'mul '(rational rational)
	 (lambda (x y) (tag (mul-rat x y))))
    (put 'div '(rational rational)
	 (lambda (x y) (tag (div-rat x y))))

    (put 'make 'rational
	 (lambda (n d) (tag (make-rat n d))))
    (put 'equ? '(rational rational)
	 (lambda (x y) (= 0 (numer (sub-rat x y)))))
    (put 'zero? '(rational) (lambda (x) (= 0 (numer x))))
    (put 'project '(rational) (lambda (x)
				(exact (truncate (/ (numer x) (denom x))))))
    (put 'to-real '(rational) (lambda (x) (/ (numer (contents x)) (denom (contents x)))))
    'done)

  (define (make-rational n d)
    ((get 'make 'rational) n d))

  (define (install-rectangular-package)

    (define (real-part z) (car z))
    (define (imag-part z) (cdr z))
    (define (make-from-real-imag x y) (cons x y))
    (define (magnitude z)
      (square-root (add (square (real-part z))
			(square (imag-part z)))))
    (define (angle z)
      (arctangent (imag-part z) (real-part z)))
    (define (make-from-mag-ang r a)
      (cons (mul r (cosine a)) (mul r (sine a))))

    (define (tag x) (attach-tag 'rectangular x))
    (put 'real-part '(rectangular) real-part)
    (put 'imag-part '(rectangular) imag-part)
    (put 'magnitude '(rectangular) magnitude)
    (put 'angle '(rectangular) angle)
    (put 'make-from-real-imag 'rectangular
	 (lambda (x y) (tag (make-from-real-imag x y))))
    (put 'make-from-mag-ang 'rectangular
	 (lambda (r a) (tag (make-from-mag-ang r a))))
    'done)

  (define (install-polar-package)

    (define (magnitude z) (car z))
    (define (angle z) (cdr z))
    (define (make-from-mag-ang r a) (cons r a))
    (define (real-part z)
      (mul (magnitude z) (cosine (angle z))))
    (define (imag-part z)
      (mul (magnitude z) (sine (angle z))))
    (define (make-from-real-imag x y)
      (cons (square-root (add (square x) (square y)))
	    (arctangent y x)))

    (define (tag x) (attach-tag 'polar x))
    (put 'real-part '(polar) real-part)
    (put 'imag-part '(polar) imag-part)
    (put 'magnitude '(polar) magnitude)
    (put 'angle '(polar) angle)
    (put 'make-from-real-imag 'polar
	 (lambda (x y) (tag (make-from-real-imag x y))))
    (put 'make-from-mag-ang 'polar
	 (lambda (r a) (tag (make-from-mag-ang r a))))
    'done)

  (define (install-complex-package)
    (define (make-from-real-imag x y)
      ((get 'make-from-real-imag 'rectangular) x y))
    (define (make-from-mag-ang r a)
      ((get 'make-from-mag-ang 'polar) r a))
    (define (add-complex z1 z2)
      (make-from-real-imag (add (real-part z1) (real-part z2))
			   (add (imag-part z1) (imag-part z2))))
    (define (sub-complex z1 z2)
      (make-from-real-imag (sub (real-part z1) (real-part z2))
			   (sub (imag-part z1) (imag-part z2))))
    (define (mul-complex z1 z2)
      (make-from-mag-ang (mul (magnitude z1) (magnitude z2))
			 (add (angle z1) (angle z2))))
    (define (div-complex z1 z2)
      (make-from-mag-ang (div (magnitude z1) (magnitude z2))
			 (sub (angle z1) (angle z2))))
    (define (tag z) (attach-tag 'complex z))
    (put 'add '(complex complex)
	 (lambda (z1 z2) (tag (add-complex z1 z2))))
    (put 'sub '(complex complex)
	 (lambda (z1 z2) (tag (sub-complex z1 z2))))
    (put 'mul '(complex complex)
	 (lambda (z1 z2) (tag (mul-complex z1 z2))))
    (put 'div '(complex complex)
	 (lambda (z1 z2) (tag (div-complex z1 z2))))
    (put 'make-from-real-imag 'complex
	 (lambda (x y) (tag (make-from-real-imag x y))))
    (put 'make-from-mag-ang 'complex
	 (lambda (r a) (tag (make-from-mag-ang r a))))
    (put 'equ? '(complex complex)
	 (lambda (x y) (and (= 0 (real-part (sub-complex x y)))
			    (= 0 (imag-part (sub-complex x y))))))
    (put 'equ? '(rectangular polar) equ?)
    (put 'equ? '(polar rectangular) equ?)
    (put 'zero? '(complex)
	 (lambda (x) (equ? (tag x) (tag (make-from-real-imag 0 0)))))
    (put 'project '(complex) (lambda (z) (real-part z)))
    'done)

  (define (make-complex-from-real-imag x y)
    ((get 'make-from-real-imag 'complex) x y))

  (define (make-complex-from-mag-ang r a)
    ((get 'make-from-mag-ang 'complex) r a))

  (install-rectangular-package)
  (install-polar-package)
  (install-rational-package)
  (install-scheme-number-package)
  (install-complex-package)

  (put 'real-part '(complex) real-part)
  (put 'imag-part '(complex) imag-part)
  (put 'magnitude '(complex) magnitude)
  (put 'angle '(complex) angle)

  (define (apply-generic op . args)
    (define (all-argtypes-same? . args)
      (let ((type (type-tag (car args))))
	(accumulate (lambda (x y) (and x y)) #t (map (lambda (x) (eq? type x)) args))))
    (define (coercion-if-exists? type arg-tags)
      (let ((coercion-list (map (lambda (x)
				  (if (eq? type x)
				      identity
				      (get-coercion x type))) arg-tags)))
	(if (accumulate (lambda (x y) (and x y)) #t coercion-list)
	    coercion-list
	    #f)))
    (drop (let* ((type-tags (map type-tag args))
		 (proc (get op type-tags)))
	    (cond (proc (apply proc (map contents args)))
		  ((= 1 (length args))
		   #;(show #t "No proc found for op=" op ", type-tags=" type-tags "\n")
		   (apply-generic op (raise-type (car args))))
		  ((= 2 (length args))
		   (if (type1<=type2? (car type-tags) (cadr type-tags))
		       (apply-generic op (raise-type (car args)) (cadr args))
		       (apply-generic op (car args)  (raise-type (cadr args)))))
		  ((and (>= (length args) 2) (not (all-argtypes-same? args)))
		   (let types-loop ((types type-tags))
		     (let ((list-of-coercion-functions
			    (coercion-if-exists? (car types) type-tags)))
		       (if list-of-coercion-functions
			   (apply apply-generic (cons op (map (lambda (fun arg) (fun arg))
							      list-of-coercion-functions
							      args)))
			   (if (not (null? (cdr types)))
			       (types-loop (cdr types))
			       (error "apply-generic:Even coercions failed. No method for these types."))))))
		  (else (error "apply-generic:No method for these types"
			       (list op type-tags)))))))
  (define (scheme-number->complex n)
    (make-complex-from-real-imag (contents n) 0))
  (put-coercion 'scheme-number
		'complex
		scheme-number->complex)

  (put 'max3-magnitude '(complex complex complex) (lambda (z1 z2 z3)
						    (max (magnitude z1) (magnitude z2) (magnitude z3))))
  (define (max3-magnitude x1 x2 x3) (apply-generic 'max3-magnitude x1 x2 x3))
  (define (identity x) x)

  (define numeric-tower (list 'integer 'rational 'scheme-number 'complex))

  (define (higher-type x)
    (define (find-higher-type x types)
      (cond ((or (null? types) (null? (cdr types))) (error "No type higher than given" x))
	    ((eq? x (car types)) (cadr types))
	    (else (find-higher-type x (cdr types)))))
    (find-higher-type x numeric-tower))

  (define (type1<=type2? type1 type2)
    (if (not (memq type1 numeric-tower))
	(error "Type 1 not in the numeric tower"))
    (if (not (memq type2 numeric-tower))
	(error "Type 2 not in the numeric tower"))
    (let loop ((types numeric-tower))
      (cond ((null? types) (error "Type 1 and type 2 are incomparable" type1 type2))
	    ((eq? (car types) type1) #t)
	    ((eq? (car types) type2) #f)
	    (else (loop (cdr types))))))

  (define (integer->rational x)
    (make-rational x 1))

  (define (rational->scheme-number x)
    (make-scheme-number ((get 'to-real '(rational)) x)))
  (put-coercion 'integer 'rational integer->rational)
  (put-coercion 'rational 'scheme-number rational->scheme-number)

  (define (raise-type x)
    (let ((converter (get-coercion (type-tag x) (higher-type (type-tag x)))))
      (if converter
	  (converter x)
	  (error "No coercion found for x" (type-tag x) x))))


  (define (remainder-integer a b)
    (when (or (not (integer? a)) (not (integer? b)))
      (error "Arguments must be integers" a b))
    (remainder a b))

  (put 'remainder '(integer integer) remainder-integer)
  (define (remainder-generalized a b) (apply-generic 'remainder a b))


  (show #t "Test 1: Subtracting complex numbers: "
	(sub
	 (make-complex-from-real-imag 1.1 2)
	 (make-complex-from-real-imag 0 2)) "\n")
  (define (install-polynomial-package)
    (define (make-poly variable term-list)
      (cons variable term-list))
    (define (variable p) (car p))
    (define (term-list p)
      (cdr p))
    (define (variable? x) (symbol? x))
    (define (same-variable? v1 v2)
      (and (variable? v1) (variable? v2) (eq? v1 v2)))
    (define (=number? exp num)
      (and (number? exp) (= exp num)))
    (define (the-empty-termlist) '())

    (define (rest-terms term-list) (cdr term-list))
    (define (empty-termlist? term-list) (null? term-list))

    (define (make-term order coeff) (list order coeff))
    (define (order term) (car term))
    (define (coeff term) (cadr term))

    #;(continued on next page)

    (define (add-poly p1 p2)
      (if (same-variable? (variable p1) (variable p2))
	  (make-poly (variable p1)
		     (add-terms (term-list p1)
				(term-list p2)))
	  (error "Polys not in same var -- ADD-POLY"
		 (list p1 p2))))
    (define (sub-poly p1 p2)
      (add-poly p1 (mul-poly p2 (make-poly (variable p2) (list (make-term 0 -1))))))
    (define (add-terms L1 L2)
      (cond ((empty-termlist? L1) L2)
	    ((empty-termlist? L2) L1)
	    (else
	     (let ((t1 (first-term L1)) (t2 (first-term L2)))
	       (cond ((> (order t1) (order t2))
		      (adjoin-term
		       t1 (add-terms (rest-terms L1) L2)))
		     ((< (order t1) (order t2))
		      (adjoin-term
		       t2 (add-terms L1 (rest-terms L2))))
		     (else
		      (adjoin-term
		       (make-term (order t1)
				  (add (coeff t1) (coeff t2)))
		       (add-terms (rest-terms L1)
				  (rest-terms L2)))))))))


    (define (mul-poly p1 p2)
      (if (same-variable? (variable p1) (variable p2))
	  (make-poly (variable p1)
		     (mul-terms (term-list p1)
				(term-list p2)))
	  (error "Polys not in same var -- MUL-POLY"
		 (list p1 p2))))
    (define (mul-terms L1 L2)
      (if (empty-termlist? L1)
	  (the-empty-termlist)
	  (add-terms (mul-term-by-all-terms (first-term L1) L2)
		     (mul-terms (rest-terms L1) L2))))

    (define (mul-term-by-all-terms t1 L)
      (if (empty-termlist? L)
	  (the-empty-termlist)
	  (let ((t2 (first-term L)))
	    (adjoin-term
	     (make-term (+ (order t1) (order t2))
			(mul (coeff t1) (coeff t2)))
	     (mul-term-by-all-terms t1 (rest-terms L))))))
    (define (zero-poly? poly)
      #;(show #t "zero-poly?: poly=" (displayed poly) "\n")
      (cond ((empty-termlist? (term-list poly)) #t)
	    ((not (= 0 (coeff (first-term (term-list poly))))) #f)
	    (else (zero-poly?
		   (make-poly (variable poly)
			      (rest-terms (term-list poly)))))))
    (define (tag p) (attach-tag 'polynomial p))
    (define (termlist-type-of term-list)
      #;(show #t "t-t-o: term-list=" (displayed term-list) "\n")
      (cond ((null? term-list) 'sparse)
	    ((pair? (car term-list)) 'sparse)
	    ((list? term-list) 'dense)
	    (else (error "Unknown type of list" term-list))))
    (define (adjoin-term term term-list)
      ((get 'adjoin-term (termlist-type-of term-list)) term term-list))
    (define (first-term term-list)
      #;(show #t "first-term: term-list=" (displayed term-list) "\n")
      #;(show #t "first-term: term-list-type=" (displayed (termlist-type-of term-list)) "\n")
      ((get 'first-term (termlist-type-of term-list)) term-list))
    (put 'add '(polynomial polynomial)
	 (lambda (p1 p2) (tag (add-poly p1 p2))))
    (put 'mul '(polynomial polynomial)
	 (lambda (p1 p2) (tag (mul-poly p1 p2))))
    (put 'sub '(polynomial polynomial)
	 (lambda (p1 p2) (tag (sub-poly p1 p2))))
    (put 'make 'polynomial
	 (lambda (var terms) (tag (make-poly var terms))))
    (put 'zero? '(polynomial) zero-poly?)
    'done)
  (install-polynomial-package)

  (define (install-polynomial-sparse-package)
    (define (coeff term) (cadr term))
    (define (first-term-sparse term-list) (car term-list))
    (define (adjoin-term-sparse term term-list)
      (if (zero? (coeff term))
	  term-list
	  (cons term term-list)))
    (put 'adjoin-term 'sparse adjoin-term-sparse)
    (put 'first-term 'sparse first-term-sparse)
    'done)
  (install-polynomial-sparse-package)

  (define (install-polynomial-dense-package)
    (define (make-term order coeff) (list order coeff))
    (define (order term) (car term))
    (define (coeff term) (cadr term))

    (define (adjoin-term-dense term term-list)
	(if (zero? (coeff term))
	    term-list
	    (if (> (order term) (length term-list))
		(append (list (coeff term))
			(make-list (- (order term) (length term-list)) 0)
			term-list)
		(error "adjoin-term:Appending a smaller order term. Recheck."))))
    (define (first-term-dense term-list)
       #;(show #t "first-term-dense: " (displayed (make-term (car term-list) (length (cdr term-list)))) "\n")
       (make-term (length (cdr term-list)) (car term-list) ))
    (put 'adjoin-term 'dense adjoin-term-dense)
    (put 'first-term 'dense first-term-dense)
    'done)
  (install-polynomial-dense-package)

  (define (make-polynomial var terms)
    ((get 'make 'polynomial) var terms))
  (show #t "Test 2: Making polynomials: "
	(make-polynomial 'x (list (list 5 1) (list 4 2))) "\n")
  (show #t "Test 3: Zero?: "
	(zero? (make-polynomial 'x (list (list 5 1) (list 4 2)))) "\n")
  (show #t "Test 4: Adding polynomials: "
	(add (make-polynomial 'x '((5 1) (4 2) (0 1)))
	     (make-polynomial 'x '((5 1)))) "\n")
  #;(show #t "Test 4: Zero?: " (zero? (make-polynomial 'x '((5 0) (3 1)))) "\n")

  (show #t "Test 5: Subtracting polynomials: "
	(sub (make-polynomial 'x '((5 1) (4 2) (0 1)))
	     (make-polynomial 'x '((0 1)))) "\n")

  (show #t "Test 6: Making a dense polynomial: " (make-polynomial 'x '(1 2 3 4 5)) "\n")
  (show #t "Test 7: zero? dense polynomial: " (displayed (zero? (make-polynomial 'x '(0)))) "\n")
  (show #t "Test 8: zero? dense polynomial: " (displayed (zero? (make-polynomial 'x '(1)))) "\n")
  (show #t "Test 9: Adding dense polynomials: "
	(add (make-polynomial 'x '(1 2 0 0 0 1))
	     (make-polynomial 'x '(1 0 0 0 0 0))) "\n")
  (show #t "Test10: Subtracting dense polynomials: "
	(sub (make-polynomial 'x '(1 2 0 0 0 1))
	     (make-polynomial 'x '(1 0 0 0 0 0))) "\n")
  (show #t "Test11: Subtracting dense and sparse polynomials: "
	(sub (make-polynomial 'x '(1 2 0 0 0 1))
	     (make-polynomial 'x '((4 2)))) "\n")
#+end_src

#+RESULTS[73ffa111c8d1f0b9dd0479c9c8db75690f851de5]:
#+begin_src scheme
Test 1: Subtracting complex numbers: (rational 2476979795053773 . 2251799813685248)
Test 2: Making polynomials: (polynomial x (5 1) (4 2))
Test 3: Zero?: #f
Test 4: Adding polynomials: (polynomial x (5 2) (4 2) (0 1))
Test 5: Subtracting polynomials: (polynomial x (5 1) (4 2))
Test 6: Making a dense polynomial: (polynomial x 1 2 3 4 5)
Test 7: zero? dense polynomial: #t
Test 8: zero? dense polynomial: #f
Test 9: Adding dense polynomials: (polynomial x (5 2) (4 2) (0 1))
Test10: Subtracting dense polynomials: (polynomial x 2 0 0 0 1)
Test11: Subtracting dense and sparse polynomials: (polynomial x 1 0 0 0 0 1)
#+end_src

This also turned out to be not such a difficult exercise. The slightly
controversial thing that I am concerned with is that the function
~termlist-type-of~ is not based on tags, and is not even using the main
generic dispatch subsystem. But so far this seems good enough.

*** DONE Exercise 2.91 Division of polynomials
    CLOSED: [2019-10-23 Wed 00:11]
And again, since div-poly is an internal procedure of the polynomial package,
let me copy the whole code.

#+begin_src scheme :exports both :results output scalar code
  (define (project obj)
    (apply-generic 'project obj))
  (define (droppable? obj)
    (cond ((not (memq (type-tag obj) numeric-tower)) #f)
	  ((eq? (type-tag obj) (car numeric-tower)) #f)
	  ((equ? obj (raise-type (project obj))) #t)
	  (else #f)))
  (define (drop obj)
    (if (droppable? obj)
	(drop (project obj))
	obj))

  (define (accumulate op initial sequence)
    (if (null? sequence)
	initial
	(accumulate op (op initial (car sequence)) (cdr sequence))))
  (define false #f)
  (define true  #t)
  (define (make-table)
    (let ((local-table (list '*table*)))
      (define (lookup key-1 key-2)
	(let ((subtable (assoc key-1 (cdr local-table))))
	  (if subtable
	      (let ((record (assoc key-2 (cdr subtable))))
		(if record
		    (cdr record)
		    false))
	      false)))
      (define (insert! key-1 key-2 value)
	(let ((subtable (assoc key-1 (cdr local-table))))
	  (if subtable
	      (let ((record (assoc key-2 (cdr subtable))))
		(if record
		    (set-cdr! record value)
		    (set-cdr! subtable
			      (cons (cons key-2 value)
				    (cdr subtable)))))
	      (set-cdr! local-table
			(cons (list key-1
				    (cons key-2 value))
			      (cdr local-table)))))
	'ok)
      (define (dispatch m)
	(cond ((eq? m 'lookup-proc) lookup)
	      ((eq? m 'insert-proc!) insert!)
	      (else (error "Unknown operation -- TABLE" m))))
      dispatch))

  (define operation-table (make-table))
  (define get (operation-table 'lookup-proc))
  (define put (operation-table 'insert-proc!))

  (define coercion-table (make-table))
  (define get-coercion (coercion-table 'lookup-proc))
  (define put-coercion (coercion-table 'insert-proc!))

  (define (attach-tag type-tag contents)
    (cons type-tag contents))

  (define (type-tag datum)
    (cond ((pair? datum) (car datum))
	  ((exact-integer? datum) 'integer)
	  ((real? datum) 'scheme-number)
	  (error "Bad tagged datum -- TYPE-TAG" datum)))

  (define (contents datum)
    (cond ((pair? datum) (cdr datum))
	  ((integer? datum) datum)
	  ((real? datum) datum)
	  (else (error "Bad tagged datum -- CONTENTS" datum))))

  (define (integer? x)
    (eq? (type-tag x) 'integer))
  (define (rectangular? z)
    (eq? (type-tag z) 'rectangular))

  (define (polar? z)
    (eq? (type-tag z) 'polar))


  (define (real-part z) (apply-generic 'real-part z))
  (define (imag-part z) (apply-generic 'imag-part z))
  (define (magnitude z) (apply-generic 'magnitude z))
  (define (angle z) (apply-generic 'angle z))

  (define (add x y) (apply-generic 'add x y))
  (define (sub x y) (apply-generic 'sub x y))
  (define (mul x y) (apply-generic 'mul x y))
  (define (div x y) (apply-generic 'div x y))

  (define (equ? x y)
    (apply-generic 'equ? x y))
  (define (zero? x) (apply-generic 'zero? x))

  (define (exp x y) (apply-generic 'exp x y))

  (define (install-scheme-number-package)
    (define (tag x)
      (attach-tag 'scheme-number x))
    (put 'add '(scheme-number scheme-number)
	 (lambda (x y) (tag (+ x y))))
    (put 'sub '(scheme-number scheme-number)
	 (lambda (x y) (tag (- x y))))
    (put 'mul '(scheme-number scheme-number)
	 (lambda (x y) (tag (* x y))))
    (put 'div '(scheme-number scheme-number)
	 (lambda (x y) (tag (/ x y))))
    (put 'make 'scheme-number
	 (lambda (x) (tag x)))
    (put 'equ? '(scheme-number scheme-number)
	 (lambda (x y) (= x y)))
    (put 'zero? '(scheme-number)
	 (lambda (x) (= 0 x)))
    (put 'exp '(scheme-number scheme-number)
	 (lambda (x y) (tag (expt x y))))
    (put 'project '(scheme-number)
	 (lambda (x)
	   (make-rational
	    (exact (numerator x))
	    (exact (denominator x)))))
    (put 'sine '(scheme-number) sin)
    (put 'cosine '(scheme-number) cos)
    (put 'square-root '(scheme-number) sqrt)
    (put 'arctangent '(schemer-number) atan)
    'done)

  (define (sine x) (apply-generic 'sine x))
  (define (cosine x) (apply-generic 'cosine x))
  (define (square-root x) (apply-generic 'square-root x))
  (define (arctangent x) (apply-generic 'arctangent x))

  (define (make-scheme-number n)
    ((get 'make 'scheme-number) n))

  (define (install-rational-package)
    (define (numer x) (car x))
    (define (denom x) (cdr x))
    (define (make-rat n d)
      (let ((g (gcd n d)))
	(cons (/ n g) (/ d g))))
    (define (add-rat x y)
      (make-rat (+ (* (numer x) (denom y))
		   (* (numer y) (denom x)))
		(* (denom x) (denom y))))
    (define (sub-rat x y)
      (make-rat (- (* (numer x) (denom y))
		   (* (numer y) (denom x)))
		(* (denom x) (denom y))))
    (define (mul-rat x y)
      (make-rat (* (numer x) (numer y))
		(* (denom x) (denom y))))
    (define (div-rat x y)
      (make-rat (* (numer x) (denom y))
		(* (denom x) (numer y))))

    (define (tag x) (attach-tag 'rational x))
    (put 'add '(rational rational)
	 (lambda (x y) (tag (add-rat x y))))
    (put 'sub '(rational rational)
	 (lambda (x y) (tag (sub-rat x y))))
    (put 'mul '(rational rational)
	 (lambda (x y) (tag (mul-rat x y))))
    (put 'div '(rational rational)
	 (lambda (x y) (tag (div-rat x y))))

    (put 'make 'rational
	 (lambda (n d) (tag (make-rat n d))))
    (put 'equ? '(rational rational)
	 (lambda (x y) (= 0 (numer (sub-rat x y)))))
    (put 'zero? '(rational) (lambda (x) (= 0 (numer x))))
    (put 'project '(rational) (lambda (x)
				(exact (truncate (/ (numer x) (denom x))))))
    (put 'to-real '(rational) (lambda (x) (/ (numer (contents x)) (denom (contents x)))))
    'done)

  (define (make-rational n d)
    ((get 'make 'rational) n d))

  (define (install-rectangular-package)

    (define (real-part z) (car z))
    (define (imag-part z) (cdr z))
    (define (make-from-real-imag x y) (cons x y))
    (define (magnitude z)
      (square-root (add (square (real-part z))
			(square (imag-part z)))))
    (define (angle z)
      (arctangent (imag-part z) (real-part z)))
    (define (make-from-mag-ang r a)
      (cons (mul r (cosine a)) (mul r (sine a))))

    (define (tag x) (attach-tag 'rectangular x))
    (put 'real-part '(rectangular) real-part)
    (put 'imag-part '(rectangular) imag-part)
    (put 'magnitude '(rectangular) magnitude)
    (put 'angle '(rectangular) angle)
    (put 'make-from-real-imag 'rectangular
	 (lambda (x y) (tag (make-from-real-imag x y))))
    (put 'make-from-mag-ang 'rectangular
	 (lambda (r a) (tag (make-from-mag-ang r a))))
    'done)

  (define (install-polar-package)

    (define (magnitude z) (car z))
    (define (angle z) (cdr z))
    (define (make-from-mag-ang r a) (cons r a))
    (define (real-part z)
      (mul (magnitude z) (cosine (angle z))))
    (define (imag-part z)
      (mul (magnitude z) (sine (angle z))))
    (define (make-from-real-imag x y)
      (cons (square-root (add (square x) (square y)))
	    (arctangent y x)))

    (define (tag x) (attach-tag 'polar x))
    (put 'real-part '(polar) real-part)
    (put 'imag-part '(polar) imag-part)
    (put 'magnitude '(polar) magnitude)
    (put 'angle '(polar) angle)
    (put 'make-from-real-imag 'polar
	 (lambda (x y) (tag (make-from-real-imag x y))))
    (put 'make-from-mag-ang 'polar
	 (lambda (r a) (tag (make-from-mag-ang r a))))
    'done)

  (define (install-complex-package)
    (define (make-from-real-imag x y)
      ((get 'make-from-real-imag 'rectangular) x y))
    (define (make-from-mag-ang r a)
      ((get 'make-from-mag-ang 'polar) r a))
    (define (add-complex z1 z2)
      (make-from-real-imag (add (real-part z1) (real-part z2))
			   (add (imag-part z1) (imag-part z2))))
    (define (sub-complex z1 z2)
      (make-from-real-imag (sub (real-part z1) (real-part z2))
			   (sub (imag-part z1) (imag-part z2))))
    (define (mul-complex z1 z2)
      (make-from-mag-ang (mul (magnitude z1) (magnitude z2))
			 (add (angle z1) (angle z2))))
    (define (div-complex z1 z2)
      (make-from-mag-ang (div (magnitude z1) (magnitude z2))
			 (sub (angle z1) (angle z2))))
    (define (tag z) (attach-tag 'complex z))
    (put 'add '(complex complex)
	 (lambda (z1 z2) (tag (add-complex z1 z2))))
    (put 'sub '(complex complex)
	 (lambda (z1 z2) (tag (sub-complex z1 z2))))
    (put 'mul '(complex complex)
	 (lambda (z1 z2) (tag (mul-complex z1 z2))))
    (put 'div '(complex complex)
	 (lambda (z1 z2) (tag (div-complex z1 z2))))
    (put 'make-from-real-imag 'complex
	 (lambda (x y) (tag (make-from-real-imag x y))))
    (put 'make-from-mag-ang 'complex
	 (lambda (r a) (tag (make-from-mag-ang r a))))
    (put 'equ? '(complex complex)
	 (lambda (x y) (and (= 0 (real-part (sub-complex x y)))
			    (= 0 (imag-part (sub-complex x y))))))
    (put 'equ? '(rectangular polar) equ?)
    (put 'equ? '(polar rectangular) equ?)
    (put 'zero? '(complex)
	 (lambda (x) (equ? (tag x) (tag (make-from-real-imag 0 0)))))
    (put 'project '(complex) (lambda (z) (real-part z)))
    'done)

  (define (make-complex-from-real-imag x y)
    ((get 'make-from-real-imag 'complex) x y))

  (define (make-complex-from-mag-ang r a)
    ((get 'make-from-mag-ang 'complex) r a))

  (install-rectangular-package)
  (install-polar-package)
  (install-rational-package)
  (install-scheme-number-package)
  (install-complex-package)

  (put 'real-part '(complex) real-part)
  (put 'imag-part '(complex) imag-part)
  (put 'magnitude '(complex) magnitude)
  (put 'angle '(complex) angle)

  (define (apply-generic op . args)
    (define (all-argtypes-same? . args)
      (let ((type (type-tag (car args))))
	(accumulate (lambda (x y) (and x y)) #t (map (lambda (x) (eq? type x)) args))))
    (define (coercion-if-exists? type arg-tags)
      (let ((coercion-list (map (lambda (x)
				  (if (eq? type x)
				      identity
				      (get-coercion x type))) arg-tags)))
	(if (accumulate (lambda (x y) (and x y)) #t coercion-list)
	    coercion-list
	    #f)))
    (drop (let* ((type-tags (map type-tag args))
		 (proc (get op type-tags)))
	    (cond (proc (apply proc (map contents args)))
		  ((= 1 (length args))
		   #;(show #t "No proc found for op=" op ", type-tags=" type-tags "\n")
		   (apply-generic op (raise-type (car args))))
		  ((= 2 (length args))
		   (if (type1<=type2? (car type-tags) (cadr type-tags))
		       (apply-generic op (raise-type (car args)) (cadr args))
		       (apply-generic op (car args)  (raise-type (cadr args)))))
		  ((and (>= (length args) 2) (not (all-argtypes-same? args)))
		   (let types-loop ((types type-tags))
		     (let ((list-of-coercion-functions
			    (coercion-if-exists? (car types) type-tags)))
		       (if list-of-coercion-functions
			   (apply apply-generic (cons op (map (lambda (fun arg) (fun arg))
							      list-of-coercion-functions
							      args)))
			   (if (not (null? (cdr types)))
			       (types-loop (cdr types))
			       (error "apply-generic:Even coercions failed. No method for these types."))))))
		  (else (error "apply-generic:No method for these types"
			       (list op type-tags)))))))
  (define (scheme-number->complex n)
    (make-complex-from-real-imag (contents n) 0))
  (put-coercion 'scheme-number
		'complex
		scheme-number->complex)

  (put 'max3-magnitude '(complex complex complex) (lambda (z1 z2 z3)
						    (max (magnitude z1) (magnitude z2) (magnitude z3))))
  (define (max3-magnitude x1 x2 x3) (apply-generic 'max3-magnitude x1 x2 x3))
  (define (identity x) x)

  (define numeric-tower (list 'integer 'rational 'scheme-number 'complex))

  (define (higher-type x)
    (define (find-higher-type x types)
      (cond ((or (null? types) (null? (cdr types))) (error "No type higher than given" x))
	    ((eq? x (car types)) (cadr types))
	    (else (find-higher-type x (cdr types)))))
    (find-higher-type x numeric-tower))

  (define (type1<=type2? type1 type2)
    (if (not (memq type1 numeric-tower))
	(error "Type 1 not in the numeric tower"))
    (if (not (memq type2 numeric-tower))
	(error "Type 2 not in the numeric tower"))
    (let loop ((types numeric-tower))
      (cond ((null? types) (error "Type 1 and type 2 are incomparable" type1 type2))
	    ((eq? (car types) type1) #t)
	    ((eq? (car types) type2) #f)
	    (else (loop (cdr types))))))

  (define (integer->rational x)
    (make-rational x 1))

  (define (rational->scheme-number x)
    (make-scheme-number ((get 'to-real '(rational)) x)))
  (put-coercion 'integer 'rational integer->rational)
  (put-coercion 'rational 'scheme-number rational->scheme-number)

  (define (raise-type x)
    (let ((converter (get-coercion (type-tag x) (higher-type (type-tag x)))))
      (if converter
	  (converter x)
	  (error "No coercion found for x" (type-tag x) x))))


  (define (remainder-integer a b)
    (when (or (not (integer? a)) (not (integer? b)))
      (error "Arguments must be integers" a b))
    (remainder a b))

  (put 'remainder '(integer integer) remainder-integer)
  (define (remainder-generalized a b) (apply-generic 'remainder a b))


  (show #t "Test 1: Subtracting complex numbers: "
	(sub
	 (make-complex-from-real-imag 1.1 2)
	 (make-complex-from-real-imag 0 2)) "\n")
  (define (install-polynomial-package)
    (define (make-poly variable term-list)
      (cons variable term-list))
    (define (variable p) (car p))
    (define (term-list p)
      (cdr p))
    (define (variable? x) (symbol? x))
    (define (same-variable? v1 v2)
      (and (variable? v1) (variable? v2) (eq? v1 v2)))
    (define (=number? exp num)
      (and (number? exp) (= exp num)))
    (define (the-empty-termlist) '())

    (define (rest-terms term-list) (cdr term-list))
    (define (empty-termlist? term-list) (null? term-list))

    (define (make-term order coeff) (list order coeff))
    (define (order term) (car term))
    (define (coeff term) (cadr term))

    #;(continued on next page)

    (define (add-poly p1 p2)
      (if (same-variable? (variable p1) (variable p2))
	  (make-poly (variable p1)
		     (add-terms (term-list p1)
				(term-list p2)))
	  (error "Polys not in same var -- ADD-POLY"
		 (list p1 p2))))
    (define (sub-poly p1 p2)
      (add-poly p1 (mul-poly p2 (make-poly (variable p2) (list (make-term 0 -1))))))
    (define (add-terms L1 L2)
      (cond ((empty-termlist? L1) L2)
	    ((empty-termlist? L2) L1)
	    (else
	     (let ((t1 (first-term L1)) (t2 (first-term L2)))
	       (cond ((> (order t1) (order t2))
		      (adjoin-term
		       t1 (add-terms (rest-terms L1) L2)))
		     ((< (order t1) (order t2))
		      (adjoin-term
		       t2 (add-terms L1 (rest-terms L2))))
		     (else
		      (adjoin-term
		       (make-term (order t1)
				  (add (coeff t1) (coeff t2)))
		       (add-terms (rest-terms L1)
				  (rest-terms L2)))))))))


    (define (mul-poly p1 p2)
      (if (same-variable? (variable p1) (variable p2))
	  (make-poly (variable p1)
		     (mul-terms (term-list p1)
				(term-list p2)))
	  (error "Polys not in same var -- MUL-POLY"
		 (list p1 p2))))
    (define (div-poly p1 p2)
      (if (same-variable? (variable p1) (variable p2))
	  (let ((quotient-and-remainder (div-terms (term-list p1)
						   (term-list p2))))
	    (list (make-poly (variable p1) (car  quotient-and-remainder))
		  (make-poly (variable p1) (cadr quotient-and-remainder))))
	    (error "div-poly: Polys not in the same var" p1 p2)))
    (define (div-terms L1 L2)
	    (if (empty-termlist? L1)
		(list (the-empty-termlist) (the-empty-termlist))
		(let ((t1 (first-term L1))
		      (t2 (first-term L2)))
		  (if (> (order t2) (order t1))
		      (list (the-empty-termlist) L1)
		      (let ((new-c (div (coeff t1) (coeff t2)))
			    (new-o (- (order t1) (order t2))))
			(let ((rest-of-result (div-terms (term-list
							  (sub-poly
							   (make-poly 'fake-var L1)
							   (mul-poly
							    (make-poly 'fake-var (list (make-term new-o new-c)))
							    (make-poly 'fake-var L2))))
							 L2)
					      ))
			  (show #t "div-terms: rest-of-result: " (displayed rest-of-result) "\n")
			  (list (adjoin-term (make-term new-o new-c) (car rest-of-result)) (cadr rest-of-result))
			  ))))))
    (define (mul-terms L1 L2)
      (if (empty-termlist? L1)
	  (the-empty-termlist)
	  (add-terms (mul-term-by-all-terms (first-term L1) L2)
		     (mul-terms (rest-terms L1) L2))))

    (define (mul-term-by-all-terms t1 L)
      (if (empty-termlist? L)
	  (the-empty-termlist)
	  (let ((t2 (first-term L)))
	    (adjoin-term
	     (make-term (+ (order t1) (order t2))
			(mul (coeff t1) (coeff t2)))
	     (mul-term-by-all-terms t1 (rest-terms L))))))
    (define (zero-poly? poly)
      #;(show #t "zero-poly?: poly=" (displayed poly) "\n")
      (cond ((empty-termlist? (term-list poly)) #t)
	    ((not (= 0 (coeff (first-term (term-list poly))))) #f)
	    (else (zero-poly?
		   (make-poly (variable poly)
			      (rest-terms (term-list poly)))))))
    (define (tag p) (attach-tag 'polynomial p))
    (define (termlist-type-of term-list)
      #;(show #t "t-t-o: term-list=" (displayed term-list) "\n")
      (cond ((null? term-list) 'sparse)
	    ((pair? (car term-list)) 'sparse)
	    ((list? term-list) 'dense)
	    (else (error "Unknown type of list" term-list))))
    (define (adjoin-term term term-list)
      ((get 'adjoin-term (termlist-type-of term-list)) term term-list))
    (define (first-term term-list)
      #;(show #t "first-term: term-list=" (displayed term-list) "\n")
      #;(show #t "first-term: term-list-type=" (displayed (termlist-type-of term-list)) "\n")
      ((get 'first-term (termlist-type-of term-list)) term-list))
    (put 'add '(polynomial polynomial)
	 (lambda (p1 p2) (tag (add-poly p1 p2))))
    (put 'mul '(polynomial polynomial)
	 (lambda (p1 p2) (tag (mul-poly p1 p2))))
    (put 'sub '(polynomial polynomial)
	 (lambda (p1 p2) (tag (sub-poly p1 p2))))
    (put 'make 'polynomial
	 (lambda (var terms) (tag (make-poly var terms))))
    (put 'zero? '(polynomial) zero-poly?)
    (put 'div '(polynomial polynomial) div-poly)
    'done)
  (install-polynomial-package)

  (define (install-polynomial-sparse-package)
    (define (coeff term) (cadr term))
    (define (first-term-sparse term-list) (car term-list))
    (define (adjoin-term-sparse term term-list)
      (if (zero? (coeff term))
	  term-list
	  (cons term term-list)))
    (put 'adjoin-term 'sparse adjoin-term-sparse)
    (put 'first-term 'sparse first-term-sparse)
    'done)
  (install-polynomial-sparse-package)

  (define (install-polynomial-dense-package)
    (define (make-term order coeff) (list order coeff))
    (define (order term) (car term))
    (define (coeff term) (cadr term))

    (define (adjoin-term-dense term term-list)
	(if (zero? (coeff term))
	    term-list
	    (if (> (order term) (length term-list))
		(append (list (coeff term))
			(make-list (- (order term) (length term-list)) 0)
			term-list)
		(error "adjoin-term:Appending a smaller order term. Recheck."))))
    (define (first-term-dense term-list)
       #;(show #t "first-term-dense: " (displayed (make-term (car term-list) (length (cdr term-list)))) "\n")
       (make-term (length (cdr term-list)) (car term-list) ))
    (put 'adjoin-term 'dense adjoin-term-dense)
    (put 'first-term 'dense first-term-dense)
    'done)
  (install-polynomial-dense-package)

  (define (make-polynomial var terms)
    ((get 'make 'polynomial) var terms))
  (show #t "Test 2: Making polynomials: "
	(make-polynomial 'x (list (list 5 1) (list 4 2))) "\n")
  (show #t "Test 3: Zero?: "
	(zero? (make-polynomial 'x (list (list 5 1) (list 4 2)))) "\n")
  (show #t "Test 4: Adding polynomials: "
	(add (make-polynomial 'x '((5 1) (4 2) (0 1)))
	     (make-polynomial 'x '((5 1)))) "\n")
  #;(show #t "Test 4: Zero?: " (zero? (make-polynomial 'x '((5 0) (3 1)))) "\n")

  (show #t "Test 5: Subtracting polynomials: "
	(sub (make-polynomial 'x '((5 1) (4 2) (0 1)))
	     (make-polynomial 'x '((0 1)))) "\n")

  (show #t "Test 6: Making a dense polynomial: " (make-polynomial 'x '(1 2 3 4 5)) "\n")
  (show #t "Test 7: zero? dense polynomial: " (displayed (zero? (make-polynomial 'x '(0)))) "\n")
  (show #t "Test 8: zero? dense polynomial: " (displayed (zero? (make-polynomial 'x '(1)))) "\n")
  (show #t "Test 9: Adding dense polynomials: "
	(add (make-polynomial 'x '(1 2 0 0 0 1))
	     (make-polynomial 'x '(1 0 0 0 0 0))) "\n")
  (show #t "Test10: Subtracting dense polynomials: "
	(sub (make-polynomial 'x '(1 2 0 0 0 1))
	     (make-polynomial 'x '(1 0 0 0 0 0))) "\n")
  (show #t "Test11: Subtracting dense and sparse polynomials: "
	(sub (make-polynomial 'x '(1 2 0 0 0 1))
	     (make-polynomial 'x '((4 2)))) "\n")
  (show #t "Test12: Dividing x^2 + 2x + 1 by x+1: "
	(displayed
	 (div (make-polynomial 'x '((2 1) (1 2) (0 1)))
	      (make-polynomial 'x '(      (1 1) (0 1)))) ) "\n")
#+end_src

#+RESULTS[d4f49c4abd9e0b75d04625dfe26b86bc37e11b40]:
#+begin_src scheme
Test 1: Subtracting complex numbers: (rational 2476979795053773 . 2251799813685248)
Test 2: Making polynomials: (polynomial x (5 1) (4 2))
Test 3: Zero?: #f
Test 4: Adding polynomials: (polynomial x (5 2) (4 2) (0 1))
Test 5: Subtracting polynomials: (polynomial x (5 1) (4 2))
Test 6: Making a dense polynomial: (polynomial x 1 2 3 4 5)
Test 7: zero? dense polynomial: #t
Test 8: zero? dense polynomial: #f
Test 9: Adding dense polynomials: (polynomial x (5 2) (4 2) (0 1))
Test10: Subtracting dense polynomials: (polynomial x 2 0 0 0 1)
Test11: Subtracting dense and sparse polynomials: (polynomial x 1 0 0 0 0 1)
div-terms: rest-of-result: (() ())
div-terms: rest-of-result: (((0 1)) ())
Test12: Dividing x^2 + 2x + 1 by x+1: ((x (1 1) (0 1)) (x))
#+end_src

This task also wasn't very difficult. The only problem here is that
~div-poly~ returns two polynomials, not one. This is a problem, because this
breaks the closure property.

*** DONE Exercise 2.92 Ordering of variables so that addition and multiplication work for different variables
    CLOSED: [2019-10-27 Sun 13:32]

"This is not easy, Prof. Abelson". Indeed, at the very beginning we are
meeting a problem: we need to add polynomials and numbers. This problem seems
to be extraordinarily laborious.

Well, the sketch of the idea was to rearrange the polynomials to a canonical
form, so that the variables are ordered sequentially. So we will need a way
to compare the variables, say, alphabetically.

To help us in this business, we shall use R^7 RS standard procedures
~symbol->string~ and ~string<?~.

Essentially, this code does a bubble-sort on the variables. The
~normalize-once~ procedure makes one pass of the exchanges, that is, it
effectively allows one "bubble" to float up.

The ~normalize-fully~ procedure repeats the normalization until it's done,
which may lead to infinite loops in case there are some bugs inside, but it
should work as \(n^2\) .

The thing that does not work in this implementation is the division of
polynomials of different variables. To be hones, because I am not sure what
it is semantically.

In total, this exercise took me several days, and the net amount of hours
spent is about 10.


#+begin_src scheme :exports both :results output scalar code
    (define (project obj)
      (apply-generic 'project obj))
    (define (droppable? obj)
      (cond ((not (memq (type-tag obj) numeric-tower)) #f)
	    ((eq? (type-tag obj) (car numeric-tower)) #f)
	    ((equ? obj (raise-type (project obj))) #t)
	    (else #f)))
    (define (drop obj)
      (if (droppable? obj)
	  (drop (project obj))
	  obj))

  (define (thingy-source thingy)
    (cond ((lambda? thingy) (list "lambda" (lambda-source thingy)))
	  ((procedure? thingy) (list "procedure" (procedure-name thingy)))
	  ((pair? thingy) (list "pair" (pair-source thingy)))
	  (else "No source? refactor")))

    (define (accumulate op initial sequence)
      (if (null? sequence)
	  initial
	  (accumulate op (op initial (car sequence)) (cdr sequence))))
    (define false #f)
    (define true  #t)
    (define (make-table)
      (let ((local-table (list '*table*)))
	(define (lookup key-1 key-2)
	  (let ((subtable (assoc key-1 (cdr local-table))))
	    (if subtable
		(let ((record (assoc key-2 (cdr subtable))))
		  (if record
		      (cdr record)
		      false))
		false)))
	(define (insert! key-1 key-2 value)
	  (let ((subtable (assoc key-1 (cdr local-table))))
	    (if subtable
		(let ((record (assoc key-2 (cdr subtable))))
		  (if record
		      (set-cdr! record value)
		      (set-cdr! subtable
				(cons (cons key-2 value)
				      (cdr subtable)))))
		(set-cdr! local-table
			  (cons (list key-1
				      (cons key-2 value))
				(cdr local-table)))))
	  'ok)
	(define (dispatch m)
	  (cond ((eq? m 'lookup-proc) lookup)
		((eq? m 'insert-proc!) insert!)
		(else (error "Unknown operation -- TABLE" m))))
	dispatch))

    (define operation-table (make-table))
    (define get (operation-table 'lookup-proc))
    (define put (operation-table 'insert-proc!))

    (define coercion-table (make-table))
    (define get-coercion (coercion-table 'lookup-proc))
    (define put-coercion (coercion-table 'insert-proc!))

    (define (attach-tag type-tag contents)
      (cons type-tag contents))

    (define (type-tag datum)
      (cond ((pair? datum) (car datum))
	    ((exact-integer? datum) 'integer)
	    ((real? datum) 'scheme-number)
	    (error "Bad tagged datum -- TYPE-TAG" datum)))

  (define (contents datum)
      (cond ((pair? datum) (cdr datum))
	    ((integer? datum) datum)
	    ((real? datum) datum)
	    (else (error "Bad tagged datum -- CONTENTS" datum))))

    (define (integer? x)
      (eq? (type-tag x) 'integer))
    (define (rectangular? z)
      (eq? (type-tag z) 'rectangular))

    (define (polar? z)
      (eq? (type-tag z) 'polar))


    (define (real-part z) (apply-generic 'real-part z))
    (define (imag-part z) (apply-generic 'imag-part z))
    (define (magnitude z) (apply-generic 'magnitude z))
    (define (angle z) (apply-generic 'angle z))

    (define (add x y) (apply-generic 'add x y))
    (define (sub x y) (apply-generic 'sub x y))
    (define (mul x y) (apply-generic 'mul x y))
    (define (div x y) (apply-generic 'div x y))

    (define (equ? x y)
      (apply-generic 'equ? x y))
    (define (zero? x) (apply-generic 'zero? x))

    (define (exp x y) (apply-generic 'exp x y))

    (define (install-scheme-number-package)
      (define (tag x)
	(attach-tag 'scheme-number x))
      (put 'add '(scheme-number scheme-number)
	   (lambda (x y) (tag (+ x y))))
      (put 'sub '(scheme-number scheme-number)
	   (lambda (x y) (tag (- x y))))
      (put 'mul '(scheme-number scheme-number)
	   (lambda (x y) (tag (* x y))))
      (put 'div '(scheme-number scheme-number)
	   (lambda (x y) (tag (/ x y))))
      (put 'make 'scheme-number
	   (lambda (x) (tag x)))
      (put 'equ? '(scheme-number scheme-number)
	   (lambda (x y) (= x y)))
      (put 'zero? '(scheme-number)
	   (lambda (x) (= 0 x)))
      (put 'exp '(scheme-number scheme-number)
	   (lambda (x y) (tag (expt x y))))
      (put 'project '(scheme-number)
	   (lambda (x)
	     (make-rational
	      (exact (numerator x))
	      (exact (denominator x)))))
      (put 'sine '(scheme-number) sin)
      (put 'cosine '(scheme-number) cos)
      (put 'square-root '(scheme-number) sqrt)
      (put 'arctangent '(schemer-number) atan)
      'done)

    (define (sine x) (apply-generic 'sine x))
    (define (cosine x) (apply-generic 'cosine x))
    (define (square-root x) (apply-generic 'square-root x))
    (define (arctangent x) (apply-generic 'arctangent x))

    (define (make-scheme-number n)
      ((get 'make 'scheme-number) n))

    (define (install-rational-package)
      (define (numer x) (car x))
      (define (denom x) (cdr x))
      (define (make-rat n d)
	(let ((g (gcd n d)))
	  (cons (/ n g) (/ d g))))
      (define (add-rat x y)
	(make-rat (+ (* (numer x) (denom y))
		     (* (numer y) (denom x)))
		  (* (denom x) (denom y))))
      (define (sub-rat x y)
	(make-rat (- (* (numer x) (denom y))
		     (* (numer y) (denom x)))
		  (* (denom x) (denom y))))
      (define (mul-rat x y)
	(make-rat (* (numer x) (numer y))
		  (* (denom x) (denom y))))
      (define (div-rat x y)
	(make-rat (* (numer x) (denom y))
		  (* (denom x) (numer y))))

      (define (tag x) (attach-tag 'rational x))
      (put 'add '(rational rational)
	   (lambda (x y) (tag (add-rat x y))))
      (put 'sub '(rational rational)
	   (lambda (x y) (tag (sub-rat x y))))
      (put 'mul '(rational rational)
	   (lambda (x y) (tag (mul-rat x y))))
      (put 'div '(rational rational)
	   (lambda (x y) (tag (div-rat x y))))

      (put 'make 'rational
	   (lambda (n d) (tag (make-rat n d))))
      (put 'equ? '(rational rational)
	   (lambda (x y) (= 0 (numer (sub-rat x y)))))
      (put 'zero? '(rational) (lambda (x) (= 0 (numer x))))
      (put 'project '(rational) (lambda (x)
				  (exact (truncate (/ (numer x) (denom x))))))
      (put 'to-real '(rational) (lambda (x) (/ (numer (contents x)) (denom (contents x)))))
      'done)

    (define (make-rational n d)
      ((get 'make 'rational) n d))

    (define (install-rectangular-package)

      (define (real-part z) (car z))
      (define (imag-part z) (cdr z))
      (define (make-from-real-imag x y) (cons x y))
      (define (magnitude z)
	(square-root (add (square (real-part z))
			  (square (imag-part z)))))
      (define (angle z)
	(arctangent (imag-part z) (real-part z)))
      (define (make-from-mag-ang r a)
	(cons (mul r (cosine a)) (mul r (sine a))))

      (define (tag x) (attach-tag 'rectangular x))
      (put 'real-part '(rectangular) real-part)
      (put 'imag-part '(rectangular) imag-part)
      (put 'magnitude '(rectangular) magnitude)
      (put 'angle '(rectangular) angle)
      (put 'make-from-real-imag 'rectangular
	   (lambda (x y) (tag (make-from-real-imag x y))))
      (put 'make-from-mag-ang 'rectangular
	   (lambda (r a) (tag (make-from-mag-ang r a))))
      'done)

    (define (install-polar-package)

      (define (magnitude z) (car z))
      (define (angle z) (cdr z))
      (define (make-from-mag-ang r a) (cons r a))
      (define (real-part z)
	(mul (magnitude z) (cosine (angle z))))
      (define (imag-part z)
	(mul (magnitude z) (sine (angle z))))
      (define (make-from-real-imag x y)
	(cons (square-root (add (square x) (square y)))
	      (arctangent y x)))

      (define (tag x) (attach-tag 'polar x))
      (put 'real-part '(polar) real-part)
      (put 'imag-part '(polar) imag-part)
      (put 'magnitude '(polar) magnitude)
      (put 'angle '(polar) angle)
      (put 'make-from-real-imag 'polar
	   (lambda (x y) (tag (make-from-real-imag x y))))
      (put 'make-from-mag-ang 'polar
	   (lambda (r a) (tag (make-from-mag-ang r a))))
      'done)

    (define (install-complex-package)
      (define (make-from-real-imag x y)
	((get 'make-from-real-imag 'rectangular) x y))
      (define (make-from-mag-ang r a)
	((get 'make-from-mag-ang 'polar) r a))
      (define (add-complex z1 z2)
	(make-from-real-imag (add (real-part z1) (real-part z2))
			     (add (imag-part z1) (imag-part z2))))
      (define (sub-complex z1 z2)
	(make-from-real-imag (sub (real-part z1) (real-part z2))
			     (sub (imag-part z1) (imag-part z2))))
      (define (mul-complex z1 z2)
	(make-from-mag-ang (mul (magnitude z1) (magnitude z2))
			   (add (angle z1) (angle z2))))
      (define (div-complex z1 z2)
	(make-from-mag-ang (div (magnitude z1) (magnitude z2))
			   (sub (angle z1) (angle z2))))
      (define (tag z) (attach-tag 'complex z))
      (put 'add '(complex complex)
	   (lambda (z1 z2) (tag (add-complex z1 z2))))
      (put 'sub '(complex complex)
	   (lambda (z1 z2) (tag (sub-complex z1 z2))))
      (put 'mul '(complex complex)
	   (lambda (z1 z2) (tag (mul-complex z1 z2))))
      (put 'div '(complex complex)
	   (lambda (z1 z2) (tag (div-complex z1 z2))))
      (put 'make-from-real-imag 'complex
	   (lambda (x y) (tag (make-from-real-imag x y))))
      (put 'make-from-mag-ang 'complex
	   (lambda (r a) (tag (make-from-mag-ang r a))))
      (put 'equ? '(complex complex)
	   (lambda (x y) (and (= 0 (real-part (sub-complex x y)))
			      (= 0 (imag-part (sub-complex x y))))))
      (put 'equ? '(rectangular polar) equ?)
      (put 'equ? '(polar rectangular) equ?)
      (put 'zero? '(complex)
	   (lambda (x) (equ? (tag x) (tag (make-from-real-imag 0 0)))))
      (put 'project '(complex) (lambda (z) (real-part z)))
      'done)

    (define (make-complex-from-real-imag x y)
      ((get 'make-from-real-imag 'complex) x y))

    (define (make-complex-from-mag-ang r a)
      ((get 'make-from-mag-ang 'complex) r a))

    (install-rectangular-package)
    (install-polar-package)
    (install-rational-package)
    (install-scheme-number-package)
    (install-complex-package)

    (put 'real-part '(complex) real-part)
    (put 'imag-part '(complex) imag-part)
    (put 'magnitude '(complex) magnitude)
    (put 'angle '(complex) angle)

    (define (apply-generic op . args)
      #;(show #t "apply-generic:entry\n")
      #;(error "debug")
      (define (variable poly) (car poly))
      (define (all-argtypes-same? . args)
	(let ((type (type-tag (car args))))
	  (accumulate (lambda (x y) (and x y)) #t (map (lambda (x) (eq? type x)) args))))
      (define (coercion-if-exists? type arg-tags)
	(let ((coercion-list (map (lambda (x)
				    (if (eq? type x)
					identity
					(get-coercion x type))) arg-tags)))
	  (if (accumulate (lambda (x y) (and x y)) #t coercion-list)
	      coercion-list
	      #f)))
      (drop (let* ((type-tags (map type-tag args))
		   (proc (get op type-tags)))
	      #;(show #t "apply-generic: type-tags="
		       (displayed type-tags)
		       " proc=" (written proc)
		       " proc-source=" (thingy-source proc) "\n")
	      (cond (proc (apply proc (map contents args)))
		    ((= 1 (length args))
		     #;(show #t "No proc found for op=" op ", type-tags=" type-tags ", arg=" (displayed args) "\n")
		     (apply-generic op (raise-type (car args))))
		    ((= 2 (length args))
		     (cond ((and (eq? 'polynomial (car type-tags))
			       (numeric? (cadr type-tags)))
			    (apply-generic op
					   (car args)
					   (make-polynomial (variable (contents (car args)))
							    (list (list 0 (cadr args))))))
			   ((and (numeric? (car type-tags))
			       (eq? 'polynomial (cadr type-tags)))
			    (apply-generic op
					   (make-polynomial (variable (contents (cadr args)))
							    (list (list 0 (car args))))
					   (cadr args)))
			   ((and (get-coercion (car type-tags) (cadr type-tags))
			       (not (eq? (car type-tags) (cadr type-tags))))
			    (apply-generic op
					   ((get-coercion
					     (car type-tags)
					     (cadr type-tags)) (car args))
					   (cadr args)))
			   ((and (get-coercion (cadr type-tags) (car type-tags))
			       (not (eq? (car type-tags) (cadr type-tags))))
			    (apply-generic op
					   (car args)
					   ((get-coercion
					     (cadr type-tags)
					     (car type-tags)) (cadr args) )))
			   ((comparable? (car type-tags) (cadr type-tags))
			    (if
			     (type1<=type2? (car type-tags) (cadr type-tags))
			     (apply-generic op (raise-type (car args)) (cadr args))
			     (apply-generic op (car args)  (raise-type (cadr args)))))
			   (else (error "apply-generic:Incomparable types: (type-tags,args)=" type-tags args))))
		    ((and (> (length args) 2) (not (all-argtypes-same? args)))
		     (let types-loop ((types type-tags))
		       (let ((list-of-coercion-functions
			      (coercion-if-exists? (car types) type-tags)))
			 (if list-of-coercion-functions
			     (apply apply-generic (cons op (map (lambda (fun arg) (fun arg))
								list-of-coercion-functions
								args)))
			     (if (not (null? (cdr types)))
				 (types-loop (cdr types))
				 (error "apply-generic:Even coercions failed. No method for these types."))))))
		    (else (error "apply-generic:No method for these types"
				 (list op type-tags)))))))
    (define (scheme-number->complex n)
      (make-complex-from-real-imag (contents n) 0))
    (put-coercion 'scheme-number
		  'complex
		  scheme-number->complex)

    (put 'max3-magnitude '(complex complex complex) (lambda (z1 z2 z3)
						      (max (magnitude z1) (magnitude z2) (magnitude z3))))
    (define (max3-magnitude x1 x2 x3) (apply-generic 'max3-magnitude x1 x2 x3))
    (define (identity x) x)

  (define numeric-tower (list 'integer 'rational 'scheme-number 'complex))
  (define (comparable? type1 type2) (and (memq type1 numeric-tower) (memq type2 numeric-tower)))
  #;(define (higher-type x)
    (show #t "higher-type:x=" (displayed x) "\n")
      (define (find-higher-type x types)
	(cond ((or (null? types) (null? (cdr types))) (error "No type higher than given" x types))
	      ((eq? x (car types)) (cadr types))
	      (else (find-higher-type x (cdr types)))))
      (find-higher-type x numeric-tower))

  (define (numeric? x)
    (memq x numeric-tower))
  (define (polynomial? x)
    (eq? (type-tag x) 'polynomial))
  (define (higher-type x)
    (let ((tail (memq x numeric-tower)))
      (cond ((eq? #f tail) (error "Type not in the tower" x))
	    ((null? (cdr tail)) (error "Already the highest type:" x))
	    (else (cadr tail)))))

  (show #t "Test: Higher than 'integer: " (higher-type 'integer) "\n")
  #;(show #t "Test: Higher than 'complex: " (higher-type 'complex) "\n")

    (define (type1<=type2? type1 type2)
      (if (not (memq type1 numeric-tower))
	  (error "Type 1 not in the numeric tower"))
      (if (not (memq type2 numeric-tower))
	  (error "Type 2 not in the numeric tower"))
      (let loop ((types numeric-tower))
	(cond ((null? types) (error "Type 1 and type 2 are incomparable" type1 type2))
	      ((eq? (car types) type1) #t)
	      ((eq? (car types) type2) #f)
	      (else (loop (cdr types))))))

    (define (integer->rational x)
      (make-rational x 1))

    (define (rational->scheme-number x)
      (make-scheme-number ((get 'to-real '(rational)) x)))
    (put-coercion 'integer 'rational integer->rational)
    (put-coercion 'rational 'scheme-number rational->scheme-number)

  (define (raise-type x)
    #;(show #t "Raising type of: " (displayed x) "\n")
      (let ((converter (get-coercion (type-tag x) (higher-type (type-tag x)))))
	(if converter
	    (converter x)
	    (error "No coercion found for x" (type-tag x) x))))


    (define (remainder-integer a b)
      (when (or (not (integer? a)) (not (integer? b)))
	(error "Arguments must be integers" a b))
      (remainder a b))

    (put 'remainder '(integer integer) remainder-integer)
    (define (remainder-generalized a b) (apply-generic 'remainder a b))


    (show #t "Test 1: Subtracting complex numbers: "
	  (sub
	   (make-complex-from-real-imag 1.1 2)
	   (make-complex-from-real-imag 0 2)) "\n")
  (define (install-polynomial-package)
    #;(define (contents generic-object)
      (cdr generic-object))
      (define (make-poly variable term-list)
	(cons variable term-list))
      (define (variable p) (car p))
      (define (term-list p)
	(cdr p))
      (define (variable? x) (symbol? x))
      (define (same-variable? v1 v2)
	(and (variable? v1) (variable? v2) (eq? v1 v2)))
      (define (=number? exp num)
	(and (number? exp) (= exp num)))
      (define (the-empty-termlist) '())

      (define (rest-terms term-list) (cdr term-list))
      (define (empty-termlist? term-list) (null? term-list))

      (define (make-term order coeff) (list order coeff))
      (define (order term) (car term))
      (define (coeff term) (cadr term))
      (define (tag p) (attach-tag 'polynomial p))
      (put 'make 'polynomial
	   (lambda (var terms) (tag (make-poly var terms))))
      #;(continued on next page)

      (define (add-poly p1 p2)
	#;(show #t "add-poly: p1=" p1 ", p2=" p2 "\n")
	(if (same-variable? (variable p1) (variable p2))
	    (make-poly (variable p1)
		       (add-terms (term-list p1)
				  (term-list p2)))
	    (let ((res (cdr (if (variable_1-order<variable_2-order (variable p1) (variable p2))
		(add (tag p1) (tag (make-poly (variable p1) (list (make-term 0 (tag p2))))))
		(add (tag (make-poly (variable p2) (list (make-term 0 (tag p1))))) (tag p2))))))
	      #;(show #t "add-poly:result: " (displayed res) "\n") res)))

      (show #t "TestY2: poly of poly: "
	    (make-poly 'x (list
			   (make-term 3 (make-poly
					 'y (list (make-term 1 1) (make-term 0 1))))
			   (make-term 1 2)
			   (make-term 0 4))) "\n")

      (define (sub-poly p1 p2)
	(add-poly p1 (mul-poly p2 (make-poly (variable p2) (list (make-term 0 -1))))))
      (define (add-terms L1 L2)
	(cond ((empty-termlist? L1) L2)
	      ((empty-termlist? L2) L1)
	      (else
	       (let ((t1 (first-term L1)) (t2 (first-term L2)))
		 (cond ((> (order t1) (order t2))
			(adjoin-term
			 t1 (add-terms (rest-terms L1) L2)))
		       ((< (order t1) (order t2))
			(adjoin-term
			 t2 (add-terms L1 (rest-terms L2))))
		       (else
			(adjoin-term
			 (make-term (order t1)
				    (add (coeff t1) (coeff t2)))
			 (add-terms (rest-terms L1)
				    (rest-terms L2)))))))))


      (define (mul-poly p1 p2)
	(if (same-variable? (variable p1) (variable p2))
	    (make-poly (variable p1)
		       (mul-terms (term-list p1)
				  (term-list p2)))
	    (contents (if (variable_1-order<variable_2-order (variable p1) (variable p2))
		(mul (tag p1)
		     (make-polynomial (variable p1)
				      (adjoin-term
				       (make-term 0
						  (tag p2)) (the-empty-termlist))))
		(mul (tag p2)
		     (make-polynomial (variable p2)
				      (adjoin-term
				       (make-term 0
						  (tag p1)) (the-empty-termlist))))))
	    #;(error "Polys not in same var -- MUL-POLY"
		   (list p1 p2))))
      (define (div-poly p1 p2)
	(if (same-variable? (variable p1) (variable p2))
	    (let ((quotient-and-remainder (div-terms (term-list p1)
						     (term-list p2))))
	      (list (make-poly (variable p1) (car  quotient-and-remainder))
		    (make-poly (variable p1) (cadr quotient-and-remainder))))
	      (error "div-poly: Polys not in the same var" p1 p2)))
      (define (div-terms L1 L2)
	      (if (empty-termlist? L1)
		  (list (the-empty-termlist) (the-empty-termlist))
		  (let ((t1 (first-term L1))
			(t2 (first-term L2)))
		    (if (> (order t2) (order t1))
			(list (the-empty-termlist) L1)
			(let ((new-c (div (coeff t1) (coeff t2)))
			      (new-o (- (order t1) (order t2))))
			  (let ((rest-of-result (div-terms (term-list
							    (sub-poly
							     (make-poly 'fake-var L1)
							     (mul-poly
							      (make-poly 'fake-var (list (make-term new-o new-c)))
							      (make-poly 'fake-var L2))))
							   L2)
						))
			    #;(show #t "div-terms: rest-of-result: " (displayed rest-of-result) "\n")
			    (list (adjoin-term (make-term new-o new-c) (car rest-of-result)) (cadr rest-of-result))
			    ))))))
      (define (mul-terms L1 L2)
	(if (empty-termlist? L1)
	    (the-empty-termlist)
	    (add-terms (mul-term-by-all-terms (first-term L1) L2)
		       (mul-terms (rest-terms L1) L2))))

      (define (mul-term-by-all-terms t1 L)
	(if (empty-termlist? L)
	    (the-empty-termlist)
	    (let ((t2 (first-term L)))
	      (adjoin-term
	       (make-term (+ (order t1) (order t2))
			  (mul (coeff t1) (coeff t2)))
	       (mul-term-by-all-terms t1 (rest-terms L))))))
      (define (zero-poly? poly)
	#;(show #t "zero-poly?: poly=" (displayed poly) "\n")
	(cond ((empty-termlist? (term-list poly)) #t)
	      ((not (zero? (coeff (first-term (term-list poly))))) #f)
	      (else (zero-poly?
		     (make-poly (variable poly)
				(rest-terms (term-list poly)))))))

      (define (termlist-type-of term-list)
	#;(show #t "t-t-o: term-list=" (displayed term-list) "\n")
	(cond ((null? term-list) 'sparse)
	      ((pair? (car term-list)) 'sparse)
	      ((list? term-list) 'dense)
	      (else (error "Unknown type of list" term-list))))
      (define (adjoin-term term term-list)
	((get 'adjoin-term (termlist-type-of term-list)) term term-list))
      (define (first-term term-list)
	((get 'first-term (termlist-type-of term-list)) term-list))
      (define (variable_1-order<variable_2-order variable_1 variable_2)
	#;(show #t "var_1-..: variable_1=" variable_1 " variable_2=" variable_2 "\n")
	#;(show #t "var12string=" (symbol->string variable_1) "var22string=" (symbol->string variable_2) "\n")
	(string<=? (symbol->string variable_1) (symbol->string variable_2)))
      (define (normalize-fully poly)
	(if (normal-polynomial? poly)
	    poly
	    (normalize-fully (normalize-once poly))))
      (put 'add '(polynomial polynomial)
	   (lambda (p1 p2)
	     #;(show #t "generic-add-poly:Polynomial dispatch found: p1="
		    (displayed p1) " p2=" (displayed p2) "\n")
	     (normalize-fully (tag (add-poly p1 p2)))))
      (put 'mul '(polynomial polynomial)
	   (lambda (p1 p2) (normalize-fully (tag (mul-poly p1 p2)))))
      (put 'sub '(polynomial polynomial)
	   (lambda (p1 p2) (tag (sub-poly p1 p2))))

      (put 'zero? '(polynomial) zero-poly?)
      (put 'div '(polynomial polynomial) div-poly)
      #;(put-coercion 'rational 'scheme-number rational->scheme-number)
      (define (monomial-flip-variables monomial)
	#;(show #t "m-f-v: monomial=" monomial "\n")
	(let* ((mono (contents monomial))
	       (inner-polynomial (contents (coeff (first-term (term-list mono)))))
	       (inner-poly (contents inner-polynomial))
	       (outer-order (order (first-term (term-list mono))))
	       (outer-var (variable mono))
	       (inner-var (variable inner-polynomial))
	       (inner-term-list (term-list inner-poly)))
	  #;(show #t "m-f-v: inner-poly=" inner-poly "\n")
	  (if (same-variable? inner-var outer-var)
	      (mul
	       (make-polynomial outer-var (adjoin-term (make-term outer-order 1) (the-empty-termlist)))
	       (tag inner-polynomial))
	      (tag (make-poly inner-var
			      (mul-term-by-all-terms (make-term
						      0
						      (make-polynomial
						       outer-var
						       (list (make-term
							      outer-order
							      1)))) inner-poly))))))
      #;(show #t "TestXX: sorting variables: Is 'x < 'y?: "
	    (variable_1-order<variable_2-order 'x 'y) "\n")
      #;(show #t "TestXX: sorting variables: Is 'z < 'y?: "
	    (variable_1-order<variable_2-order 'z 'y) "\n")
      #;(show #t "TestXX: (adding two basic poly): "
	    (add (make-polynomial 'x (list (make-term 1 2) (make-term 0 4)))
		 (make-polynomial 'y (list (make-term 2 3) (make-term 0 5)))) "\n")

      (define (polynomial->sum-of-first-and-rest poly)
	#;(show #t "p->s-o-f-a-r: " (displayed poly) "\n")
	(if (zero? poly)
	    poly
	    (let* ((poly1 (contents poly))
		   (first-monomial (tag
				    (make-poly
				     (variable poly1)
				     (list (first-term (term-list poly1)))))))
	      #;(show #t "p->s-o-f-a-r: " (displayed first-monomial) "\n")
	      (add
		first-monomial
		(polynomial->sum-of-first-and-rest
		 (tag (make-poly (variable poly1) (rest-terms (term-list poly1)))))))))

      (show #t "Test13: Expanding a polynomial as monomials: "
	    (displayed
	     (polynomial->sum-of-first-and-rest
	      (make-polynomial 'y
			       (list (make-term 2 (make-polynomial
						   'x
						   (list (make-term 2 1) (make-term 0 1))))
				     (make-term 0 2))))) "\n")

      (show #t "\nTest20: start monomial: "
	    (displayed (make-polynomial 'x
					(list
					 (make-term
					  2
					  (make-polynomial
					   'y
					   (list
					    (make-term 2 1) (make-term 0 1))))))) "\n")
      (show #t "Test20: Flipping a monomial variable: "
	    (displayed
	     (monomial-flip-variables
	      (make-polynomial 'x
			       (list (make-term 1 (make-polynomial
						   'y
						   (list
						    (make-term 2 1)
						    (make-term 0 1)))))))) "\n\n")


      (define (normal-polynomial? poly)
	#;(show #t "n-p?: poly=" poly "\n")
	(cond ((not (polynomial? poly)) #t)
	      ((null? (term-list (contents poly))) #t)
	      (else (let* ((poly1 (contents poly))
			   (outer-var (variable poly1)))
		      #;(show #t "Inner-let: outer-var=" (displayed outer-var) "\n")
		      (let loop ((terms (term-list poly1)))
			#;(show #t "n-p?-loop: terms=" (displayed terms) "\n")
			(cond ((null? terms) #t)
			      ((not (polynomial? (coeff (first-term terms)))) (loop (rest-terms terms)))
			      ((not (variable_1-order<variable_2-order
				   outer-var
				   (variable (contents (coeff (first-term terms)))))) (begin #;(show #t "wrong variable order \n") #f))
			      ((not (normal-polynomial? (coeff (first-term terms)))) (begin #;(show #t "not normal poly\n") #f))
			      (else (loop (rest-terms terms)))))
		      ))))
      (define (normalize-once poly)
	#;(show #t "normalize-once poly= " (displayed poly) "\n")
	(if (zero? poly)
	    poly
	    (let* ((poly1 (contents poly))
		   (first-monomial (tag
				    (make-poly
				     (variable poly1)
				     (list (make-term
					    (order (first-term (term-list poly1)))
					    (if (polynomial? (coeff (first-term (term-list poly1))))
						(normalize-once (coeff (first-term (term-list poly1))))
						(coeff (first-term (term-list poly1))))))))))
	      #;(show #t "p->s-o-f-a-r: " (displayed first-monomial) "\n")
	      (add
	       (if (and (polynomial?
		       (coeff
			(first-term
			 (term-list
			  (contents first-monomial)))))
		      (variable_1-order<variable_2-order
		       (variable
			(contents
			 (coeff
			  (first-term
			   (term-list
			    (contents first-monomial))))))
		       (variable
			(contents first-monomial))))
		   (monomial-flip-variables first-monomial)
		   first-monomial)
		(polynomial->sum-of-first-and-rest
		 (tag (make-poly (variable poly1) (rest-terms (term-list poly1)))))))))

      (show #t "Test21: normal-polynomial?:start: " (displayed (make-polynomial 'y
					     (list (make-term 2 (make-polynomial
								 'x
						   (list (make-term 2 1) (make-term 0 1))))
						   (make-term 0 2)))) "\n")
      (show #t "Test21: normal-polynomial?:result:" (normal-polynomial? (make-polynomial 'y
					     (list (make-term 2 (make-polynomial
								 'x
						   (list (make-term 2 1) (make-term 0 1))))
						   (make-term 0 2)))) "\n")
      (show #t "Test22: normal-polynomial?-good:start: "
	    (displayed
	     (make-polynomial 'x
			      (list (make-term 2 (make-polynomial
						  'y
						  (list (make-term 2 1) (make-term 0 1))))
				    (make-term 0 2)))) "\n")
      (show #t "Test22: normal-polynomial?-good:result:"
	    (normal-polynomial?
	     (make-polynomial 'x
			      (list (make-term 2 (make-polynomial
						  'y
						  (list (make-term 2 1) (make-term 0 1))))
				    (make-term 0 2)))) "\n")

      (show #t "Test23:input: normalizing a bad polynomial: "
	    (make-polynomial 'y
			       (list (make-term 2 (make-polynomial
						   'x
						   (list (make-term 2 1) (make-term 0 1))))
				     (make-term 0 2))) "\n")
      (show #t "Test23:result: normalizing a bad polynomial: "
	    (normalize-once (make-polynomial 'y
					     (list (make-term 2 (make-polynomial
								 'x
						   (list (make-term 2 1) (make-term 0 1))))
						   (make-term 0 2)))) "\n")
      (show #t "Test24:input: normalizing a bad polynomial: "
	    (make-polynomial 'x
			       (list (make-term 2 (make-polynomial
						   'x
						   (list (make-term 2 1) (make-term 0 1))))
				     (make-term 0 2))) "\n")
      (show #t "Test24:result: normalizing a bad polynomial: "
	    (normalize-once (make-polynomial 'x
					     (list (make-term 2 (make-polynomial
								 'x
						   (list (make-term 2 1) (make-term 0 1))))
						   (make-term 0 2)))) "\n")


      (show #t "Test24:input: normalize-fully a bad polynomial: "
	    (make-polynomial 'y
			       (list (make-term 2 (make-polynomial
						   'x
						   (list (make-term 2 1) (make-term 0 1))))
				     (make-term 0 2))) "\n")
      (show #t "Test24:result: normalize-fully a bad polynomial: "
	    (normalize-fully (make-polynomial 'y
					     (list (make-term 2 (make-polynomial
								 'x
						   (list (make-term 2 1) (make-term 0 1))))
						   (make-term 0 2)))) "\n")



      'done)


    (define (install-polynomial-sparse-package)
      (define (coeff term) (cadr term))
      (define (first-term-sparse term-list) (car term-list))
      (define (adjoin-term-sparse term term-list)
	(if (zero? (coeff term))
	    term-list
	    (cons term term-list)))
      (put 'adjoin-term 'sparse adjoin-term-sparse)
      (put 'first-term 'sparse first-term-sparse)
      'done)
    (install-polynomial-sparse-package)

    (define (install-polynomial-dense-package)
      (define (make-term order coeff) (list order coeff))
      (define (order term) (car term))
      (define (coeff term) (cadr term))

      (define (adjoin-term-dense term term-list)
	  (if (zero? (coeff term))
	      term-list
	      (if (> (order term) (length term-list))
		  (append (list (coeff term))
			  (make-list (- (order term) (length term-list)) 0)
			  term-list)
		  (error "adjoin-term:Appending a smaller order term. Recheck."))))
      (define (first-term-dense term-list)
	 #;(show #t "first-term-dense: " (displayed (make-term (car term-list) (length (cdr term-list)))) "\n")
	 (make-term (length (cdr term-list)) (car term-list) ))
      (put 'adjoin-term 'dense adjoin-term-dense)
      (put 'first-term 'dense first-term-dense)
      'done)
    #;(install-polynomial-dense-package)

    (define (make-polynomial var terms)
      ((get 'make 'polynomial) var terms))

  (install-polynomial-package)


    #;(show #t "Test 2: Making polynomials: "
	  (make-polynomial 'x (list (list 5 1) (list 4 2))) "\n")
    #;(show #t "Test 3: Zero?: "
	  (zero? (make-polynomial 'x (list (list 5 1) (list 4 2)))) "\n")
    #;(show #t "Test 4: Adding polynomials: "
	  (add (make-polynomial 'x '((5 1) (4 2) (0 1)))
	       (make-polynomial 'x '((5 1)))) "\n")
    #;(show #t "Test 4: Zero?: " (zero? (make-polynomial 'x '((5 0) (3 1)))) "\n")

    #;(show #t "Test 5: Subtracting polynomials: "
	  (sub (make-polynomial 'x '((5 1) (4 2) (0 1)))
	       (make-polynomial 'x '((0 1)))) "\n")

    #;(show #t "Test 6: Making a dense polynomial: " (make-polynomial 'x '(1 2 3 4 5)) "\n")
    #;(show #t "Test 7: zero? dense polynomial: " (displayed (zero? (make-polynomial 'x '(0)))) "\n")
    #;(show #t "Test 8: zero? dense polynomial: " (displayed (zero? (make-polynomial 'x '(1)))) "\n")
    #;(show #t "Test 9: Adding dense polynomials: "
	  (add (make-polynomial 'x '(1 2 0 0 0 1))
	       (make-polynomial 'x '(1 0 0 0 0 0))) "\n")
    #;(show #t "Test10: Subtracting dense polynomials: "
	  (sub (make-polynomial 'x '(1 2 0 0 0 1))
	       (make-polynomial 'x '(1 0 0 0 0 0))) "\n")
    #;(show #t "Test11: Subtracting dense and sparse polynomials: "
	  (sub (make-polynomial 'x '(1 2 0 0 0 1))
	       (make-polynomial 'x '((4 2)))) "\n")
    #;(show #t "Test12: Dividing x^2 + 2x + 1 by x+1: "
	  (displayed
	   (div (make-polynomial 'x '((2 1) (1 2) (0 1)))
		(make-polynomial 'x '(      (1 1) (0 1)))) ) "\n")
    #;(show #t "Test14: Adding polynomials of two variables: "
	  (displayed
	   (add (make-polynomial 'x '((1 1)))
		(make-polynomial 'y '((1 1))))))
    #;(show #t "Test14: Adding polynomials of two variables, when one of them is nonexistant: "
	  (displayed
	   (add (make-polynomial 'x '((1 1)))
		(make-polynomial 'y '((0 1))))))
  (show #t "Test25: multiplying different variables: "
	(displayed (mul (make-polynomial 'x '((1 1)))
			(make-polynomial 'y '((1 1))))) "\n")


#+end_src

#+RESULTS[f79b271de0f74177f3577032e4d846f03401626e]:
#+begin_src scheme
Test: Higher than 'integer: rational
Test 1: Subtracting complex numbers: (rational 2476979795053773 . 2251799813685248)
TestY2: poly of poly: (x (3 (y (1 1) (0 1))) (1 2) (0 4))
Test13: Expanding a polynomial as monomials: (polynomial x (2 (polynomial y (2 1))) (0 (polynomial y (2 1) (0 2))))

Test20: start monomial: (polynomial x (2 (polynomial y (2 1) (0 1))))
Test20: Flipping a monomial variable: (polynomial y (2 (polynomial x (1 1))) (0 (polynomial x (1 1))))

Test21: normal-polynomial?:start: (polynomial y (2 (polynomial x (2 1) (0 1))) (0 2))
Test21: normal-polynomial?:result:#f
Test22: normal-polynomial?-good:start: (polynomial x (2 (polynomial y (2 1) (0 1))) (0 2))
Test22: normal-polynomial?-good:result:#t
Test23:input: normalizing a bad polynomial: (polynomial y (2 (polynomial x (2 1) (0 1))) (0 2))
Test23:result: normalizing a bad polynomial: (polynomial x (2 (polynomial y (2 1))) (0 (polynomial y (2 1) (0 2))))
Test24:input: normalizing a bad polynomial: (polynomial x (2 (polynomial x (2 1) (0 1))) (0 2))
Test24:result: normalizing a bad polynomial: (polynomial x (4 1) (2 1) (0 2))
Test24:input: normalize-fully a bad polynomial: (polynomial y (2 (polynomial x (2 1) (0 1))) (0 2))
Test24:result: normalize-fully a bad polynomial: (polynomial x (2 (polynomial y (2 1))) (0 (polynomial y (2 1) (0 2))))
Test25: multiplying different variables: (polynomial x (1 (polynomial y (1 1))))
#+end_src

*** DONE Exercise 2.93 Rational polynomials
    CLOSED: [2019-10-27 Sun 22:36]

I do not have any other choice rather than copy everything again.

This turned out to be quite an easy exercise. The architectural decision was
to stop using rational numbers entirely and remove them from the numeric
tower. In principle, rationals can be added as a super-type of polynomials,
but so far this has not been requested.

Note that the normalization algorithm developed in the Exercise p2.92 is still
hooked into the system, even though it would only be used for the case when
the "inner" and "outer" polynomials are of the same variable.

#+begin_src scheme :exports both :results output scalar code
      (define (project obj)
	(apply-generic 'project obj))
      (define (droppable? obj)
	#;(show #t "droppable?: obj=" obj ", type-tag=" (type-tag obj) "\n")
	(cond ((eq? (type-tag obj) 'rational) (begin (show #t "rational not droppable: #f\n") #f))
	      ((not (memq (type-tag obj) numeric-tower)) #f)
	      ((eq? (type-tag obj) (car numeric-tower)) #f)
	      ((equ? obj (raise-type (project obj))) #t)
	      (else #f)))
      (define (drop obj)
	(if (droppable? obj)
	    (drop (project obj))
	    obj))

    (define (thingy-source thingy)
      (cond ((lambda? thingy) (list "lambda" (lambda-source thingy)))
	    ((procedure? thingy) (list "procedure" (procedure-name thingy)))
	    ((pair? thingy) (list "pair" (pair-source thingy)))
	    (else "No source? refactor")))

      (define (accumulate op initial sequence)
	(if (null? sequence)
	    initial
	    (accumulate op (op initial (car sequence)) (cdr sequence))))
      (define false #f)
      (define true  #t)
      (define (make-table)
	(let ((local-table (list '*table*)))
	  (define (lookup key-1 key-2)
	    (let ((subtable (assoc key-1 (cdr local-table))))
	      (if subtable
		  (let ((record (assoc key-2 (cdr subtable))))
		    (if record
			(cdr record)
			false))
		  false)))
	  (define (insert! key-1 key-2 value)
	    (let ((subtable (assoc key-1 (cdr local-table))))
	      (if subtable
		  (let ((record (assoc key-2 (cdr subtable))))
		    (if record
			(set-cdr! record value)
			(set-cdr! subtable
				  (cons (cons key-2 value)
					(cdr subtable)))))
		  (set-cdr! local-table
			    (cons (list key-1
					(cons key-2 value))
				  (cdr local-table)))))
	    'ok)
	  (define (dispatch m)
	    (cond ((eq? m 'lookup-proc) lookup)
		  ((eq? m 'insert-proc!) insert!)
		  (else (error "Unknown operation -- TABLE" m))))
	  dispatch))

      (define operation-table (make-table))
      (define get (operation-table 'lookup-proc))
      (define put (operation-table 'insert-proc!))

      (define coercion-table (make-table))
      (define get-coercion (coercion-table 'lookup-proc))
      (define put-coercion (coercion-table 'insert-proc!))

      (define (attach-tag type-tag contents)
	(cons type-tag contents))

      (define (type-tag datum)
	(cond ((pair? datum) (car datum))
	      ((exact-integer? datum) 'integer)
	      ((real? datum) 'scheme-number)
	      (error "Bad tagged datum -- TYPE-TAG" datum)))

    (define (contents datum)
	(cond ((pair? datum) (cdr datum))
	      ((integer? datum) datum)
	      ((real? datum) datum)
	      (else (error "Bad tagged datum -- CONTENTS" datum))))

      (define (integer? x)
	(eq? (type-tag x) 'integer))
      (define (rectangular? z)
	(eq? (type-tag z) 'rectangular))

      (define (polar? z)
	(eq? (type-tag z) 'polar))


      (define (real-part z) (apply-generic 'real-part z))
      (define (imag-part z) (apply-generic 'imag-part z))
      (define (magnitude z) (apply-generic 'magnitude z))
      (define (angle z) (apply-generic 'angle z))

      (define (add x y) (apply-generic 'add x y))
      (define (sub x y) (apply-generic 'sub x y))
      (define (mul x y) (apply-generic 'mul x y))
      (define (div x y) (apply-generic 'div x y))

      (define (equ? x y)
	(apply-generic 'equ? x y))
      (define (zero? x) (apply-generic 'zero? x))

      (define (exp x y) (apply-generic 'exp x y))

      (define (install-scheme-number-package)
	(define (tag x)
	  (attach-tag 'scheme-number x))
	(put 'add '(scheme-number scheme-number)
	     (lambda (x y) (tag (+ x y))))
	(put 'sub '(scheme-number scheme-number)
	     (lambda (x y) (tag (- x y))))
	(put 'mul '(scheme-number scheme-number)
	     (lambda (x y) (tag (* x y))))
	(put 'div '(scheme-number scheme-number)
	     (lambda (x y) (tag (/ x y))))
	(put 'make 'scheme-number
	     (lambda (x) (tag x)))
	(put 'equ? '(scheme-number scheme-number)
	     (lambda (x y) (= x y)))
	(put 'zero? '(scheme-number)
	     (lambda (x) (= 0 x)))
	(put 'exp '(scheme-number scheme-number)
	     (lambda (x y) (tag (expt x y))))
	(put 'project '(scheme-number)
	     (lambda (x)
	       (exact (truncate x))))
	(put 'sine '(scheme-number) sin)
	(put 'cosine '(scheme-number) cos)
	(put 'square-root '(scheme-number) sqrt)
	(put 'arctangent '(schemer-number) atan)
	'done)

      (define (sine x) (apply-generic 'sine x))
      (define (cosine x) (apply-generic 'cosine x))
      (define (square-root x) (apply-generic 'square-root x))
      (define (arctangent x) (apply-generic 'arctangent x))

      (define (make-scheme-number n)
	((get 'make 'scheme-number) n))

      (define (install-rational-package)
	(define (numer x) (car x))
	(define (denom x) (cdr x))
	(define (make-rat n d)
	  #;(let ((g (gcd n d)))
	    (cons (/ n g) (/ d g)))
	    (cons n d))
	(define (add-rat x y)
	  (make-rat (add (mul (numer x) (denom y))
		       (mul (numer y) (denom x)))
		    (mul (denom x) (denom y))))
	(define (sub-rat x y)
	  (make-rat (sub (mul (numer x) (denom y))
		       (mul (numer y) (denom x)))
		    (mul (denom x) (denom y))))
	(define (mul-rat x y)
	  (make-rat (mul (numer x) (numer y))
		    (mul (denom x) (denom y))))
	(define (div-rat x y)
	  (make-rat (mul (numer x) (denom y))
		    (mul (denom x) (numer y))))

	(define (tag x) (attach-tag 'rational x))
	(put 'add '(rational rational)
	     (lambda (x y) (tag (add-rat x y))))
	(put 'sub '(rational rational)
	     (lambda (x y) (tag (sub-rat x y))))
	(put 'mul '(rational rational)
	     (lambda (x y) (tag (mul-rat x y))))
	(put 'div '(rational rational)
	     (lambda (x y) (tag (div-rat x y))))

	(put 'make 'rational
	     (lambda (n d) (tag (make-rat n d))))
	(put 'equ? '(rational rational)
	     (lambda (x y) (zero? (numer (sub-rat x y)))))
	(put 'zero? '(rational) (lambda (x) (zero? (numer x))))
	#;(put 'project '(rational) (lambda (x)
				    (exact (truncate (/ (numer x) (denom x))))))
	#;(put 'to-real '(rational) (lambda (x) (/ (numer (contents x)) (denom (contents x)))))
	'done)

      (define (make-rational n d)
	((get 'make 'rational) n d))

      (define (install-rectangular-package)

	(define (real-part z) (car z))
	(define (imag-part z) (cdr z))
	(define (make-from-real-imag x y) (cons x y))
	(define (magnitude z)
	  (square-root (add (square (real-part z))
			    (square (imag-part z)))))
	(define (angle z)
	  (arctangent (imag-part z) (real-part z)))
	(define (make-from-mag-ang r a)
	  (cons (mul r (cosine a)) (mul r (sine a))))

	(define (tag x) (attach-tag 'rectangular x))
	(put 'real-part '(rectangular) real-part)
	(put 'imag-part '(rectangular) imag-part)
	(put 'magnitude '(rectangular) magnitude)
	(put 'angle '(rectangular) angle)
	(put 'make-from-real-imag 'rectangular
	     (lambda (x y) (tag (make-from-real-imag x y))))
	(put 'make-from-mag-ang 'rectangular
	     (lambda (r a) (tag (make-from-mag-ang r a))))
	'done)

      (define (install-polar-package)

	(define (magnitude z) (car z))
	(define (angle z) (cdr z))
	(define (make-from-mag-ang r a) (cons r a))
	(define (real-part z)
	  (mul (magnitude z) (cosine (angle z))))
	(define (imag-part z)
	  (mul (magnitude z) (sine (angle z))))
	(define (make-from-real-imag x y)
	  (cons (square-root (add (square x) (square y)))
		(arctangent y x)))

	(define (tag x) (attach-tag 'polar x))
	(put 'real-part '(polar) real-part)
	(put 'imag-part '(polar) imag-part)
	(put 'magnitude '(polar) magnitude)
	(put 'angle '(polar) angle)
	(put 'make-from-real-imag 'polar
	     (lambda (x y) (tag (make-from-real-imag x y))))
	(put 'make-from-mag-ang 'polar
	     (lambda (r a) (tag (make-from-mag-ang r a))))
	'done)

      (define (install-complex-package)
	(define (make-from-real-imag x y)
	  ((get 'make-from-real-imag 'rectangular) x y))
	(define (make-from-mag-ang r a)
	  ((get 'make-from-mag-ang 'polar) r a))
	(define (add-complex z1 z2)
	  (make-from-real-imag (add (real-part z1) (real-part z2))
			       (add (imag-part z1) (imag-part z2))))
	(define (sub-complex z1 z2)
	  (make-from-real-imag (sub (real-part z1) (real-part z2))
			       (sub (imag-part z1) (imag-part z2))))
	(define (mul-complex z1 z2)
	  (make-from-mag-ang (mul (magnitude z1) (magnitude z2))
			     (add (angle z1) (angle z2))))
	(define (div-complex z1 z2)
	  (make-from-mag-ang (div (magnitude z1) (magnitude z2))
			     (sub (angle z1) (angle z2))))
	(define (tag z) (attach-tag 'complex z))
	(put 'add '(complex complex)
	     (lambda (z1 z2) (tag (add-complex z1 z2))))
	(put 'sub '(complex complex)
	     (lambda (z1 z2) (tag (sub-complex z1 z2))))
	(put 'mul '(complex complex)
	     (lambda (z1 z2) (tag (mul-complex z1 z2))))
	(put 'div '(complex complex)
	     (lambda (z1 z2) (tag (div-complex z1 z2))))
	(put 'make-from-real-imag 'complex
	     (lambda (x y) (tag (make-from-real-imag x y))))
	(put 'make-from-mag-ang 'complex
	     (lambda (r a) (tag (make-from-mag-ang r a))))
	(put 'equ? '(complex complex)
	     (lambda (x y) (and (= 0 (real-part (sub-complex x y)))
				(= 0 (imag-part (sub-complex x y))))))
	(put 'equ? '(rectangular polar) equ?)
	(put 'equ? '(polar rectangular) equ?)
	(put 'zero? '(complex)
	     (lambda (x) (equ? (tag x) (tag (make-from-real-imag 0 0)))))
	(put 'project '(complex) (lambda (z) (real-part z)))
	'done)

      (define (make-complex-from-real-imag x y)
	((get 'make-from-real-imag 'complex) x y))

      (define (make-complex-from-mag-ang r a)
	((get 'make-from-mag-ang 'complex) r a))

      (install-rectangular-package)
      (install-polar-package)
      (install-rational-package)
      (install-scheme-number-package)
      (install-complex-package)

      (put 'real-part '(complex) real-part)
      (put 'imag-part '(complex) imag-part)
      (put 'magnitude '(complex) magnitude)
      (put 'angle '(complex) angle)

      (define (apply-generic op . args)
	#;(show #t "apply-generic:entry\n")
	#;(error "debug")
	(define (variable poly) (car poly))
	(define (all-argtypes-same? . args)
	  (let ((type (type-tag (car args))))
	    (accumulate (lambda (x y) (and x y)) #t (map (lambda (x) (eq? type x)) args))))
	(define (coercion-if-exists? type arg-tags)
	  (let ((coercion-list (map (lambda (x)
				      (if (eq? type x)
					  identity
					  (get-coercion x type))) arg-tags)))
	    (if (accumulate (lambda (x y) (and x y)) #t coercion-list)
		coercion-list
		#f)))
	(drop (let* ((type-tags (map type-tag args))
		     (proc (get op type-tags)))
		#;(show #t "apply-generic: type-tags="
			 (displayed type-tags)
			 " proc=" (written proc)
			 " proc-source=" (thingy-source proc) "\n")
		(cond (proc (apply proc (map contents args)))
		      ((= 1 (length args))
		       #;(show #t "No proc found for op=" op ", type-tags=" type-tags ", arg=" (displayed args) "\n")
		       (apply-generic op (raise-type (car args))))
		      ((= 2 (length args))
		       (cond ((and (eq? 'polynomial (car type-tags))
				 (numeric? (cadr type-tags)))
			      (apply-generic op
					     (car args)
					     (make-polynomial (variable (contents (car args)))
							      (list (list 0 (cadr args))))))
			     ((and (numeric? (car type-tags))
				 (eq? 'polynomial (cadr type-tags)))
			      (apply-generic op
					     (make-polynomial (variable (contents (cadr args)))
							      (list (list 0 (car args))))
					     (cadr args)))
			     ((and (get-coercion (car type-tags) (cadr type-tags))
				 (not (eq? (car type-tags) (cadr type-tags))))
			      (apply-generic op
					     ((get-coercion
					       (car type-tags)
					       (cadr type-tags)) (car args))
					     (cadr args)))
			     ((and (get-coercion (cadr type-tags) (car type-tags))
				 (not (eq? (car type-tags) (cadr type-tags))))
			      (apply-generic op
					     (car args)
					     ((get-coercion
					       (cadr type-tags)
					       (car type-tags)) (cadr args) )))
			     ((comparable? (car type-tags) (cadr type-tags))
			      (if
			       (type1<=type2? (car type-tags) (cadr type-tags))
			       (apply-generic op (raise-type (car args)) (cadr args))
			       (apply-generic op (car args)  (raise-type (cadr args)))))
			     (else (error "apply-generic:Incomparable types: (type-tags,args)=" type-tags args))))
		      ((and (> (length args) 2) (not (all-argtypes-same? args)))
		       (let types-loop ((types type-tags))
			 (let ((list-of-coercion-functions
				(coercion-if-exists? (car types) type-tags)))
			   (if list-of-coercion-functions
			       (apply apply-generic (cons op (map (lambda (fun arg) (fun arg))
								  list-of-coercion-functions
								  args)))
			       (if (not (null? (cdr types)))
				   (types-loop (cdr types))
				   (error "apply-generic:Even coercions failed. No method for these types."))))))
		      (else (error "apply-generic:No method for these types"
				   (list op type-tags)))))))
      (define (scheme-number->complex n)
	(make-complex-from-real-imag (contents n) 0))
      (put-coercion 'scheme-number
		    'complex
		    scheme-number->complex)

      (put 'max3-magnitude '(complex complex complex) (lambda (z1 z2 z3)
							(max (magnitude z1) (magnitude z2) (magnitude z3))))
      (define (max3-magnitude x1 x2 x3) (apply-generic 'max3-magnitude x1 x2 x3))
      (define (identity x) x)

    #;(define numeric-tower (list 'integer 'rational 'scheme-number 'complex))
    (define numeric-tower (list 'integer 'scheme-number 'complex))
    (define (comparable? type1 type2) (and (memq type1 numeric-tower) (memq type2 numeric-tower)))
    #;(define (higher-type x)
      (show #t "higher-type:x=" (displayed x) "\n")
	(define (find-higher-type x types)
	  (cond ((or (null? types) (null? (cdr types))) (error "No type higher than given" x types))
		((eq? x (car types)) (cadr types))
		(else (find-higher-type x (cdr types)))))
	(find-higher-type x numeric-tower))

    (define (numeric? x)
      (memq x numeric-tower))
    (define (polynomial? x)
      (eq? (type-tag x) 'polynomial))
    (define (higher-type x)
      (let ((tail (memq x numeric-tower)))
	(cond ((eq? #f tail) (error "Type not in the tower" x))
	      ((null? (cdr tail)) (error "Already the highest type:" x))
	      (else (cadr tail)))))

    (show #t "Test: Higher than 'integer: " (higher-type 'integer) "\n")
    #;(show #t "Test: Higher than 'complex: " (higher-type 'complex) "\n")

      (define (type1<=type2? type1 type2)
	(if (not (memq type1 numeric-tower))
	    (error "Type 1 not in the numeric tower"))
	(if (not (memq type2 numeric-tower))
	    (error "Type 2 not in the numeric tower"))
	(let loop ((types numeric-tower))
	  (cond ((null? types) (error "Type 1 and type 2 are incomparable" type1 type2))
		((eq? (car types) type1) #t)
		((eq? (car types) type2) #f)
		(else (loop (cdr types))))))

      #;(define (integer->rational x)
	(make-rational x 1))

      #;(define (rational->scheme-number x)
	(make-scheme-number ((get 'to-real '(rational)) x)))
      #;(put-coercion 'integer 'rational integer->rational)
      #;(put-coercion 'rational 'scheme-number rational->scheme-number)
    (define (integer->scheme-number x)
       (make-scheme-number (contents (exact->inexact x))))
    (put-coercion 'integer 'scheme-number integer->scheme-number)

    (define (raise-type x)
      #;(show #t "Raising type of: " (displayed x) "\n")
	(let ((converter (get-coercion (type-tag x) (higher-type (type-tag x)))))
	  (if converter
	      (converter x)
	      (error "No coercion found for x" (type-tag x) x))))


      (define (remainder-integer a b)
	(when (or (not (integer? a)) (not (integer? b)))
	  (error "Arguments must be integers" a b))
	(remainder a b))

      (put 'remainder '(integer integer) remainder-integer)
      (define (remainder-generalized a b) (apply-generic 'remainder a b))



      (show #t "Test 1: Subtracting complex numbers: "
	    (sub
	     (make-complex-from-real-imag 1.1 2)
	     (make-complex-from-real-imag 0 2)) "\n")
    (define (install-polynomial-package)
      #;(define (contents generic-object)
	(cdr generic-object))
	(define (make-poly variable term-list)
	  (cons variable term-list))
	(define (variable p) (car p))
	(define (term-list p)
	  (cdr p))
	(define (variable? x) (symbol? x))
	(define (same-variable? v1 v2)
	  (and (variable? v1) (variable? v2) (eq? v1 v2)))
	(define (=number? exp num)
	  (and (number? exp) (= exp num)))
	(define (the-empty-termlist) '())

	(define (rest-terms term-list) (cdr term-list))
	(define (empty-termlist? term-list) (null? term-list))

	(define (make-term order coeff) (list order coeff))
	(define (order term) (car term))
	(define (coeff term) (cadr term))
	(define (tag p) (attach-tag 'polynomial p))
	(put 'make 'polynomial
	     (lambda (var terms) (tag (make-poly var terms))))
	#;(continued on next page)

	(define (add-poly p1 p2)
	  #;(show #t "add-poly: p1=" p1 ", p2=" p2 "\n")
	  (if (same-variable? (variable p1) (variable p2))
	      (make-poly (variable p1)
			 (add-terms (term-list p1)
				    (term-list p2)))
	      (let ((res (cdr (if (variable_1-order<variable_2-order (variable p1) (variable p2))
		  (add (tag p1) (tag (make-poly (variable p1) (list (make-term 0 (tag p2))))))
		  (add (tag (make-poly (variable p2) (list (make-term 0 (tag p1))))) (tag p2))))))
		#;(show #t "add-poly:result: " (displayed res) "\n") res)))

	(show #t "TestY2: poly of poly: "
	      (make-poly 'x (list
			     (make-term 3 (make-poly
					   'y (list (make-term 1 1) (make-term 0 1))))
			     (make-term 1 2)
			     (make-term 0 4))) "\n")

	(define (sub-poly p1 p2)
	  (add-poly p1 (mul-poly p2 (make-poly (variable p2) (list (make-term 0 -1))))))
	(define (add-terms L1 L2)
	  (cond ((empty-termlist? L1) L2)
		((empty-termlist? L2) L1)
		(else
		 (let ((t1 (first-term L1)) (t2 (first-term L2)))
		   (cond ((> (order t1) (order t2))
			  (adjoin-term
			   t1 (add-terms (rest-terms L1) L2)))
			 ((< (order t1) (order t2))
			  (adjoin-term
			   t2 (add-terms L1 (rest-terms L2))))
			 (else
			  (adjoin-term
			   (make-term (order t1)
				      (add (coeff t1) (coeff t2)))
			   (add-terms (rest-terms L1)
				      (rest-terms L2)))))))))


	(define (mul-poly p1 p2)
	  (if (same-variable? (variable p1) (variable p2))
	      (make-poly (variable p1)
			 (mul-terms (term-list p1)
				    (term-list p2)))
	      (contents (if (variable_1-order<variable_2-order (variable p1) (variable p2))
		  (mul (tag p1)
		       (make-polynomial (variable p1)
					(adjoin-term
					 (make-term 0
						    (tag p2)) (the-empty-termlist))))
		  (mul (tag p2)
		       (make-polynomial (variable p2)
					(adjoin-term
					 (make-term 0
						    (tag p1)) (the-empty-termlist))))))
	      #;(error "Polys not in same var -- MUL-POLY"
		     (list p1 p2))))
	(define (div-poly p1 p2)
	  (if (same-variable? (variable p1) (variable p2))
	      (let ((quotient-and-remainder (div-terms (term-list p1)
						       (term-list p2))))
		(list (make-poly (variable p1) (car  quotient-and-remainder))
		      (make-poly (variable p1) (cadr quotient-and-remainder))))
		(error "div-poly: Polys not in the same var" p1 p2)))
	(define (div-terms L1 L2)
		(if (empty-termlist? L1)
		    (list (the-empty-termlist) (the-empty-termlist))
		    (let ((t1 (first-term L1))
			  (t2 (first-term L2)))
		      (if (> (order t2) (order t1))
			  (list (the-empty-termlist) L1)
			  (let ((new-c (div (coeff t1) (coeff t2)))
				(new-o (- (order t1) (order t2))))
			    (let ((rest-of-result (div-terms (term-list
							      (sub-poly
							       (make-poly 'fake-var L1)
							       (mul-poly
								(make-poly 'fake-var (list (make-term new-o new-c)))
								(make-poly 'fake-var L2))))
							     L2)
						  ))
			      #;(show #t "div-terms: rest-of-result: " (displayed rest-of-result) "\n")
			      (list (adjoin-term (make-term new-o new-c) (car rest-of-result)) (cadr rest-of-result))
			      ))))))
	(define (mul-terms L1 L2)
	  (if (empty-termlist? L1)
	      (the-empty-termlist)
	      (add-terms (mul-term-by-all-terms (first-term L1) L2)
			 (mul-terms (rest-terms L1) L2))))

	(define (mul-term-by-all-terms t1 L)
	  (if (empty-termlist? L)
	      (the-empty-termlist)
	      (let ((t2 (first-term L)))
		(adjoin-term
		 (make-term (+ (order t1) (order t2))
			    (mul (coeff t1) (coeff t2)))
		 (mul-term-by-all-terms t1 (rest-terms L))))))
	(define (zero-poly? poly)
	  #;(show #t "zero-poly?: poly=" (displayed poly) "\n")
	  (cond ((empty-termlist? (term-list poly)) #t)
		((not (zero? (coeff (first-term (term-list poly))))) #f)
		(else (zero-poly?
		       (make-poly (variable poly)
				  (rest-terms (term-list poly)))))))

	(define (termlist-type-of term-list)
	  #;(show #t "t-t-o: term-list=" (displayed term-list) "\n")
	  (cond ((null? term-list) 'sparse)
		((pair? (car term-list)) 'sparse)
		((list? term-list) 'dense)
		(else (error "Unknown type of list" term-list))))
	(define (adjoin-term term term-list)
	  ((get 'adjoin-term (termlist-type-of term-list)) term term-list))
	(define (first-term term-list)
	  ((get 'first-term (termlist-type-of term-list)) term-list))
	(define (variable_1-order<variable_2-order variable_1 variable_2)
	  #;(show #t "var_1-..: variable_1=" variable_1 " variable_2=" variable_2 "\n")
	  #;(show #t "var12string=" (symbol->string variable_1) "var22string=" (symbol->string variable_2) "\n")
	  (string<=? (symbol->string variable_1) (symbol->string variable_2)))
	(define (normalize-fully poly)
	  (if (normal-polynomial? poly)
	      poly
	      (normalize-fully (normalize-once poly))))
	(put 'add '(polynomial polynomial)
	     (lambda (p1 p2)
	       #;(show #t "generic-add-poly:Polynomial dispatch found: p1="
		      (displayed p1) " p2=" (displayed p2) "\n")
	       (normalize-fully (tag (add-poly p1 p2)))))
	(put 'mul '(polynomial polynomial)
	     (lambda (p1 p2) (normalize-fully (tag (mul-poly p1 p2)))))
	(put 'sub '(polynomial polynomial)
	     (lambda (p1 p2) (tag (sub-poly p1 p2))))

	(put 'zero? '(polynomial) zero-poly?)
	(put 'div '(polynomial polynomial) div-poly)
	#;(put-coercion 'rational 'scheme-number rational->scheme-number)
	(define (monomial-flip-variables monomial)
	  #;(show #t "m-f-v: monomial=" monomial "\n")
	  (let* ((mono (contents monomial))
		 (inner-polynomial (contents (coeff (first-term (term-list mono)))))
		 (inner-poly (contents inner-polynomial))
		 (outer-order (order (first-term (term-list mono))))
		 (outer-var (variable mono))
		 (inner-var (variable inner-polynomial))
		 (inner-term-list (term-list inner-poly)))
	    #;(show #t "m-f-v: inner-poly=" inner-poly "\n")
	    (if (same-variable? inner-var outer-var)
		(mul
		 (make-polynomial outer-var (adjoin-term (make-term outer-order 1) (the-empty-termlist)))
		 (tag inner-polynomial))
		(tag (make-poly inner-var
				(mul-term-by-all-terms (make-term
							0
							(make-polynomial
							 outer-var
							 (list (make-term
								outer-order
								1)))) inner-poly))))))
	#;(show #t "TestXX: sorting variables: Is 'x < 'y?: "
	      (variable_1-order<variable_2-order 'x 'y) "\n")
	#;(show #t "TestXX: sorting variables: Is 'z < 'y?: "
	      (variable_1-order<variable_2-order 'z 'y) "\n")
	#;(show #t "TestXX: (adding two basic poly): "
	      (add (make-polynomial 'x (list (make-term 1 2) (make-term 0 4)))
		   (make-polynomial 'y (list (make-term 2 3) (make-term 0 5)))) "\n")

	(define (polynomial->sum-of-first-and-rest poly)
	  #;(show #t "p->s-o-f-a-r: " (displayed poly) "\n")
	  (if (zero? poly)
	      poly
	      (let* ((poly1 (contents poly))
		     (first-monomial (tag
				      (make-poly
				       (variable poly1)
				       (list (first-term (term-list poly1)))))))
		#;(show #t "p->s-o-f-a-r: " (displayed first-monomial) "\n")
		(add
		  first-monomial
		  (polynomial->sum-of-first-and-rest
		   (tag (make-poly (variable poly1) (rest-terms (term-list poly1)))))))))

	(show #t "Test13: Expanding a polynomial as monomials: "
	      (displayed
	       (polynomial->sum-of-first-and-rest
		(make-polynomial 'y
				 (list (make-term 2 (make-polynomial
						     'x
						     (list (make-term 2 1) (make-term 0 1))))
				       (make-term 0 2))))) "\n")

	(show #t "\nTest20: start monomial: "
	      (displayed (make-polynomial 'x
					  (list
					   (make-term
					    2
					    (make-polynomial
					     'y
					     (list
					      (make-term 2 1) (make-term 0 1))))))) "\n")
	(show #t "Test20: Flipping a monomial variable: "
	      (displayed
	       (monomial-flip-variables
		(make-polynomial 'x
				 (list (make-term 1 (make-polynomial
						     'y
						     (list
						      (make-term 2 1)
						      (make-term 0 1)))))))) "\n\n")


	(define (normal-polynomial? poly)
	  #;(show #t "n-p?: poly=" poly "\n")
	  (cond ((not (polynomial? poly)) #t)
		((null? (term-list (contents poly))) #t)
		(else (let* ((poly1 (contents poly))
			     (outer-var (variable poly1)))
			#;(show #t "Inner-let: outer-var=" (displayed outer-var) "\n")
			(let loop ((terms (term-list poly1)))
			  #;(show #t "n-p?-loop: terms=" (displayed terms) "\n")
			  (cond ((null? terms) #t)
				((not (polynomial? (coeff (first-term terms)))) (loop (rest-terms terms)))
				((not (variable_1-order<variable_2-order
				     outer-var
				     (variable (contents (coeff (first-term terms)))))) (begin #;(show #t "wrong variable order \n") #f))
				((not (normal-polynomial? (coeff (first-term terms)))) (begin #;(show #t "not normal poly\n") #f))
				(else (loop (rest-terms terms)))))
			))))
	(define (normalize-once poly)
	  #;(show #t "normalize-once poly= " (displayed poly) "\n")
	  (if (zero? poly)
	      poly
	      (let* ((poly1 (contents poly))
		     (first-monomial (tag
				      (make-poly
				       (variable poly1)
				       (list (make-term
					      (order (first-term (term-list poly1)))
					      (if (polynomial? (coeff (first-term (term-list poly1))))
						  (normalize-once (coeff (first-term (term-list poly1))))
						  (coeff (first-term (term-list poly1))))))))))
		#;(show #t "p->s-o-f-a-r: " (displayed first-monomial) "\n")
		(add
		 (if (and (polynomial?
			 (coeff
			  (first-term
			   (term-list
			    (contents first-monomial)))))
			(variable_1-order<variable_2-order
			 (variable
			  (contents
			   (coeff
			    (first-term
			     (term-list
			      (contents first-monomial))))))
			 (variable
			  (contents first-monomial))))
		     (monomial-flip-variables first-monomial)
		     first-monomial)
		  (polynomial->sum-of-first-and-rest
		   (tag (make-poly (variable poly1) (rest-terms (term-list poly1)))))))))

	(show #t "Test21: normal-polynomial?:start: " (displayed (make-polynomial 'y
					       (list (make-term 2 (make-polynomial
								   'x
						     (list (make-term 2 1) (make-term 0 1))))
						     (make-term 0 2)))) "\n")
	(show #t "Test21: normal-polynomial?:result:" (normal-polynomial? (make-polynomial 'y
					       (list (make-term 2 (make-polynomial
								   'x
						     (list (make-term 2 1) (make-term 0 1))))
						     (make-term 0 2)))) "\n")
	(show #t "Test22: normal-polynomial?-good:start: "
	      (displayed
	       (make-polynomial 'x
				(list (make-term 2 (make-polynomial
						    'y
						    (list (make-term 2 1) (make-term 0 1))))
				      (make-term 0 2)))) "\n")
	(show #t "Test22: normal-polynomial?-good:result:"
	      (normal-polynomial?
	       (make-polynomial 'x
				(list (make-term 2 (make-polynomial
						    'y
						    (list (make-term 2 1) (make-term 0 1))))
				      (make-term 0 2)))) "\n")

	(show #t "Test23:input: normalizing a bad polynomial: "
	      (make-polynomial 'y
				 (list (make-term 2 (make-polynomial
						     'x
						     (list (make-term 2 1) (make-term 0 1))))
				       (make-term 0 2))) "\n")
	(show #t "Test23:result: normalizing a bad polynomial: "
	      (normalize-once (make-polynomial 'y
					       (list (make-term 2 (make-polynomial
								   'x
						     (list (make-term 2 1) (make-term 0 1))))
						     (make-term 0 2)))) "\n")
	(show #t "Test24:input: normalizing a bad polynomial: "
	      (make-polynomial 'x
				 (list (make-term 2 (make-polynomial
						     'x
						     (list (make-term 2 1) (make-term 0 1))))
				       (make-term 0 2))) "\n")
	(show #t "Test24:result: normalizing a bad polynomial: "
	      (normalize-once (make-polynomial 'x
					       (list (make-term 2 (make-polynomial
								   'x
						     (list (make-term 2 1) (make-term 0 1))))
						     (make-term 0 2)))) "\n")


	(show #t "Test24:input: normalize-fully a bad polynomial: "
	      (make-polynomial 'y
				 (list (make-term 2 (make-polynomial
						     'x
						     (list (make-term 2 1) (make-term 0 1))))
				       (make-term 0 2))) "\n")
	(show #t "Test24:result: normalize-fully a bad polynomial: "
	      (normalize-fully (make-polynomial 'y
					       (list (make-term 2 (make-polynomial
								   'x
						     (list (make-term 2 1) (make-term 0 1))))
						     (make-term 0 2)))) "\n")



	'done)


      (define (install-polynomial-sparse-package)
	(define (coeff term) (cadr term))
	(define (first-term-sparse term-list) (car term-list))
	(define (adjoin-term-sparse term term-list)
	  (if (zero? (coeff term))
	      term-list
	      (cons term term-list)))
	(put 'adjoin-term 'sparse adjoin-term-sparse)
	(put 'first-term 'sparse first-term-sparse)
	'done)
      (install-polynomial-sparse-package)

      (define (install-polynomial-dense-package)
	(define (make-term order coeff) (list order coeff))
	(define (order term) (car term))
	(define (coeff term) (cadr term))

	(define (adjoin-term-dense term term-list)
	    (if (zero? (coeff term))
		term-list
		(if (> (order term) (length term-list))
		    (append (list (coeff term))
			    (make-list (- (order term) (length term-list)) 0)
			    term-list)
		    (error "adjoin-term:Appending a smaller order term. Recheck."))))
	(define (first-term-dense term-list)
	   #;(show #t "first-term-dense: " (displayed (make-term (car term-list) (length (cdr term-list)))) "\n")
	   (make-term (length (cdr term-list)) (car term-list) ))
	(put 'adjoin-term 'dense adjoin-term-dense)
	(put 'first-term 'dense first-term-dense)
	'done)
      #;(install-polynomial-dense-package)

      (define (make-polynomial var terms)
	((get 'make 'polynomial) var terms))

    (install-polynomial-package)


      #;(show #t "Test 2: Making polynomials: "
	    (make-polynomial 'x (list (list 5 1) (list 4 2))) "\n")
      #;(show #t "Test 3: Zero?: "
	    (zero? (make-polynomial 'x (list (list 5 1) (list 4 2)))) "\n")
      #;(show #t "Test 4: Adding polynomials: "
	    (add (make-polynomial 'x '((5 1) (4 2) (0 1)))
		 (make-polynomial 'x '((5 1)))) "\n")
      #;(show #t "Test 4: Zero?: " (zero? (make-polynomial 'x '((5 0) (3 1)))) "\n")

      #;(show #t "Test 5: Subtracting polynomials: "
	    (sub (make-polynomial 'x '((5 1) (4 2) (0 1)))
		 (make-polynomial 'x '((0 1)))) "\n")

      #;(show #t "Test 6: Making a dense polynomial: " (make-polynomial 'x '(1 2 3 4 5)) "\n")
      #;(show #t "Test 7: zero? dense polynomial: " (displayed (zero? (make-polynomial 'x '(0)))) "\n")
      #;(show #t "Test 8: zero? dense polynomial: " (displayed (zero? (make-polynomial 'x '(1)))) "\n")
      #;(show #t "Test 9: Adding dense polynomials: "
	    (add (make-polynomial 'x '(1 2 0 0 0 1))
		 (make-polynomial 'x '(1 0 0 0 0 0))) "\n")
      #;(show #t "Test10: Subtracting dense polynomials: "
	    (sub (make-polynomial 'x '(1 2 0 0 0 1))
		 (make-polynomial 'x '(1 0 0 0 0 0))) "\n")
      #;(show #t "Test11: Subtracting dense and sparse polynomials: "
	    (sub (make-polynomial 'x '(1 2 0 0 0 1))
		 (make-polynomial 'x '((4 2)))) "\n")
      #;(show #t "Test12: Dividing x^2 + 2x + 1 by x+1: "
	    (displayed
	     (div (make-polynomial 'x '((2 1) (1 2) (0 1)))
		  (make-polynomial 'x '(      (1 1) (0 1)))) ) "\n")
      #;(show #t "Test14: Adding polynomials of two variables: "
	    (displayed
	     (add (make-polynomial 'x '((1 1)))
		  (make-polynomial 'y '((1 1))))))
      #;(show #t "Test14: Adding polynomials of two variables, when one of them is nonexistant: "
	    (displayed
	     (add (make-polynomial 'x '((1 1)))
		  (make-polynomial 'y '((0 1))))))
    (show #t "Test25: multiplying different variables: "
	  (displayed (mul (make-polynomial 'x '((1 1)))
			  (make-polynomial 'y '((1 1))))) "\n")

  (define p1 (make-polynomial 'x '((2 1) (0 1))))
  (define p2 (make-polynomial 'x '((3 1) (0 1))))
  (define rf (make-rational p2 p1))
  (show #t "Test 26: make-rational-polynomial: " rf "\n")
  (show #t "Test 27: add-rational\n")
  (show #t "Test 27: " (add rf rf) "\n")
#+end_src

#+RESULTS[6401a904a6fe8852faacecf638699ce04c9f53d8]:
#+begin_src scheme
Test: Higher than 'integer: scheme-number
Test 1: Subtracting complex numbers: (scheme-number . 1.1)
TestY2: poly of poly: (x (3 (y (1 1) (0 1))) (1 2) (0 4))
Test13: Expanding a polynomial as monomials: (polynomial x (2 (polynomial y (2 1))) (0 (polynomial y (2 1) (0 2))))

Test20: start monomial: (polynomial x (2 (polynomial y (2 1) (0 1))))
Test20: Flipping a monomial variable: (polynomial y (2 (polynomial x (1 1))) (0 (polynomial x (1 1))))

Test21: normal-polynomial?:start: (polynomial y (2 (polynomial x (2 1) (0 1))) (0 2))
Test21: normal-polynomial?:result:#f
Test22: normal-polynomial?-good:start: (polynomial x (2 (polynomial y (2 1) (0 1))) (0 2))
Test22: normal-polynomial?-good:result:#t
Test23:input: normalizing a bad polynomial: (polynomial y (2 (polynomial x (2 1) (0 1))) (0 2))
Test23:result: normalizing a bad polynomial: (polynomial x (2 (polynomial y (2 1))) (0 (polynomial y (2 1) (0 2))))
Test24:input: normalizing a bad polynomial: (polynomial x (2 (polynomial x (2 1) (0 1))) (0 2))
Test24:result: normalizing a bad polynomial: (polynomial x (4 1) (2 1) (0 2))
Test24:input: normalize-fully a bad polynomial: (polynomial y (2 (polynomial x (2 1) (0 1))) (0 2))
Test24:result: normalize-fully a bad polynomial: (polynomial x (2 (polynomial y (2 1))) (0 (polynomial y (2 1) (0 2))))
Test25: multiplying different variables: (polynomial x (1 (polynomial y (1 1))))
Test 26: make-rational-polynomial: (rational (polynomial x (3 1) (0 1)) polynomial x (2 1) (0 1))
Test 27: add-rational
rational not droppable: #f
Test 27: (rational (polynomial x (5 2) (3 2) (2 2) (0 2)) polynomial x (4 1) (2 2) (0 1))
#+end_src

*** DONE Exercise 2.94 Greatest-common-divisor for polynomials
    CLOSED: [2019-10-28 Mon 00:47]

I will still copy the source code of the whole Computer Algebra System,
because extending the system with a GCD subroutine would require adding
functions to the polynomial package, which cannot be done with a mere
include.

#+name: cas-with-rational-polynomials
#+begin_src scheme :exports code :results output scalar code
      (define (project obj)
	(apply-generic 'project obj))
      (define (droppable? obj)
	#;(show #t "droppable?: obj=" obj ", type-tag=" (type-tag obj) "\n")
	(cond ((eq? (type-tag obj) 'rational) (begin (show #t "rational not droppable: #f\n") #f))
	      ((not (memq (type-tag obj) numeric-tower)) #f)
	      ((eq? (type-tag obj) (car numeric-tower)) #f)
	      ((equ? obj (raise-type (project obj))) #t)
	      (else #f)))
      (define (drop obj)
	(if (droppable? obj)
	    (drop (project obj))
	    obj))

    (define (thingy-source thingy)
      (cond ((lambda? thingy) (list "lambda" (lambda-source thingy)))
	    ((procedure? thingy) (list "procedure" (procedure-name thingy)))
	    ((pair? thingy) (list "pair" (pair-source thingy)))
	    (else "No source? refactor")))

      (define (accumulate op initial sequence)
	(if (null? sequence)
	    initial
	    (accumulate op (op initial (car sequence)) (cdr sequence))))
      (define false #f)
      (define true  #t)
      (define (make-table)
	(let ((local-table (list '*table*)))
	  (define (lookup key-1 key-2)
	    (let ((subtable (assoc key-1 (cdr local-table))))
	      (if subtable
		  (let ((record (assoc key-2 (cdr subtable))))
		    (if record
			(cdr record)
			false))
		  false)))
	  (define (insert! key-1 key-2 value)
	    (let ((subtable (assoc key-1 (cdr local-table))))
	      (if subtable
		  (let ((record (assoc key-2 (cdr subtable))))
		    (if record
			(set-cdr! record value)
			(set-cdr! subtable
				  (cons (cons key-2 value)
					(cdr subtable)))))
		  (set-cdr! local-table
			    (cons (list key-1
					(cons key-2 value))
				  (cdr local-table)))))
	    'ok)
	  (define (dispatch m)
	    (cond ((eq? m 'lookup-proc) lookup)
		  ((eq? m 'insert-proc!) insert!)
		  (else (error "Unknown operation -- TABLE" m))))
	  dispatch))

      (define operation-table (make-table))
      (define get (operation-table 'lookup-proc))
      (define put (operation-table 'insert-proc!))

      (define coercion-table (make-table))
      (define get-coercion (coercion-table 'lookup-proc))
      (define put-coercion (coercion-table 'insert-proc!))

      (define (attach-tag type-tag contents)
	(cons type-tag contents))

      (define (type-tag datum)
	(cond ((pair? datum) (car datum))
	      ((exact-integer? datum) 'integer)
	      ((real? datum) 'scheme-number)
	      (error "Bad tagged datum -- TYPE-TAG" datum)))

    (define (contents datum)
	(cond ((pair? datum) (cdr datum))
	      ((integer? datum) datum)
	      ((real? datum) datum)
	      (else (error "Bad tagged datum -- CONTENTS" datum))))

      (define (integer? x)
	(eq? (type-tag x) 'integer))
      (define (rectangular? z)
	(eq? (type-tag z) 'rectangular))

      (define (polar? z)
	(eq? (type-tag z) 'polar))


      (define (real-part z) (apply-generic 'real-part z))
      (define (imag-part z) (apply-generic 'imag-part z))
      (define (magnitude z) (apply-generic 'magnitude z))
      (define (angle z) (apply-generic 'angle z))

      (define (add x y) (apply-generic 'add x y))
      (define (sub x y) (apply-generic 'sub x y))
      (define (mul x y) (apply-generic 'mul x y))
      (define (div x y) (apply-generic 'div x y))

      (define (equ? x y)
	(apply-generic 'equ? x y))
      (define (zero? x) (apply-generic 'zero? x))

      (define (exp x y) (apply-generic 'exp x y))

      (define (install-scheme-number-package)
	(define (tag x)
	  (attach-tag 'scheme-number x))
	(put 'add '(scheme-number scheme-number)
	     (lambda (x y) (tag (+ x y))))
	(put 'sub '(scheme-number scheme-number)
	     (lambda (x y) (tag (- x y))))
	(put 'mul '(scheme-number scheme-number)
	     (lambda (x y) (tag (* x y))))
	(put 'div '(scheme-number scheme-number)
	     (lambda (x y) (tag (/ x y))))
	(put 'make 'scheme-number
	     (lambda (x) (tag x)))
	(put 'equ? '(scheme-number scheme-number)
	     (lambda (x y) (= x y)))
	(put 'zero? '(scheme-number)
	     (lambda (x) (= 0 x)))
	(put 'exp '(scheme-number scheme-number)
	     (lambda (x y) (tag (expt x y))))
	(put 'project '(scheme-number)
	     (lambda (x)
	       (exact (truncate x))))
	(put 'sine '(scheme-number) sin)
	(put 'cosine '(scheme-number) cos)
	(put 'square-root '(scheme-number) sqrt)
	(put 'arctangent '(schemer-number) atan)
	'done)

      (define (sine x) (apply-generic 'sine x))
      (define (cosine x) (apply-generic 'cosine x))
      (define (square-root x) (apply-generic 'square-root x))
      (define (arctangent x) (apply-generic 'arctangent x))

      (define (make-scheme-number n)
	((get 'make 'scheme-number) n))

      (define (install-rational-package)
	(define (numer x) (car x))
	(define (denom x) (cdr x))
	(define (make-rat n d)
	  #;(let ((g (gcd n d)))
	    (cons (/ n g) (/ d g)))
	    (cons n d))
	(define (add-rat x y)
	  (make-rat (add (mul (numer x) (denom y))
		       (mul (numer y) (denom x)))
		    (mul (denom x) (denom y))))
	(define (sub-rat x y)
	  (make-rat (sub (mul (numer x) (denom y))
		       (mul (numer y) (denom x)))
		    (mul (denom x) (denom y))))
	(define (mul-rat x y)
	  (make-rat (mul (numer x) (numer y))
		    (mul (denom x) (denom y))))
	(define (div-rat x y)
	  (make-rat (mul (numer x) (denom y))
		    (mul (denom x) (numer y))))

	(define (tag x) (attach-tag 'rational x))
	(put 'add '(rational rational)
	     (lambda (x y) (tag (add-rat x y))))
	(put 'sub '(rational rational)
	     (lambda (x y) (tag (sub-rat x y))))
	(put 'mul '(rational rational)
	     (lambda (x y) (tag (mul-rat x y))))
	(put 'div '(rational rational)
	     (lambda (x y) (tag (div-rat x y))))

	(put 'make 'rational
	     (lambda (n d) (tag (make-rat n d))))
	(put 'equ? '(rational rational)
	     (lambda (x y) (zero? (numer (sub-rat x y)))))
	(put 'zero? '(rational) (lambda (x) (zero? (numer x))))
	#;(put 'project '(rational) (lambda (x)
				    (exact (truncate (/ (numer x) (denom x))))))
	#;(put 'to-real '(rational) (lambda (x) (/ (numer (contents x)) (denom (contents x)))))
	'done)

      (define (make-rational n d)
	((get 'make 'rational) n d))

      (define (install-rectangular-package)

	(define (real-part z) (car z))
	(define (imag-part z) (cdr z))
	(define (make-from-real-imag x y) (cons x y))
	(define (magnitude z)
	  (square-root (add (square (real-part z))
			    (square (imag-part z)))))
	(define (angle z)
	  (arctangent (imag-part z) (real-part z)))
	(define (make-from-mag-ang r a)
	  (cons (mul r (cosine a)) (mul r (sine a))))

	(define (tag x) (attach-tag 'rectangular x))
	(put 'real-part '(rectangular) real-part)
	(put 'imag-part '(rectangular) imag-part)
	(put 'magnitude '(rectangular) magnitude)
	(put 'angle '(rectangular) angle)
	(put 'make-from-real-imag 'rectangular
	     (lambda (x y) (tag (make-from-real-imag x y))))
	(put 'make-from-mag-ang 'rectangular
	     (lambda (r a) (tag (make-from-mag-ang r a))))
	'done)

      (define (install-polar-package)

	(define (magnitude z) (car z))
	(define (angle z) (cdr z))
	(define (make-from-mag-ang r a) (cons r a))
	(define (real-part z)
	  (mul (magnitude z) (cosine (angle z))))
	(define (imag-part z)
	  (mul (magnitude z) (sine (angle z))))
	(define (make-from-real-imag x y)
	  (cons (square-root (add (square x) (square y)))
		(arctangent y x)))

	(define (tag x) (attach-tag 'polar x))
	(put 'real-part '(polar) real-part)
	(put 'imag-part '(polar) imag-part)
	(put 'magnitude '(polar) magnitude)
	(put 'angle '(polar) angle)
	(put 'make-from-real-imag 'polar
	     (lambda (x y) (tag (make-from-real-imag x y))))
	(put 'make-from-mag-ang 'polar
	     (lambda (r a) (tag (make-from-mag-ang r a))))
	'done)

      (define (install-complex-package)
	(define (make-from-real-imag x y)
	  ((get 'make-from-real-imag 'rectangular) x y))
	(define (make-from-mag-ang r a)
	  ((get 'make-from-mag-ang 'polar) r a))
	(define (add-complex z1 z2)
	  (make-from-real-imag (add (real-part z1) (real-part z2))
			       (add (imag-part z1) (imag-part z2))))
	(define (sub-complex z1 z2)
	  (make-from-real-imag (sub (real-part z1) (real-part z2))
			       (sub (imag-part z1) (imag-part z2))))
	(define (mul-complex z1 z2)
	  (make-from-mag-ang (mul (magnitude z1) (magnitude z2))
			     (add (angle z1) (angle z2))))
	(define (div-complex z1 z2)
	  (make-from-mag-ang (div (magnitude z1) (magnitude z2))
			     (sub (angle z1) (angle z2))))
	(define (tag z) (attach-tag 'complex z))
	(put 'add '(complex complex)
	     (lambda (z1 z2) (tag (add-complex z1 z2))))
	(put 'sub '(complex complex)
	     (lambda (z1 z2) (tag (sub-complex z1 z2))))
	(put 'mul '(complex complex)
	     (lambda (z1 z2) (tag (mul-complex z1 z2))))
	(put 'div '(complex complex)
	     (lambda (z1 z2) (tag (div-complex z1 z2))))
	(put 'make-from-real-imag 'complex
	     (lambda (x y) (tag (make-from-real-imag x y))))
	(put 'make-from-mag-ang 'complex
	     (lambda (r a) (tag (make-from-mag-ang r a))))
	(put 'equ? '(complex complex)
	     (lambda (x y) (and (= 0 (real-part (sub-complex x y)))
				(= 0 (imag-part (sub-complex x y))))))
	(put 'equ? '(rectangular polar) equ?)
	(put 'equ? '(polar rectangular) equ?)
	(put 'zero? '(complex)
	     (lambda (x) (equ? (tag x) (tag (make-from-real-imag 0 0)))))
	(put 'project '(complex) (lambda (z) (real-part z)))
	'done)

      (define (make-complex-from-real-imag x y)
	((get 'make-from-real-imag 'complex) x y))

      (define (make-complex-from-mag-ang r a)
	((get 'make-from-mag-ang 'complex) r a))

      (install-rectangular-package)
      (install-polar-package)
      (install-rational-package)
      (install-scheme-number-package)
      (install-complex-package)

      (put 'real-part '(complex) real-part)
      (put 'imag-part '(complex) imag-part)
      (put 'magnitude '(complex) magnitude)
      (put 'angle '(complex) angle)

      (define (apply-generic op . args)
	#;(show #t "apply-generic:entry\n")
	#;(error "debug")
	(define (variable poly) (car poly))
	(define (all-argtypes-same? . args)
	  (let ((type (type-tag (car args))))
	    (accumulate (lambda (x y) (and x y)) #t (map (lambda (x) (eq? type x)) args))))
	(define (coercion-if-exists? type arg-tags)
	  (let ((coercion-list (map (lambda (x)
				      (if (eq? type x)
					  identity
					  (get-coercion x type))) arg-tags)))
	    (if (accumulate (lambda (x y) (and x y)) #t coercion-list)
		coercion-list
		#f)))
	(drop (let* ((type-tags (map type-tag args))
		     (proc (get op type-tags)))
		#;(show #t "apply-generic: type-tags="
			 (displayed type-tags)
			 " proc=" (written proc)
			 " proc-source=" (thingy-source proc) "\n")
		(cond (proc (apply proc (map contents args)))
		      ((= 1 (length args))
		       #;(show #t "No proc found for op=" op ", type-tags=" type-tags ", arg=" (displayed args) "\n")
		       (apply-generic op (raise-type (car args))))
		      ((= 2 (length args))
		       (cond ((and (eq? 'polynomial (car type-tags))
				 (numeric? (cadr type-tags)))
			      (apply-generic op
					     (car args)
					     (make-polynomial (variable (contents (car args)))
							      (list (list 0 (cadr args))))))
			     ((and (numeric? (car type-tags))
				 (eq? 'polynomial (cadr type-tags)))
			      (apply-generic op
					     (make-polynomial (variable (contents (cadr args)))
							      (list (list 0 (car args))))
					     (cadr args)))
			     ((and (get-coercion (car type-tags) (cadr type-tags))
				 (not (eq? (car type-tags) (cadr type-tags))))
			      (apply-generic op
					     ((get-coercion
					       (car type-tags)
					       (cadr type-tags)) (car args))
					     (cadr args)))
			     ((and (get-coercion (cadr type-tags) (car type-tags))
				 (not (eq? (car type-tags) (cadr type-tags))))
			      (apply-generic op
					     (car args)
					     ((get-coercion
					       (cadr type-tags)
					       (car type-tags)) (cadr args) )))
			     ((comparable? (car type-tags) (cadr type-tags))
			      (if
			       (type1<=type2? (car type-tags) (cadr type-tags))
			       (apply-generic op (raise-type (car args)) (cadr args))
			       (apply-generic op (car args)  (raise-type (cadr args)))))
			     (else (error "apply-generic:Incomparable types: (type-tags,args)=" type-tags args))))
		      ((and (> (length args) 2) (not (all-argtypes-same? args)))
		       (let types-loop ((types type-tags))
			 (let ((list-of-coercion-functions
				(coercion-if-exists? (car types) type-tags)))
			   (if list-of-coercion-functions
			       (apply apply-generic (cons op (map (lambda (fun arg) (fun arg))
								  list-of-coercion-functions
								  args)))
			       (if (not (null? (cdr types)))
				   (types-loop (cdr types))
				   (error "apply-generic:Even coercions failed. No method for these types."))))))
		      (else (error "apply-generic:No method for these types"
				   (list op type-tags)))))))
      (define (scheme-number->complex n)
	(make-complex-from-real-imag (contents n) 0))
      (put-coercion 'scheme-number
		    'complex
		    scheme-number->complex)

      (put 'max3-magnitude '(complex complex complex) (lambda (z1 z2 z3)
							(max (magnitude z1) (magnitude z2) (magnitude z3))))
      (define (max3-magnitude x1 x2 x3) (apply-generic 'max3-magnitude x1 x2 x3))
      (define (identity x) x)

    #;(define numeric-tower (list 'integer 'rational 'scheme-number 'complex))
    (define numeric-tower (list 'integer 'scheme-number 'complex))
    (define (comparable? type1 type2) (and (memq type1 numeric-tower) (memq type2 numeric-tower)))
    #;(define (higher-type x)
      (show #t "higher-type:x=" (displayed x) "\n")
	(define (find-higher-type x types)
	  (cond ((or (null? types) (null? (cdr types))) (error "No type higher than given" x types))
		((eq? x (car types)) (cadr types))
		(else (find-higher-type x (cdr types)))))
	(find-higher-type x numeric-tower))

    (define (numeric? x)
      (memq x numeric-tower))
    (define (polynomial? x)
      (eq? (type-tag x) 'polynomial))
    (define (higher-type x)
      (let ((tail (memq x numeric-tower)))
	(cond ((eq? #f tail) (error "Type not in the tower" x))
	      ((null? (cdr tail)) (error "Already the highest type:" x))
	      (else (cadr tail)))))

    (show #t "Test: Higher than 'integer: " (higher-type 'integer) "\n")
    #;(show #t "Test: Higher than 'complex: " (higher-type 'complex) "\n")

      (define (type1<=type2? type1 type2)
	(if (not (memq type1 numeric-tower))
	    (error "Type 1 not in the numeric tower"))
	(if (not (memq type2 numeric-tower))
	    (error "Type 2 not in the numeric tower"))
	(let loop ((types numeric-tower))
	  (cond ((null? types) (error "Type 1 and type 2 are incomparable" type1 type2))
		((eq? (car types) type1) #t)
		((eq? (car types) type2) #f)
		(else (loop (cdr types))))))

      #;(define (integer->rational x)
	(make-rational x 1))

      #;(define (rational->scheme-number x)
	(make-scheme-number ((get 'to-real '(rational)) x)))
      #;(put-coercion 'integer 'rational integer->rational)
      #;(put-coercion 'rational 'scheme-number rational->scheme-number)
    (define (integer->scheme-number x)
       (make-scheme-number (contents (exact->inexact x))))
    (put-coercion 'integer 'scheme-number integer->scheme-number)

    (define (raise-type x)
      #;(show #t "Raising type of: " (displayed x) "\n")
	(let ((converter (get-coercion (type-tag x) (higher-type (type-tag x)))))
	  (if converter
	      (converter x)
	      (error "No coercion found for x" (type-tag x) x))))


      (define (remainder-integer a b)
	(when (or (not (integer? a)) (not (integer? b)))
	  (error "Arguments must be integers" a b))
	(remainder a b))

      (put 'remainder '(integer integer) remainder-integer)
      (define (remainder-generalized a b) (apply-generic 'remainder a b))



      (show #t "Test 1: Subtracting complex numbers: "
	    (sub
	     (make-complex-from-real-imag 1.1 2)
	     (make-complex-from-real-imag 0 2)) "\n")
    (define (install-polynomial-package)
      #;(define (contents generic-object)
	(cdr generic-object))
	(define (make-poly variable term-list)
	  (cons variable term-list))
	(define (variable p) (car p))
	(define (term-list p)
	  (cdr p))
	(define (variable? x) (symbol? x))
	(define (same-variable? v1 v2)
	  (and (variable? v1) (variable? v2) (eq? v1 v2)))
	(define (=number? exp num)
	  (and (number? exp) (= exp num)))
	(define (the-empty-termlist) '())

	(define (rest-terms term-list) (cdr term-list))
	(define (empty-termlist? term-list) (null? term-list))

	(define (make-term order coeff) (list order coeff))
	(define (order term) (car term))
	(define (coeff term) (cadr term))
	(define (tag p) (attach-tag 'polynomial p))
	(put 'make 'polynomial
	     (lambda (var terms) (tag (make-poly var terms))))
	#;(continued on next page)

	(define (add-poly p1 p2)
	  #;(show #t "add-poly: p1=" p1 ", p2=" p2 "\n")
	  (if (same-variable? (variable p1) (variable p2))
	      (make-poly (variable p1)
			 (add-terms (term-list p1)
				    (term-list p2)))
	      (let ((res (cdr (if (variable_1-order<variable_2-order (variable p1) (variable p2))
		  (add (tag p1) (tag (make-poly (variable p1) (list (make-term 0 (tag p2))))))
		  (add (tag (make-poly (variable p2) (list (make-term 0 (tag p1))))) (tag p2))))))
		#;(show #t "add-poly:result: " (displayed res) "\n") res)))

	(show #t "TestY2: poly of poly: "
	      (make-poly 'x (list
			     (make-term 3 (make-poly
					   'y (list (make-term 1 1) (make-term 0 1))))
			     (make-term 1 2)
			     (make-term 0 4))) "\n")

	(define (sub-poly p1 p2)
	  (add-poly p1 (mul-poly p2 (make-poly (variable p2) (list (make-term 0 -1))))))
	(define (add-terms L1 L2)
	  (cond ((empty-termlist? L1) L2)
		((empty-termlist? L2) L1)
		(else
		 (let ((t1 (first-term L1)) (t2 (first-term L2)))
		   (cond ((> (order t1) (order t2))
			  (adjoin-term
			   t1 (add-terms (rest-terms L1) L2)))
			 ((< (order t1) (order t2))
			  (adjoin-term
			   t2 (add-terms L1 (rest-terms L2))))
			 (else
			  (adjoin-term
			   (make-term (order t1)
				      (add (coeff t1) (coeff t2)))
			   (add-terms (rest-terms L1)
				      (rest-terms L2)))))))))


	(define (mul-poly p1 p2)
	  (if (same-variable? (variable p1) (variable p2))
	      (make-poly (variable p1)
			 (mul-terms (term-list p1)
				    (term-list p2)))
	      (contents (if (variable_1-order<variable_2-order (variable p1) (variable p2))
		  (mul (tag p1)
		       (make-polynomial (variable p1)
					(adjoin-term
					 (make-term 0
						    (tag p2)) (the-empty-termlist))))
		  (mul (tag p2)
		       (make-polynomial (variable p2)
					(adjoin-term
					 (make-term 0
						    (tag p1)) (the-empty-termlist))))))
	      #;(error "Polys not in same var -- MUL-POLY"
		     (list p1 p2))))
	(define (div-poly p1 p2)
	  (if (same-variable? (variable p1) (variable p2))
	      (let ((quotient-and-remainder (div-terms (term-list p1)
						       (term-list p2))))
		(list (make-poly (variable p1) (car  quotient-and-remainder))
		      (make-poly (variable p1) (cadr quotient-and-remainder))))
		(error "div-poly: Polys not in the same var" p1 p2)))
	(define (div-terms L1 L2)
		(if (empty-termlist? L1)
		    (list (the-empty-termlist) (the-empty-termlist))
		    (let ((t1 (first-term L1))
			  (t2 (first-term L2)))
		      (if (> (order t2) (order t1))
			  (list (the-empty-termlist) L1)
			  (let ((new-c (div (coeff t1) (coeff t2)))
				(new-o (- (order t1) (order t2))))
			    (let ((rest-of-result (div-terms (term-list
							      (sub-poly
							       (make-poly 'fake-var L1)
							       (mul-poly
								(make-poly 'fake-var (list (make-term new-o new-c)))
								(make-poly 'fake-var L2))))
							     L2)
						  ))
			      #;(show #t "div-terms: rest-of-result: " (displayed rest-of-result) "\n")
			      (list (adjoin-term (make-term new-o new-c) (car rest-of-result)) (cadr rest-of-result))
			      ))))))
	(define (gcd-terms a b)
	  (if (empty-termlist? b)
	      a
	      (gcd-terms b (remainder-terms a b))))
	(define (remainder-terms a b)
	  (cadr (div-terms a b)))
	(define (gcd-poly p1 p2)
	  (if (same-variable? (variable p1) (variable p2))
	      (make-poly (variable p1) (gcd-terms (term-list p1) (term-list p2)))
	      (error "div-poly: Polys not in the same var" p1 p2)))
	(put 'gcd '(polynomial polynomial)
	     (lambda (x y) (tag (gcd-poly x y))))
	(put 'gcd '(integer integer) gcd)

	(define (mul-terms L1 L2)
	  (if (empty-termlist? L1)
	      (the-empty-termlist)
	      (add-terms (mul-term-by-all-terms (first-term L1) L2)
			 (mul-terms (rest-terms L1) L2))))

	(define (mul-term-by-all-terms t1 L)
	  (if (empty-termlist? L)
	      (the-empty-termlist)
	      (let ((t2 (first-term L)))
		(adjoin-term
		 (make-term (+ (order t1) (order t2))
			    (mul (coeff t1) (coeff t2)))
		 (mul-term-by-all-terms t1 (rest-terms L))))))
	(define (zero-poly? poly)
	  #;(show #t "zero-poly?: poly=" (displayed poly) "\n")
	  (cond ((empty-termlist? (term-list poly)) #t)
		((not (zero? (coeff (first-term (term-list poly))))) #f)
		(else (zero-poly?
		       (make-poly (variable poly)
				  (rest-terms (term-list poly)))))))

	(define (termlist-type-of term-list)
	  #;(show #t "t-t-o: term-list=" (displayed term-list) "\n")
	  (cond ((null? term-list) 'sparse)
		((pair? (car term-list)) 'sparse)
		((list? term-list) 'dense)
		(else (error "Unknown type of list" term-list))))
	(define (adjoin-term term term-list)
	  ((get 'adjoin-term (termlist-type-of term-list)) term term-list))
	(define (first-term term-list)
	  ((get 'first-term (termlist-type-of term-list)) term-list))
	(define (variable_1-order<variable_2-order variable_1 variable_2)
	  #;(show #t "var_1-..: variable_1=" variable_1 " variable_2=" variable_2 "\n")
	  #;(show #t "var12string=" (symbol->string variable_1) "var22string=" (symbol->string variable_2) "\n")
	  (string<=? (symbol->string variable_1) (symbol->string variable_2)))
	(define (normalize-fully poly)
	  (if (normal-polynomial? poly)
	      poly
	      (normalize-fully (normalize-once poly))))
	(put 'add '(polynomial polynomial)
	     (lambda (p1 p2)
	       #;(show #t "generic-add-poly:Polynomial dispatch found: p1="
		      (displayed p1) " p2=" (displayed p2) "\n")
	       (normalize-fully (tag (add-poly p1 p2)))))
	(put 'mul '(polynomial polynomial)
	     (lambda (p1 p2) (normalize-fully (tag (mul-poly p1 p2)))))
	(put 'sub '(polynomial polynomial)
	     (lambda (p1 p2) (tag (sub-poly p1 p2))))

	(put 'zero? '(polynomial) zero-poly?)
	(put 'div '(polynomial polynomial) div-poly)
	#;(put-coercion 'rational 'scheme-number rational->scheme-number)
	(define (monomial-flip-variables monomial)
	  #;(show #t "m-f-v: monomial=" monomial "\n")
	  (let* ((mono (contents monomial))
		 (inner-polynomial (contents (coeff (first-term (term-list mono)))))
		 (inner-poly (contents inner-polynomial))
		 (outer-order (order (first-term (term-list mono))))
		 (outer-var (variable mono))
		 (inner-var (variable inner-polynomial))
		 (inner-term-list (term-list inner-poly)))
	    #;(show #t "m-f-v: inner-poly=" inner-poly "\n")
	    (if (same-variable? inner-var outer-var)
		(mul
		 (make-polynomial outer-var (adjoin-term (make-term outer-order 1) (the-empty-termlist)))
		 (tag inner-polynomial))
		(tag (make-poly inner-var
				(mul-term-by-all-terms (make-term
							0
							(make-polynomial
							 outer-var
							 (list (make-term
								outer-order
								1)))) inner-poly))))))
	#;(show #t "TestXX: sorting variables: Is 'x < 'y?: "
	      (variable_1-order<variable_2-order 'x 'y) "\n")
	#;(show #t "TestXX: sorting variables: Is 'z < 'y?: "
	      (variable_1-order<variable_2-order 'z 'y) "\n")
	#;(show #t "TestXX: (adding two basic poly): "
	      (add (make-polynomial 'x (list (make-term 1 2) (make-term 0 4)))
		   (make-polynomial 'y (list (make-term 2 3) (make-term 0 5)))) "\n")

	(define (polynomial->sum-of-first-and-rest poly)
	  #;(show #t "p->s-o-f-a-r: " (displayed poly) "\n")
	  (if (zero? poly)
	      poly
	      (let* ((poly1 (contents poly))
		     (first-monomial (tag
				      (make-poly
				       (variable poly1)
				       (list (first-term (term-list poly1)))))))
		#;(show #t "p->s-o-f-a-r: " (displayed first-monomial) "\n")
		(add
		  first-monomial
		  (polynomial->sum-of-first-and-rest
		   (tag (make-poly (variable poly1) (rest-terms (term-list poly1)))))))))

	(show #t "Test13: Expanding a polynomial as monomials: "
	      (displayed
	       (polynomial->sum-of-first-and-rest
		(make-polynomial 'y
				 (list (make-term 2 (make-polynomial
						     'x
						     (list (make-term 2 1) (make-term 0 1))))
				       (make-term 0 2))))) "\n")

	(show #t "\nTest20: start monomial: "
	      (displayed (make-polynomial 'x
					  (list
					   (make-term
					    2
					    (make-polynomial
					     'y
					     (list
					      (make-term 2 1) (make-term 0 1))))))) "\n")
	(show #t "Test20: Flipping a monomial variable: "
	      (displayed
	       (monomial-flip-variables
		(make-polynomial 'x
				 (list (make-term 1 (make-polynomial
						     'y
						     (list
						      (make-term 2 1)
						      (make-term 0 1)))))))) "\n\n")


	(define (normal-polynomial? poly)
	  #;(show #t "n-p?: poly=" poly "\n")
	  (cond ((not (polynomial? poly)) #t)
		((null? (term-list (contents poly))) #t)
		(else (let* ((poly1 (contents poly))
			     (outer-var (variable poly1)))
			#;(show #t "Inner-let: outer-var=" (displayed outer-var) "\n")
			(let loop ((terms (term-list poly1)))
			  #;(show #t "n-p?-loop: terms=" (displayed terms) "\n")
			  (cond ((null? terms) #t)
				((not (polynomial? (coeff (first-term terms)))) (loop (rest-terms terms)))
				((not (variable_1-order<variable_2-order
				     outer-var
				     (variable (contents (coeff (first-term terms)))))) (begin #;(show #t "wrong variable order \n") #f))
				((not (normal-polynomial? (coeff (first-term terms)))) (begin #;(show #t "not normal poly\n") #f))
				(else (loop (rest-terms terms)))))
			))))
	(define (normalize-once poly)
	  #;(show #t "normalize-once poly= " (displayed poly) "\n")
	  (if (zero? poly)
	      poly
	      (let* ((poly1 (contents poly))
		     (first-monomial (tag
				      (make-poly
				       (variable poly1)
				       (list (make-term
					      (order (first-term (term-list poly1)))
					      (if (polynomial? (coeff (first-term (term-list poly1))))
						  (normalize-once (coeff (first-term (term-list poly1))))
						  (coeff (first-term (term-list poly1))))))))))
		#;(show #t "p->s-o-f-a-r: " (displayed first-monomial) "\n")
		(add
		 (if (and (polynomial?
			 (coeff
			  (first-term
			   (term-list
			    (contents first-monomial)))))
			(variable_1-order<variable_2-order
			 (variable
			  (contents
			   (coeff
			    (first-term
			     (term-list
			      (contents first-monomial))))))
			 (variable
			  (contents first-monomial))))
		     (monomial-flip-variables first-monomial)
		     first-monomial)
		  (polynomial->sum-of-first-and-rest
		   (tag (make-poly (variable poly1) (rest-terms (term-list poly1)))))))))

	(show #t "Test21: normal-polynomial?:start: " (displayed (make-polynomial 'y
					       (list (make-term 2 (make-polynomial
								   'x
						     (list (make-term 2 1) (make-term 0 1))))
						     (make-term 0 2)))) "\n")
	(show #t "Test21: normal-polynomial?:result:" (normal-polynomial? (make-polynomial 'y
					       (list (make-term 2 (make-polynomial
								   'x
						     (list (make-term 2 1) (make-term 0 1))))
						     (make-term 0 2)))) "\n")
	(show #t "Test22: normal-polynomial?-good:start: "
	      (displayed
	       (make-polynomial 'x
				(list (make-term 2 (make-polynomial
						    'y
						    (list (make-term 2 1) (make-term 0 1))))
				      (make-term 0 2)))) "\n")
	(show #t "Test22: normal-polynomial?-good:result:"
	      (normal-polynomial?
	       (make-polynomial 'x
				(list (make-term 2 (make-polynomial
						    'y
						    (list (make-term 2 1) (make-term 0 1))))
				      (make-term 0 2)))) "\n")

	(show #t "Test23:input: normalizing a bad polynomial: "
	      (make-polynomial 'y
				 (list (make-term 2 (make-polynomial
						     'x
						     (list (make-term 2 1) (make-term 0 1))))
				       (make-term 0 2))) "\n")
	(show #t "Test23:result: normalizing a bad polynomial: "
	      (normalize-once (make-polynomial 'y
					       (list (make-term 2 (make-polynomial
								   'x
						     (list (make-term 2 1) (make-term 0 1))))
						     (make-term 0 2)))) "\n")
	(show #t "Test24:input: normalizing a bad polynomial: "
	      (make-polynomial 'x
				 (list (make-term 2 (make-polynomial
						     'x
						     (list (make-term 2 1) (make-term 0 1))))
				       (make-term 0 2))) "\n")
	(show #t "Test24:result: normalizing a bad polynomial: "
	      (normalize-once (make-polynomial 'x
					       (list (make-term 2 (make-polynomial
								   'x
						     (list (make-term 2 1) (make-term 0 1))))
						     (make-term 0 2)))) "\n")


	(show #t "Test24:input: normalize-fully a bad polynomial: "
	      (make-polynomial 'y
				 (list (make-term 2 (make-polynomial
						     'x
						     (list (make-term 2 1) (make-term 0 1))))
				       (make-term 0 2))) "\n")
	(show #t "Test24:result: normalize-fully a bad polynomial: "
	      (normalize-fully (make-polynomial 'y
					       (list (make-term 2 (make-polynomial
								   'x
						     (list (make-term 2 1) (make-term 0 1))))
						     (make-term 0 2)))) "\n")



	'done)


      (define (install-polynomial-sparse-package)
	(define (coeff term) (cadr term))
	(define (first-term-sparse term-list) (car term-list))
	(define (adjoin-term-sparse term term-list)
	  (if (zero? (coeff term))
	      term-list
	      (cons term term-list)))
	(put 'adjoin-term 'sparse adjoin-term-sparse)
	(put 'first-term 'sparse first-term-sparse)
	'done)
      (install-polynomial-sparse-package)

      (define (install-polynomial-dense-package)
	(define (make-term order coeff) (list order coeff))
	(define (order term) (car term))
	(define (coeff term) (cadr term))

	(define (adjoin-term-dense term term-list)
	    (if (zero? (coeff term))
		term-list
		(if (> (order term) (length term-list))
		    (append (list (coeff term))
			    (make-list (- (order term) (length term-list)) 0)
			    term-list)
		    (error "adjoin-term:Appending a smaller order term. Recheck."))))
	(define (first-term-dense term-list)
	   #;(show #t "first-term-dense: " (displayed (make-term (car term-list) (length (cdr term-list)))) "\n")
	   (make-term (length (cdr term-list)) (car term-list) ))
	(put 'adjoin-term 'dense adjoin-term-dense)
	(put 'first-term 'dense first-term-dense)
	'done)
      #;(install-polynomial-dense-package)

      (define (make-polynomial var terms)
	((get 'make 'polynomial) var terms))

    (install-polynomial-package)


      #;(show #t "Test 2: Making polynomials: "
	    (make-polynomial 'x (list (list 5 1) (list 4 2))) "\n")
      #;(show #t "Test 3: Zero?: "
	    (zero? (make-polynomial 'x (list (list 5 1) (list 4 2)))) "\n")
      #;(show #t "Test 4: Adding polynomials: "
	    (add (make-polynomial 'x '((5 1) (4 2) (0 1)))
		 (make-polynomial 'x '((5 1)))) "\n")
      #;(show #t "Test 4: Zero?: " (zero? (make-polynomial 'x '((5 0) (3 1)))) "\n")

      #;(show #t "Test 5: Subtracting polynomials: "
	    (sub (make-polynomial 'x '((5 1) (4 2) (0 1)))
		 (make-polynomial 'x '((0 1)))) "\n")

      #;(show #t "Test 6: Making a dense polynomial: " (make-polynomial 'x '(1 2 3 4 5)) "\n")
      #;(show #t "Test 7: zero? dense polynomial: " (displayed (zero? (make-polynomial 'x '(0)))) "\n")
      #;(show #t "Test 8: zero? dense polynomial: " (displayed (zero? (make-polynomial 'x '(1)))) "\n")
      #;(show #t "Test 9: Adding dense polynomials: "
	    (add (make-polynomial 'x '(1 2 0 0 0 1))
		 (make-polynomial 'x '(1 0 0 0 0 0))) "\n")
      #;(show #t "Test10: Subtracting dense polynomials: "
	    (sub (make-polynomial 'x '(1 2 0 0 0 1))
		 (make-polynomial 'x '(1 0 0 0 0 0))) "\n")
      #;(show #t "Test11: Subtracting dense and sparse polynomials: "
	    (sub (make-polynomial 'x '(1 2 0 0 0 1))
		 (make-polynomial 'x '((4 2)))) "\n")
      #;(show #t "Test12: Dividing x^2 + 2x + 1 by x+1: "
	    (displayed
	     (div (make-polynomial 'x '((2 1) (1 2) (0 1)))
		  (make-polynomial 'x '(      (1 1) (0 1)))) ) "\n")
      #;(show #t "Test14: Adding polynomials of two variables: "
	    (displayed
	     (add (make-polynomial 'x '((1 1)))
		  (make-polynomial 'y '((1 1))))))
      #;(show #t "Test14: Adding polynomials of two variables, when one of them is nonexistant: "
	    (displayed
	     (add (make-polynomial 'x '((1 1)))
		  (make-polynomial 'y '((0 1))))))
    (show #t "Test25: multiplying different variables: "
	  (displayed (mul (make-polynomial 'x '((1 1)))
			  (make-polynomial 'y '((1 1))))) "\n")
  (begin
  (define p1 (make-polynomial 'x '((2 1) (0 1))))
  (define p2 (make-polynomial 'x '((3 1) (0 1))))
  (define rf (make-rational p2 p1))
  (show #t "Test 26: make-rational-polynomial: " rf "\n")
  (show #t "Test 27: add-rational\n")
  (show #t "Test 27: " (add rf rf) "\n")
  )

  (show #t "Test 28: polynomial-gcd: start\n")
  (define (greatest-common-divisor p1 p2) (apply-generic 'gcd p1 p2))
  (begin
    (define p1 (make-polynomial
		 'x '((4 1) (3 -1) (2 -2) (1 2))))
    (define p2 (make-polynomial 'x '((3 1) (1 -1))))

    (show #t "Test 28: polynomial-gcd: " (greatest-common-divisor p1 p2) "\n"))
#+end_src

#+RESULTS[b16dedb2123fdf3d13d68461e53c385c5fcf42aa]: cas-with-rational-polynomials
#+begin_src scheme
Test: Higher than 'integer: scheme-number
Test 1: Subtracting complex numbers: (scheme-number . 1.1)
TestY2: poly of poly: (x (3 (y (1 1) (0 1))) (1 2) (0 4))
Test13: Expanding a polynomial as monomials: (polynomial x (2 (polynomial y (2 1))) (0 (polynomial y (2 1) (0 2))))

Test20: start monomial: (polynomial x (2 (polynomial y (2 1) (0 1))))
Test20: Flipping a monomial variable: (polynomial y (2 (polynomial x (1 1))) (0 (polynomial x (1 1))))

Test21: normal-polynomial?:start: (polynomial y (2 (polynomial x (2 1) (0 1))) (0 2))
Test21: normal-polynomial?:result:#f
Test22: normal-polynomial?-good:start: (polynomial x (2 (polynomial y (2 1) (0 1))) (0 2))
Test22: normal-polynomial?-good:result:#t
Test23:input: normalizing a bad polynomial: (polynomial y (2 (polynomial x (2 1) (0 1))) (0 2))
Test23:result: normalizing a bad polynomial: (polynomial x (2 (polynomial y (2 1))) (0 (polynomial y (2 1) (0 2))))
Test24:input: normalizing a bad polynomial: (polynomial x (2 (polynomial x (2 1) (0 1))) (0 2))
Test24:result: normalizing a bad polynomial: (polynomial x (4 1) (2 1) (0 2))
Test24:input: normalize-fully a bad polynomial: (polynomial y (2 (polynomial x (2 1) (0 1))) (0 2))
Test24:result: normalize-fully a bad polynomial: (polynomial x (2 (polynomial y (2 1))) (0 (polynomial y (2 1) (0 2))))
Test25: multiplying different variables: (polynomial x (1 (polynomial y (1 1))))
Test 26: make-rational-polynomial: (rational (polynomial x (3 1) (0 1)) polynomial x (2 1) (0 1))
Test 27: add-rational
rational not droppable: #f
Test 27: (rational (polynomial x (5 2) (3 2) (2 2) (0 2)) polynomial x (4 1) (2 2) (0 1))
Test 28: polynomial-gcd: start
Test 28: polynomial-gcd: (polynomial x (2 -1) (1 1))
#+end_src


So the answer is \(-x^2 + x\). Now we need to check this. Luckily, the number
of iterations is not very big.

Wolfram Alpha gives me \(x^2 - x\), which is the same thing, I guess.

*** DONE Exercise 2.95 Illustrate the non-integer problem
    CLOSED: [2019-10-28 Mon 11:35]

#+begin_src scheme :exports both :results output scalar code
      (define (project obj)
	(apply-generic 'project obj))
      (define (droppable? obj)
	#;(show #t "droppable?: obj=" obj ", type-tag=" (type-tag obj) "\n")
	(cond ((eq? (type-tag obj) 'rational) (begin (show #t "rational not droppable: #f\n") #f))
	      ((not (memq (type-tag obj) numeric-tower)) #f)
	      ((eq? (type-tag obj) (car numeric-tower)) #f)
	      ((equ? obj (raise-type (project obj))) #t)
	      (else #f)))
      (define (drop obj)
	(if (droppable? obj)
	    (drop (project obj))
	    obj))
    (define (thingy-source thingy)
      (cond ((lambda? thingy) (list "lambda" (lambda-source thingy)))
	    ((procedure? thingy) (list "procedure" (procedure-name thingy)))
	    ((pair? thingy) (list "pair" (pair-source thingy)))
	    (else "No source? refactor")))

      (define (accumulate op initial sequence)
	(if (null? sequence)
	    initial
	    (accumulate op (op initial (car sequence)) (cdr sequence))))
      (define false #f)
      (define true  #t)
      (define (make-table)
	(let ((local-table (list '*table*)))
	  (define (lookup key-1 key-2)
	    (let ((subtable (assoc key-1 (cdr local-table))))
	      (if subtable
		  (let ((record (assoc key-2 (cdr subtable))))
		    (if record
			(cdr record)
			false))
		  false)))
	  (define (insert! key-1 key-2 value)
	    (let ((subtable (assoc key-1 (cdr local-table))))
	      (if subtable
		  (let ((record (assoc key-2 (cdr subtable))))
		    (if record
			(set-cdr! record value)
			(set-cdr! subtable
				  (cons (cons key-2 value)
					(cdr subtable)))))
		  (set-cdr! local-table
			    (cons (list key-1
					(cons key-2 value))
				  (cdr local-table)))))
	    'ok)
	  (define (dispatch m)
	    (cond ((eq? m 'lookup-proc) lookup)
		  ((eq? m 'insert-proc!) insert!)
		  (else (error "Unknown operation -- TABLE" m))))
	  dispatch))

      (define operation-table (make-table))
      (define get (operation-table 'lookup-proc))
      (define put (operation-table 'insert-proc!))

      (define coercion-table (make-table))
      (define get-coercion (coercion-table 'lookup-proc))
      (define put-coercion (coercion-table 'insert-proc!))

      (define (attach-tag type-tag contents)
	(cons type-tag contents))

      (define (type-tag datum)
	(cond ((pair? datum) (car datum))
	      ((exact-integer? datum) 'integer)
	      ((real? datum) 'scheme-number)
	      (error "Bad tagged datum -- TYPE-TAG" datum)))

    (define (contents datum)
	(cond ((pair? datum) (cdr datum))
	      ((integer? datum) datum)
	      ((real? datum) datum)
	      (else (error "Bad tagged datum -- CONTENTS" datum))))

      (define (integer? x)
	(eq? (type-tag x) 'integer))
      (define (rectangular? z)
	(eq? (type-tag z) 'rectangular))

      (define (polar? z)
	(eq? (type-tag z) 'polar))


      (define (real-part z) (apply-generic 'real-part z))
      (define (imag-part z) (apply-generic 'imag-part z))
      (define (magnitude z) (apply-generic 'magnitude z))
      (define (angle z) (apply-generic 'angle z))

      (define (add x y) (apply-generic 'add x y))
      (define (sub x y) (apply-generic 'sub x y))
      (define (mul x y) (apply-generic 'mul x y))
      (define (div x y) (apply-generic 'div x y))

      (define (equ? x y)
	(apply-generic 'equ? x y))
      (define (zero? x) (apply-generic 'zero? x))

      (define (exp x y) (apply-generic 'exp x y))

      (define (install-scheme-number-package)
	(define (tag x)
	  (attach-tag 'scheme-number x))
	(put 'add '(scheme-number scheme-number)
	     (lambda (x y) (tag (+ x y))))
	(put 'sub '(scheme-number scheme-number)
	     (lambda (x y) (tag (- x y))))
	(put 'mul '(scheme-number scheme-number)
	     (lambda (x y) (tag (* x y))))
	(put 'div '(scheme-number scheme-number)
	     (lambda (x y) (tag (/ x y))))
	(put 'make 'scheme-number
	     (lambda (x) (tag x)))
	(put 'equ? '(scheme-number scheme-number)
	     (lambda (x y) (= x y)))
	(put 'zero? '(scheme-number)
	     (lambda (x) (= 0 x)))
	(put 'exp '(scheme-number scheme-number)
	     (lambda (x y) (tag (expt x y))))
	(put 'project '(scheme-number)
	     (lambda (x)
	       (exact (truncate x))))
	(put 'sine '(scheme-number) sin)
	(put 'cosine '(scheme-number) cos)
	(put 'square-root '(scheme-number) sqrt)
	(put 'arctangent '(schemer-number) atan)
	'done)

      (define (sine x) (apply-generic 'sine x))
      (define (cosine x) (apply-generic 'cosine x))
      (define (square-root x) (apply-generic 'square-root x))
      (define (arctangent x) (apply-generic 'arctangent x))

      (define (make-scheme-number n)
	((get 'make 'scheme-number) n))

      (define (install-rational-package)
	(define (numer x) (car x))
	(define (denom x) (cdr x))
	(define (make-rat n d)
	  #;(let ((g (gcd n d)))
	    (cons (/ n g) (/ d g)))
	    (cons n d))
	(define (add-rat x y)
	  (make-rat (add (mul (numer x) (denom y))
		       (mul (numer y) (denom x)))
		    (mul (denom x) (denom y))))
	(define (sub-rat x y)
	  (make-rat (sub (mul (numer x) (denom y))
		       (mul (numer y) (denom x)))
		    (mul (denom x) (denom y))))
	(define (mul-rat x y)
	  (make-rat (mul (numer x) (numer y))
		    (mul (denom x) (denom y))))
	(define (div-rat x y)
	  (make-rat (mul (numer x) (denom y))
		    (mul (denom x) (numer y))))

	(define (tag x) (attach-tag 'rational x))
	(put 'add '(rational rational)
	     (lambda (x y) (tag (add-rat x y))))
	(put 'sub '(rational rational)
	     (lambda (x y) (tag (sub-rat x y))))
	(put 'mul '(rational rational)
	     (lambda (x y) (tag (mul-rat x y))))
	(put 'div '(rational rational)
	     (lambda (x y) (tag (div-rat x y))))

	(put 'make 'rational
	     (lambda (n d) (tag (make-rat n d))))
	(put 'equ? '(rational rational)
	     (lambda (x y) (zero? (numer (sub-rat x y)))))
	(put 'zero? '(rational) (lambda (x) (zero? (numer x))))
	#;(put 'project '(rational) (lambda (x)
				    (exact (truncate (/ (numer x) (denom x))))))
	#;(put 'to-real '(rational) (lambda (x) (/ (numer (contents x)) (denom (contents x)))))
	'done)

      (define (make-rational n d)
	((get 'make 'rational) n d))

      (define (install-rectangular-package)

	(define (real-part z) (car z))
	(define (imag-part z) (cdr z))
	(define (make-from-real-imag x y) (cons x y))
	(define (magnitude z)
	  (square-root (add (square (real-part z))
			    (square (imag-part z)))))
	(define (angle z)
	  (arctangent (imag-part z) (real-part z)))
	(define (make-from-mag-ang r a)
	  (cons (mul r (cosine a)) (mul r (sine a))))

	(define (tag x) (attach-tag 'rectangular x))
	(put 'real-part '(rectangular) real-part)
	(put 'imag-part '(rectangular) imag-part)
	(put 'magnitude '(rectangular) magnitude)
	(put 'angle '(rectangular) angle)
	(put 'make-from-real-imag 'rectangular
	     (lambda (x y) (tag (make-from-real-imag x y))))
	(put 'make-from-mag-ang 'rectangular
	     (lambda (r a) (tag (make-from-mag-ang r a))))
	'done)

      (define (install-polar-package)

	(define (magnitude z) (car z))
	(define (angle z) (cdr z))
	(define (make-from-mag-ang r a) (cons r a))
	(define (real-part z)
	  (mul (magnitude z) (cosine (angle z))))
	(define (imag-part z)
	  (mul (magnitude z) (sine (angle z))))
	(define (make-from-real-imag x y)
	  (cons (square-root (add (square x) (square y)))
		(arctangent y x)))

	(define (tag x) (attach-tag 'polar x))
	(put 'real-part '(polar) real-part)
	(put 'imag-part '(polar) imag-part)
	(put 'magnitude '(polar) magnitude)
	(put 'angle '(polar) angle)
	(put 'make-from-real-imag 'polar
	     (lambda (x y) (tag (make-from-real-imag x y))))
	(put 'make-from-mag-ang 'polar
	     (lambda (r a) (tag (make-from-mag-ang r a))))
	'done)

      (define (install-complex-package)
	(define (make-from-real-imag x y)
	  ((get 'make-from-real-imag 'rectangular) x y))
	(define (make-from-mag-ang r a)
	  ((get 'make-from-mag-ang 'polar) r a))
	(define (add-complex z1 z2)
	  (make-from-real-imag (add (real-part z1) (real-part z2))
			       (add (imag-part z1) (imag-part z2))))
	(define (sub-complex z1 z2)
	  (make-from-real-imag (sub (real-part z1) (real-part z2))
			       (sub (imag-part z1) (imag-part z2))))
	(define (mul-complex z1 z2)
	  (make-from-mag-ang (mul (magnitude z1) (magnitude z2))
			     (add (angle z1) (angle z2))))
	(define (div-complex z1 z2)
	  (make-from-mag-ang (div (magnitude z1) (magnitude z2))
			     (sub (angle z1) (angle z2))))
	(define (tag z) (attach-tag 'complex z))
	(put 'add '(complex complex)
	     (lambda (z1 z2) (tag (add-complex z1 z2))))
	(put 'sub '(complex complex)
	     (lambda (z1 z2) (tag (sub-complex z1 z2))))
	(put 'mul '(complex complex)
	     (lambda (z1 z2) (tag (mul-complex z1 z2))))
	(put 'div '(complex complex)
	     (lambda (z1 z2) (tag (div-complex z1 z2))))
	(put 'make-from-real-imag 'complex
	     (lambda (x y) (tag (make-from-real-imag x y))))
	(put 'make-from-mag-ang 'complex
	     (lambda (r a) (tag (make-from-mag-ang r a))))
	(put 'equ? '(complex complex)
	     (lambda (x y) (and (= 0 (real-part (sub-complex x y)))
				(= 0 (imag-part (sub-complex x y))))))
	(put 'equ? '(rectangular polar) equ?)
	(put 'equ? '(polar rectangular) equ?)
	(put 'zero? '(complex)
	     (lambda (x) (equ? (tag x) (tag (make-from-real-imag 0 0)))))
	(put 'project '(complex) (lambda (z) (real-part z)))
	'done)

      (define (make-complex-from-real-imag x y)
	((get 'make-from-real-imag 'complex) x y))

      (define (make-complex-from-mag-ang r a)
	((get 'make-from-mag-ang 'complex) r a))

      (install-rectangular-package)
      (install-polar-package)
      (install-rational-package)
      (install-scheme-number-package)
      (install-complex-package)

      (put 'real-part '(complex) real-part)
      (put 'imag-part '(complex) imag-part)
      (put 'magnitude '(complex) magnitude)
      (put 'angle '(complex) angle)

      (define (apply-generic op . args)
	#;(show #t "apply-generic:entry\n")
	#;(error "debug")
	(define (variable poly) (car poly))
	(define (all-argtypes-same? . args)
	  (let ((type (type-tag (car args))))
	    (accumulate (lambda (x y) (and x y)) #t (map (lambda (x) (eq? type x)) args))))
	(define (coercion-if-exists? type arg-tags)
	  (let ((coercion-list (map (lambda (x)
				      (if (eq? type x)
					  identity
					  (get-coercion x type))) arg-tags)))
	    (if (accumulate (lambda (x y) (and x y)) #t coercion-list)
		coercion-list
		#f)))
	(drop (let* ((type-tags (map type-tag args))
		     (proc (get op type-tags)))
		#;(show #t "apply-generic: type-tags="
			 (displayed type-tags)
			 " proc=" (written proc)
			 " proc-source=" (thingy-source proc) "\n")
		(cond (proc (apply proc (map contents args)))
		      ((= 1 (length args))
		       #;(show #t "No proc found for op=" op ", type-tags=" type-tags ", arg=" (displayed args) "\n")
		       (apply-generic op (raise-type (car args))))
		      ((= 2 (length args))
		       (cond ((and (eq? 'polynomial (car type-tags))
				 (numeric? (cadr type-tags)))
			      (apply-generic op
					     (car args)
					     (make-polynomial (variable (contents (car args)))
							      (list (list 0 (cadr args))))))
			     ((and (numeric? (car type-tags))
				 (eq? 'polynomial (cadr type-tags)))
			      (apply-generic op
					     (make-polynomial (variable (contents (cadr args)))
							      (list (list 0 (car args))))
					     (cadr args)))
			     ((and (get-coercion (car type-tags) (cadr type-tags))
				 (not (eq? (car type-tags) (cadr type-tags))))
			      (apply-generic op
					     ((get-coercion
					       (car type-tags)
					       (cadr type-tags)) (car args))
					     (cadr args)))
			     ((and (get-coercion (cadr type-tags) (car type-tags))
				 (not (eq? (car type-tags) (cadr type-tags))))
			      (apply-generic op
					     (car args)
					     ((get-coercion
					       (cadr type-tags)
					       (car type-tags)) (cadr args) )))
			     ((comparable? (car type-tags) (cadr type-tags))
			      (if
			       (type1<=type2? (car type-tags) (cadr type-tags))
			       (apply-generic op (raise-type (car args)) (cadr args))
			       (apply-generic op (car args)  (raise-type (cadr args)))))
			     (else (error "apply-generic:Incomparable types: (type-tags,args)=" type-tags args))))
		      ((and (> (length args) 2) (not (all-argtypes-same? args)))
		       (let types-loop ((types type-tags))
			 (let ((list-of-coercion-functions
				(coercion-if-exists? (car types) type-tags)))
			   (if list-of-coercion-functions
			       (apply apply-generic (cons op (map (lambda (fun arg) (fun arg))
								  list-of-coercion-functions
								  args)))
			       (if (not (null? (cdr types)))
				   (types-loop (cdr types))
				   (error "apply-generic:Even coercions failed. No method for these types."))))))
		      (else (error "apply-generic:No method for these types"
				   (list op type-tags)))))))
      (define (scheme-number->complex n)
	(make-complex-from-real-imag (contents n) 0))
      (put-coercion 'scheme-number
		    'complex
		    scheme-number->complex)

      (put 'max3-magnitude '(complex complex complex) (lambda (z1 z2 z3)
							(max (magnitude z1) (magnitude z2) (magnitude z3))))
      (define (max3-magnitude x1 x2 x3) (apply-generic 'max3-magnitude x1 x2 x3))
      (define (identity x) x)

    #;(define numeric-tower (list 'integer 'rational 'scheme-number 'complex))
    (define numeric-tower (list 'integer 'scheme-number 'complex))
    (define (comparable? type1 type2) (and (memq type1 numeric-tower) (memq type2 numeric-tower)))
    #;(define (higher-type x)
      (show #t "higher-type:x=" (displayed x) "\n")
	(define (find-higher-type x types)
	  (cond ((or (null? types) (null? (cdr types))) (error "No type higher than given" x types))
		((eq? x (car types)) (cadr types))
		(else (find-higher-type x (cdr types)))))
	(find-higher-type x numeric-tower))

    (define (numeric? x)
      (memq x numeric-tower))
    (define (polynomial? x)
      (eq? (type-tag x) 'polynomial))
    (define (higher-type x)
      (let ((tail (memq x numeric-tower)))
	(cond ((eq? #f tail) (error "Type not in the tower" x))
	      ((null? (cdr tail)) (error "Already the highest type:" x))
	      (else (cadr tail)))))

    (show #t "Test: Higher than 'integer: " (higher-type 'integer) "\n")
    #;(show #t "Test: Higher than 'complex: " (higher-type 'complex) "\n")

      (define (type1<=type2? type1 type2)
	(if (not (memq type1 numeric-tower))
	    (error "Type 1 not in the numeric tower"))
	(if (not (memq type2 numeric-tower))
	    (error "Type 2 not in the numeric tower"))
	(let loop ((types numeric-tower))
	  (cond ((null? types) (error "Type 1 and type 2 are incomparable" type1 type2))
		((eq? (car types) type1) #t)
		((eq? (car types) type2) #f)
		(else (loop (cdr types))))))

      #;(define (integer->rational x)
	(make-rational x 1))

      #;(define (rational->scheme-number x)
	(make-scheme-number ((get 'to-real '(rational)) x)))
      #;(put-coercion 'integer 'rational integer->rational)
      #;(put-coercion 'rational 'scheme-number rational->scheme-number)
    (define (integer->scheme-number x)
       (make-scheme-number (contents (exact->inexact x))))
    (put-coercion 'integer 'scheme-number integer->scheme-number)

    (define (raise-type x)
      #;(show #t "Raising type of: " (displayed x) "\n")
	(let ((converter (get-coercion (type-tag x) (higher-type (type-tag x)))))
	  (if converter
	      (converter x)
	      (error "No coercion found for x" (type-tag x) x))))


      (define (remainder-integer a b)
	(when (or (not (integer? a)) (not (integer? b)))
	  (error "Arguments must be integers" a b))
	(remainder a b))

      (put 'remainder '(integer integer) remainder-integer)
      (define (remainder-generalized a b) (apply-generic 'remainder a b))



      (show #t "Test 1: Subtracting complex numbers: "
	    (sub
	     (make-complex-from-real-imag 1.1 2)
	     (make-complex-from-real-imag 0 2)) "\n")
    (define (install-polynomial-package)
      #;(define (contents generic-object)
	(cdr generic-object))
	(define (make-poly variable term-list)
	  (cons variable term-list))
	(define (variable p) (car p))
	(define (term-list p)
	  (cdr p))
	(define (variable? x) (symbol? x))
	(define (same-variable? v1 v2)
	  (and (variable? v1) (variable? v2) (eq? v1 v2)))
	(define (=number? exp num)
	  (and (number? exp) (= exp num)))
	(define (the-empty-termlist) '())

	(define (rest-terms term-list) (cdr term-list))
	(define (empty-termlist? term-list) (null? term-list))

	(define (make-term order coeff) (list order coeff))
	(define (order term) (car term))
	(define (coeff term) (cadr term))
	(define (tag p) (attach-tag 'polynomial p))
	(put 'make 'polynomial
	     (lambda (var terms) (tag (make-poly var terms))))
	#;(continued on next page)

	(define (add-poly p1 p2)
	  #;(show #t "add-poly: p1=" p1 ", p2=" p2 "\n")
	  (if (same-variable? (variable p1) (variable p2))
	      (make-poly (variable p1)
			 (add-terms (term-list p1)
				    (term-list p2)))
	      (let ((res (cdr (if (variable_1-order<variable_2-order (variable p1) (variable p2))
		  (add (tag p1) (tag (make-poly (variable p1) (list (make-term 0 (tag p2))))))
		  (add (tag (make-poly (variable p2) (list (make-term 0 (tag p1))))) (tag p2))))))
		#;(show #t "add-poly:result: " (displayed res) "\n") res)))

	(show #t "TestY2: poly of poly: "
	      (make-poly 'x (list
			     (make-term 3 (make-poly
					   'y (list (make-term 1 1) (make-term 0 1))))
			     (make-term 1 2)
			     (make-term 0 4))) "\n")

	(define (sub-poly p1 p2)
	  (add-poly p1 (mul-poly p2 (make-poly (variable p2) (list (make-term 0 -1))))))
	(define (add-terms L1 L2)
	  (cond ((empty-termlist? L1) L2)
		((empty-termlist? L2) L1)
		(else
		 (let ((t1 (first-term L1)) (t2 (first-term L2)))
		   (cond ((> (order t1) (order t2))
			  (adjoin-term
			   t1 (add-terms (rest-terms L1) L2)))
			 ((< (order t1) (order t2))
			  (adjoin-term
			   t2 (add-terms L1 (rest-terms L2))))
			 (else
			  (adjoin-term
			   (make-term (order t1)
				      (add (coeff t1) (coeff t2)))
			   (add-terms (rest-terms L1)
				      (rest-terms L2)))))))))


	(define (mul-poly p1 p2)
	  (if (same-variable? (variable p1) (variable p2))
	      (make-poly (variable p1)
			 (mul-terms (term-list p1)
				    (term-list p2)))
	      (contents (if (variable_1-order<variable_2-order (variable p1) (variable p2))
		  (mul (tag p1)
		       (make-polynomial (variable p1)
					(adjoin-term
					 (make-term 0
						    (tag p2)) (the-empty-termlist))))
		  (mul (tag p2)
		       (make-polynomial (variable p2)
					(adjoin-term
					 (make-term 0
						    (tag p1)) (the-empty-termlist))))))
	      #;(error "Polys not in same var -- MUL-POLY"
		     (list p1 p2))))
	(define (div-poly p1 p2)
	  (if (same-variable? (variable p1) (variable p2))
	      (let ((quotient-and-remainder (div-terms (term-list p1)
						       (term-list p2))))
		(list (make-poly (variable p1) (car  quotient-and-remainder))
		      (make-poly (variable p1) (cadr quotient-and-remainder))))
		(error "div-poly: Polys not in the same var" p1 p2)))
	(define (div-terms L1 L2)
		(if (empty-termlist? L1)
		    (list (the-empty-termlist) (the-empty-termlist))
		    (let ((t1 (first-term L1))
			  (t2 (first-term L2)))
		      (if (> (order t2) (order t1))
			  (list (the-empty-termlist) L1)
			  (let ((new-c (div (coeff t1) (coeff t2)))
				(new-o (- (order t1) (order t2))))
			    (let ((rest-of-result (div-terms (term-list
							      (sub-poly
							       (make-poly 'fake-var L1)
							       (mul-poly
								(make-poly 'fake-var (list (make-term new-o new-c)))
								(make-poly 'fake-var L2))))
							     L2)
						  ))
			      #;(show #t "div-terms: rest-of-result: " (displayed rest-of-result) "\n")
			      (list (adjoin-term (make-term new-o new-c) (car rest-of-result)) (cadr rest-of-result))
			      ))))))
	(define (gcd-terms a b)
	  (if (empty-termlist? b)
	      a
	      (begin
              (show #t "gcd-terms: (term-list b)=" (term-list b) "\n")
              (gcd-terms b (remainder-terms a b)))))
	(define (remainder-terms a b)
	  (cadr (div-terms a b)))
	(define (gcd-poly p1 p2)
	  (if (same-variable? (variable p1) (variable p2))
	      (make-poly (variable p1) (gcd-terms (term-list p1) (term-list p2)))
	      (error "div-poly: Polys not in the same var" p1 p2)))
	(put 'gcd '(polynomial polynomial)
	     (lambda (x y) (tag (gcd-poly x y))))
	(put 'gcd '(integer integer) gcd)

	(define (mul-terms L1 L2)
	  (if (empty-termlist? L1)
	      (the-empty-termlist)
	      (add-terms (mul-term-by-all-terms (first-term L1) L2)
			 (mul-terms (rest-terms L1) L2))))

	(define (mul-term-by-all-terms t1 L)
	  (if (empty-termlist? L)
	      (the-empty-termlist)
	      (let ((t2 (first-term L)))
		(adjoin-term
		 (make-term (+ (order t1) (order t2))
			    (mul (coeff t1) (coeff t2)))
		 (mul-term-by-all-terms t1 (rest-terms L))))))
	(define (zero-poly? poly)
	  #;(show #t "zero-poly?: poly=" (displayed poly) "\n")
	  (cond ((empty-termlist? (term-list poly)) #t)
		((not (zero? (coeff (first-term (term-list poly))))) #f)
		(else (zero-poly?
		       (make-poly (variable poly)
				  (rest-terms (term-list poly)))))))

	(define (termlist-type-of term-list)
	  #;(show #t "t-t-o: term-list=" (displayed term-list) "\n")
	  (cond ((null? term-list) 'sparse)
		((pair? (car term-list)) 'sparse)
		((list? term-list) 'dense)
		(else (error "Unknown type of list" term-list))))
	(define (adjoin-term term term-list)
	  ((get 'adjoin-term (termlist-type-of term-list)) term term-list))
	(define (first-term term-list)
	  ((get 'first-term (termlist-type-of term-list)) term-list))
	(define (variable_1-order<variable_2-order variable_1 variable_2)
	  #;(show #t "var_1-..: variable_1=" variable_1 " variable_2=" variable_2 "\n")
	  #;(show #t "var12string=" (symbol->string variable_1) "var22string=" (symbol->string variable_2) "\n")
	  (string<=? (symbol->string variable_1) (symbol->string variable_2)))
	(define (normalize-fully poly)
	  (if (normal-polynomial? poly)
	      poly
	      (normalize-fully (normalize-once poly))))
	(put 'add '(polynomial polynomial)
	     (lambda (p1 p2)
	       #;(show #t "generic-add-poly:Polynomial dispatch found: p1="
		      (displayed p1) " p2=" (displayed p2) "\n")
	       (normalize-fully (tag (add-poly p1 p2)))))
	(put 'mul '(polynomial polynomial)
	     (lambda (p1 p2) (normalize-fully (tag (mul-poly p1 p2)))))
	(put 'sub '(polynomial polynomial)
	     (lambda (p1 p2) (tag (sub-poly p1 p2))))

	(put 'zero? '(polynomial) zero-poly?)
	(put 'div '(polynomial polynomial) div-poly)
	#;(put-coercion 'rational 'scheme-number rational->scheme-number)
	(define (monomial-flip-variables monomial)
	  #;(show #t "m-f-v: monomial=" monomial "\n")
	  (let* ((mono (contents monomial))
		 (inner-polynomial (contents (coeff (first-term (term-list mono)))))
		 (inner-poly (contents inner-polynomial))
		 (outer-order (order (first-term (term-list mono))))
		 (outer-var (variable mono))
		 (inner-var (variable inner-polynomial))
		 (inner-term-list (term-list inner-poly)))
	    #;(show #t "m-f-v: inner-poly=" inner-poly "\n")
	    (if (same-variable? inner-var outer-var)
		(mul
		 (make-polynomial outer-var (adjoin-term (make-term outer-order 1) (the-empty-termlist)))
		 (tag inner-polynomial))
		(tag (make-poly inner-var
				(mul-term-by-all-terms (make-term
							0
							(make-polynomial
							 outer-var
							 (list (make-term
								outer-order
								1)))) inner-poly))))))
	#;(show #t "TestXX: sorting variables: Is 'x < 'y?: "
	      (variable_1-order<variable_2-order 'x 'y) "\n")
	#;(show #t "TestXX: sorting variables: Is 'z < 'y?: "
	      (variable_1-order<variable_2-order 'z 'y) "\n")
	#;(show #t "TestXX: (adding two basic poly): "
	      (add (make-polynomial 'x (list (make-term 1 2) (make-term 0 4)))
		   (make-polynomial 'y (list (make-term 2 3) (make-term 0 5)))) "\n")

	(define (polynomial->sum-of-first-and-rest poly)
	  #;(show #t "p->s-o-f-a-r: " (displayed poly) "\n")
	  (if (zero? poly)
	      poly
	      (let* ((poly1 (contents poly))
		     (first-monomial (tag
				      (make-poly
				       (variable poly1)
				       (list (first-term (term-list poly1)))))))
		#;(show #t "p->s-o-f-a-r: " (displayed first-monomial) "\n")
		(add
		  first-monomial
		  (polynomial->sum-of-first-and-rest
		   (tag (make-poly (variable poly1) (rest-terms (term-list poly1)))))))))

	(show #t "Test13: Expanding a polynomial as monomials: "
	      (displayed
	       (polynomial->sum-of-first-and-rest
		(make-polynomial 'y
				 (list (make-term 2 (make-polynomial
						     'x
						     (list (make-term 2 1) (make-term 0 1))))
				       (make-term 0 2))))) "\n")

	(show #t "\nTest20: start monomial: "
	      (displayed (make-polynomial 'x
					  (list
					   (make-term
					    2
					    (make-polynomial
					     'y
					     (list
					      (make-term 2 1) (make-term 0 1))))))) "\n")
	(show #t "Test20: Flipping a monomial variable: "
	      (displayed
	       (monomial-flip-variables
		(make-polynomial 'x
				 (list (make-term 1 (make-polynomial
						     'y
						     (list
						      (make-term 2 1)
						      (make-term 0 1)))))))) "\n\n")


	(define (normal-polynomial? poly)
	  #;(show #t "n-p?: poly=" poly "\n")
	  (cond ((not (polynomial? poly)) #t)
		((null? (term-list (contents poly))) #t)
		(else (let* ((poly1 (contents poly))
			     (outer-var (variable poly1)))
			#;(show #t "Inner-let: outer-var=" (displayed outer-var) "\n")
			(let loop ((terms (term-list poly1)))
			  #;(show #t "n-p?-loop: terms=" (displayed terms) "\n")
			  (cond ((null? terms) #t)
				((not (polynomial? (coeff (first-term terms)))) (loop (rest-terms terms)))
				((not (variable_1-order<variable_2-order
				     outer-var
				     (variable (contents (coeff (first-term terms)))))) (begin #;(show #t "wrong variable order \n") #f))
				((not (normal-polynomial? (coeff (first-term terms)))) (begin #;(show #t "not normal poly\n") #f))
				(else (loop (rest-terms terms)))))
			))))
	(define (normalize-once poly)
	  #;(show #t "normalize-once poly= " (displayed poly) "\n")
	  (if (zero? poly)
	      poly
	      (let* ((poly1 (contents poly))
		     (first-monomial (tag
				      (make-poly
				       (variable poly1)
				       (list (make-term
					      (order (first-term (term-list poly1)))
					      (if (polynomial? (coeff (first-term (term-list poly1))))
						  (normalize-once (coeff (first-term (term-list poly1))))
						  (coeff (first-term (term-list poly1))))))))))
		#;(show #t "p->s-o-f-a-r: " (displayed first-monomial) "\n")
		(add
		 (if (and (polynomial?
			 (coeff
			  (first-term
			   (term-list
			    (contents first-monomial)))))
			(variable_1-order<variable_2-order
			 (variable
			  (contents
			   (coeff
			    (first-term
			     (term-list
			      (contents first-monomial))))))
			 (variable
			  (contents first-monomial))))
		     (monomial-flip-variables first-monomial)
		     first-monomial)
		  (polynomial->sum-of-first-and-rest
		   (tag (make-poly (variable poly1) (rest-terms (term-list poly1)))))))))

	(show #t "Test21: normal-polynomial?:start: " (displayed (make-polynomial 'y
					       (list (make-term 2 (make-polynomial
								   'x
						     (list (make-term 2 1) (make-term 0 1))))
						     (make-term 0 2)))) "\n")
	(show #t "Test21: normal-polynomial?:result:" (normal-polynomial? (make-polynomial 'y
					       (list (make-term 2 (make-polynomial
								   'x
						     (list (make-term 2 1) (make-term 0 1))))
						     (make-term 0 2)))) "\n")
	(show #t "Test22: normal-polynomial?-good:start: "
	      (displayed
	       (make-polynomial 'x
				(list (make-term 2 (make-polynomial
						    'y
						    (list (make-term 2 1) (make-term 0 1))))
				      (make-term 0 2)))) "\n")
	(show #t "Test22: normal-polynomial?-good:result:"
	      (normal-polynomial?
	       (make-polynomial 'x
				(list (make-term 2 (make-polynomial
						    'y
						    (list (make-term 2 1) (make-term 0 1))))
				      (make-term 0 2)))) "\n")

	(show #t "Test23:input: normalizing a bad polynomial: "
	      (make-polynomial 'y
				 (list (make-term 2 (make-polynomial
						     'x
						     (list (make-term 2 1) (make-term 0 1))))
				       (make-term 0 2))) "\n")
	(show #t "Test23:result: normalizing a bad polynomial: "
	      (normalize-once (make-polynomial 'y
					       (list (make-term 2 (make-polynomial
								   'x
						     (list (make-term 2 1) (make-term 0 1))))
						     (make-term 0 2)))) "\n")
	(show #t "Test24:input: normalizing a bad polynomial: "
	      (make-polynomial 'x
				 (list (make-term 2 (make-polynomial
						     'x
						     (list (make-term 2 1) (make-term 0 1))))
				       (make-term 0 2))) "\n")
	(show #t "Test24:result: normalizing a bad polynomial: "
	      (normalize-once (make-polynomial 'x
					       (list (make-term 2 (make-polynomial
								   'x
						     (list (make-term 2 1) (make-term 0 1))))
						     (make-term 0 2)))) "\n")


	(show #t "Test24:input: normalize-fully a bad polynomial: "
	      (make-polynomial 'y
				 (list (make-term 2 (make-polynomial
						     'x
						     (list (make-term 2 1) (make-term 0 1))))
				       (make-term 0 2))) "\n")
	(show #t "Test24:result: normalize-fully a bad polynomial: "
	      (normalize-fully (make-polynomial 'y
					       (list (make-term 2 (make-polynomial
								   'x
						     (list (make-term 2 1) (make-term 0 1))))
						     (make-term 0 2)))) "\n")



	'done)


      (define (install-polynomial-sparse-package)
	(define (coeff term) (cadr term))
	(define (first-term-sparse term-list) (car term-list))
	(define (adjoin-term-sparse term term-list)
	  (if (zero? (coeff term))
	      term-list
	      (cons term term-list)))
	(put 'adjoin-term 'sparse adjoin-term-sparse)
	(put 'first-term 'sparse first-term-sparse)
	'done)
      (install-polynomial-sparse-package)

      (define (install-polynomial-dense-package)
	(define (make-term order coeff) (list order coeff))
	(define (order term) (car term))
	(define (coeff term) (cadr term))

	(define (adjoin-term-dense term term-list)
	    (if (zero? (coeff term))
		term-list
		(if (> (order term) (length term-list))
		    (append (list (coeff term))
			    (make-list (- (order term) (length term-list)) 0)
			    term-list)
		    (error "adjoin-term:Appending a smaller order term. Recheck."))))
	(define (first-term-dense term-list)
	   #;(show #t "first-term-dense: " (displayed (make-term (car term-list) (length (cdr term-list)))) "\n")
	   (make-term (length (cdr term-list)) (car term-list) ))
	(put 'adjoin-term 'dense adjoin-term-dense)
	#;(put 'first-term 'dense first-term-dense)
	'done)
      #;(install-polynomial-dense-package)

      (define (make-polynomial var terms)
	((get 'make 'polynomial) var terms))

    (install-polynomial-package)


      #;(show #t "Test 2: Making polynomials: "
	    (make-polynomial 'x (list (list 5 1) (list 4 2))) "\n")
      #;(show #t "Test 3: Zero?: "
	    (zero? (make-polynomial 'x (list (list 5 1) (list 4 2)))) "\n")
      #;(show #t "Test 4: Adding polynomials: "
	    (add (make-polynomial 'x '((5 1) (4 2) (0 1)))
		 (make-polynomial 'x '((5 1)))) "\n")
      #;(show #t "Test 4: Zero?: " (zero? (make-polynomial 'x '((5 0) (3 1)))) "\n")

      #;(show #t "Test 5: Subtracting polynomials: "
	    (sub (make-polynomial 'x '((5 1) (4 2) (0 1)))
		 (make-polynomial 'x '((0 1)))) "\n")

      #;(show #t "Test 6: Making a dense polynomial: " (make-polynomial 'x '(1 2 3 4 5)) "\n")
      #;(show #t "Test 7: zero? dense polynomial: " (displayed (zero? (make-polynomial 'x '(0)))) "\n")
      #;(show #t "Test 8: zero? dense polynomial: " (displayed (zero? (make-polynomial 'x '(1)))) "\n")
      #;(show #t "Test 9: Adding dense polynomials: "
	    (add (make-polynomial 'x '(1 2 0 0 0 1))
		 (make-polynomial 'x '(1 0 0 0 0 0))) "\n")
      #;(show #t "Test10: Subtracting dense polynomials: "
	    (sub (make-polynomial 'x '(1 2 0 0 0 1))
		 (make-polynomial 'x '(1 0 0 0 0 0))) "\n")
      #;(show #t "Test11: Subtracting dense and sparse polynomials: "
	    (sub (make-polynomial 'x '(1 2 0 0 0 1))
		 (make-polynomial 'x '((4 2)))) "\n")
      #;(show #t "Test12: Dividing x^2 + 2x + 1 by x+1: "
	    (displayed
	     (div (make-polynomial 'x '((2 1) (1 2) (0 1)))
		  (make-polynomial 'x '(      (1 1) (0 1)))) ) "\n")
      #;(show #t "Test14: Adding polynomials of two variables: "
	    (displayed
	     (add (make-polynomial 'x '((1 1)))
		  (make-polynomial 'y '((1 1))))))
      #;(show #t "Test14: Adding polynomials of two variables, when one of them is nonexistant: "
	    (displayed
	     (add (make-polynomial 'x '((1 1)))
		  (make-polynomial 'y '((0 1))))))
    (show #t "Test25: multiplying different variables: "
	  (displayed (mul (make-polynomial 'x '((1 1)))
			  (make-polynomial 'y '((1 1))))) "\n")
  (begin
  (define p1 (make-polynomial 'x '((2 1) (0 1))))
  (define p2 (make-polynomial 'x '((3 1) (0 1))))
  (define rf (make-rational p2 p1))
  (show #t "Test 26: make-rational-polynomial: " rf "\n")
  (show #t "Test 27: add-rational\n")
  (show #t "Test 27: " (add rf rf) "\n")
  )

  (show #t "Test 28: polynomial-gcd: start\n")
  (define (greatest-common-divisor p1 p2) (apply-generic 'gcd p1 p2))
  (begin
    (define p1 (make-polynomial
		 'x '((4 1) (3 -1) (2 -2) (1 2))))
    (define p2 (make-polynomial 'x '((3 1) (1 -1))))

    (show #t "Test 28: polynomial-gcd: " (greatest-common-divisor p1 p2) "\n"))

  (begin
      (define p1 (make-polynomial
		   'x '((2 1) (1 -2) (0 1))))
      (define p2 (make-polynomial 'x '((2 11) (0 7))))

      (define p3 (make-polynomial 'x '((1 13) (0 5))))
      (define q1 (mul p1 p2))
      (define q2 (mul p1 p3))
      (show #t "Test 29: gcd-integer-problem: start\n")
      (show #t "Test 29: gcd : " (greatest-common-divisor q1 q2) "\n")
    )
#+end_src

#+RESULTS[17b02fb04ff2d386fe792f8b9e99f502c7d46fe2]:
#+begin_src scheme
Test: Higher than 'integer: scheme-number
Test 1: Subtracting complex numbers: (scheme-number . 1.1)
TestY2: poly of poly: (x (3 (y (1 1) (0 1))) (1 2) (0 4))
Test13: Expanding a polynomial as monomials: (polynomial x (2 (polynomial y (2 1))) (0 (polynomial y (2 1) (0 2))))

Test20: start monomial: (polynomial x (2 (polynomial y (2 1) (0 1))))
Test20: Flipping a monomial variable: (polynomial y (2 (polynomial x (1 1))) (0 (polynomial x (1 1))))

Test21: normal-polynomial?:start: (polynomial y (2 (polynomial x (2 1) (0 1))) (0 2))
Test21: normal-polynomial?:result:#f
Test22: normal-polynomial?-good:start: (polynomial x (2 (polynomial y (2 1) (0 1))) (0 2))
Test22: normal-polynomial?-good:result:#t
Test23:input: normalizing a bad polynomial: (polynomial y (2 (polynomial x (2 1) (0 1))) (0 2))
Test23:result: normalizing a bad polynomial: (polynomial x (2 (polynomial y (2 1))) (0 (polynomial y (2 1) (0 2))))
Test24:input: normalizing a bad polynomial: (polynomial x (2 (polynomial x (2 1) (0 1))) (0 2))
Test24:result: normalizing a bad polynomial: (polynomial x (4 1) (2 1) (0 2))
Test24:input: normalize-fully a bad polynomial: (polynomial y (2 (polynomial x (2 1) (0 1))) (0 2))
Test24:result: normalize-fully a bad polynomial: (polynomial x (2 (polynomial y (2 1))) (0 (polynomial y (2 1) (0 2))))
Test25: multiplying different variables: (polynomial x (1 (polynomial y (1 1))))
Test 26: make-rational-polynomial: (rational (polynomial x (3 1) (0 1)) polynomial x (2 1) (0 1))
Test 27: add-rational
rational not droppable: #f
Test 27: (rational (polynomial x (5 2) (3 2) (2 2) (0 2)) polynomial x (4 1) (2 2) (0 1))
Test 28: polynomial-gcd: start
gcd-terms: (term-list b)=((1 -1))
gcd-terms: (term-list b)=((1 1))
Test 28: polynomial-gcd: (polynomial x (2 -1) (1 1))
Test 29: gcd-integer-problem: start
gcd-terms: (term-list b)=((2 -21) (1 3) (0 5))
gcd-terms: (term-list b)=((1 (scheme-number . -17.254437869822485)) (0 (scheme-number . 8.627218934911243)))
gcd-terms: (term-list b)=((0 (scheme-number . 7.993605777301127e-15)))
gcd-terms: (term-list b)=()
Test 29: gcd : (polynomial x (0 (scheme-number . 1.100410578432558)))
#+end_src

The answer is a polynomial \(x^0 \times 1.100410578432558\), which is
essentially just a number. Clearly, this is not the greatest common
divisor. I believe, this problem happens because at some point, the
comparison "(if (= 0 b))" fails, because b is very small, but still nonzero
due to precision problems. In principle, this should be possible to fix by
carefully studying the algorithm and ensuring that every operation in
"div-terms" preserves exactness. Still, this should give a polynomial with
very long coefficients.

When I was doing the manual repetition of the algorithm, I found that the
numerators and denominators of the numbers grow very fast, so it quickly
becomes very hard to operate with these numbers.
*** DONE Exercise 2.96 Integerizing factor
    CLOSED: [2019-10-28 Mon 19:23]

This is not a very hard exercise. The only problem here is still the messy
part in the division by the gcd, but hey, formally the exercise is done.


#+begin_src scheme :exports both :results output scalar code
	  (define (project obj)
	    (apply-generic 'project obj))
	  (define (droppable? obj)
	    #;(show #t "droppable?: obj=" obj ", type-tag=" (type-tag obj) "\n")
	    (cond ((eq? (type-tag obj) 'rational) (begin (show #t "rational not droppable: #f\n") #f))
		  ((not (memq (type-tag obj) numeric-tower)) #f)
		  ((eq? (type-tag obj) (car numeric-tower)) #f)
		  ((equ? obj (raise-type (project obj))) #t)
		  (else #f)))
	  (define (drop obj)
	    (if (droppable? obj)
		(drop (project obj))
		obj))
	(define (thingy-source thingy)
	  (cond ((lambda? thingy) (list "lambda" (lambda-source thingy)))
		((procedure? thingy) (list "procedure" (procedure-name thingy)))
		((pair? thingy) (list "pair" (pair-source thingy)))
		(else "No source? refactor")))

	  (define (accumulate op initial sequence)
	    (if (null? sequence)
		initial
		(accumulate op (op initial (car sequence)) (cdr sequence))))
	  (define false #f)
	  (define true  #t)
	  (define (make-table)
	    (let ((local-table (list '*table*)))
	      (define (lookup key-1 key-2)
		(let ((subtable (assoc key-1 (cdr local-table))))
		  (if subtable
		      (let ((record (assoc key-2 (cdr subtable))))
			(if record
			    (cdr record)
			    false))
		      false)))
	      (define (insert! key-1 key-2 value)
		(let ((subtable (assoc key-1 (cdr local-table))))
		  (if subtable
		      (let ((record (assoc key-2 (cdr subtable))))
			(if record
			    (set-cdr! record value)
			    (set-cdr! subtable
				      (cons (cons key-2 value)
					    (cdr subtable)))))
		      (set-cdr! local-table
				(cons (list key-1
					    (cons key-2 value))
				      (cdr local-table)))))
		'ok)
	      (define (dispatch m)
		(cond ((eq? m 'lookup-proc) lookup)
		      ((eq? m 'insert-proc!) insert!)
		      (else (error "Unknown operation -- TABLE" m))))
	      dispatch))

	  (define operation-table (make-table))
	  (define get (operation-table 'lookup-proc))
	  (define put (operation-table 'insert-proc!))

	  (define coercion-table (make-table))
	  (define get-coercion (coercion-table 'lookup-proc))
	  (define put-coercion (coercion-table 'insert-proc!))

	  (define (attach-tag type-tag contents)
	    (cons type-tag contents))

	  (define (type-tag datum)
	    (cond ((pair? datum) (car datum))
		  ((exact-integer? datum) 'integer)
		  ((real? datum) 'scheme-number)
		  (error "Bad tagged datum -- TYPE-TAG" datum)))

	(define (contents datum)
	    (cond ((pair? datum) (cdr datum))
		  ((integer? datum) datum)
		  ((real? datum) datum)
		  (else (error "Bad tagged datum -- CONTENTS" datum))))

	  (define (integer? x)
	    (eq? (type-tag x) 'integer))
	  (define (rectangular? z)
	    (eq? (type-tag z) 'rectangular))

	  (define (polar? z)
	    (eq? (type-tag z) 'polar))


	  (define (real-part z) (apply-generic 'real-part z))
	  (define (imag-part z) (apply-generic 'imag-part z))
	  (define (magnitude z) (apply-generic 'magnitude z))
	  (define (angle z) (apply-generic 'angle z))

	  (define (add x y)
	     #;(show #t "debug:add: x=" x ", y=" y ", starting apply-generic\n")
	     #;(show #t "debug:add: (type-tags x,y)=(" (type-tag x) "," (type-tag y) ")" "\n")
	     #;(show #t "debug:add:can we access apply-generic?" (written apply-generic)
		      "\n" )
	     #;(error "Debug1")
	     (apply-generic 'add x y))
	  (define (sub x y) (apply-generic 'sub x y))
	  (define (mul x y) (apply-generic 'mul x y))
	  (define (div x y) (apply-generic 'div x y))

	  (define (equ? x y)
	    (apply-generic 'equ? x y))
	  (define (zero? x) (apply-generic 'zero? x))

	  (define (exp x y) (apply-generic 'exp x y))

	  (define (install-scheme-number-package)
	    (define (tag x)
	      #;(attach-tag 'scheme-number x) x)
	    (show #t "(tag 5)=" (tag 5) "\n")
	    (put 'add '(scheme-number scheme-number)
		 (lambda (x y) #;(show #t "debug:found plus dispatch\n") (tag (+ x y))))
	    (put 'sub '(scheme-number scheme-number)
		 (lambda (x y) (tag (- x y))))
	    (put 'mul '(scheme-number scheme-number)
		 (lambda (x y) (tag (* x y))))
	    (put 'div '(scheme-number scheme-number)
		 (lambda (x y) (tag (/ x y))))
	    (put 'make 'scheme-number
		 (lambda (x) #;(show #t "debug:found 'make 'scheme-number\n") (tag x)))
	    (put 'equ? '(scheme-number scheme-number)
		 (lambda (x y) (= x y)))
	    (put 'zero? '(scheme-number)
		 (lambda (x) (= 0 x)))
	    (put 'exp '(scheme-number scheme-number)
		 (lambda (x y) (tag (expt x y))))
	    (put 'project '(scheme-number)
		 (lambda (x)
		   (if (finite? x)
                      (exact (truncate x))
                      0)))
	    (put 'sine '(scheme-number) sin)
	    (put 'cosine '(scheme-number) cos)
	    (put 'square-root '(scheme-number) sqrt)
	    (put 'arctangent '(schemer-number) atan)
	    'done)
  (install-scheme-number-package)
	(define (integer->scheme-number x)
	   (make-scheme-number (inexact (contents x))))
	(put-coercion 'integer 'scheme-number integer->scheme-number)

	  (define (sine x) (apply-generic 'sine x))
	  (define (cosine x) (apply-generic 'cosine x))
	  (define (square-root x) (apply-generic 'square-root x))
	  (define (arctangent x) (apply-generic 'arctangent x))

	  (define (make-scheme-number n)
	     #;(show #t "debug:make-scheme-number: n=" n "\n")
	    ((get 'make 'scheme-number) n))
	  (show #t "Test 31: start\n")
	  (show #t "Test 31:" (equal? (make-scheme-number 1) 1) "\n")


	  (define (install-rational-package)
	    (define (numer x) (car x))
	    (define (denom x) (cdr x))
	    (define (make-rat n d)
	      #;(let ((g (gcd n d)))
		(cons (/ n g) (/ d g)))
		(cons n d))
	    (define (add-rat x y)
	      (make-rat (add (mul (numer x) (denom y))
			   (mul (numer y) (denom x)))
			(mul (denom x) (denom y))))
	    (define (sub-rat x y)
	      (make-rat (sub (mul (numer x) (denom y))
			   (mul (numer y) (denom x)))
			(mul (denom x) (denom y))))
	    (define (mul-rat x y)
	      (make-rat (mul (numer x) (numer y))
			(mul (denom x) (denom y))))
	    (define (div-rat x y)
	      (make-rat (mul (numer x) (denom y))
			(mul (denom x) (numer y))))

	    (define (tag x) (attach-tag 'rational x))
	    (put 'add '(rational rational)
		 (lambda (x y) (tag (add-rat x y))))
	    (put 'sub '(rational rational)
		 (lambda (x y) (tag (sub-rat x y))))
	    (put 'mul '(rational rational)
		 (lambda (x y) (tag (mul-rat x y))))
	    (put 'div '(rational rational)
		 (lambda (x y) (tag (div-rat x y))))

	    (put 'make 'rational
		 (lambda (n d) (tag (make-rat n d))))
	    (put 'equ? '(rational rational)
		 (lambda (x y) (zero? (numer (sub-rat x y)))))
	    (put 'zero? '(rational) (lambda (x) (zero? (numer x))))
	    #;(put 'project '(rational) (lambda (x)
					(exact (truncate (/ (numer x) (denom x))))))
	    #;(put 'to-real '(rational) (lambda (x) (/ (numer (contents x)) (denom (contents x)))))
	    'done)

	  (define (make-rational n d)
	    ((get 'make 'rational) n d))

	  (define (install-rectangular-package)

	    (define (real-part z) (car z))
	    (define (imag-part z) (cdr z))
	    (define (make-from-real-imag x y) (cons x y))
	    (define (magnitude z)
	      (square-root (add (square (real-part z))
				(square (imag-part z)))))
	    (define (angle z)
	      (arctangent (imag-part z) (real-part z)))
	    (define (make-from-mag-ang r a)
	      (cons (mul r (cosine a)) (mul r (sine a))))

	    (define (tag x) (attach-tag 'rectangular x))
	    (put 'real-part '(rectangular) real-part)
	    (put 'imag-part '(rectangular) imag-part)
	    (put 'magnitude '(rectangular) magnitude)
	    (put 'angle '(rectangular) angle)
	    (put 'make-from-real-imag 'rectangular
		 (lambda (x y) (tag (make-from-real-imag x y))))
	    (put 'make-from-mag-ang 'rectangular
		 (lambda (r a) (tag (make-from-mag-ang r a))))
	    'done)

	  (define (install-polar-package)

	    (define (magnitude z) (car z))
	    (define (angle z) (cdr z))
	    (define (make-from-mag-ang r a) (cons r a))
	    (define (real-part z)
	      (mul (magnitude z) (cosine (angle z))))
	    (define (imag-part z)
	      (mul (magnitude z) (sine (angle z))))
	    (define (make-from-real-imag x y)
	      (cons (square-root (add (square x) (square y)))
		    (arctangent y x)))

	    (define (tag x) (attach-tag 'polar x))
	    (put 'real-part '(polar) real-part)
	    (put 'imag-part '(polar) imag-part)
	    (put 'magnitude '(polar) magnitude)
	    (put 'angle '(polar) angle)
	    (put 'make-from-real-imag 'polar
		 (lambda (x y) (tag (make-from-real-imag x y))))
	    (put 'make-from-mag-ang 'polar
		 (lambda (r a) (tag (make-from-mag-ang r a))))
	    'done)

	  (define (install-complex-package)
	    (define (make-from-real-imag x y)
	      ((get 'make-from-real-imag 'rectangular) x y))
	    (define (make-from-mag-ang r a)
	      ((get 'make-from-mag-ang 'polar) r a))
	    (define (add-complex z1 z2)
	      (make-from-real-imag (add (real-part z1) (real-part z2))
				   (add (imag-part z1) (imag-part z2))))
	    (define (sub-complex z1 z2)
	      (make-from-real-imag (sub (real-part z1) (real-part z2))
				   (sub (imag-part z1) (imag-part z2))))
	    (define (mul-complex z1 z2)
	      (make-from-mag-ang (mul (magnitude z1) (magnitude z2))
				 (add (angle z1) (angle z2))))
	    (define (div-complex z1 z2)
	      (make-from-mag-ang (div (magnitude z1) (magnitude z2))
				 (sub (angle z1) (angle z2))))
	    (define (tag z) (attach-tag 'complex z))
	    (put 'add '(complex complex)
		 (lambda (z1 z2) (tag (add-complex z1 z2))))
	    (put 'sub '(complex complex)
		 (lambda (z1 z2) (tag (sub-complex z1 z2))))
	    (put 'mul '(complex complex)
		 (lambda (z1 z2) (tag (mul-complex z1 z2))))
	    (put 'div '(complex complex)
		 (lambda (z1 z2) (tag (div-complex z1 z2))))
	    (put 'make-from-real-imag 'complex
		 (lambda (x y) (tag (make-from-real-imag x y))))
	    (put 'make-from-mag-ang 'complex
		 (lambda (r a) (tag (make-from-mag-ang r a))))
	    (put 'equ? '(complex complex)
		 (lambda (x y) (and (= 0 (real-part (sub-complex x y)))
				    (= 0 (imag-part (sub-complex x y))))))
	    (put 'equ? '(rectangular polar) equ?)
	    (put 'equ? '(polar rectangular) equ?)
	    (put 'zero? '(complex)
		 (lambda (x) (equ? (tag x) (tag (make-from-real-imag 0 0)))))
	    (put 'project '(complex) (lambda (z) (real-part z)))
	    'done)

	  (define (make-complex-from-real-imag x y)
	    ((get 'make-from-real-imag 'complex) x y))

	  (define (make-complex-from-mag-ang r a)
	    ((get 'make-from-mag-ang 'complex) r a))

	  (install-rectangular-package)
	  (install-polar-package)
	  (install-rational-package)

	  (install-complex-package)

	  (put 'real-part '(complex) real-part)
	  (put 'imag-part '(complex) imag-part)
	  (put 'magnitude '(complex) magnitude)
	  (put 'angle '(complex) angle)
	  (define (polynomial? x)
	    (eq? (type-tag x) 'polynomial))
	  (define numeric-tower (list 'integer 'scheme-number 'complex))
	  (define (numeric? x)
	    (memq x numeric-tower))
	  (define (type1<=type2? type1 type2)
	    (if (not (memq type1 numeric-tower))
		(error "Type 1 not in the numeric tower"))
	    (if (not (memq type2 numeric-tower))
		(error "Type 2 not in the numeric tower"))
	    (let loop ((types numeric-tower))
	      (cond ((null? types) (error "Type 1 and type 2 are incomparable" type1 type2))
		    ((eq? (car types) type1) #t)
		    ((eq? (car types) type2) #f)
		    (else (loop (cdr types))))))
	  (define (comparable? type1 type2)
	    (and (memq type1 numeric-tower)
		(memq type2 numeric-tower)))
	  (define (raise-type x)
	  #;(show #t "Raising type of: " (displayed x) "\n")
	    (let ((converter (get-coercion (type-tag x) (higher-type (type-tag x)))))
	      (if converter
		  (converter x)
		  (error "No coercion found for x" (type-tag x) x))))
	(define (higher-type x)
	  (let ((tail (memq x numeric-tower)))
	    (cond ((eq? #f tail) (error "Type not in the tower" x))
		  ((null? (cdr tail)) (error "Already the highest type:" x))
		  (else (cadr tail)))))

	(show #t "Test: Higher than 'integer: " (higher-type 'integer) "\n")
	  (define (remainder-integer a b)
	    (when (or (not (integer? a)) (not (integer? b)))
	      (error "Arguments must be integers" a b))
	    (remainder a b))

	  (put 'remainder '(integer integer) remainder-integer)
	  (define (remainder-generalized a b) (apply-generic 'remainder a b))



	  (define (apply-generic op . args)
	    #;(show #t "apply-generic:entry\n")
	    #;(error "debug")
	    (define (variable poly) (car poly))
	    (define (all-argtypes-same? . args)
	      (let ((type (type-tag (car args))))
		(accumulate (lambda (x y) (and x y)) #t (map (lambda (x) (eq? type x)) args))))
	    (define (coercion-if-exists? type arg-tags)
	      (let ((coercion-list (map (lambda (x)
					  (if (eq? type x)
					      identity
					      (get-coercion x type))) arg-tags)))
		(if (accumulate (lambda (x y) (and x y)) #t coercion-list)
		    coercion-list
		    #f)))
	    (drop (let* ((type-tags (map type-tag args))
			 (proc (get op type-tags)))
		   #;(show #t "apply-generic: type-tags="
			     (displayed type-tags)
			     " proc=" (written proc)
			     " proc-source=" (thingy-source proc) "\n")
		    (cond (proc (apply proc (map contents args)))
			  ((= 1 (length args))
		   #;(show #t "No proc found for op=" op ", type-tags=" type-tags ", arg=" (displayed args) "\n")
			   (apply-generic op (raise-type (car args))))
			  ((= 2 (length args))
			   (cond ((and (eq? 'polynomial (car type-tags))
				     (numeric? (cadr type-tags)))
				  (apply-generic op
						 (car args)
						 (make-polynomial (variable (contents (car args)))
								  (list (list 0 (cadr args))))))
				 ((and (numeric? (car type-tags))
			       (eq? 'polynomial (cadr type-tags)))
				  (apply-generic op
						 (make-polynomial (variable (contents (cadr args)))
								  (list (list 0 (car args))))
						 (cadr args)))
				 ((and (get-coercion (car type-tags) (cadr type-tags))
				     (not (eq? (car type-tags) (cadr type-tags))))
				  (apply-generic op
						 ((get-coercion
						   (car type-tags)
						   (cadr type-tags)) (car args))
						 (cadr args)))
				 ((and (get-coercion (cadr type-tags) (car type-tags))
				     (not (eq? (car type-tags) (cadr type-tags))))
				  (apply-generic op
						 (car args)
						 ((get-coercion
						   (cadr type-tags)
						   (car type-tags)) (cadr args) )))
				 ((comparable? (car type-tags) (cadr type-tags))
				  (if
				   (type1<=type2? (car type-tags) (cadr type-tags))
				   (apply-generic op (raise-type (car args)) (cadr args))
				   (apply-generic op (car args)  (raise-type (cadr args)))))
				 (else (error "apply-generic:Incomparable types: (type-tags,args)=" type-tags args))))
			  ((and (> (length args) 2) (not (all-argtypes-same? args)))
			   (let types-loop ((types type-tags))
			     (let ((list-of-coercion-functions
				    (coercion-if-exists? (car types) type-tags)))
			       (if list-of-coercion-functions
				   (apply apply-generic (cons op (map (lambda (fun arg) (fun arg))
								      list-of-coercion-functions
								      args)))
				   (if (not (null? (cdr types)))
				       (types-loop (cdr types))
				       (error "apply-generic:Even coercions failed. No method for these types."))))))
			  (else (error "apply-generic:No method for these types"
				       (list op type-tags)))))))
	  (show #t "Test 30: start\n")
	  (show #t "Test 30:(add (make-scheme-number 1) (make-scheme-number 1))= "
	     (add (make-scheme-number 1) (make-scheme-number 1)) "\n")
	  #;(error "Debug6")
	  (define (scheme-number->complex n)
	    (make-complex-from-real-imag (contents n) 0))
	  (put-coercion 'scheme-number
			'complex
			scheme-number->complex)

	  (show #t "Test 32: start")
	  (show #t "Test 32: Subtracting complex numbers: "
		(sub
		 (make-complex-from-real-imag 1.1 2)
		 (make-complex-from-real-imag 0 2)) "\n")



	  (put 'max3-magnitude '(complex complex complex) (lambda (z1 z2 z3)
							    (max (magnitude z1) (magnitude z2) (magnitude z3))))
	  (define (max3-magnitude x1 x2 x3) (apply-generic 'max3-magnitude x1 x2 x3))
	  (define (identity x) x)

	#;(define numeric-tower (list 'integer 'rational 'scheme-number 'complex))


	#;(define (higher-type x)
	  (show #t "higher-type:x=" (displayed x) "\n")
	    (define (find-higher-type x types)
	      (cond ((or (null? types) (null? (cdr types))) (error "No type higher than given" x types))
		    ((eq? x (car types)) (cadr types))
		    (else (find-higher-type x (cdr types)))))
	    (find-higher-type x numeric-tower))

	#;(show #t "Test: Higher than 'complex: " (higher-type 'complex) "\n")

	  #;(define (integer->rational x)
	    (make-rational x 1))

	  #;(define (rational->scheme-number x)
	    (make-scheme-number ((get 'to-real '(rational)) x)))
	  #;(put-coercion 'integer 'rational integer->rational)
	  #;(put-coercion 'rational 'scheme-number rational->scheme-number)

	(define (install-polynomial-package)
	  #;(define (contents generic-object)
	    (cdr generic-object))
	    (define (make-poly variable term-list)
	      (cons variable term-list))
	    (define (variable p) (car p))
	    (define (term-list p)
	      (cdr p))
	    (define (variable? x) (symbol? x))
	    (define (same-variable? v1 v2)
	      (and (variable? v1) (variable? v2) (eq? v1 v2)))
	    (define (=number? exp num)
	      (and (number? exp) (= exp num)))
	    (define (the-empty-termlist) '())

	    (define (rest-terms term-list) (cdr term-list))
	    (define (empty-termlist? term-list) (null? term-list))

	    (define (make-term order coeff) (list order coeff))
	    (define (order term) (car term))
	    (define (coeff term) (cadr term))
	    (define (tag p) (attach-tag 'polynomial p))
	    (put 'make 'polynomial
		 (lambda (var terms) (tag (make-poly var terms))))
	    #;(continued on next page)

	    (define (add-poly p1 p2)
	      #;(show #t "add-poly: p1=" p1 ", p2=" p2 "\n")
	      (if (same-variable? (variable p1) (variable p2))
		  (make-poly (variable p1)
			     (add-terms (term-list p1)
					(term-list p2)))
		  (let ((res (cdr (if (variable_1-order<variable_2-order (variable p1) (variable p2))
		      (add (tag p1) (tag (make-poly (variable p1) (list (make-term 0 (tag p2))))))
		      (add (tag (make-poly (variable p2) (list (make-term 0 (tag p1))))) (tag p2))))))
		    #;(show #t "add-poly:result: " (displayed res) "\n") res)))

	    (show #t "TestY2: poly of poly: "
		  (make-poly 'x (list
				 (make-term 3 (make-poly
					       'y (list (make-term 1 1) (make-term 0 1))))
				 (make-term 1 2)
				 (make-term 0 4))) "\n")

	    (define (sub-poly p1 p2)
	      (add-poly p1 (mul-poly p2 (make-poly (variable p2) (list (make-term 0 -1))))))
	    (define (add-terms L1 L2)
	      (cond ((empty-termlist? L1) L2)
		    ((empty-termlist? L2) L1)
		    (else
		     (let ((t1 (first-term L1)) (t2 (first-term L2)))
		       (cond ((> (order t1) (order t2))
			      (adjoin-term
			       t1 (add-terms (rest-terms L1) L2)))
			     ((< (order t1) (order t2))
			      (adjoin-term
			       t2 (add-terms L1 (rest-terms L2))))
			     (else
			      (adjoin-term
			       (make-term (order t1)
					  (add (coeff t1) (coeff t2)))
			       (add-terms (rest-terms L1)
					  (rest-terms L2)))))))))


	    (define (mul-poly p1 p2)
	      (if (same-variable? (variable p1) (variable p2))
		  (make-poly (variable p1)
			     (mul-terms (term-list p1)
					(term-list p2)))
		  (contents (if (variable_1-order<variable_2-order (variable p1) (variable p2))
		      (mul (tag p1)
			   (make-polynomial (variable p1)
					    (adjoin-term
					     (make-term 0
							(tag p2)) (the-empty-termlist))))
		      (mul (tag p2)
			   (make-polynomial (variable p2)
					    (adjoin-term
					     (make-term 0
							(tag p1)) (the-empty-termlist))))))
		  #;(error "Polys not in same var -- MUL-POLY"
			 (list p1 p2))))
	    (define (div-poly p1 p2)
	      (if (same-variable? (variable p1) (variable p2))
		  (let ((quotient-and-remainder (div-terms (term-list p1)
							   (term-list p2))))
		    (list (make-poly (variable p1) (car  quotient-and-remainder))
			  (make-poly (variable p1) (cadr quotient-and-remainder))))
		    (error "div-poly: Polys not in the same var" p1 p2)))
	    (define (div-terms L1 L2)
                    (show #t "div-terms: L1=" L1 ", L2=" L2 "\n")
		    (if (empty-termlist? L1)
			(list (the-empty-termlist) (the-empty-termlist))
			(let ((t1 (first-term L1))
			      (t2 (first-term L2)))
			  (if (> (order t2) (order t1))
			      (list (the-empty-termlist) L1)
			      (let ((new-c (div (coeff t1) (coeff t2)))
				    (new-o (- (order t1) (order t2))))
				(let ((rest-of-result (div-terms (term-list
								  (sub-poly
								   (make-poly 'fake-var L1)
								   (mul-poly
								    (make-poly 'fake-var (list (make-term new-o new-c)))
								    (make-poly 'fake-var L2))))
								 L2)
						      ))
				  #;(show #t "div-terms: rest-of-result: " (displayed rest-of-result) "\n")
				  (list (adjoin-term (make-term new-o new-c) (car rest-of-result)) (cadr rest-of-result))
				  ))))))
	    (define (gcd-terms a b)
            (show #t "gcd-terms: a=" a ", b=" b "\n")
	      (if (empty-termlist? b)
		  a
		  (gcd-terms b (pseudoremainder-terms a b))))
	    (define (pseudoremainder-terms P Q)
	      (let ((O1 (order (first-term P)))
		    (O2 (order (first-term Q)))
		    (c  (coeff (first-term Q))))
                 (show #t "pseudoremainder-terms: P=" P "\n")
                 (show #t "pseudoremainder-terms: Q=" Q "\n")
                 (show #t "pseudoremainder-terms: O1=" O1 "\n")
                 (show #t "pseudoremainder-terms: O2=" O2 "\n")
                 (show #t "pseudoremainder-terms: c=" c "\n")

                 (show #t "pseudoremainder-terms: the integerizing factor="
                    (make-term 0 (exp c (add 1 (sub O1 O2)))) "\n" )
                 (show #t "pseudoremainder-terms: P after multiplication="
                   (mul-term-by-all-terms
				       (make-term 0 (exp c (add 1 (sub O1 O2)))) P)  "\n" )
		 (cadr (div-terms (mul-term-by-all-terms
				       (make-term 0 (exp c (add 1 (sub O1 O2)))) P) Q))))

	    (define (gcd-poly p1 p2)
              (show #t "gcd-poly:p1=" p1 ", p2=" p2 "\n")
              (define (maprest operation term-list)
                   (if (empty-termlist? term-list)
                       '()
                       (cons (operation term-list) (maprest operation (rest-terms term-list))))
              )
	      (if (same-variable? (variable p1) (variable p2))
		  (let* ((unoptimized-termlist (gcd-terms (term-list p1) (term-list p2)))
                         (first-terms (maprest first-term unoptimized-termlist))
                        (coefficients (map coeff first-terms))
                        (coeff-gcd (apply gcd coefficients))
                        (optimized-termlist (mul-term-by-all-terms
				       (make-term 0 (div 1 coeff-gcd)) unoptimized-termlist)))
                     (show #t "gcd-poly: unoptimized-termlist=" unoptimized-termlist "\n")
                     (show #t "gcd-poly: first-terms=" first-terms "\n")
                     (show #t "gcd-poly: coefficients=" coefficients "\n")
                     (show #t "gcd-poly: coeff-gcd=" coeff-gcd "\n")
                     (make-poly (variable p1) optimized-termlist))
		  (error "div-poly: Polys not in the same var" p1 p2)))
	    (put 'gcd '(polynomial polynomial)
		 (lambda (x y) (tag (gcd-poly x y))))
	    (put 'gcd '(integer integer) gcd)

	    (define (mul-terms L1 L2)
	      (if (empty-termlist? L1)
		  (the-empty-termlist)
		  (add-terms (mul-term-by-all-terms (first-term L1) L2)
			     (mul-terms (rest-terms L1) L2))))

	    (define (mul-term-by-all-terms t1 L)
	      (if (empty-termlist? L)
		  (the-empty-termlist)
		  (let ((t2 (first-term L)))
		    (adjoin-term
		     (make-term (+ (order t1) (order t2))
				(mul (coeff t1) (coeff t2)))
		     (mul-term-by-all-terms t1 (rest-terms L))))))
	    (define (zero-poly? poly)
	      (show #t "zero-poly?: poly=" (displayed poly) "\n")
	      (cond ((empty-termlist? (term-list poly)) #t)
		    ((not (zero? (coeff (first-term (term-list poly))))) #f)
		    (else (zero-poly?
			   (make-poly (variable poly)
				      (rest-terms (term-list poly)))))))

	    (define (termlist-type-of term-list)
	      #;(show #t "t-t-o: term-list=" (displayed term-list) "\n")
	      (cond ((null? term-list) 'sparse)
		    ((pair? (car term-list)) 'sparse)
		    ((list? term-list) 'dense)
		    (else (error "Unknown type of list" term-list))))
	    (define (adjoin-term term term-list)
	      ((get 'adjoin-term (termlist-type-of term-list)) term term-list))
	    (define (first-term term-list)
	      ((get 'first-term (termlist-type-of term-list)) term-list))
	    (define (variable_1-order<variable_2-order variable_1 variable_2)
	      #;(show #t "var_1-..: variable_1=" variable_1 " variable_2=" variable_2 "\n")
	      #;(show #t "var12string=" (symbol->string variable_1) "var22string=" (symbol->string variable_2) "\n")
	      (string<=? (symbol->string variable_1) (symbol->string variable_2)))
	    (define (normalize-fully poly)
	      (if (normal-polynomial? poly)
		  poly
		  (normalize-fully (normalize-once poly))))
	    (put 'add '(polynomial polynomial)
		 (lambda (p1 p2)
		   #;(show #t "generic-add-poly:Polynomial dispatch found: p1="
			  (displayed p1) " p2=" (displayed p2) "\n")
		   (normalize-fully (tag (add-poly p1 p2)))))
	    (put 'mul '(polynomial polynomial)
		 (lambda (p1 p2) (normalize-fully (tag (mul-poly p1 p2)))))
	    (put 'sub '(polynomial polynomial)
		 (lambda (p1 p2) (tag (sub-poly p1 p2))))

	    (put 'zero? '(polynomial) zero-poly?)
	    (put 'div '(polynomial polynomial) div-poly)
	    #;(put-coercion 'rational 'scheme-number rational->scheme-number)
	    (define (monomial-flip-variables monomial)
	      #;(show #t "m-f-v: monomial=" monomial "\n")
	      (let* ((mono (contents monomial))
		     (inner-polynomial (contents (coeff (first-term (term-list mono)))))
		     (inner-poly (contents inner-polynomial))
		     (outer-order (order (first-term (term-list mono))))
		     (outer-var (variable mono))
		     (inner-var (variable inner-polynomial))
		     (inner-term-list (term-list inner-poly)))
		#;(show #t "m-f-v: inner-poly=" inner-poly "\n")
		(if (same-variable? inner-var outer-var)
		    (mul
		     (make-polynomial outer-var (adjoin-term (make-term outer-order 1) (the-empty-termlist)))
		     (tag inner-polynomial))
		    (tag (make-poly inner-var
				    (mul-term-by-all-terms (make-term
							    0
							    (make-polynomial
							     outer-var
							     (list (make-term
								    outer-order
								    1)))) inner-poly))))))
	    #;(show #t "TestXX: sorting variables: Is 'x < 'y?: "
		  (variable_1-order<variable_2-order 'x 'y) "\n")
	    #;(show #t "TestXX: sorting variables: Is 'z < 'y?: "
		  (variable_1-order<variable_2-order 'z 'y) "\n")
	    #;(show #t "TestXX: (adding two basic poly): "
		  (add (make-polynomial 'x (list (make-term 1 2) (make-term 0 4)))
		       (make-polynomial 'y (list (make-term 2 3) (make-term 0 5)))) "\n")

	    (define (polynomial->sum-of-first-and-rest poly)
	      #;(show #t "p->s-o-f-a-r: " (displayed poly) "\n")
	      (if (zero? poly)
		  poly
		  (let* ((poly1 (contents poly))
			 (first-monomial (tag
					  (make-poly
					   (variable poly1)
					   (list (first-term (term-list poly1)))))))
		    #;(show #t "p->s-o-f-a-r: " (displayed first-monomial) "\n")
		    (add
		      first-monomial
		      (polynomial->sum-of-first-and-rest
		       (tag (make-poly (variable poly1) (rest-terms (term-list poly1)))))))))

	    (show #t "Test13: Expanding a polynomial as monomials: "
		  (displayed
		   (polynomial->sum-of-first-and-rest
		    (make-polynomial 'y
				     (list (make-term 2 (make-polynomial
							 'x
							 (list (make-term 2 1) (make-term 0 1))))
					   (make-term 0 2))))) "\n")

	    (show #t "\nTest20: start monomial: "
		  (displayed (make-polynomial 'x
					      (list
					       (make-term
						2
						(make-polynomial
						 'y
						 (list
						  (make-term 2 1) (make-term 0 1))))))) "\n")
	    (show #t "Test20: Flipping a monomial variable: "
		  (displayed
		   (monomial-flip-variables
		    (make-polynomial 'x
				     (list (make-term 1 (make-polynomial
							 'y
							 (list
							  (make-term 2 1)
							  (make-term 0 1)))))))) "\n\n")


	    (define (normal-polynomial? poly)
	      #;(show #t "n-p?: poly=" poly "\n")
	      (cond ((not (polynomial? poly)) #t)
		    ((null? (term-list (contents poly))) #t)
		    (else (let* ((poly1 (contents poly))
				 (outer-var (variable poly1)))
			    #;(show #t "Inner-let: outer-var=" (displayed outer-var) "\n")
			    (let loop ((terms (term-list poly1)))
			      #;(show #t "n-p?-loop: terms=" (displayed terms) "\n")
			      (cond ((null? terms) #t)
				    ((not (polynomial? (coeff (first-term terms)))) (loop (rest-terms terms)))
				    ((not (variable_1-order<variable_2-order
					 outer-var
					 (variable (contents (coeff (first-term terms)))))) (begin #;(show #t "wrong variable order \n") #f))
				    ((not (normal-polynomial? (coeff (first-term terms)))) (begin #;(show #t "not normal poly\n") #f))
				    (else (loop (rest-terms terms)))))
			    ))))
	    (define (normalize-once poly)
	      #;(show #t "normalize-once poly= " (displayed poly) "\n")
	      (if (zero? poly)
		  poly
		  (let* ((poly1 (contents poly))
			 (first-monomial (tag
					  (make-poly
					   (variable poly1)
					   (list (make-term
						  (order (first-term (term-list poly1)))
						  (if (polynomial? (coeff (first-term (term-list poly1))))
						      (normalize-once (coeff (first-term (term-list poly1))))
						      (coeff (first-term (term-list poly1))))))))))
		    #;(show #t "p->s-o-f-a-r: " (displayed first-monomial) "\n")
		    (add
		     (if (and (polynomial?
			     (coeff
			      (first-term
			       (term-list
				(contents first-monomial)))))
			    (variable_1-order<variable_2-order
			     (variable
			      (contents
			       (coeff
				(first-term
				 (term-list
				  (contents first-monomial))))))
			     (variable
			      (contents first-monomial))))
			 (monomial-flip-variables first-monomial)
			 first-monomial)
		      (polynomial->sum-of-first-and-rest
		       (tag (make-poly (variable poly1) (rest-terms (term-list poly1)))))))))

	    (show #t "Test21: normal-polynomial?:start: " (displayed (make-polynomial 'y
						   (list (make-term 2 (make-polynomial
								       'x
							 (list (make-term 2 1) (make-term 0 1))))
							 (make-term 0 2)))) "\n")
	    #;(show #t "Test21: normal-polynomial?:result:" (normal-polynomial? (make-polynomial 'y
						   (list (make-term 2 (make-polynomial
								       'x
							 (list (make-term 2 1) (make-term 0 1))))
							 (make-term 0 2)))) "\n")
	    #;(show #t "Test22: normal-polynomial?-good:start: "
		  (displayed
		   (make-polynomial 'x
				    (list (make-term 2 (make-polynomial
							'y
							(list (make-term 2 1) (make-term 0 1))))
					  (make-term 0 2)))) "\n")
	    #;(show #t "Test22: normal-polynomial?-good:result:"
		  (normal-polynomial?
		   (make-polynomial 'x
				    (list (make-term 2 (make-polynomial
							'y
							(list (make-term 2 1) (make-term 0 1))))
					  (make-term 0 2)))) "\n")

	    #;(show #t "Test23:input: normalizing a bad polynomial: "
		  (make-polynomial 'y
				     (list (make-term 2 (make-polynomial
							 'x
							 (list (make-term 2 1) (make-term 0 1))))
					   (make-term 0 2))) "\n")
	    #;(show #t "Test23:result: normalizing a bad polynomial: "
		  (normalize-once (make-polynomial 'y
						   (list (make-term 2 (make-polynomial
								       'x
							 (list (make-term 2 1) (make-term 0 1))))
							 (make-term 0 2)))) "\n")
	    #;(show #t "Test24:input: normalizing a bad polynomial: "
		  (make-polynomial 'x
				     (list (make-term 2 (make-polynomial
							 'x
							 (list (make-term 2 1) (make-term 0 1))))
					   (make-term 0 2))) "\n")
	    #;(show #t "Test24:result: normalizing a bad polynomial: "
		  (normalize-once (make-polynomial 'x
						   (list (make-term 2 (make-polynomial
								       'x
							 (list (make-term 2 1) (make-term 0 1))))
							 (make-term 0 2)))) "\n")


	    #;(show #t "Test24:input: normalize-fully a bad polynomial: "
		  (make-polynomial 'y
				     (list (make-term 2 (make-polynomial
							 'x
							 (list (make-term 2 1) (make-term 0 1))))
					   (make-term 0 2))) "\n")
	    #;(show #t "Test24:result: normalize-fully a bad polynomial: "
		  (normalize-fully (make-polynomial 'y
						   (list (make-term 2 (make-polynomial
								       'x
							 (list (make-term 2 1) (make-term 0 1))))
							 (make-term 0 2)))) "\n")



	    'done)


	  (define (install-polynomial-sparse-package)
	    (define (coeff term) (cadr term))
	    (define (first-term-sparse term-list) (car term-list))
	    (define (adjoin-term-sparse term term-list)
	      (if (zero? (coeff term))
		  term-list
		  (cons term term-list)))
	    (put 'adjoin-term 'sparse adjoin-term-sparse)
	    (put 'first-term 'sparse first-term-sparse)
	    'done)
	  (install-polynomial-sparse-package)

	  (define (install-polynomial-dense-package)
	    (define (make-term order coeff) (list order coeff))
	    (define (order term) (car term))
	    (define (coeff term) (cadr term))

	    (define (adjoin-term-dense term term-list)
		(if (zero? (coeff term))
		    term-list
		    (if (> (order term) (length term-list))
			(append (list (coeff term))
				(make-list (- (order term) (length term-list)) 0)
				term-list)
			(error "adjoin-term:Appending a smaller order term. Recheck."))))
	    (define (first-term-dense term-list)
	       #;(show #t "first-term-dense: " (displayed (make-term (car term-list) (length (cdr term-list)))) "\n")
	       (make-term (length (cdr term-list)) (car term-list) ))
	    (put 'adjoin-term 'dense adjoin-term-dense)
	    (put 'first-term 'dense first-term-dense)
	    'done)
	  #;(install-polynomial-dense-package)

	  (define (make-polynomial var terms)
	    ((get 'make 'polynomial) var terms))

	(install-polynomial-package)


	  (show #t "Test 2: Making polynomials: "
		(make-polynomial 'x (list (list 5 1) (list 4 2))) "\n")
	  (show #t "Test 3: Zero?: "
		(zero? (make-polynomial 'x (list (list 5 1) (list 4 2)))) "\n")
	  (show #t "Test 4: Adding polynomials: "
		(add (make-polynomial 'x '((5 1) (4 2) (0 1)))
		     (make-polynomial 'x '((5 1)))) "\n")
	  (show #t "Test 4: Zero?: " (zero? (make-polynomial 'x '((5 0) (3 1)))) "\n")

	  (show #t "Test 5: Subtracting polynomials: "
		(sub (make-polynomial 'x '((5 1) (4 2) (0 1)))
		     (make-polynomial 'x '((0 1)))) "\n")

	  #;(show #t "Test 6: Making a dense polynomial: " (make-polynomial 'x '(1 2 3 4 5)) "\n")
	  #;(show #t "Test 7: zero? dense polynomial: " (displayed (zero? (make-polynomial 'x '(0)))) "\n")
	  #;(show #t "Test 8: zero? dense polynomial: " (displayed (zero? (make-polynomial 'x '(1)))) "\n")
	  #;(show #t "Test 9: Adding dense polynomials: "
		(add (make-polynomial 'x '(1 2 0 0 0 1))
		     (make-polynomial 'x '(1 0 0 0 0 0))) "\n")
	  #;(show #t "Test10: Subtracting dense polynomials: "
		(sub (make-polynomial 'x '(1 2 0 0 0 1))
		     (make-polynomial 'x '(1 0 0 0 0 0))) "\n")
	  #;(show #t "Test11: Subtracting dense and sparse polynomials: "
		(sub (make-polynomial 'x '(1 2 0 0 0 1))
		     (make-polynomial 'x '((4 2)))) "\n")
	  (show #t "Test12: Dividing x^2 + 2x + 1 by x+1: "
		(pretty
		 (div (make-polynomial 'x '((2 1) (1 2) (0 1)))
		      (make-polynomial 'x '(      (1 1) (0 1)))) ) "\n")
	  (show #t "Test14: Adding polynomials of two variables: "
		(pretty
		 (add (make-polynomial 'x '((1 1)))
		      (make-polynomial 'y '((1 1))))))
	  (show #t "Test14: Adding polynomials of two variables,\n when one of them is nonexistant: \n"
		(pretty
		 (add (make-polynomial 'x '((1 1)))
		      (make-polynomial 'y '((0 1))))))
	  (show #t "Test25: multiplying different variables: "
	      (pretty (mul (make-polynomial 'x '((1 1)))
			      (make-polynomial 'y '((1 1))))) "\n")
      (begin
      (define p1 (make-polynomial 'x '((2 1) (0 1))))
      (define p2 (make-polynomial 'x '((3 1) (0 1))))
      (define rf (make-rational p2 p1))
      (show #t "Test 26: make-rational-polynomial: " rf "\n")
      (show #t "Test 27: add-rational\n")
      (show #t "Test 27: " (add rf rf) "\n")
      )

      (show #t "Test 28: polynomial-gcd: start\n")
      (define (greatest-common-divisor p1 p2) (apply-generic 'gcd p1 p2))
      (begin
	(define p1 (make-polynomial
		     'x '((4 1) (3 -1) (2 -2) (1 2))))
	(define p2 (make-polynomial 'x '((3 1) (1 -1))))

	(show #t "Test 28: polynomial-gcd: " (greatest-common-divisor p1 p2) "\n"))

      (begin
	  (define p1 (make-polynomial
		       'x '((2 1) (1 -2) (0 1))))
	  (define p2 (make-polynomial 'x '((2 11) (0 7))))

	  (define p3 (make-polynomial 'x '((1 13) (0 5))))
	  (define q1 (mul p1 p2))
	  (define q2 (mul p1 p3))
	  (show #t "Test 29: gcd-integer-problem: start\n")
          (show #t "Test 29: p1=" p1 "\n")
          (show #t "Test 29: p2=" p2 "\n")
          (show #t "Test 29: p3=" p3 "\n")
          (show #t "Test 29: q1=" q1 "\n")
          (show #t "Test 29: q2=" q2 "\n")
	  (show #t "Test 29: gcd : " (greatest-common-divisor q1 q2) "\n")
	)

#+end_src

#+RESULTS[9cf0e4fd4ba150889fdb5f8e0ac298018492d6b5]:
#+begin_src scheme
(tag 5)=5
Test 31: start
Test 31:#t
Test: Higher than 'integer: scheme-number
Test 30: start
Test 30:(add (make-scheme-number 1) (make-scheme-number 1))= 2
Test 32: startTest 32: Subtracting complex numbers: 1.1
TestY2: poly of poly: (x (3 (y (1 1) (0 1))) (1 2) (0 4))
zero-poly?: poly=(y (2 (polynomial x (2 1) (0 1))) (0 2))
zero-poly?: poly=(x (2 1) (0 1))
zero-poly?: poly=(y (0 2))
zero-poly?: poly=(y)
zero-poly?: poly=(x (2 1) (0 1))
zero-poly?: poly=(y (2 (polynomial x (2 1) (0 1))) (0 2))
zero-poly?: poly=(x (2 1) (0 1))
zero-poly?: poly=(x (2 1) (0 1))
zero-poly?: poly=(x (0 1))
zero-poly?: poly=(x)
zero-poly?: poly=(y (0 2))
zero-poly?: poly=(y)
zero-poly?: poly=(y (2 1))
zero-poly?: poly=(y (2 1))
zero-poly?: poly=(y (2 1) (0 2))
zero-poly?: poly=(y (2 1))
Test13: Expanding a polynomial as monomials: (polynomial x (2 (polynomial y (2 1))) (0 (polynomial y (2 1) (0 2))))

Test20: start monomial: (polynomial x (2 (polynomial y (2 1) (0 1))))
zero-poly?: poly=(x (1 1))
zero-poly?: poly=(x (1 1))
Test20: Flipping a monomial variable: (polynomial y (2 (polynomial x (1 1))) (0 (polynomial x (1 1))))

Test21: normal-polynomial?:start: (polynomial y (2 (polynomial x (2 1) (0 1))) (0 2))
Test 2: Making polynomials: (polynomial x (5 1) (4 2))
zero-poly?: poly=(x (5 1) (4 2))
Test 3: Zero?: #f
Test 4: Adding polynomials: (polynomial x (5 2) (4 2) (0 1))
zero-poly?: poly=(x (5 0) (3 1))
zero-poly?: poly=(x (3 1))
Test 4: Zero?: #f
Test 5: Subtracting polynomials: (polynomial x (5 1) (4 2))
div-terms: L1=((2 1) (1 2) (0 1)), L2=((1 1) (0 1))
div-terms: L1=((1 1) (0 1)), L2=((1 1) (0 1))
div-terms: L1=(), L2=((1 1) (0 1))
Test12: Dividing x^2 + 2x + 1 by x+1: ((x (1 1) (0 1)) (x))

Test14: Adding polynomials of two variables: (polynomial x
                                                         (1 1)
                                                         (0
                                                          (polynomial y (1 1))))
Test14: Adding polynomials of two variables,
 when one of them is nonexistant: 
(polynomial x (1 1) (0 (polynomial y (0 1))))
zero-poly?: poly=(y (1 1))
zero-poly?: poly=(y (1 1))
Test25: multiplying different variables: (polynomial x
                                                     (1 (polynomial y (1 1))))

Test 26: make-rational-polynomial: (rational (polynomial x (3 1) (0 1)) polynomial x (2 1) (0 1))
Test 27: add-rational
rational not droppable: #f
Test 27: (rational (polynomial x (5 2) (3 2) (2 2) (0 2)) polynomial x (4 1) (2 2) (0 1))
Test 28: polynomial-gcd: start
gcd-poly:p1=(x (4 1) (3 -1) (2 -2) (1 2)), p2=(x (3 1) (1 -1))
gcd-terms: a=((4 1) (3 -1) (2 -2) (1 2)), b=((3 1) (1 -1))
pseudoremainder-terms: P=((4 1) (3 -1) (2 -2) (1 2))
pseudoremainder-terms: Q=((3 1) (1 -1))
pseudoremainder-terms: O1=4
pseudoremainder-terms: O2=3
pseudoremainder-terms: c=1
pseudoremainder-terms: the integerizing factor=(0 1)
pseudoremainder-terms: P after multiplication=((4 1) (3 -1) (2 -2) (1 2))
div-terms: L1=((4 1) (3 -1) (2 -2) (1 2)), L2=((3 1) (1 -1))
div-terms: L1=((3 -1) (2 -1) (1 2)), L2=((3 1) (1 -1))
div-terms: L1=((2 -1) (1 1)), L2=((3 1) (1 -1))
gcd-terms: a=((3 1) (1 -1)), b=((2 -1) (1 1))
pseudoremainder-terms: P=((3 1) (1 -1))
pseudoremainder-terms: Q=((2 -1) (1 1))
pseudoremainder-terms: O1=3
pseudoremainder-terms: O2=2
pseudoremainder-terms: c=-1
pseudoremainder-terms: the integerizing factor=(0 1)
pseudoremainder-terms: P after multiplication=((3 1) (1 -1))
div-terms: L1=((3 1) (1 -1)), L2=((2 -1) (1 1))
div-terms: L1=((2 1) (1 -1)), L2=((2 -1) (1 1))
div-terms: L1=(), L2=((2 -1) (1 1))
gcd-terms: a=((2 -1) (1 1)), b=()
gcd-poly: unoptimized-termlist=((2 -1) (1 1))
gcd-poly: first-terms=((2 -1) (1 1))
gcd-poly: coefficients=(-1 1)
gcd-poly: coeff-gcd=1
Test 28: polynomial-gcd: (polynomial x (2 -1) (1 1))
Test 29: gcd-integer-problem: start
Test 29: p1=(polynomial x (2 1) (1 -2) (0 1))
Test 29: p2=(polynomial x (2 11) (0 7))
Test 29: p3=(polynomial x (1 13) (0 5))
Test 29: q1=(polynomial x (4 11) (3 -22) (2 18) (1 -14) (0 7))
Test 29: q2=(polynomial x (3 13) (2 -21) (1 3) (0 5))
gcd-poly:p1=(x (4 11) (3 -22) (2 18) (1 -14) (0 7)), p2=(x (3 13) (2 -21) (1 3) (0 5))
gcd-terms: a=((4 11) (3 -22) (2 18) (1 -14) (0 7)), b=((3 13) (2 -21) (1 3) (0 5))
pseudoremainder-terms: P=((4 11) (3 -22) (2 18) (1 -14) (0 7))
pseudoremainder-terms: Q=((3 13) (2 -21) (1 3) (0 5))
pseudoremainder-terms: O1=4
pseudoremainder-terms: O2=3
pseudoremainder-terms: c=13
pseudoremainder-terms: the integerizing factor=(0 169)
pseudoremainder-terms: P after multiplication=((4 1859) (3 -3718) (2 3042) (1 -2366) (0 1183))
div-terms: L1=((4 1859) (3 -3718) (2 3042) (1 -2366) (0 1183)), L2=((3 13) (2 -21) (1 3) (0 5))
div-terms: L1=((3 -715) (2 2613) (1 -3081) (0 1183)), L2=((3 13) (2 -21) (1 3) (0 5))
div-terms: L1=((2 1458) (1 -2916) (0 1458)), L2=((3 13) (2 -21) (1 3) (0 5))
gcd-terms: a=((3 13) (2 -21) (1 3) (0 5)), b=((2 1458) (1 -2916) (0 1458))
pseudoremainder-terms: P=((3 13) (2 -21) (1 3) (0 5))
pseudoremainder-terms: Q=((2 1458) (1 -2916) (0 1458))
pseudoremainder-terms: O1=3
pseudoremainder-terms: O2=2
pseudoremainder-terms: c=1458
pseudoremainder-terms: the integerizing factor=(0 2125764)
pseudoremainder-terms: P after multiplication=((3 27634932) (2 -44641044) (1 6377292) (0 10628820))
div-terms: L1=((3 27634932) (2 -44641044) (1 6377292) (0 10628820)), L2=((2 1458) (1 -2916) (0 1458))
div-terms: L1=((2 10628820) (1 -21257640) (0 10628820)), L2=((2 1458) (1 -2916) (0 1458))
div-terms: L1=(), L2=((2 1458) (1 -2916) (0 1458))
gcd-terms: a=((2 1458) (1 -2916) (0 1458)), b=()
gcd-poly: unoptimized-termlist=((2 1458) (1 -2916) (0 1458))
gcd-poly: first-terms=((2 1458) (1 -2916) (0 1458))
gcd-poly: coefficients=(1458 -2916 1458)
gcd-poly: coeff-gcd=1458
Test 29: gcd : (polynomial x (2 0.9999999999999999) (1 -1.9999999999999998) (0 0.9999999999999999))
#+end_src

We unfortunately, there is an error with exact-inexact numbers somewhere
here. I am too tired to fix it, but this should be doable. Let me say, I'd
also leave it as an exercise to the reader.

*** DONE Exercise 2.97 Reduction of polynomials
    CLOSED: [2019-10-29 Tue 00:12]

Here is the solution of the exercise. I have to copy the code again, because
implementing term reduction requires extending the polynomial package.


#+begin_src scheme :exports both :results output scalar code
  (define (project obj)
    (apply-generic 'project obj))
  (define (droppable? obj)
    #;(show #t "droppable?: obj=" obj ", type-tag=" (type-tag obj) "\n")
    (cond ((eq? (type-tag obj) 'rational) (begin (show #t "rational not droppable: #f\n") #f))
	  ((not (memq (type-tag obj) numeric-tower)) #f)
	  ((eq? (type-tag obj) (car numeric-tower)) #f)
	  ((equ? obj (raise-type (project obj))) #t)
	  (else #f)))
  (define (drop obj)
    (if (droppable? obj)
	(drop (project obj))
	obj))
  (define (thingy-source thingy)
    (cond ((lambda? thingy) (list "lambda" (lambda-source thingy)))
	  ((procedure? thingy) (list "procedure" (procedure-name thingy)))
	  ((pair? thingy) (list "pair" (pair-source thingy)))
	  (else "No source? refactor")))

  (define (accumulate op initial sequence)
    (if (null? sequence)
	initial
	(accumulate op (op initial (car sequence)) (cdr sequence))))
  (define false #f)
  (define true  #t)
  (define (make-table)
    (let ((local-table (list '*table*)))
      (define (lookup key-1 key-2)
	(let ((subtable (assoc key-1 (cdr local-table))))
	  (if subtable
	      (let ((record (assoc key-2 (cdr subtable))))
		(if record
		    (cdr record)
		    false))
	      false)))
      (define (insert! key-1 key-2 value)
	(let ((subtable (assoc key-1 (cdr local-table))))
	  (if subtable
	      (let ((record (assoc key-2 (cdr subtable))))
		(if record
		    (set-cdr! record value)
		    (set-cdr! subtable
			      (cons (cons key-2 value)
				    (cdr subtable)))))
	      (set-cdr! local-table
			(cons (list key-1
				    (cons key-2 value))
			      (cdr local-table)))))
	'ok)
      (define (dispatch m)
	(cond ((eq? m 'lookup-proc) lookup)
	      ((eq? m 'insert-proc!) insert!)
	      (else (error "Unknown operation -- TABLE" m))))
      dispatch))

  (define operation-table (make-table))
  (define get (operation-table 'lookup-proc))
  (define put (operation-table 'insert-proc!))

  (define coercion-table (make-table))
  (define get-coercion (coercion-table 'lookup-proc))
  (define put-coercion (coercion-table 'insert-proc!))

  (define (attach-tag type-tag contents)
    (cons type-tag contents))

  (define (type-tag datum)
    (cond ((pair? datum) (car datum))
	  ((exact-integer? datum) 'integer)
	  ((real? datum) 'scheme-number)
	  (error "Bad tagged datum -- TYPE-TAG" datum)))

  (define (contents datum)
    (cond ((pair? datum) (cdr datum))
	  ((integer? datum) datum)
	  ((real? datum) datum)
	  (else (error "Bad tagged datum -- CONTENTS" datum))))

  (define (integer? x)
    (eq? (type-tag x) 'integer))
  (define (rectangular? z)
    (eq? (type-tag z) 'rectangular))

  (define (polar? z)
    (eq? (type-tag z) 'polar))


  (define (real-part z) (apply-generic 'real-part z))
  (define (imag-part z) (apply-generic 'imag-part z))
  (define (magnitude z) (apply-generic 'magnitude z))
  (define (angle z) (apply-generic 'angle z))

  (define (add x y)
    #;(show #t "debug:add: x=" x ", y=" y ", starting apply-generic\n")
    #;(show #t "debug:add: (type-tags x,y)=(" (type-tag x) "," (type-tag y) ")" "\n")
    #;(show #t "debug:add:can we access apply-generic?" (written apply-generic)
    "\n" )
    #;(error "Debug1")
    (apply-generic 'add x y))
  (define (sub x y) (apply-generic 'sub x y))
  (define (mul x y) (apply-generic 'mul x y))
  (define (div x y) (apply-generic 'div x y))

  (define (equ? x y)
    (apply-generic 'equ? x y))
  (define (zero? x) (apply-generic 'zero? x))

  (define (exp x y) (apply-generic 'exp x y))

  (define (install-scheme-number-package)
    (define (tag x)
      #;(attach-tag 'scheme-number x) x)
    (show #t "(tag 5)=" (tag 5) "\n")
    (put 'add '(scheme-number scheme-number)
	 (lambda (x y) #;(show #t "debug:found plus dispatch\n") (tag (+ x y))))
    (put 'sub '(scheme-number scheme-number)
	 (lambda (x y) (tag (- x y))))
    (put 'mul '(scheme-number scheme-number)
	 (lambda (x y) (tag (* x y))))
    (put 'div '(scheme-number scheme-number)
	 (lambda (x y) (tag (/ x y))))
    (put 'make 'scheme-number
	 (lambda (x) #;(show #t "debug:found 'make 'scheme-number\n") (tag x)))
    (put 'equ? '(scheme-number scheme-number)
	 (lambda (x y) (= x y)))
    (put 'zero? '(scheme-number)
	 (lambda (x) (= 0 x)))
    (put 'exp '(scheme-number scheme-number)
	 (lambda (x y) (tag (expt x y))))
    (put 'project '(scheme-number)
	 (lambda (x)
	   (if (finite? x)
	       (exact (truncate x))
	       0)))
    (put 'sine '(scheme-number) sin)
    (put 'cosine '(scheme-number) cos)
    (put 'square-root '(scheme-number) sqrt)
    (put 'arctangent '(schemer-number) atan)
    'done)
  (install-scheme-number-package)
  (define (integer->scheme-number x)
    (make-scheme-number (inexact (contents x))))
  (put-coercion 'integer 'scheme-number integer->scheme-number)

  (define (sine x) (apply-generic 'sine x))
  (define (cosine x) (apply-generic 'cosine x))
  (define (square-root x) (apply-generic 'square-root x))
  (define (arctangent x) (apply-generic 'arctangent x))

  (define (make-scheme-number n)
    #;(show #t "debug:make-scheme-number: n=" n "\n")
    ((get 'make 'scheme-number) n))
  (show #t "Test 31: start\n")
  (show #t "Test 31:" (equal? (make-scheme-number 1) 1) "\n")

  (define (reduce a b) (apply-generic 'reduce a b))
  (define (install-rational-package)
    (define (numer x) (car x))
    (define (denom x) (cdr x))
    (define (make-rat n d)
      (show #t "make-rat: n=" n ", d="d "\n")
      #;(let ((g (gcd n d)))
      (cons (/ n g) (/ d g)))
      (let ((new-list (reduce n d)))
	(cons (car new-list) (cadr new-list))))
    (define (add-rat x y)
      (make-rat (add (mul (numer x) (denom y))
		     (mul (numer y) (denom x)))
		(mul (denom x) (denom y))))
    (define (sub-rat x y)
      (make-rat (sub (mul (numer x) (denom y))
		     (mul (numer y) (denom x)))
		(mul (denom x) (denom y))))
    (define (mul-rat x y)
      (make-rat (mul (numer x) (numer y))
		(mul (denom x) (denom y))))
    (define (div-rat x y)
      (make-rat (mul (numer x) (denom y))
		(mul (denom x) (numer y))))

    (define (tag x) (attach-tag 'rational x))
    (put 'add '(rational rational)
	 (lambda (x y) (tag (add-rat x y))))
    (put 'sub '(rational rational)
	 (lambda (x y) (tag (sub-rat x y))))
    (put 'mul '(rational rational)
	 (lambda (x y) (tag (mul-rat x y))))
    (put 'div '(rational rational)
	 (lambda (x y) (tag (div-rat x y))))

    (put 'make 'rational
	 (lambda (n d) (tag (make-rat n d))))
    (put 'equ? '(rational rational)
	 (lambda (x y) (zero? (numer (sub-rat x y)))))
    (put 'zero? '(rational) (lambda (x) (zero? (numer x))))
    #;(put 'project '(rational) (lambda (x)
    (exact (truncate (/ (numer x) (denom x))))))
    #;(put 'to-real '(rational) (lambda (x) (/ (numer (contents x)) (denom (contents x)))))
    'done)

  (define (make-rational n d)
    ((get 'make 'rational) n d))

  (define (install-rectangular-package)

    (define (real-part z) (car z))
    (define (imag-part z) (cdr z))
    (define (make-from-real-imag x y) (cons x y))
    (define (magnitude z)
      (square-root (add (square (real-part z))
			(square (imag-part z)))))
    (define (angle z)
      (arctangent (imag-part z) (real-part z)))
    (define (make-from-mag-ang r a)
      (cons (mul r (cosine a)) (mul r (sine a))))

    (define (tag x) (attach-tag 'rectangular x))
    (put 'real-part '(rectangular) real-part)
    (put 'imag-part '(rectangular) imag-part)
    (put 'magnitude '(rectangular) magnitude)
    (put 'angle '(rectangular) angle)
    (put 'make-from-real-imag 'rectangular
	 (lambda (x y) (tag (make-from-real-imag x y))))
    (put 'make-from-mag-ang 'rectangular
	 (lambda (r a) (tag (make-from-mag-ang r a))))
    'done)

  (define (install-polar-package)

    (define (magnitude z) (car z))
    (define (angle z) (cdr z))
    (define (make-from-mag-ang r a) (cons r a))
    (define (real-part z)
      (mul (magnitude z) (cosine (angle z))))
    (define (imag-part z)
      (mul (magnitude z) (sine (angle z))))
    (define (make-from-real-imag x y)
      (cons (square-root (add (square x) (square y)))
	    (arctangent y x)))

    (define (tag x) (attach-tag 'polar x))
    (put 'real-part '(polar) real-part)
    (put 'imag-part '(polar) imag-part)
    (put 'magnitude '(polar) magnitude)
    (put 'angle '(polar) angle)
    (put 'make-from-real-imag 'polar
	 (lambda (x y) (tag (make-from-real-imag x y))))
    (put 'make-from-mag-ang 'polar
	 (lambda (r a) (tag (make-from-mag-ang r a))))
    'done)

  (define (install-complex-package)
    (define (make-from-real-imag x y)
      ((get 'make-from-real-imag 'rectangular) x y))
    (define (make-from-mag-ang r a)
      ((get 'make-from-mag-ang 'polar) r a))
    (define (add-complex z1 z2)
      (make-from-real-imag (add (real-part z1) (real-part z2))
			   (add (imag-part z1) (imag-part z2))))
    (define (sub-complex z1 z2)
      (make-from-real-imag (sub (real-part z1) (real-part z2))
			   (sub (imag-part z1) (imag-part z2))))
    (define (mul-complex z1 z2)
      (make-from-mag-ang (mul (magnitude z1) (magnitude z2))
			 (add (angle z1) (angle z2))))
    (define (div-complex z1 z2)
      (make-from-mag-ang (div (magnitude z1) (magnitude z2))
			 (sub (angle z1) (angle z2))))
    (define (tag z) (attach-tag 'complex z))
    (put 'add '(complex complex)
	 (lambda (z1 z2) (tag (add-complex z1 z2))))
    (put 'sub '(complex complex)
	 (lambda (z1 z2) (tag (sub-complex z1 z2))))
    (put 'mul '(complex complex)
	 (lambda (z1 z2) (tag (mul-complex z1 z2))))
    (put 'div '(complex complex)
	 (lambda (z1 z2) (tag (div-complex z1 z2))))
    (put 'make-from-real-imag 'complex
	 (lambda (x y) (tag (make-from-real-imag x y))))
    (put 'make-from-mag-ang 'complex
	 (lambda (r a) (tag (make-from-mag-ang r a))))
    (put 'equ? '(complex complex)
	 (lambda (x y) (and (= 0 (real-part (sub-complex x y)))
			    (= 0 (imag-part (sub-complex x y))))))
    (put 'equ? '(rectangular polar) equ?)
    (put 'equ? '(polar rectangular) equ?)
    (put 'zero? '(complex)
	 (lambda (x) (equ? (tag x) (tag (make-from-real-imag 0 0)))))
    (put 'project '(complex) (lambda (z) (real-part z)))
    'done)

  (define (make-complex-from-real-imag x y)
    ((get 'make-from-real-imag 'complex) x y))

  (define (make-complex-from-mag-ang r a)
    ((get 'make-from-mag-ang 'complex) r a))

  (install-rectangular-package)
  (install-polar-package)
  (install-rational-package)

  (install-complex-package)

  (put 'real-part '(complex) real-part)
  (put 'imag-part '(complex) imag-part)
  (put 'magnitude '(complex) magnitude)
  (put 'angle '(complex) angle)
  (define (polynomial? x)
    (eq? (type-tag x) 'polynomial))
  (define numeric-tower (list 'integer 'scheme-number 'complex))
  (define (numeric? x)
    (memq x numeric-tower))
  (define (type1<=type2? type1 type2)
    (if (not (memq type1 numeric-tower))
	(error "Type 1 not in the numeric tower"))
    (if (not (memq type2 numeric-tower))
	(error "Type 2 not in the numeric tower"))
    (let loop ((types numeric-tower))
      (cond ((null? types) (error "Type 1 and type 2 are incomparable" type1 type2))
	    ((eq? (car types) type1) #t)
	    ((eq? (car types) type2) #f)
	    (else (loop (cdr types))))))
  (define (comparable? type1 type2)
    (and (memq type1 numeric-tower)
	 (memq type2 numeric-tower)))
  (define (raise-type x)
    #;(show #t "Raising type of: " (displayed x) "\n")
    (let ((converter (get-coercion (type-tag x) (higher-type (type-tag x)))))
      (if converter
	  (converter x)
	  (error "No coercion found for x" (type-tag x) x))))
  (define (higher-type x)
    (let ((tail (memq x numeric-tower)))
      (cond ((eq? #f tail) (error "Type not in the tower" x))
	    ((null? (cdr tail)) (error "Already the highest type:" x))
	    (else (cadr tail)))))

  (show #t "Test: Higher than 'integer: " (higher-type 'integer) "\n")
  (define (remainder-integer a b)
    (when (or (not (integer? a)) (not (integer? b)))
      (error "Arguments must be integers" a b))
    (remainder a b))

  (put 'remainder '(integer integer) remainder-integer)
  (define (remainder-generalized a b) (apply-generic 'remainder a b))



  (define (apply-generic op . args)
    #;(show #t "apply-generic:entry\n")
    #;(error "debug")
    (define (variable poly) (car poly))
    (define (all-argtypes-same? . args)
      (let ((type (type-tag (car args))))
	(accumulate (lambda (x y) (and x y)) #t (map (lambda (x) (eq? type x)) args))))
    (define (coercion-if-exists? type arg-tags)
      (let ((coercion-list (map (lambda (x)
				  (if (eq? type x)
				      identity
				      (get-coercion x type))) arg-tags)))
	(if (accumulate (lambda (x y) (and x y)) #t coercion-list)
	    coercion-list
	    #f)))
    (drop (let* ((type-tags (map type-tag args))
		 (proc (get op type-tags)))
	    #;(show #t "apply-generic: type-tags="
	    (displayed type-tags)
	    " proc=" (written proc)
	    " proc-source=" (thingy-source proc) "\n")
	    (cond (proc (apply proc (map contents args)))
		  ((= 1 (length args))
		   #;(show #t "No proc found for op=" op ", type-tags=" type-tags ", arg=" (displayed args) "\n")
		   (apply-generic op (raise-type (car args))))
		  ((= 2 (length args))
		   (cond ((and (eq? 'polynomial (car type-tags))
			       (numeric? (cadr type-tags)))
			  (apply-generic op
					 (car args)
					 (make-polynomial (variable (contents (car args)))
							  (list (list 0 (cadr args))))))
			 ((and (numeric? (car type-tags))
			       (eq? 'polynomial (cadr type-tags)))
			  (apply-generic op
					 (make-polynomial (variable (contents (cadr args)))
							  (list (list 0 (car args))))
					 (cadr args)))
			 ((and (get-coercion (car type-tags) (cadr type-tags))
			       (not (eq? (car type-tags) (cadr type-tags))))
			  (apply-generic op
					 ((get-coercion
					   (car type-tags)
					   (cadr type-tags)) (car args))
					 (cadr args)))
			 ((and (get-coercion (cadr type-tags) (car type-tags))
			       (not (eq? (car type-tags) (cadr type-tags))))
			  (apply-generic op
					 (car args)
					 ((get-coercion
					   (cadr type-tags)
					   (car type-tags)) (cadr args) )))
			 ((comparable? (car type-tags) (cadr type-tags))
			  (if
			   (type1<=type2? (car type-tags) (cadr type-tags))
			   (apply-generic op (raise-type (car args)) (cadr args))
			   (apply-generic op (car args)  (raise-type (cadr args)))))
			 (else (error "apply-generic:Incomparable types: (type-tags,args)=" type-tags args))))
		  ((and (> (length args) 2) (not (all-argtypes-same? args)))
		   (let types-loop ((types type-tags))
		     (let ((list-of-coercion-functions
			    (coercion-if-exists? (car types) type-tags)))
		       (if list-of-coercion-functions
			   (apply apply-generic (cons op (map (lambda (fun arg) (fun arg))
							      list-of-coercion-functions
							      args)))
			   (if (not (null? (cdr types)))
			       (types-loop (cdr types))
			       (error "apply-generic:Even coercions failed. No method for these types."))))))
		  (else (error "apply-generic:No method for these types"
			       (list op type-tags)))))))
  (show #t "Test 30: start\n")
  (show #t "Test 30:(add (make-scheme-number 1) (make-scheme-number 1))= "
	(add (make-scheme-number 1) (make-scheme-number 1)) "\n")
  #;(error "Debug6")
  (define (scheme-number->complex n)
    (make-complex-from-real-imag (contents n) 0))
  (put-coercion 'scheme-number
		'complex
		scheme-number->complex)

  (show #t "Test 32: start")
  (show #t "Test 32: Subtracting complex numbers: "
	(sub
	 (make-complex-from-real-imag 1.1 2)
	 (make-complex-from-real-imag 0 2)) "\n")



  (put 'max3-magnitude '(complex complex complex) (lambda (z1 z2 z3)
						    (max (magnitude z1) (magnitude z2) (magnitude z3))))
  (define (max3-magnitude x1 x2 x3) (apply-generic 'max3-magnitude x1 x2 x3))
  (define (identity x) x)

  #;(define numeric-tower (list 'integer 'rational 'scheme-number 'complex))


  #;(define (higher-type x)
  (show #t "higher-type:x=" (displayed x) "\n")
  (define (find-higher-type x types)
  (cond ((or (null? types) (null? (cdr types))) (error "No type higher than given" x types))
  ((eq? x (car types)) (cadr types))
  (else (find-higher-type x (cdr types)))))
  (find-higher-type x numeric-tower))

  #;(show #t "Test: Higher than 'complex: " (higher-type 'complex) "\n")

  #;(define (integer->rational x)
  (make-rational x 1))

  #;(define (rational->scheme-number x)
  (make-scheme-number ((get 'to-real '(rational)) x)))
  #;(put-coercion 'integer 'rational integer->rational)
  #;(put-coercion 'rational 'scheme-number rational->scheme-number)
  (define (reduce-integers n d)
    (let ((g (gcd n d)))
      (list (/ n g) (/ d g))))
  (put 'reduce '(integer integer) reduce-integers)

  (define (install-polynomial-package)
    #;(define (contents generic-object)
    (cdr generic-object))
    (define (make-poly variable term-list)
      (cons variable term-list))
    (define (variable p) (car p))
    (define (term-list p)
      (cdr p))
    (define (variable? x) (symbol? x))
    (define (same-variable? v1 v2)
      (and (variable? v1) (variable? v2) (eq? v1 v2)))
    (define (=number? exp num)
      (and (number? exp) (= exp num)))
    (define (the-empty-termlist) '())

    (define (rest-terms term-list) (cdr term-list))
    (define (empty-termlist? term-list) (null? term-list))

    (define (make-term order coeff) (list order coeff))
    (define (order term) (car term))
    (define (coeff term) (cadr term))
    (define (tag p) (attach-tag 'polynomial p))
    (put 'make 'polynomial
	 (lambda (var terms) (tag (make-poly var terms))))
    #;(continued on next page)

    (define (add-poly p1 p2)
      #;(show #t "add-poly: p1=" p1 ", p2=" p2 "\n")
      (if (same-variable? (variable p1) (variable p2))
	  (make-poly (variable p1)
		     (add-terms (term-list p1)
				(term-list p2)))
	  (let ((res (cdr (if (variable_1-order<variable_2-order (variable p1) (variable p2))
			      (add (tag p1) (tag (make-poly (variable p1) (list (make-term 0 (tag p2))))))
			      (add (tag (make-poly (variable p2) (list (make-term 0 (tag p1))))) (tag p2))))))
	    #;(show #t "add-poly:result: " (displayed res) "\n") res)))

    (show #t "TestY2: poly of poly: "
	  (make-poly 'x (list
			 (make-term 3 (make-poly
				       'y (list (make-term 1 1) (make-term 0 1))))
			 (make-term 1 2)
			 (make-term 0 4))) "\n")

    (define (sub-poly p1 p2)
      (add-poly p1 (mul-poly p2 (make-poly (variable p2) (list (make-term 0 -1))))))
    (define (add-terms L1 L2)
      (cond ((empty-termlist? L1) L2)
	    ((empty-termlist? L2) L1)
	    (else
	     (let ((t1 (first-term L1)) (t2 (first-term L2)))
	       (cond ((> (order t1) (order t2))
		      (adjoin-term
		       t1 (add-terms (rest-terms L1) L2)))
		     ((< (order t1) (order t2))
		      (adjoin-term
		       t2 (add-terms L1 (rest-terms L2))))
		     (else
		      (adjoin-term
		       (make-term (order t1)
				  (add (coeff t1) (coeff t2)))
		       (add-terms (rest-terms L1)
				  (rest-terms L2)))))))))


    (define (mul-poly p1 p2)
      (if (same-variable? (variable p1) (variable p2))
	  (make-poly (variable p1)
		     (mul-terms (term-list p1)
				(term-list p2)))
	  (contents (if (variable_1-order<variable_2-order (variable p1) (variable p2))
			(mul (tag p1)
			     (make-polynomial (variable p1)
					      (adjoin-term
					       (make-term 0
							  (tag p2)) (the-empty-termlist))))
			(mul (tag p2)
			     (make-polynomial (variable p2)
					      (adjoin-term
					       (make-term 0
							  (tag p1)) (the-empty-termlist))))))
	  #;(error "Polys not in same var -- MUL-POLY"
	  (list p1 p2))))
    (define (div-poly p1 p2)
      (show #t "div-poly: p1=" p1 ", p2=" p2 "\n")
      (if (same-variable? (variable p1) (variable p2))
	  (let ((quotient-and-remainder (div-terms (term-list p1)
						   (term-list p2))))
	    (list (make-poly (variable p1) (car  quotient-and-remainder))
		  (make-poly (variable p1) (cadr quotient-and-remainder))))
	  (error "div-poly: Polys not in the same var" p1 p2)))
    (define (div-terms L1 L2)
      (show #t "div-terms: L1=" L1 ", L2=" L2 "\n")
      (if (empty-termlist? L1)
	  (list (the-empty-termlist) (the-empty-termlist))
	  (let ((t1 (first-term L1))
		(t2 (first-term L2)))
	    (if (> (order t2) (order t1))
		(list (the-empty-termlist) L1)
		(let ((new-c (div (coeff t1) (coeff t2)))
		      (new-o (- (order t1) (order t2))))
		  (let ((rest-of-result (div-terms (term-list
						    (sub-poly
						     (make-poly 'fake-var L1)
						     (mul-poly
						      (make-poly 'fake-var (list (make-term new-o new-c)))
						      (make-poly 'fake-var L2))))
						   L2)
					))
		    #;(show #t "div-terms: rest-of-result: " (displayed rest-of-result) "\n")
		    (list (adjoin-term (make-term new-o new-c) (car rest-of-result)) (cadr rest-of-result))
		    ))))))
    (define (gcd-terms a b)
      (show #t "gcd-terms: a=" a ", b=" b "\n")
      (if (empty-termlist? b)
	  a
	  (gcd-terms b (pseudoremainder-terms a b))))
    (define (pseudoremainder-terms P Q)
      (let ((O1 (order (first-term P)))
	    (O2 (order (first-term Q)))
	    (c  (coeff (first-term Q))))
	(show #t "pseudoremainder-terms: P=" P "\n")
	(show #t "pseudoremainder-terms: Q=" Q "\n")
	(show #t "pseudoremainder-terms: O1=" O1 "\n")
	(show #t "pseudoremainder-terms: O2=" O2 "\n")
	(show #t "pseudoremainder-terms: c=" c "\n")

	(show #t "pseudoremainder-terms: the integerizing factor="
	      (make-term 0 (exp c (add 1 (sub O1 O2)))) "\n" )
	(show #t "pseudoremainder-terms: P after multiplication="
	      (mul-term-by-all-terms
	       (make-term 0 (exp c (add 1 (sub O1 O2)))) P)  "\n" )
	(cadr (div-terms (mul-term-by-all-terms
			  (make-term 0 (exp c (add 1 (sub O1 O2)))) P) Q))))
    (define (maprest operation term-list)
      (show #t "maprest: operation=" (written operation) "term-list=" term-list "\n" )
      (if (empty-termlist? term-list)
	  '()
	  (cons (operation term-list) (maprest operation (rest-terms term-list))))
      )
    (define (gcd-poly p1 p2)
      (show #t "gcd-poly:p1=" p1 ", p2=" p2 "\n")

      (if (same-variable? (variable p1) (variable p2))
	  (let* ((unoptimized-termlist (gcd-terms (term-list p1) (term-list p2)))
		 (first-terms (maprest first-term unoptimized-termlist))
		 (coefficients (map coeff first-terms))
		 (coeff-gcd (apply gcd coefficients))
		 (optimized-termlist (mul-term-by-all-terms
				      (make-term 0 (div 1 coeff-gcd)) unoptimized-termlist)))
	    (show #t "gcd-poly: unoptimized-termlist=" unoptimized-termlist "\n")
	    (show #t "gcd-poly: first-terms=" first-terms "\n")
	    (show #t "gcd-poly: coefficients=" coefficients "\n")
	    (show #t "gcd-poly: coeff-gcd=" coeff-gcd "\n")
	    (make-poly (variable p1) optimized-termlist))
	  (error "div-poly: Polys not in the same var" p1 p2)))
    (put 'gcd '(polynomial polynomial)
	 (lambda (x y) (tag (gcd-poly x y))))
    (put 'gcd '(integer integer) gcd)

    (define (mul-terms L1 L2)
      (if (empty-termlist? L1)
	  (the-empty-termlist)
	  (add-terms (mul-term-by-all-terms (first-term L1) L2)
		     (mul-terms (rest-terms L1) L2))))

    (define (mul-term-by-all-terms t1 L)
      (if (empty-termlist? L)
	  (the-empty-termlist)
	  (let ((t2 (first-term L)))
	    (adjoin-term
	     (make-term (+ (order t1) (order t2))
			(mul (coeff t1) (coeff t2)))
	     (mul-term-by-all-terms t1 (rest-terms L))))))

    (define (reduce-terms termlist-1 termlist-2)
      (show #t "reduce-terms: termlist-1=" termlist-1
	    ", termlist-2=" termlist-2 "\n")
      (let* ((poly-gcd (gcd-terms termlist-1 termlist-2))
	     (O1 (max (order (first-term termlist-1))
		      (order (first-term termlist-2))))
	     (O2 (order (first-term poly-gcd)))
	     (c  (coeff (first-term poly-gcd)))
	     (int-factor (exp c (+ 1 (- O1 O2))))
	     (int-term (make-term 0 int-factor))
	     (impr-termlist-1 (mul-term-by-all-terms int-term termlist-1))
	     (impr-termlist-2 (mul-term-by-all-terms int-term termlist-2))
	     (new-t1 (car (div-terms impr-termlist-1 poly-gcd)))
	     (new-t2 (car (div-terms impr-termlist-2 poly-gcd)))
	     (new-t1-terms (map coeff (maprest first-term new-t1)))
	     (new-t2-terms (map coeff (maprest first-term new-t2)))
	     (full-list (append new-t1-terms new-t2-terms))
	     (new-gcd (begin (show #t "full-list=" full-list "\n")
			     (apply gcd full-list)))
	     (divisor-term (make-term 0 (div 1 new-gcd)))
	     (new-t1-impr (mul-term-by-all-terms divisor-term new-t1))
	     (new-t2-impr (mul-term-by-all-terms divisor-term new-t2)))
	(list new-t1-impr new-t2-impr)))
    (define (reduce-poly p1 p2)
      (show #t "reduce-poly: p1=" p1 ", p2=" p2 "\n")
      (if (same-variable? (variable p1) (variable p2))
	  (let* ((num-den-list (reduce-terms (term-list p1) (term-list p2)))
		 (my-var (variable p1))
		 (new-p1 (make-poly my-var (car num-den-list)))
		 (new-p2 (make-poly my-var (cadr num-den-list))))
	    (list (tag new-p1) (tag new-p2)))
	  (error "reduce-poly: different variables")))
    (put 'reduce '(polynomial polynomial) reduce-poly)
    (define (zero-poly? poly)
      (show #t "zero-poly?: poly=" (displayed poly) "\n")
      (cond ((empty-termlist? (term-list poly)) #t)
	    ((not (zero? (coeff (first-term (term-list poly))))) #f)
	    (else (zero-poly?
		   (make-poly (variable poly)
			      (rest-terms (term-list poly)))))))

    (define (termlist-type-of term-list)
      #;(show #t "t-t-o: term-list=" (displayed term-list) "\n")
      (cond ((null? term-list) 'sparse)
	    ((pair? (car term-list)) 'sparse)
	    ((list? term-list) 'dense)
	    (else (error "Unknown type of list" term-list))))
    (define (adjoin-term term term-list)
      ((get 'adjoin-term (termlist-type-of term-list)) term term-list))
    (define (first-term term-list)
      ((get 'first-term (termlist-type-of term-list)) term-list))
    (define (variable_1-order<variable_2-order variable_1 variable_2)
      #;(show #t "var_1-..: variable_1=" variable_1 " variable_2=" variable_2 "\n")
      #;(show #t "var12string=" (symbol->string variable_1) "var22string=" (symbol->string variable_2) "\n")
      (string<=? (symbol->string variable_1) (symbol->string variable_2)))
    (define (normalize-fully poly)
      (if (normal-polynomial? poly)
	  poly
	  (normalize-fully (normalize-once poly))))
    (put 'add '(polynomial polynomial)
	 (lambda (p1 p2)
	   #;(show #t "generic-add-poly:Polynomial dispatch found: p1="
	   (displayed p1) " p2=" (displayed p2) "\n")
	   (normalize-fully (tag (add-poly p1 p2)))))
    (put 'mul '(polynomial polynomial)
	 (lambda (p1 p2) (normalize-fully (tag (mul-poly p1 p2)))))
    (put 'sub '(polynomial polynomial)
	 (lambda (p1 p2) (tag (sub-poly p1 p2))))

    (put 'zero? '(polynomial) zero-poly?)
    (put 'div '(polynomial polynomial) div-poly)
    #;(put-coercion 'rational 'scheme-number rational->scheme-number)
    (define (monomial-flip-variables monomial)
      #;(show #t "m-f-v: monomial=" monomial "\n")
      (let* ((mono (contents monomial))
	     (inner-polynomial (contents (coeff (first-term (term-list mono)))))
	     (inner-poly (contents inner-polynomial))
	     (outer-order (order (first-term (term-list mono))))
	     (outer-var (variable mono))
	     (inner-var (variable inner-polynomial))
	     (inner-term-list (term-list inner-poly)))
	#;(show #t "m-f-v: inner-poly=" inner-poly "\n")
	(if (same-variable? inner-var outer-var)
	    (mul
	     (make-polynomial outer-var (adjoin-term (make-term outer-order 1) (the-empty-termlist)))
	     (tag inner-polynomial))
	    (tag (make-poly inner-var
			    (mul-term-by-all-terms (make-term
						    0
						    (make-polynomial
						     outer-var
						     (list (make-term
							    outer-order
							    1)))) inner-poly))))))
    #;(show #t "TestXX: sorting variables: Is 'x < 'y?: "
    (variable_1-order<variable_2-order 'x 'y) "\n")
    #;(show #t "TestXX: sorting variables: Is 'z < 'y?: "
    (variable_1-order<variable_2-order 'z 'y) "\n")
    #;(show #t "TestXX: (adding two basic poly): "
    (add (make-polynomial 'x (list (make-term 1 2) (make-term 0 4)))
    (make-polynomial 'y (list (make-term 2 3) (make-term 0 5)))) "\n")

    (define (polynomial->sum-of-first-and-rest poly)
      #;(show #t "p->s-o-f-a-r: " (displayed poly) "\n")
      (if (zero? poly)
	  poly
	  (let* ((poly1 (contents poly))
		 (first-monomial (tag
				  (make-poly
				   (variable poly1)
				   (list (first-term (term-list poly1)))))))
	    #;(show #t "p->s-o-f-a-r: " (displayed first-monomial) "\n")
	    (add
	     first-monomial
	     (polynomial->sum-of-first-and-rest
	      (tag (make-poly (variable poly1) (rest-terms (term-list poly1)))))))))

    (show #t "Test13: Expanding a polynomial as monomials: "
	  (displayed
	   (polynomial->sum-of-first-and-rest
	    (make-polynomial 'y
			     (list (make-term 2 (make-polynomial
						 'x
						 (list (make-term 2 1) (make-term 0 1))))
				   (make-term 0 2))))) "\n")

    (show #t "\nTest20: start monomial: "
	  (displayed (make-polynomial 'x
				      (list
				       (make-term
					2
					(make-polynomial
					 'y
					 (list
					  (make-term 2 1) (make-term 0 1))))))) "\n")
    (show #t "Test20: Flipping a monomial variable: "
	  (displayed
	   (monomial-flip-variables
	    (make-polynomial 'x
			     (list (make-term 1 (make-polynomial
						 'y
						 (list
						  (make-term 2 1)
						  (make-term 0 1)))))))) "\n\n")


    (define (normal-polynomial? poly)
      #;(show #t "n-p?: poly=" poly "\n")
      (cond ((not (polynomial? poly)) #t)
	    ((null? (term-list (contents poly))) #t)
	    (else (let* ((poly1 (contents poly))
			 (outer-var (variable poly1)))
		    #;(show #t "Inner-let: outer-var=" (displayed outer-var) "\n")
		    (let loop ((terms (term-list poly1)))
		      #;(show #t "n-p?-loop: terms=" (displayed terms) "\n")
		      (cond ((null? terms) #t)
			    ((not (polynomial? (coeff (first-term terms))))
			     (loop (rest-terms terms)))
			    ((not (variable_1-order<variable_2-order
				   outer-var
				   (variable (contents (coeff (first-term terms))))))
			     (begin #;(show #t "wrong variable order \n") #f))
			    ((not (normal-polynomial? (coeff (first-term terms))))
			     (begin #;(show #t "not normal poly\n") #f))
			    (else (loop (rest-terms terms)))))
		    ))))
    (define (normalize-once poly)
      #;(show #t "normalize-once poly= " (displayed poly) "\n")
      (if (zero? poly)
	  poly
	  (let* ((poly1 (contents poly))
		 (first-monomial (tag
				  (make-poly
				   (variable poly1)
				   (list (make-term
					  (order (first-term (term-list poly1)))
					  (if (polynomial? (coeff (first-term (term-list poly1))))
					      (normalize-once (coeff (first-term (term-list poly1))))
					      (coeff (first-term (term-list poly1))))))))))
	    #;(show #t "p->s-o-f-a-r: " (displayed first-monomial) "\n")
	    (add
	     (if (and (polynomial?
		       (coeff
			(first-term
			 (term-list
			  (contents first-monomial)))))
		      (variable_1-order<variable_2-order
		       (variable
			(contents
			 (coeff
			  (first-term
			   (term-list
			    (contents first-monomial))))))
		       (variable
			(contents first-monomial))))
		 (monomial-flip-variables first-monomial)
		 first-monomial)
	     (polynomial->sum-of-first-and-rest
	      (tag (make-poly (variable poly1) (rest-terms (term-list poly1)))))))))

    (show #t "Test21: normal-polynomial?:start: " (displayed (make-polynomial 'y
									      (list (make-term 2 (make-polynomial
												  'x
												  (list (make-term 2 1) (make-term 0 1))))
										    (make-term 0 2)))) "\n")
    #;(show #t "Test21: normal-polynomial?:result:" (normal-polynomial? (make-polynomial 'y
    (list (make-term 2 (make-polynomial
    'x
    (list (make-term 2 1) (make-term 0 1))))
    (make-term 0 2)))) "\n")
    #;(show #t "Test22: normal-polynomial?-good:start: "
    (displayed
    (make-polynomial 'x
    (list (make-term 2 (make-polynomial
    'y
    (list (make-term 2 1) (make-term 0 1))))
    (make-term 0 2)))) "\n")
    #;(show #t "Test22: normal-polynomial?-good:result:"
    (normal-polynomial?
    (make-polynomial 'x
    (list (make-term 2 (make-polynomial
    'y
    (list (make-term 2 1) (make-term 0 1))))
    (make-term 0 2)))) "\n")

    #;(show #t "Test23:input: normalizing a bad polynomial: "
    (make-polynomial 'y
    (list (make-term 2 (make-polynomial
    'x
    (list (make-term 2 1) (make-term 0 1))))
    (make-term 0 2))) "\n")
    #;(show #t "Test23:result: normalizing a bad polynomial: "
    (normalize-once (make-polynomial 'y
    (list (make-term 2 (make-polynomial
    'x
    (list (make-term 2 1) (make-term 0 1))))
    (make-term 0 2)))) "\n")
    #;(show #t "Test24:input: normalizing a bad polynomial: "
    (make-polynomial 'x
    (list (make-term 2 (make-polynomial
    'x
    (list (make-term 2 1) (make-term 0 1))))
    (make-term 0 2))) "\n")
    #;(show #t "Test24:result: normalizing a bad polynomial: "
    (normalize-once (make-polynomial 'x
    (list (make-term 2 (make-polynomial
    'x
    (list (make-term 2 1) (make-term 0 1))))
    (make-term 0 2)))) "\n")


    #;(show #t "Test24:input: normalize-fully a bad polynomial: "
    (make-polynomial 'y
    (list (make-term 2 (make-polynomial
    'x
    (list (make-term 2 1) (make-term 0 1))))
    (make-term 0 2))) "\n")
    #;(show #t "Test24:result: normalize-fully a bad polynomial: "
    (normalize-fully (make-polynomial 'y
    (list (make-term 2 (make-polynomial
    'x
    (list (make-term 2 1) (make-term 0 1))))
    (make-term 0 2)))) "\n")



    'done)


  (define (install-polynomial-sparse-package)
    (define (coeff term) (cadr term))
    (define (first-term-sparse term-list) (car term-list))
    (define (adjoin-term-sparse term term-list)
      (if (zero? (coeff term))
	  term-list
	  (cons term term-list)))
    (put 'adjoin-term 'sparse adjoin-term-sparse)
    (put 'first-term 'sparse first-term-sparse)
    'done)
  (install-polynomial-sparse-package)

  (define (install-polynomial-dense-package)
    (define (make-term order coeff) (list order coeff))
    (define (order term) (car term))
    (define (coeff term) (cadr term))

    (define (adjoin-term-dense term term-list)
      (if (zero? (coeff term))
	  term-list
	  (if (> (order term) (length term-list))
	      (append (list (coeff term))
		      (make-list (- (order term) (length term-list)) 0)
		      term-list)
	      (error "adjoin-term:Appending a smaller order term. Recheck."))))
    (define (first-term-dense term-list)
      #;(show #t "first-term-dense: " (displayed (make-term (car term-list) (length (cdr term-list)))) "\n")
      (make-term (length (cdr term-list)) (car term-list) ))
    (put 'adjoin-term 'dense adjoin-term-dense)
    (put 'first-term 'dense first-term-dense)
    'done)
  #;(install-polynomial-dense-package)

  (define (make-polynomial var terms)
    ((get 'make 'polynomial) var terms))

  (install-polynomial-package)


  (show #t "Test 2: Making polynomials: "
	(make-polynomial 'x (list (list 5 1) (list 4 2))) "\n")
  (show #t "Test 3: Zero?: "
	(zero? (make-polynomial 'x (list (list 5 1) (list 4 2)))) "\n")
  (show #t "Test 4: Adding polynomials: "
	(add (make-polynomial 'x '((5 1) (4 2) (0 1)))
	     (make-polynomial 'x '((5 1)))) "\n")
  (show #t "Test 4: Zero?: " (zero? (make-polynomial 'x '((5 0) (3 1)))) "\n")

  (show #t "Test 5: Subtracting polynomials: "
	(sub (make-polynomial 'x '((5 1) (4 2) (0 1)))
	     (make-polynomial 'x '((0 1)))) "\n")

  #;(show #t "Test 6: Making a dense polynomial: " (make-polynomial 'x '(1 2 3 4 5)) "\n")
  #;(show #t "Test 7: zero? dense polynomial: " (displayed (zero? (make-polynomial 'x '(0)))) "\n")
  #;(show #t "Test 8: zero? dense polynomial: " (displayed (zero? (make-polynomial 'x '(1)))) "\n")
  #;(show #t "Test 9: Adding dense polynomials: "
  (add (make-polynomial 'x '(1 2 0 0 0 1))
  (make-polynomial 'x '(1 0 0 0 0 0))) "\n")
  #;(show #t "Test10: Subtracting dense polynomials: "
  (sub (make-polynomial 'x '(1 2 0 0 0 1))
  (make-polynomial 'x '(1 0 0 0 0 0))) "\n")
  #;(show #t "Test11: Subtracting dense and sparse polynomials: "
  (sub (make-polynomial 'x '(1 2 0 0 0 1))
  (make-polynomial 'x '((4 2)))) "\n")
  (show #t "Test12: Dividing x^2 + 2x + 1 by x+1: "
	(displayed
	 (div (make-polynomial 'x '((2 1) (1 2) (0 1)))
	      (make-polynomial 'x '(      (1 1) (0 1)))) ) "\n")
  (show #t "Test14: Adding polynomials of two variables: "
	(displayed
	 (add (make-polynomial 'x '((1 1)))
	      (make-polynomial 'y '((1 1))))))
  (show #t "Test14: Adding polynomials of two variables,\n when one of them is nonexistant: \n"
	(pretty
	 (add (make-polynomial 'x '((1 1)))
	      (make-polynomial 'y '((0 1))))))
  (show #t "Test25: multiplying different variables: "
	(displayed (mul (make-polynomial 'x '((1 1)))
			(make-polynomial 'y '((1 1))))) "\n")
  (begin
    (show #t "Test 26:start\n")
    (define p1 (make-polynomial 'x '((2 1) (0 1))))
    (define p2 (make-polynomial 'x '((3 1) (0 1))))
    (define rf (make-rational p2 p1))

    (show #t "Test 26: make-rational-polynomial: " rf "\n")
    (show #t "Test 27: add-rational\n")
    (show #t "Test 27: " (add rf rf) "\n")
    )

  (show #t "Test 28: polynomial-gcd: start\n")
  (define (greatest-common-divisor p1 p2) (apply-generic 'gcd p1 p2))
  (begin
    (define p1 (make-polynomial
		'x '((4 1) (3 -1) (2 -2) (1 2))))
    (define p2 (make-polynomial 'x '((3 1) (1 -1))))

    (show #t "Test 28: polynomial-gcd: " (greatest-common-divisor p1 p2) "\n"))

  (begin
    (define p1 (make-polynomial
		'x '((2 1) (1 -2) (0 1))))
    (define p2 (make-polynomial 'x '((2 11) (0 7))))

    (define p3 (make-polynomial 'x '((1 13) (0 5))))
    (define q1 (mul p1 p2))
    (define q2 (mul p1 p3))
    (show #t "Test 29: gcd-integer-problem: start\n")
    (show #t "Test 29: p1=" p1 "\n")
    (show #t "Test 29: p2=" p2 "\n")
    (show #t "Test 29: p3=" p3 "\n")
    (show #t "Test 29: q1=" q1 "\n")
    (show #t "Test 29: q2=" q2 "\n")
    (show #t "Test 29: gcd : " (greatest-common-divisor q1 q2) "\n")
    )

  (begin
    (show #t "Test 30: start\n")
    (define p1 (make-polynomial 'x '((1 1)(0 1))))
    (define p2 (make-polynomial 'x '((3 1)(0 -1))))
    (define p3 (make-polynomial 'x '((1 1))))
    (define p4 (make-polynomial 'x '((2 1)(0 -1))))

    (define rf1 (make-rational p1 p2))
    (define rf2 (make-rational p3 p4))

    (show #t "Test 33: " (add rf1 rf2) "\n"))


#+end_src

#+RESULTS[1b38b44f1730a7e90cc23c2ae39d360472b17533]:
#+begin_src scheme
(tag 5)=5
Test 31: start
Test 31:#t
Test: Higher than 'integer: scheme-number
Test 30: start
Test 30:(add (make-scheme-number 1) (make-scheme-number 1))= 2
Test 32: startTest 32: Subtracting complex numbers: 1.1
TestY2: poly of poly: (x (3 (y (1 1) (0 1))) (1 2) (0 4))
zero-poly?: poly=(y (2 (polynomial x (2 1) (0 1))) (0 2))
zero-poly?: poly=(x (2 1) (0 1))
zero-poly?: poly=(y (0 2))
zero-poly?: poly=(y)
zero-poly?: poly=(x (2 1) (0 1))
zero-poly?: poly=(y (2 (polynomial x (2 1) (0 1))) (0 2))
zero-poly?: poly=(x (2 1) (0 1))
zero-poly?: poly=(x (2 1) (0 1))
zero-poly?: poly=(x (0 1))
zero-poly?: poly=(x)
zero-poly?: poly=(y (0 2))
zero-poly?: poly=(y)
zero-poly?: poly=(y (2 1))
zero-poly?: poly=(y (2 1))
zero-poly?: poly=(y (2 1) (0 2))
zero-poly?: poly=(y (2 1))
Test13: Expanding a polynomial as monomials: (polynomial x (2 (polynomial y (2 1))) (0 (polynomial y (2 1) (0 2))))

Test20: start monomial: (polynomial x (2 (polynomial y (2 1) (0 1))))
zero-poly?: poly=(x (1 1))
zero-poly?: poly=(x (1 1))
Test20: Flipping a monomial variable: (polynomial y (2 (polynomial x (1 1))) (0 (polynomial x (1 1))))

Test21: normal-polynomial?:start: (polynomial y (2 (polynomial x (2 1) (0 1))) (0 2))
Test 2: Making polynomials: (polynomial x (5 1) (4 2))
zero-poly?: poly=(x (5 1) (4 2))
Test 3: Zero?: #f
Test 4: Adding polynomials: (polynomial x (5 2) (4 2) (0 1))
zero-poly?: poly=(x (5 0) (3 1))
zero-poly?: poly=(x (3 1))
Test 4: Zero?: #f
Test 5: Subtracting polynomials: (polynomial x (5 1) (4 2))
div-poly: p1=(x (2 1) (1 2) (0 1)), p2=(x (1 1) (0 1))
div-terms: L1=((2 1) (1 2) (0 1)), L2=((1 1) (0 1))
div-terms: L1=((1 1) (0 1)), L2=((1 1) (0 1))
div-terms: L1=(), L2=((1 1) (0 1))
Test12: Dividing x^2 + 2x + 1 by x+1: ((x (1 1) (0 1)) (x))
Test14: Adding polynomials of two variables: (polynomial x (1 1) (0 (polynomial y (1 1))))Test14: Adding polynomials of two variables,
 when one of them is nonexistant: 
(polynomial x (1 1) (0 (polynomial y (0 1))))
zero-poly?: poly=(y (1 1))
zero-poly?: poly=(y (1 1))
Test25: multiplying different variables: (polynomial x (1 (polynomial y (1 1))))
Test 26:start
make-rat: n=(polynomial x (3 1) (0 1)), d=(polynomial x (2 1) (0 1))
reduce-poly: p1=(x (3 1) (0 1)), p2=(x (2 1) (0 1))
reduce-terms: termlist-1=((3 1) (0 1)), termlist-2=((2 1) (0 1))
gcd-terms: a=((3 1) (0 1)), b=((2 1) (0 1))
pseudoremainder-terms: P=((3 1) (0 1))
pseudoremainder-terms: Q=((2 1) (0 1))
pseudoremainder-terms: O1=3
pseudoremainder-terms: O2=2
pseudoremainder-terms: c=1
pseudoremainder-terms: the integerizing factor=(0 1)
pseudoremainder-terms: P after multiplication=((3 1) (0 1))
div-terms: L1=((3 1) (0 1)), L2=((2 1) (0 1))
div-terms: L1=((1 -1) (0 1)), L2=((2 1) (0 1))
gcd-terms: a=((2 1) (0 1)), b=((1 -1) (0 1))
pseudoremainder-terms: P=((2 1) (0 1))
pseudoremainder-terms: Q=((1 -1) (0 1))
pseudoremainder-terms: O1=2
pseudoremainder-terms: O2=1
pseudoremainder-terms: c=-1
pseudoremainder-terms: the integerizing factor=(0 1)
pseudoremainder-terms: P after multiplication=((2 1) (0 1))
div-terms: L1=((2 1) (0 1)), L2=((1 -1) (0 1))
div-terms: L1=((1 1) (0 1)), L2=((1 -1) (0 1))
div-terms: L1=((0 2)), L2=((1 -1) (0 1))
gcd-terms: a=((1 -1) (0 1)), b=((0 2))
pseudoremainder-terms: P=((1 -1) (0 1))
pseudoremainder-terms: Q=((0 2))
pseudoremainder-terms: O1=1
pseudoremainder-terms: O2=0
pseudoremainder-terms: c=2
pseudoremainder-terms: the integerizing factor=(0 4)
pseudoremainder-terms: P after multiplication=((1 -4) (0 4))
div-terms: L1=((1 -4) (0 4)), L2=((0 2))
div-terms: L1=((0 4)), L2=((0 2))
div-terms: L1=(), L2=((0 2))
gcd-terms: a=((0 2)), b=()
div-terms: L1=((3 16) (0 16)), L2=((0 2))
div-terms: L1=((0 16)), L2=((0 2))
div-terms: L1=(), L2=((0 2))
div-terms: L1=((2 16) (0 16)), L2=((0 2))
div-terms: L1=((0 16)), L2=((0 2))
div-terms: L1=(), L2=((0 2))
maprest: operation=#<procedure first-term>term-list=((3 8) (0 8))
maprest: operation=#<procedure first-term>term-list=((0 8))
maprest: operation=#<procedure first-term>term-list=()
maprest: operation=#<procedure first-term>term-list=((2 8) (0 8))
maprest: operation=#<procedure first-term>term-list=((0 8))
maprest: operation=#<procedure first-term>term-list=()
full-list=(8 8 8 8)
Test 26: make-rational-polynomial: (rational (polynomial x (3 1) (0 1)) polynomial x (2 1) (0 1))
Test 27: add-rational
make-rat: n=(polynomial x (5 2) (3 2) (2 2) (0 2)), d=(polynomial x (4 1) (2 2) (0 1))
reduce-poly: p1=(x (5 2) (3 2) (2 2) (0 2)), p2=(x (4 1) (2 2) (0 1))
reduce-terms: termlist-1=((5 2) (3 2) (2 2) (0 2)), termlist-2=((4 1) (2 2) (0 1))
gcd-terms: a=((5 2) (3 2) (2 2) (0 2)), b=((4 1) (2 2) (0 1))
pseudoremainder-terms: P=((5 2) (3 2) (2 2) (0 2))
pseudoremainder-terms: Q=((4 1) (2 2) (0 1))
pseudoremainder-terms: O1=5
pseudoremainder-terms: O2=4
pseudoremainder-terms: c=1
pseudoremainder-terms: the integerizing factor=(0 1)
pseudoremainder-terms: P after multiplication=((5 2) (3 2) (2 2) (0 2))
div-terms: L1=((5 2) (3 2) (2 2) (0 2)), L2=((4 1) (2 2) (0 1))
div-terms: L1=((3 -2) (2 2) (1 -2) (0 2)), L2=((4 1) (2 2) (0 1))
gcd-terms: a=((4 1) (2 2) (0 1)), b=((3 -2) (2 2) (1 -2) (0 2))
pseudoremainder-terms: P=((4 1) (2 2) (0 1))
pseudoremainder-terms: Q=((3 -2) (2 2) (1 -2) (0 2))
pseudoremainder-terms: O1=4
pseudoremainder-terms: O2=3
pseudoremainder-terms: c=-2
pseudoremainder-terms: the integerizing factor=(0 4)
pseudoremainder-terms: P after multiplication=((4 4) (2 8) (0 4))
div-terms: L1=((4 4) (2 8) (0 4)), L2=((3 -2) (2 2) (1 -2) (0 2))
div-terms: L1=((3 4) (2 4) (1 4) (0 4)), L2=((3 -2) (2 2) (1 -2) (0 2))
div-terms: L1=((2 8) (0 8)), L2=((3 -2) (2 2) (1 -2) (0 2))
gcd-terms: a=((3 -2) (2 2) (1 -2) (0 2)), b=((2 8) (0 8))
pseudoremainder-terms: P=((3 -2) (2 2) (1 -2) (0 2))
pseudoremainder-terms: Q=((2 8) (0 8))
pseudoremainder-terms: O1=3
pseudoremainder-terms: O2=2
pseudoremainder-terms: c=8
pseudoremainder-terms: the integerizing factor=(0 64)
pseudoremainder-terms: P after multiplication=((3 -128) (2 128) (1 -128) (0 128))
div-terms: L1=((3 -128) (2 128) (1 -128) (0 128)), L2=((2 8) (0 8))
div-terms: L1=((2 128) (0 128)), L2=((2 8) (0 8))
div-terms: L1=(), L2=((2 8) (0 8))
gcd-terms: a=((2 8) (0 8)), b=()
div-terms: L1=((5 8192) (3 8192) (2 8192) (0 8192)), L2=((2 8) (0 8))
div-terms: L1=((2 8192) (0 8192)), L2=((2 8) (0 8))
div-terms: L1=(), L2=((2 8) (0 8))
div-terms: L1=((4 4096) (2 8192) (0 4096)), L2=((2 8) (0 8))
div-terms: L1=((2 4096) (0 4096)), L2=((2 8) (0 8))
div-terms: L1=(), L2=((2 8) (0 8))
maprest: operation=#<procedure first-term>term-list=((3 1024) (0 1024))
maprest: operation=#<procedure first-term>term-list=((0 1024))
maprest: operation=#<procedure first-term>term-list=()
maprest: operation=#<procedure first-term>term-list=((2 512) (0 512))
maprest: operation=#<procedure first-term>term-list=((0 512))
maprest: operation=#<procedure first-term>term-list=()
full-list=(1024 1024 512 512)
rational not droppable: #f
Test 27: (rational (polynomial x (3 2) (0 2)) polynomial x (2 1) (0 1))
Test 28: polynomial-gcd: start
gcd-poly:p1=(x (4 1) (3 -1) (2 -2) (1 2)), p2=(x (3 1) (1 -1))
gcd-terms: a=((4 1) (3 -1) (2 -2) (1 2)), b=((3 1) (1 -1))
pseudoremainder-terms: P=((4 1) (3 -1) (2 -2) (1 2))
pseudoremainder-terms: Q=((3 1) (1 -1))
pseudoremainder-terms: O1=4
pseudoremainder-terms: O2=3
pseudoremainder-terms: c=1
pseudoremainder-terms: the integerizing factor=(0 1)
pseudoremainder-terms: P after multiplication=((4 1) (3 -1) (2 -2) (1 2))
div-terms: L1=((4 1) (3 -1) (2 -2) (1 2)), L2=((3 1) (1 -1))
div-terms: L1=((3 -1) (2 -1) (1 2)), L2=((3 1) (1 -1))
div-terms: L1=((2 -1) (1 1)), L2=((3 1) (1 -1))
gcd-terms: a=((3 1) (1 -1)), b=((2 -1) (1 1))
pseudoremainder-terms: P=((3 1) (1 -1))
pseudoremainder-terms: Q=((2 -1) (1 1))
pseudoremainder-terms: O1=3
pseudoremainder-terms: O2=2
pseudoremainder-terms: c=-1
pseudoremainder-terms: the integerizing factor=(0 1)
pseudoremainder-terms: P after multiplication=((3 1) (1 -1))
div-terms: L1=((3 1) (1 -1)), L2=((2 -1) (1 1))
div-terms: L1=((2 1) (1 -1)), L2=((2 -1) (1 1))
div-terms: L1=(), L2=((2 -1) (1 1))
gcd-terms: a=((2 -1) (1 1)), b=()
maprest: operation=#<procedure first-term>term-list=((2 -1) (1 1))
maprest: operation=#<procedure first-term>term-list=((1 1))
maprest: operation=#<procedure first-term>term-list=()
gcd-poly: unoptimized-termlist=((2 -1) (1 1))
gcd-poly: first-terms=((2 -1) (1 1))
gcd-poly: coefficients=(-1 1)
gcd-poly: coeff-gcd=1
Test 28: polynomial-gcd: (polynomial x (2 -1) (1 1))
Test 29: gcd-integer-problem: start
Test 29: p1=(polynomial x (2 1) (1 -2) (0 1))
Test 29: p2=(polynomial x (2 11) (0 7))
Test 29: p3=(polynomial x (1 13) (0 5))
Test 29: q1=(polynomial x (4 11) (3 -22) (2 18) (1 -14) (0 7))
Test 29: q2=(polynomial x (3 13) (2 -21) (1 3) (0 5))
gcd-poly:p1=(x (4 11) (3 -22) (2 18) (1 -14) (0 7)), p2=(x (3 13) (2 -21) (1 3) (0 5))
gcd-terms: a=((4 11) (3 -22) (2 18) (1 -14) (0 7)), b=((3 13) (2 -21) (1 3) (0 5))
pseudoremainder-terms: P=((4 11) (3 -22) (2 18) (1 -14) (0 7))
pseudoremainder-terms: Q=((3 13) (2 -21) (1 3) (0 5))
pseudoremainder-terms: O1=4
pseudoremainder-terms: O2=3
pseudoremainder-terms: c=13
pseudoremainder-terms: the integerizing factor=(0 169)
pseudoremainder-terms: P after multiplication=((4 1859) (3 -3718) (2 3042) (1 -2366) (0 1183))
div-terms: L1=((4 1859) (3 -3718) (2 3042) (1 -2366) (0 1183)), L2=((3 13) (2 -21) (1 3) (0 5))
div-terms: L1=((3 -715) (2 2613) (1 -3081) (0 1183)), L2=((3 13) (2 -21) (1 3) (0 5))
div-terms: L1=((2 1458) (1 -2916) (0 1458)), L2=((3 13) (2 -21) (1 3) (0 5))
gcd-terms: a=((3 13) (2 -21) (1 3) (0 5)), b=((2 1458) (1 -2916) (0 1458))
pseudoremainder-terms: P=((3 13) (2 -21) (1 3) (0 5))
pseudoremainder-terms: Q=((2 1458) (1 -2916) (0 1458))
pseudoremainder-terms: O1=3
pseudoremainder-terms: O2=2
pseudoremainder-terms: c=1458
pseudoremainder-terms: the integerizing factor=(0 2125764)
pseudoremainder-terms: P after multiplication=((3 27634932) (2 -44641044) (1 6377292) (0 10628820))
div-terms: L1=((3 27634932) (2 -44641044) (1 6377292) (0 10628820)), L2=((2 1458) (1 -2916) (0 1458))
div-terms: L1=((2 10628820) (1 -21257640) (0 10628820)), L2=((2 1458) (1 -2916) (0 1458))
div-terms: L1=(), L2=((2 1458) (1 -2916) (0 1458))
gcd-terms: a=((2 1458) (1 -2916) (0 1458)), b=()
maprest: operation=#<procedure first-term>term-list=((2 1458) (1 -2916) (0 1458))
maprest: operation=#<procedure first-term>term-list=((1 -2916) (0 1458))
maprest: operation=#<procedure first-term>term-list=((0 1458))
maprest: operation=#<procedure first-term>term-list=()
gcd-poly: unoptimized-termlist=((2 1458) (1 -2916) (0 1458))
gcd-poly: first-terms=((2 1458) (1 -2916) (0 1458))
gcd-poly: coefficients=(1458 -2916 1458)
gcd-poly: coeff-gcd=1458
Test 29: gcd : (polynomial x (2 0.9999999999999999) (1 -1.9999999999999998) (0 0.9999999999999999))
Test 30: start
make-rat: n=(polynomial x (1 1) (0 1)), d=(polynomial x (3 1) (0 -1))
reduce-poly: p1=(x (1 1) (0 1)), p2=(x (3 1) (0 -1))
reduce-terms: termlist-1=((1 1) (0 1)), termlist-2=((3 1) (0 -1))
gcd-terms: a=((1 1) (0 1)), b=((3 1) (0 -1))
pseudoremainder-terms: P=((1 1) (0 1))
pseudoremainder-terms: Q=((3 1) (0 -1))
pseudoremainder-terms: O1=1
pseudoremainder-terms: O2=3
pseudoremainder-terms: c=1
pseudoremainder-terms: the integerizing factor=(0 1)
pseudoremainder-terms: P after multiplication=((1 1) (0 1))
div-terms: L1=((1 1) (0 1)), L2=((3 1) (0 -1))
gcd-terms: a=((3 1) (0 -1)), b=((1 1) (0 1))
pseudoremainder-terms: P=((3 1) (0 -1))
pseudoremainder-terms: Q=((1 1) (0 1))
pseudoremainder-terms: O1=3
pseudoremainder-terms: O2=1
pseudoremainder-terms: c=1
pseudoremainder-terms: the integerizing factor=(0 1)
pseudoremainder-terms: P after multiplication=((3 1) (0 -1))
div-terms: L1=((3 1) (0 -1)), L2=((1 1) (0 1))
div-terms: L1=((2 -1) (0 -1)), L2=((1 1) (0 1))
div-terms: L1=((1 1) (0 -1)), L2=((1 1) (0 1))
div-terms: L1=((0 -2)), L2=((1 1) (0 1))
gcd-terms: a=((1 1) (0 1)), b=((0 -2))
pseudoremainder-terms: P=((1 1) (0 1))
pseudoremainder-terms: Q=((0 -2))
pseudoremainder-terms: O1=1
pseudoremainder-terms: O2=0
pseudoremainder-terms: c=-2
pseudoremainder-terms: the integerizing factor=(0 4)
pseudoremainder-terms: P after multiplication=((1 4) (0 4))
div-terms: L1=((1 4) (0 4)), L2=((0 -2))
div-terms: L1=((0 4)), L2=((0 -2))
div-terms: L1=(), L2=((0 -2))
gcd-terms: a=((0 -2)), b=()
div-terms: L1=((1 16) (0 16)), L2=((0 -2))
div-terms: L1=((0 16)), L2=((0 -2))
div-terms: L1=(), L2=((0 -2))
div-terms: L1=((3 16) (0 -16)), L2=((0 -2))
div-terms: L1=((0 -16)), L2=((0 -2))
div-terms: L1=(), L2=((0 -2))
maprest: operation=#<procedure first-term>term-list=((1 -8) (0 -8))
maprest: operation=#<procedure first-term>term-list=((0 -8))
maprest: operation=#<procedure first-term>term-list=()
maprest: operation=#<procedure first-term>term-list=((3 -8) (0 8))
maprest: operation=#<procedure first-term>term-list=((0 8))
maprest: operation=#<procedure first-term>term-list=()
full-list=(-8 -8 -8 8)
make-rat: n=(polynomial x (1 1)), d=(polynomial x (2 1) (0 -1))
reduce-poly: p1=(x (1 1)), p2=(x (2 1) (0 -1))
reduce-terms: termlist-1=((1 1)), termlist-2=((2 1) (0 -1))
gcd-terms: a=((1 1)), b=((2 1) (0 -1))
pseudoremainder-terms: P=((1 1))
pseudoremainder-terms: Q=((2 1) (0 -1))
pseudoremainder-terms: O1=1
pseudoremainder-terms: O2=2
pseudoremainder-terms: c=1
pseudoremainder-terms: the integerizing factor=(0 1)
pseudoremainder-terms: P after multiplication=((1 1))
div-terms: L1=((1 1)), L2=((2 1) (0 -1))
gcd-terms: a=((2 1) (0 -1)), b=((1 1))
pseudoremainder-terms: P=((2 1) (0 -1))
pseudoremainder-terms: Q=((1 1))
pseudoremainder-terms: O1=2
pseudoremainder-terms: O2=1
pseudoremainder-terms: c=1
pseudoremainder-terms: the integerizing factor=(0 1)
pseudoremainder-terms: P after multiplication=((2 1) (0 -1))
div-terms: L1=((2 1) (0 -1)), L2=((1 1))
div-terms: L1=((0 -1)), L2=((1 1))
gcd-terms: a=((1 1)), b=((0 -1))
pseudoremainder-terms: P=((1 1))
pseudoremainder-terms: Q=((0 -1))
pseudoremainder-terms: O1=1
pseudoremainder-terms: O2=0
pseudoremainder-terms: c=-1
pseudoremainder-terms: the integerizing factor=(0 1)
pseudoremainder-terms: P after multiplication=((1 1))
div-terms: L1=((1 1)), L2=((0 -1))
div-terms: L1=(), L2=((0 -1))
gcd-terms: a=((0 -1)), b=()
div-terms: L1=((1 -1)), L2=((0 -1))
div-terms: L1=(), L2=((0 -1))
div-terms: L1=((2 -1) (0 1)), L2=((0 -1))
div-terms: L1=((0 1)), L2=((0 -1))
div-terms: L1=(), L2=((0 -1))
maprest: operation=#<procedure first-term>term-list=((1 1))
maprest: operation=#<procedure first-term>term-list=()
maprest: operation=#<procedure first-term>term-list=((2 1) (0 -1))
maprest: operation=#<procedure first-term>term-list=((0 -1))
maprest: operation=#<procedure first-term>term-list=()
full-list=(1 1 -1)
make-rat: n=(polynomial x (4 -1) (3 -1) (2 -1) (1 2) (0 1)), d=(polynomial x (5 -1) (3 1) (2 1) (0 -1))
reduce-poly: p1=(x (4 -1) (3 -1) (2 -1) (1 2) (0 1)), p2=(x (5 -1) (3 1) (2 1) (0 -1))
reduce-terms: termlist-1=((4 -1) (3 -1) (2 -1) (1 2) (0 1)), termlist-2=((5 -1) (3 1) (2 1) (0 -1))
gcd-terms: a=((4 -1) (3 -1) (2 -1) (1 2) (0 1)), b=((5 -1) (3 1) (2 1) (0 -1))
pseudoremainder-terms: P=((4 -1) (3 -1) (2 -1) (1 2) (0 1))
pseudoremainder-terms: Q=((5 -1) (3 1) (2 1) (0 -1))
pseudoremainder-terms: O1=4
pseudoremainder-terms: O2=5
pseudoremainder-terms: c=-1
pseudoremainder-terms: the integerizing factor=(0 1)
pseudoremainder-terms: P after multiplication=((4 -1) (3 -1) (2 -1) (1 2) (0 1))
div-terms: L1=((4 -1) (3 -1) (2 -1) (1 2) (0 1)), L2=((5 -1) (3 1) (2 1) (0 -1))
gcd-terms: a=((5 -1) (3 1) (2 1) (0 -1)), b=((4 -1) (3 -1) (2 -1) (1 2) (0 1))
pseudoremainder-terms: P=((5 -1) (3 1) (2 1) (0 -1))
pseudoremainder-terms: Q=((4 -1) (3 -1) (2 -1) (1 2) (0 1))
pseudoremainder-terms: O1=5
pseudoremainder-terms: O2=4
pseudoremainder-terms: c=-1
pseudoremainder-terms: the integerizing factor=(0 1)
pseudoremainder-terms: P after multiplication=((5 -1) (3 1) (2 1) (0 -1))
div-terms: L1=((5 -1) (3 1) (2 1) (0 -1)), L2=((4 -1) (3 -1) (2 -1) (1 2) (0 1))
div-terms: L1=((4 1) (3 2) (2 -1) (1 -1) (0 -1)), L2=((4 -1) (3 -1) (2 -1) (1 2) (0 1))
div-terms: L1=((3 1) (2 -2) (1 1)), L2=((4 -1) (3 -1) (2 -1) (1 2) (0 1))
gcd-terms: a=((4 -1) (3 -1) (2 -1) (1 2) (0 1)), b=((3 1) (2 -2) (1 1))
pseudoremainder-terms: P=((4 -1) (3 -1) (2 -1) (1 2) (0 1))
pseudoremainder-terms: Q=((3 1) (2 -2) (1 1))
pseudoremainder-terms: O1=4
pseudoremainder-terms: O2=3
pseudoremainder-terms: c=1
pseudoremainder-terms: the integerizing factor=(0 1)
pseudoremainder-terms: P after multiplication=((4 -1) (3 -1) (2 -1) (1 2) (0 1))
div-terms: L1=((4 -1) (3 -1) (2 -1) (1 2) (0 1)), L2=((3 1) (2 -2) (1 1))
div-terms: L1=((3 -3) (1 2) (0 1)), L2=((3 1) (2 -2) (1 1))
div-terms: L1=((2 -6) (1 5) (0 1)), L2=((3 1) (2 -2) (1 1))
gcd-terms: a=((3 1) (2 -2) (1 1)), b=((2 -6) (1 5) (0 1))
pseudoremainder-terms: P=((3 1) (2 -2) (1 1))
pseudoremainder-terms: Q=((2 -6) (1 5) (0 1))
pseudoremainder-terms: O1=3
pseudoremainder-terms: O2=2
pseudoremainder-terms: c=-6
pseudoremainder-terms: the integerizing factor=(0 36)
pseudoremainder-terms: P after multiplication=((3 36) (2 -72) (1 36))
div-terms: L1=((3 36) (2 -72) (1 36)), L2=((2 -6) (1 5) (0 1))
div-terms: L1=((2 -42) (1 42)), L2=((2 -6) (1 5) (0 1))
div-terms: L1=((1 7) (0 -7)), L2=((2 -6) (1 5) (0 1))
gcd-terms: a=((2 -6) (1 5) (0 1)), b=((1 7) (0 -7))
pseudoremainder-terms: P=((2 -6) (1 5) (0 1))
pseudoremainder-terms: Q=((1 7) (0 -7))
pseudoremainder-terms: O1=2
pseudoremainder-terms: O2=1
pseudoremainder-terms: c=7
pseudoremainder-terms: the integerizing factor=(0 49)
pseudoremainder-terms: P after multiplication=((2 -294) (1 245) (0 49))
div-terms: L1=((2 -294) (1 245) (0 49)), L2=((1 7) (0 -7))
div-terms: L1=((1 -49) (0 49)), L2=((1 7) (0 -7))
div-terms: L1=(), L2=((1 7) (0 -7))
gcd-terms: a=((1 7) (0 -7)), b=()
div-terms: L1=((4 -16807) (3 -16807) (2 -16807) (1 33614) (0 16807)), L2=((1 7) (0 -7))
div-terms: L1=((3 -33614) (2 -16807) (1 33614) (0 16807)), L2=((1 7) (0 -7))
div-terms: L1=((2 -50421) (1 33614) (0 16807)), L2=((1 7) (0 -7))
div-terms: L1=((1 -16807) (0 16807)), L2=((1 7) (0 -7))
div-terms: L1=(), L2=((1 7) (0 -7))
div-terms: L1=((5 -16807) (3 16807) (2 16807) (0 -16807)), L2=((1 7) (0 -7))
div-terms: L1=((4 -16807) (3 16807) (2 16807) (0 -16807)), L2=((1 7) (0 -7))
div-terms: L1=((2 16807) (0 -16807)), L2=((1 7) (0 -7))
div-terms: L1=((1 16807) (0 -16807)), L2=((1 7) (0 -7))
div-terms: L1=(), L2=((1 7) (0 -7))
maprest: operation=#<procedure first-term>term-list=((3 -2401) (2 -4802) (1 -7203) (0 -2401))
maprest: operation=#<procedure first-term>term-list=((2 -4802) (1 -7203) (0 -2401))
maprest: operation=#<procedure first-term>term-list=((1 -7203) (0 -2401))
maprest: operation=#<procedure first-term>term-list=((0 -2401))
maprest: operation=#<procedure first-term>term-list=()
maprest: operation=#<procedure first-term>term-list=((4 -2401) (3 -2401) (1 2401) (0 2401))
maprest: operation=#<procedure first-term>term-list=((3 -2401) (1 2401) (0 2401))
maprest: operation=#<procedure first-term>term-list=((1 2401) (0 2401))
maprest: operation=#<procedure first-term>term-list=((0 2401))
maprest: operation=#<procedure first-term>term-list=()
full-list=(-2401 -4802 -7203 -2401 -2401 -2401 2401 2401)
rational not droppable: #f
Test 33: (rational (polynomial x (3 -1) (2 -2) (1 -3) (0 -1)) polynomial x (4 -1) (3 -1) (1 1) (0 1))
#+end_src

This exercise ends the Chapter 2 of the Structure and Interpretation of
Computer programs.

The main pedagogical conclusion one may infer from this exercise is that it
is a good idea to read a book on algebra and integer algorithms.
** Chapter 3: Modularity, Objects and State [84/84]

*** DONE Exercise 3.1 accumulators
    CLOSED: [2019-10-29 Tue 10:24]

#+begin_src scheme :exports both :results output scalar code
(define (make-accumulator initial-amount)
   (lambda (increment) (set! initial-amount (+ initial-amount increment)) initial-amount))
(define A (make-accumulator 5))
(show #t "Test: (check (A 10) => 15): " (equal? (A 10) 15) "\n")
(show #t "Test: (check (A 20) => 35): " (equal? (A 20) 35) "\n")
(define B (make-accumulator 100))
(show #t "Test: (check (B 200) => 300): " (equal? (B 200) 300) "\n")
(show #t "Test: (check (B   1) => 301): " (equal? (B   1) 301) "\n")
#+end_src

#+RESULTS[ea5fe9c6a72a768d568a44d1f55bd12487d91312]:
#+begin_src scheme
Test: (check (A 10) => 15): #t
Test: (check (A 20) => 35): #t
Test: (check (B 200) => 300): #t
Test: (check (B   1) => 301): #t
#+end_src

*** DONE Exercise 3.2 make-monitored
    CLOSED: [2019-10-29 Tue 11:03]

This problem is ill-defined. In particular, it doesn't specify whether we
should be counting calls to ~f~ only, or to ~mf~ in total, including the
calls to ~'how-many-calls?~.

#+begin_src scheme :exports both :results output scalar code
  (define (make-monitored f)
    (let ((call-counter 0))
      (lambda (arg)
	(cond ((eq? arg 'reset-count) (set! call-counter 0))
	      ((eq? arg 'how-many-calls?) call-counter)
	      (else (begin (set! call-counter (+ 1 call-counter)) (f arg)))))))
  (define s (make-monitored sqrt))

  (show #t "Test: (check (s 100) => 10): " (equal? (s 100) 10) "\n")
  (show #t "Test: (check (s 'how-many-calls?) => 1): " (equal? (s 'how-many-calls?) 1)) "\n"
#+end_src

#+RESULTS[f0248ce7466e974c7873e84e9dbf3e75dda0ae11]:
#+begin_src scheme
Test: (check (s 100) => 10): #t
Test: (check (s 'how-many-calls?) => 1): #t
#+end_src

*** DONE Exercise 3.3 password protection
    CLOSED: [2019-10-29 Tue 11:17]

This exercise is slightly tricky in that it uses the less commonly used form
of ~lambda~, which can take any number of arguments.

#+begin_src scheme :exports both :results output scalar code
(define (make-account balance password)
       (define (withdraw amount)
         (if (>= balance amount)
             (begin (set! balance (- balance amount))
                    balance)
             "Insufficient funds"))
       (define (deposit amount)
         (set! balance (+ balance amount))
         balance)
       (define (dispatch pass m)
        (if (eq? pass password)
         (cond ((eq? m 'withdraw) withdraw)
               ((eq? m 'deposit) deposit)
               (else (error "Unknown request -- MAKE-ACCOUNT"
                            m)))
         (lambda rest "Incorrect password")))
       dispatch)

(define acc (make-account 100 'secret-password))

(show #t "Test: (check ((acc 'secret-password 'withdraw) 40) => 60): " (equal? ((acc 'secret-password 'withdraw) 40) 60) "\n")

(show #t "Test: (check ((acc 'some-other-password 'deposit) 50) => \"Incorrect password\"): " (equal? ((acc 'some-other-password 'deposit) 50) "Incorrect password") "\n")

#+end_src

#+RESULTS[3a6e771aa236eca173d350b94e45f0e2f438c896]:
#+begin_src scheme
Test: (check ((acc 'secret-password 'withdraw) 40) => 60): #t
Test: (check ((acc 'some-other-password 'deposit) 50) => "Incorrect password"): #t
#+end_src

*** DONE Exercise 3.4 call-the-cops
    CLOSED: [2019-10-29 Tue 11:32]


#+begin_src scheme :exports both :results output scalar code
(define (make-account balance password)
       (define (withdraw amount)
         (if (>= balance amount)
             (begin (set! balance (- balance amount))
                    balance)
             "Insufficient funds"))
       (define (deposit amount)
         (set! balance (+ balance amount))
         balance)
       (let ((cops-counter 7))
        (define (call-the-cops) "Call the cops")
        (define (dispatch pass m)
        (if (eq? pass password)
         (cond ((eq? m 'withdraw) withdraw)
               ((eq? m 'deposit) deposit)
               (else (error "Unknown request -- MAKE-ACCOUNT"
                            m)))
         (lambda rest
           (if (< 0 cops-counter)
             (begin (set! cops-counter (- cops-counter 1)) "Incorrect password")
             (call-the-cops)))))
       dispatch))

(define acc (make-account 100 'secret-password))

(show #t "Test: (check ((acc 'secret-password 'withdraw) 40) => 60): " (equal? ((acc 'secret-password 'withdraw) 40) 60) "\n")

(show #t "Test: (check ((acc 'some-other-password 'deposit) 50) => \"Incorrect password\") " 
  (equal? ((acc 'some-other-password 'deposit) 50) "Incorrect password") "\n")
(show #t "Test: (check ((acc 'some-other-password 'deposit) 50) => \"Incorrect password\") " 
  (equal? ((acc 'some-other-password 'deposit) 50) "Incorrect password") "\n")
(show #t "Test: (check ((acc 'some-other-password 'deposit) 50) => \"Incorrect password\") " 
  (equal? ((acc 'some-other-password 'deposit) 50) "Incorrect password") "\n")
(show #t "Test: (check ((acc 'some-other-password 'deposit) 50) => \"Incorrect password\") " 
  (equal? ((acc 'some-other-password 'deposit) 50) "Incorrect password") "\n")
(show #t "Test: (check ((acc 'some-other-password 'deposit) 50) => \"Incorrect password\") " 
  (equal? ((acc 'some-other-password 'deposit) 50) "Incorrect password") "\n")
(show #t "Test: (check ((acc 'some-other-password 'deposit) 50) => \"Incorrect password\") " 
  (equal? ((acc 'some-other-password 'deposit) 50) "Incorrect password") "\n")
(show #t "Test: (check ((acc 'some-other-password 'deposit) 50) => \"Incorrect password\") " 
  (equal? ((acc 'some-other-password 'deposit) 50) "Incorrect password") "\n")
(show #t "Test: (check ((acc 'some-other-password 'deposit) 50) => \"Call the cops\") " 
  (equal? ((acc 'some-other-password 'deposit) 50) "Call the cops") "\n")

#+end_src

#+RESULTS[22d704aeaf1eea5a9125cf479a049a194c91962a]:
#+begin_src scheme
Test: (check ((acc 'secret-password 'withdraw) 40) => 60): #t
Test: (check ((acc 'some-other-password 'deposit) 50) => "Incorrect password") #t
Test: (check ((acc 'some-other-password 'deposit) 50) => "Incorrect password") #t
Test: (check ((acc 'some-other-password 'deposit) 50) => "Incorrect password") #t
Test: (check ((acc 'some-other-password 'deposit) 50) => "Incorrect password") #t
Test: (check ((acc 'some-other-password 'deposit) 50) => "Incorrect password") #t
Test: (check ((acc 'some-other-password 'deposit) 50) => "Incorrect password") #t
Test: (check ((acc 'some-other-password 'deposit) 50) => "Incorrect password") #t
Test: (check ((acc 'some-other-password 'deposit) 50) => "Call the cops") #t
#+end_src

*** DONE Exercise 3.5 Monte-Carlo
    CLOSED: [2019-10-30 Wed 00:12]

I am using the random function first defined in Exercise 1.24, not the
rand-update, because I am not very sure in my prng development skills.

#+begin_src scheme :exports both :results output scalar code
  <<random>>
  (define (random-in-range low high)
      (let ((range (- high low)))
      (+ low (random range))))
  (show #t "Test 01: " (random-in-range 1 2000) "\n")

  (define (monte-carlo trials experiment)
    (define (iter trials-remaining trials-passed)
      (cond ((= trials-remaining 0)
	     (/ trials-passed trials))
	    ((experiment)
	     (iter (- trials-remaining 1) (+ trials-passed 1)))
	    (else
	     (iter (- trials-remaining 1) trials-passed))))
    (iter trials 0))

  (define (is-inside-circle? x y radius)
    #;(show #t "x=" x ", y=" y "\n")
    (if (< (+ (expt (- x 1000) 2) (expt (- y 1000) 2)) (expt radius 2))
	#t
	#f))

  (define (estimate-integral P x1 x2 y1 y2 trials)
    #;(show #t "estimate-integral: x1=" x1 ", x2=" x2 ", y1=" y1 ", y2=" y2 ", trials=" trials "\n")
    (monte-carlo trials
		 (lambda ()
		   (P (random-in-range x1 x2) (random-in-range y1 y2)))))

  (define (estimate-pi trials)
    (inexact (* 4 (estimate-integral
	  (lambda (x y) (is-inside-circle? x y 1000)) 1 2000 1 2000 trials))))
(show #t "Test 02: " (estimate-pi 100100) "\n")
#+end_src

#+RESULTS[b8c4b2f83b9877d1d2a9f511fc18e6597353689d]:
#+begin_src scheme
Test 01: 38
Test 02:3.1442157842157843
#+end_src

It took me more time to understand what exactly is wanted than to write the
actual code.

*** DONE Exercise 3.6 reset a prng
    CLOSED: [2019-10-30 Wed 11:42]

All three components in the random formula are primes. Is this good?

#+begin_src scheme :exports both :results output scalar code
  (define rand
    (let ((seed 1))
      (define (rand-update x)
	(remainder (+ (* x 111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111389)
		      211111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111801)
		   2111111111111111111111111111111111111111227))
      (lambda (operation)
	(case operation
	  ('generate (begin (show #t "Seed=" seed "\n") (set! seed (rand-update seed)) seed))
	  ('reset (lambda (number)
		    (set! seed number)))
	  (else (error "rand: wrong operation" operation))))))
  (show #t "Test 01: First random call: " (rand 'generate) "\n")

  ((rand 'reset) 100)

  (show #t "Test 02: Second random call: " (rand 'generate) "\n")
#+end_src

#+RESULTS[59cf48b620e440cebb36771995a32a567fb9ec15]:
#+begin_src scheme
Seed=1
Test 01: First random call: 473684210526315790444679008925823330256457
Seed=100
Test 02: Second random call: 701754385964912314820502646968297937855541
#+end_src

*** DONE Exercise 3.7 Joint accounts
    CLOSED: [2019-10-30 Wed 13:07]

This exercise illustrates a fairly common thing in programming called
"wrapping" or "interfacing".

#+begin_src scheme :exports both :results output scalar code
(define (make-account balance password)
       (define (withdraw amount)
         (if (>= balance amount)
             (begin (set! balance (- balance amount))
                    balance)
             "Insufficient funds"))
       (define (deposit amount)
         (set! balance (+ balance amount))
         balance)
       (define (dispatch pass m)
        (if (eq? pass password)
         (cond ((eq? m 'withdraw) withdraw)
               ((eq? m 'deposit) deposit)
               (else (error "Unknown request -- MAKE-ACCOUNT"
                            m)))
         (lambda rest "Incorrect password")))
       dispatch)
(define acc (make-account 100 'secret-password))
(show #t "Test: (check ((acc 'secret-password 'withdraw) 40) => 60): " (equal? ((acc 'secret-password 'withdraw) 40) 60) "\n")
(show #t "Test: (check ((acc 'some-other-password 'deposit) 50) => \"Incorrect password\"): " 
  (equal? ((acc 'some-other-password 'deposit) 50) "Incorrect password") "\n")
(define (make-joint account main-password sub-password)
 (define (dispatch pass m)
        (if (eq? pass sub-password)
         (account main-password m)
         (lambda rest "Incorrect password")))
 dispatch)
(define peter-acc (make-account 100 'open-sesame))
(define paul-acc
 (make-joint peter-acc 'open-sesame 'rosebud))
(show #t "Test: (check ((peter-acc 'open-sesame 'withdraw) 40) => 60): " (equal? ((peter-acc 'open-sesame 'withdraw) 40) 60) "\n")
(show #t "Test: (check ((paul-acc  'rosebud     'deposit)  50) => 110): " (equal? ((paul-acc  'rosebud     'deposit)  50) 110) "\n")
#+end_src

#+RESULTS[619d08dddec9ac7b863db752b4663cdcacbfe9ae]:
#+begin_src scheme
Test: (check ((acc 'secret-password 'withdraw) 40) => 60): #t
Test: (check ((acc 'some-other-password 'deposit) 50) => "Incorrect password"): #t
Test: (check ((peter-acc 'open-sesame 'withdraw) 40) => 60): #t
Test: (check ((paul-acc  'rosebud     'deposit)  50) => 110): #t
#+end_src

*** DONE Exercise 3.8 Right-to-left vs Left-to-right
    CLOSED: [2019-10-30 Wed 13:45]

#+begin_src scheme :exports both :results output scalar code

(define (make-lock a)
  (lambda (arg)
    (if (= arg 0)
       (set! a 0))
    a))
(define f (make-lock 100))

(show #t "Test 01:" (+ (f 0) (f 1)) "\n")

(define-syntax plus-oneway
  (syntax-rules ()
    ((plus-oneway a b) (let* ((first a)
                              (second b))
                           (+ first second)))))
(define-syntax plus-otherway
  (syntax-rules ()
    ((plus-otherway a b) (let* ((first b)
                                (second a))
                           (+ first second)))))
(define g (make-lock 101))
(define h (make-lock 201))
(show #t "Test 02:" (plus-oneway   (g 0) (g 1)) "\n")
(show #t "Test 03:" (plus-otherway (h 0) (h 1)) "\n")

#+end_src

#+RESULTS[2ff92dc5061d37230916530575dec911bb64b2c8]:
#+begin_src scheme
Test 01:100
Test 02:0
Test 03:201
#+end_src

This is a fun exercise, which is nicely illustrated using
macros. Unlike ~+~, ~let*~ is guaranteed to evaluate its parameters
top to bottom, so we can specify the order of evaluation. The order of
evaluation in the next ~+~ does not matter, because its arguments are
already values and so evaluate to themselves.

*** DONE Exercise 3.9 Environment structures
    CLOSED: [2019-11-20 Wed 14:28]

Okay, this is not a very good solution. I only display the
environments, and the code is only displayed to clarify the
environments. The ~if~ special forms are expanded.

Let us draw the environment number 1.

#+name: exercise-3-9-part-1
#+header: :imagemagick yes :iminoptions -density 300 :imoutoptions -geometry 1000
#+header: :fit yes :headers '("\\usepackage{tikz} \\usetikzlibrary{positioning,fit,petri,arrows}")
#+header: :buffer on
#+begin_src latex :results raw file :exports both :file exercise-3-9-part-1.png
\begin{tikzpicture}[inner sep=0mm,>=stealth',very thick,color=blue,
     font=\sffamily,pics/two dots/.style={code={
     \node [draw,minimum size=5mm,circle,colored tokens={blue!99}]
     (#1-left) {};
    \node [draw,minimum size=5mm,circle,colored tokens={blue!99},
    right=0pt of #1-left]
        (#1-right) {};
    \node [rectangle, fit=(#1-left) (#1-right)] (#1){};
    }},
    every pin edge/.style={<-,very thick},
    box/.style={draw,rectangle,inner sep=#1},box/.default=2mm]
  %
  \node (W1)  {factorial:};
  \node (fake1) [right=190mm of W1] {};
  %
  \node (g env) [box, fit=(W1) (fake1),
  pin={[text width=1cm,pin distance=10mm]left:global env}]
  { };
  %
  \path ([yshift=-20mm]W1.east)pic{two dots=w1fun}
    (w1fun) edge [<-, to path={|- (\tikztotarget)}] (W1.east);
  %
  \node [below=of w1fun-left, align=left] {parameters: n \\ body: \dots}
    edge [<-] (w1fun-left.center);

  \path (w1fun-right.center) edge[->,to path={-| (\tikztotarget)}]
    (node cs:name=g env,angle=183);
\path (g env.south west) -- (g env.south east)
\foreach \idx in {1,...,5}
{
  node [pos=1/7.5+\idx/7.5] (fake2-\idx)  {}
  node (E\idx-env) [below=5mm of fake2-\idx,box,
    pin={[pin distance=5mm]left:E\idx}] {n:\idx}
    edge [->] (fake2-\idx)

  node (E\idx-code) [below=5mm of E\idx-env, align=center]{
       (* \the\numexpr7-\idx \hskip5pt (factorial \the\numexpr6-\idx))
    }
}
node [pos=1/7.5+6/7.5] (fake2-6) {}
node (E6-env) [below=5mm of fake2-6,box,
    pin={[pin distance=5mm]left:E6}] {n:1}
    edge [->] (fake2-6)
node (E6-code) [below=5mm of E6-env, align=center]{
       1
    };
%\draw (g env.south east) node [draw=red,rectangle]  {debug};
\end{tikzpicture}
#+end_src

#+RESULTS[1c3cb625348848485fe0a4892804aa83f6a85f41]: exercise-3-9-part-1
[[file:exercise-3-9-part-1.png]]


Let us draw the environment number 2.


#+name: exercise-3-9-part-2
#+header: :imagemagick yes :iminoptions -density 300 :imoutoptions -geometry 1000
#+header: :fit yes :headers '("\\usepackage{tikz} \\usetikzlibrary{positioning,fit,petri,arrows}")
#+header: :buffer on
#+begin_src latex :results raw file :exports both :file exercise-3-9-part-2.png
\begin{tikzpicture}[inner sep=0mm,>=stealth',very thick,color=blue!99,
     font=\sffamily,pics/two dots/.style={code={
     \node [draw,minimum size=5mm,circle,colored tokens={blue!99}]
     (#1-left) {};
    \node [draw,minimum size=5mm,circle,colored tokens={blue!99},
    right=0pt of #1-left]
        (#1-right) {};
    \node [rectangle, fit=(#1-left) (#1-right)] (#1){};
    }},
    every pin edge/.style={<-,very thick},
    box/.style={draw,rectangle,inner sep=#1},box/.default=2mm]

  \node (W1)   {factorial:};
  \node (fake1) [right=340mm of W1] {};
  \node (fact-iter) [above=1mm of W1] {fact-iter:};
%
  \node (g env) [box, fit=(W1) (fake1) (fact-iter),
  pin={[text width=1cm,pin distance=10mm]left:global env}]
  { };
  % factorial
  \path ([yshift=-20mm]W1.east)pic{two dots=w1fun}
    (w1fun) edge [<-, to path={|- (\tikztotarget)}] (W1.east);
  \node [below=of w1fun-left, align=left] {\ttfamily \noindent parameters:\vphantom{d}n \\ body: \dots}
    edge [<-] (w1fun-left.center);
  \draw[->] (w1fun-right.center) -| ([xshift=3mm] w1fun-right.east |- g env.south);

  % fact-iter
\path coordinate[base right=22mm of w1fun.east] (aux)
    (aux) pic{two dots=fact-iter-fun}
    (fact-iter-fun) edge [<-, to path={|- (\tikztotarget)}] (fact-iter.east);
  \node [below=of fact-iter-fun-left, align=left,node font=\ttfamily] {
     parameters:product,\\
     \phantom{parameters:}counter,\\
     \phantom{parameters:}max-count \\ body: \dots}
    edge [<-] (fact-iter-fun-left.center);
  \draw[->] (fact-iter-fun-right.center) -| ([xshift=3mm] fact-iter-fun-right.east |- g env.south);

\path (g env.south west) -- (g env.south east)
\foreach \idx in {1,...,6}
{

  node [pos=2.6/7.5+\idx/11] (fake2-\idx)  {}
  node (E\idx-env) [below=5mm of fake2-\idx,box,
    pin={[pin distance=5mm]left:E\idx}, align=left] {
        counter:\idx\\
        product:\pgfmathparse{int(factorial(\idx-1))}\pgfmathresult \\
        max-count:6}
    edge [->] (fake2-\idx)

  node (E\idx-code) [below=5mm of E\idx-env, align=left]{
       (fact-iter\\
        (* counter product) \\
       (+ counter 1)  \\
       max-count)
    }
}
node [pos=2.6/7.5+7/11] (fake2-7) {}
node (E7-env) [below=5mm of fake2-7,box,
    pin={[pin distance=5mm]left:E7},align=left]
    {counter:7\\
     product:\pgfmathparse{int(factorial(7-1))}\pgfmathresult \\
     max-count:6
    }
    edge [->] (fake2-7)
node (E7-code) [below=5mm of E7-env, align=center]{
       720
    }
node [pos=2.0/7.5] (fake2-0) {}
node (E0-env) [below=5mm of fake2-0, box,
    pin={[pin distance=5mm]left:E0},align=left]
    {n:6}
    edge [->] (fake2-0)
node (E0-code) [below=5mm of E0-env, align=left]{
  (fact-iter 1 1 n)}
;

\end{tikzpicture}
#+end_src

#+RESULTS[419a7ea7516feed374f65d4b7f0e45629f8cc855]: exercise-3-9-part-2
[[file:exercise-3-9-part-2.png]]

These pictures would have never happened unless generous people from
TeX StackExchange had helped.

 - https://tex.stackexchange.com/questions/515909/how-to-make-this-tikz-picture-more-idiomatic-environment-diagram/515913
 - https://tex.stackexchange.com/questions/516560/how-to-place-evenly-spaced-nodes-in-tikz-from-node1-to-node2
 - https://tex.stackexchange.com/questions/517061/how-to-debug-token-positions-in-petri-nets-in-tikz
 - https://tex.stackexchange.com/questions/517217/how-is-text-indented-and-glued-within-tikz-node-contents

I feel that these diagrams are already quite cluttered, so I am
implicitly expanding ~if~ forms in the "code" blocks. I am also
ignoring top level commands and I am not drawing arrows when function
calls occur.[fn:2]

*** DONE Exercise 3.10 Using ~let~ to create state variables
    CLOSED: [2019-11-25 Mon 12:52]

We need to compare two versions of ~make-withdraw~, the one using a
parameter variable as a state variable, the one created automatically,
and the one which creates a state variable explicitly using ~let~.

The first one:

#+begin_src scheme :exports code :results none
(define (make-withdraw balance)
  (lambda (amount)
    (if (>= balance amount)
      (begin (set! balance (- balance amount))
             balance)
"Insufficient funds")))
#+end_src

#+name: exercise-3-10-part-1
#+header: :imagemagick yes :iminoptions -density 300 :imoutoptions -geometry 1000
#+header: :fit yes :headers '("\\usepackage{tikz} \\usetikzlibrary{positioning,fit,petri,arrows}")
#+header: :buffer on
#+begin_src latex :results raw file :exports both :file exercise-3-10-part-1.png
\begin{tikzpicture}[inner sep=0mm,>=stealth',very thick,color=blue!99,
     font=\sffamily,pics/two dots/.style={code={
     \node [draw,minimum size=5mm,circle,colored tokens={blue!99}]
     (#1-left) {};
    \node [draw,minimum size=5mm,circle,colored tokens={blue!99},
    right=0pt of #1-left]
        (#1-right) {};
    \node [rectangle, fit=(#1-left) (#1-right)] (#1){};
    }},
    every pin edge/.style={<-,very thick},
    box/.style={draw,rectangle,inner sep=#1},box/.default=2mm]

  \node (W1)   {make-withdraw:};
  \node (fake1) [right=100mm of W1] {};
  \node (fact-iter) [above=3mm of W1.west,anchor=west] {W1:};
%
  \node (g env) [box, fit=(W1) (fake1) (fact-iter),
  pin={[text width=1cm,pin distance=10mm]left:global env}]
  { };

  \path ([yshift=-20mm]W1.east)pic{two dots=w1fun}
    (w1fun) edge [<-, to path={|- (\tikztotarget)}] (W1.east);
  \node [below=of w1fun-left, align=left,font=\ttfamily]
{\noindent parameters:\vphantom{d}balance \\
body:\\
  (lambda (amount)\\
    (if (>= balance amount)\\
      (begin (set! balance\\ (- balance amount))\\
             balance)\\
"Insufficient funds"))
}
    edge [<-] (w1fun-left.center);
  \draw[->] (w1fun-right.center) -| ([xshift=3mm] w1fun-right.east |- g env.south);

\path (g env.south west) -- (g env.south east)
node [pos=7/8] (fake2-7) {}
node (E7-env) [below=5mm of fake2-7,box,
    pin={[pin distance=5mm]left:E1},align=left]
    {balance:100}
    edge [->] (fake2-7) ;

\path coordinate[below right=5mm and 40mm of w1fun] (aux)
    (aux) pic{two dots=fact-iter-fun}
    (fact-iter-fun) edge [<-, to path={|- (\tikztotarget)}] (fact-iter.east);
  \node [below=of fact-iter-fun-left, align=left,node font=\ttfamily] {
     parameters:amount \\
     body: (if (>= balance amount)\\
      (begin (set! balance\\ (- balance amount))\\
             balance)}
    edge [<-] (fact-iter-fun-left.center);
  \draw[->] (fact-iter-fun-right.center) -|  (E7-env.south);


\end{tikzpicture}
#+end_src

#+RESULTS[420c0e52d4024a45e2813d15c4dbe80dfe0b95c3]: exercise-3-10-part-1
[[file:exercise-3-10-part-1.png]]


The second one:

#+begin_src scheme :exports code :results none
  (define (make-withdraw initial-amount)
  (let ((balance initial-amount))
  (lambda (amount)
  (if (>= balance amount)
  (begin (set! balance (- balance amount))
  balance)
  "Insufficient funds"))))
#+end_src

#+name: exercise-3-10-part-2
#+header: :imagemagick yes :iminoptions -density 300 :imoutoptions -geometry 1000
#+header: :fit yes :headers '("\\usepackage{tikz} \\usetikzlibrary{positioning,fit,petri,arrows}")
#+header: :buffer on
#+begin_src latex :results raw file :exports both :file exercise-3-10-part-2.png
\begin{tikzpicture}[inner sep=0mm,>=stealth',very thick,color=blue!99,
     font=\sffamily,pics/two dots/.style={code={
     \node [draw,minimum size=5mm,circle,colored tokens={blue!99}]
     (#1-left) {};
    \node [draw,minimum size=5mm,circle,colored tokens={blue!99},
    right=0pt of #1-left]
        (#1-right) {};
    \node [rectangle, fit=(#1-left) (#1-right)] (#1){};
    }},
    every pin edge/.style={<-,very thick},
    box/.style={draw,rectangle,inner sep=#1},box/.default=2mm]

  \node (W1)   {make-withdraw:};
  \node (fake1) [right=100mm of W1] {};
  \node (fact-iter) [above=3mm of W1.west,anchor=west] {W1:};
%
  \node (g env) [box, fit=(W1) (fake1) (fact-iter),
  pin={[text width=1cm,pin distance=10mm]left:global env}]
  { };

  \path ([yshift=-20mm]W1.east)pic{two dots=w1fun}
    (w1fun) edge [<-, to path={|- (\tikztotarget)}] (W1.east);
  \node [below=of w1fun-left, align=left,font=\ttfamily]
{\noindent parameters:initial-amount \\
body:\\
(let ((balance initial-amount))\\
  (lambda (amount)\\
  (if (>= balance amount)\\
  (begin (set! balance\\ (- balance amount))\\
  balance)\\
  "Insufficient funds"))
}
    edge [<-] (w1fun-left.center);
  \draw[->] (w1fun-right.center) -| ([xshift=3mm] w1fun-right.east |- g env.south);

\path (g env.south west) -- (g env.south east)
node [pos=7/8] (fake2-7) {}
node (E7-env) [below=5mm of fake2-7,box,
    pin={[pin distance=5mm]left:E1},align=left]
    {initial-amount:100}
    edge [->] (fake2-7)
node (E2) [below=5mm of E7-env,box,
    pin={[pin distance=5mm]left:E2},align=left]
    {balance:100}
    edge [->] (E7-env)

;

\path coordinate[below right=15mm and 40mm of w1fun] (aux)
    (aux) pic{two dots=fact-iter-fun}
    (fact-iter-fun) edge [<-, to path={|- (\tikztotarget)}] (fact-iter.east);
  \node [below=of fact-iter-fun-left, align=left,node font=\ttfamily] {
     parameters:amount \\
     body: (if (>= balance amount)\\
      (begin (set! balance\\ (- balance amount))\\
             balance)}
    edge [<-] (fact-iter-fun-left.center);
  \draw[->] (fact-iter-fun-right.center) -|  (E2);

\end{tikzpicture}
#+end_src

#+RESULTS[d680b352ce7c5b7cbb7d7a6d979a4638d1fece16]: exercise-3-10-part-2
[[file:exercise-3-10-part-2.png]]

I think these two diagrams explain things quite well. An additional
~let~ creates an additional frame, which is visible on the figure
[[exercise-3-10-part-2]].

*** DONE Exercise 3.11 Internal definitions
    CLOSED: [2019-11-26 Tue 12:44]

This is a huge task. Let us first draw ~make-account~, and then
improve on it.

#+name: exercise-3-11-part-1
#+header: :imagemagick yes :iminoptions -density 300 :imoutoptions -geometry 1000
#+header: :fit yes :headers '("\\usepackage{tikz} \\usetikzlibrary{positioning,fit,petri,arrows,calc}")
#+header: :buffer on
#+begin_src latex :results raw file :exports both :file exercise-3-11-part-1.png
  \begin{tikzpicture}[inner sep=0mm,>=stealth',very thick,color=blue!99,
       font=\sffamily,pics/two dots/.style={code={
       \node [draw,minimum size=5mm,circle,colored tokens={blue!99}]
       (#1-left) {};
      \node [draw,minimum size=5mm,circle,colored tokens={blue!99},
      right=0pt of #1-left]
	  (#1-right) {};
      \node [rectangle, fit=(#1-left) (#1-right)] (#1){};
      }},
      every pin edge/.style={<-,very thick},
      box/.style={draw,rectangle,inner sep=#1},box/.default=2mm,
      node distance=4mm]

    \node (W1)   {make-account:};
    \node (fake1) [right=100mm of W1] {};
    \node (fact-iter) [above=3mm of W1.west,anchor=west] {acc:};
  %
    \node (g env) [box, fit=(W1) (fake1) (fact-iter),
    pin={[text width=1cm,pin distance=10mm]left:global env}]
    { };

    \path ([yshift=-20mm]W1.east)pic{two dots=w1fun}
      (w1fun) edge [<-, to path={|- (\tikztotarget)}] (W1.east);
    \node [below=5mm of w1fun-left, align=left,font=\ttfamily]
  {\noindent parameters:\vphantom{d}balance \\
  body:\\
  (define (withdraw amount)\\
  (if (>= balance amount)\\
  (begin (set! balance\\ (- balance amount))\\
  balance)\\
  "Insufficient funds"))\\
  (define (deposit amount)\\
  (set! balance (+ balance amount))\\
  balance)\\
  (define (dispatch m)\\
  (cond ((eq? m 'withdraw) withdraw)\\
  ((eq? m 'deposit) deposit)\\
  (else\\
  (error "Unknown request: MAKE-ACCOUNT"\\
  m))))\\
  dispatch
  }
      edge [<-] (w1fun-left.center);
    \draw[->] (w1fun-right.center) -| ([xshift=3mm] w1fun-right.east |- g env.south);

  \path (g env.south west) -- (g env.south east)
  node [pos=7/8] (fake2-7) {}
  node (balance-var)  [below=6mm of fake2-7] {\vphantom{l}balance:30}
  node (withdraw-var) [below=of balance-var.west,anchor=west] {\vphantom{l}withdraw:}
  node (deposit-var)  [below=of withdraw-var.west,anchor=west] {\vphantom{l}deposit:}
  node (E7-env) [box,
      pin={[pin distance=5mm]left:E1},align=left,
      fit=(balance-var) (deposit-var) (withdraw-var)]
      {}
  edge [->] (fake2-7) ;

  \path coordinate[below right=5mm and 40mm of w1fun] (aux)
      (aux) pic{two dots=fact-iter-fun}
      (fact-iter-fun) edge [<-, to path={|- (\tikztotarget)}] (fact-iter.east);
  \node [below=5mm of fact-iter-fun-left, align=left,node font=\ttfamily] {
       parameters:m \\
       body: (cond ((eq? m 'withdraw) withdraw)\\
	     ((eq? m 'deposit) deposit)\\
	     (else\\
	     (error "Unknown request: MAKE-ACCOUNT"\\
	     m)))
      }
   edge [<-] (fact-iter-fun-left.center);
  \draw[->] (fact-iter-fun-right.center) -|  ($ (E7-env.south) - (5mm,0mm) $);

  \path coordinate[below right=10mm and 13mm of E7-env.south] (aux)
      (aux) pic{two dots=deposit}
      (deposit) edge [<-, to path={|- (\tikztotarget)}] (deposit-var.east);
  \node [below=5mm of deposit-left, align=left,node font=\ttfamily] {
       parameters:amount \\
       body:  (set! balance\\ (+ balance amount))\\
              balance
      }
   edge [<-] (deposit-left.center);
  \draw[->] (deposit-right.center) |- (fact-iter-fun -| E7-env.south) -|  ($ (E7-env.south) - (0mm,0mm) $);

  \path coordinate[below right=10mm and 50mm of E7-env.south] (aux)
      (aux) pic{two dots=withdraw}
      (withdraw) edge [<-, to path={|- (\tikztotarget)}] (withdraw-var.east);
  \node [below=5mm of withdraw-left, align=left,node font=\ttfamily] {
       parameters:amount \\
       body:  (set! balance\\ (- balance amount))\\
              balance
      }
   edge [<-] (withdraw-left.center);
  \draw[->] (withdraw-right.center) |-  ($ (E7-env.east) + (0mm,5mm) $);

  \end{tikzpicture}
#+end_src

#+RESULTS[436b06b7d964f7d6c8ea65f58bca05ff84ab8eb2]: exercise-3-11-part-1
[[file:exercise-3-11-part-1.png]]

I am not plotting the intermediate environments, that is too much
work, but the important thing is that when ~acc~ is evaluated, the
evaluation frame is appended to the environment E1, and the lookup is
performed in the enclosing environment, including the bindings for
~dispatch~ and ~withdraw~.

The state for ~acc~ is kept in the environment E1.

If we to define ~acc2~, the frame in which we define it would mean a
lot. Let us assume that we define ~acc2~ at the top level. This would
mean that now we would have two environments, E1 and E2 pointing, both
the children of the global environment. Only the global definitions
(that is ~make-account~, ~acc1~ and ~acc2~) would be shared.

*** DONE Exercise 3.12 Drawing ~append!~
    CLOSED: [2019-11-29 Fri 11:55]

Now we need to draw box-and-pointer diagrams for the two variants of ~append~.

The first ~append~ can be drawn like this:

#+name: exercise-3-12-part1
#+header: :imagemagick yes :iminoptions -density 300 :imoutoptions -geometry 1000
#+header: :fit yes :headers '("\\usepackage{tikz} \\usetikzlibrary{positioning,fit,petri,arrows,calc}")
#+header: :buffer on
#+begin_src latex :results raw file :exports both :file exercise-3-12-part1.png

\begin{tikzpicture}[inner sep=0mm,>=stealth',very thick,color=blue!99,
      font=\sffamily,
      node distance=20mm,
      pics/cons cell/.style n args={3}{code={
      \coordinate (origin);
      \node[anchor=east,minimum size=10mm,inner sep=0] (#1-car) at(0,0) {};
      \node[anchor=west,minimum size=10mm,inner sep=0] (#1-cdr) at(0,0) {};
      \node[name=#1-box,fit=(#1-car) (#1-cdr),draw,shape=rectangle,rounded
 corners=0.5mm]  {};
      \draw[shorten <=1pt, shorten >=1pt] (#1-box.south -| origin) -- (#1-box.north -| origin);
      \if#2t
      % \path node[shape=circle,fill,draw,radius=2mm] at (#1-car.center) {};
      \filldraw (#1-car.center) circle[radius=0.66mm] ;
      \else
      \draw[shorten <=1pt] (#1-car.south west) to (#1-car.north east);
      \fi
      \if#3t
      \filldraw (#1-cdr.center) circle[radius=0.66mm] ;
      \else
      \draw[shorten >=1pt] (#1-cdr.south west) to (#1-cdr.north east);
      \fi
      }},
      pics/cons element/.style n args={2}{code={
      \node [minimum size=10mm,inner sep=0,rounded corners=1mm, draw, shape=rectangle] (#1) {#2};
      }},
      box/.style={draw,rectangle,inner sep=#1},box/.default=2mm,
      ]
\node (x) {x};
\node[right=200mm of x] {};
\pic[right=of x] {cons cell={cell-a}{t}{t}};
\draw[->] (x) to (cell-a-box);
\pic[below=of cell-a-car] {cons element={a}{a}};
\pic[right=of cell-a-cdr] {cons cell={cell-b}{t}{f}};
\pic[below=of cell-b-car] {cons element={b}{b}};
\draw[->] (cell-a-cdr.center) to (cell-b-box);
\draw[->] (cell-a-car.center) to (a);
\draw[->] (cell-b-car.center) to (b);

\node[right=of cell-b-box] (y) {y};
\pic[right=of y] {cons cell={cell-c}{t}{t}};
\draw[->] (y) to (cell-c-box);
\pic[below=of cell-c-car] {cons element={c}{c}};
\pic[right=of cell-c-cdr] {cons cell={cell-d}{t}{f}};
\pic[below=of cell-d-car] {cons element={d}{d}};
\draw[->] (cell-c-cdr.center) to (cell-d-box);
\draw[->] (cell-c-car.center) to (c);
\draw[->] (cell-d-car.center) to (d);

\node[below=50mm of x] (z) {z};
\pic[right=of z] {cons cell={cell-a-2}{t}{t}};
\draw[->] (z) to (cell-a-2-box);
\pic[below=of cell-a-2-car] {cons element={a2}{a}};
\pic[right=of cell-a-2-cdr] {cons cell={cell-b-2}{t}{t}};
\pic[below=of cell-b-2-car] {cons element={b2}{b}};
\pic[right=of cell-b-2-cdr] {cons cell={cell-c-2}{t}{t}};
\pic[below=of cell-c-2-car] {cons element={c2}{c}};
\pic[right=of cell-c-2-cdr] {cons cell={cell-d-2}{t}{f}};
\pic[below=of cell-d-2-car] {cons element={d2}{d}};


\draw[->] (cell-a-2-cdr.center) to (cell-b-2-box);
\draw[->] (cell-a-2-car.center) to (a2);
\draw[->] (cell-b-2-car.center) to (b2);
\draw[->] (cell-b-2-cdr.center) to (cell-c-2-box);
\draw[->] (cell-c-2-car.center) to (c2);
\draw[->] (cell-c-2-cdr.center) to (cell-d-2-box);
\draw[->] (cell-d-2-car.center) to (d2);


\end{tikzpicture}
#+end_src

#+RESULTS[a995a86a4b18fd6099de62db5fbe3169429a2176]: exercise-3-12-part1
[[file:exercise-3-12-part1.png]]



#+begin_src scheme :exports both :results value scalar code
?
(define x (list 'a 'b))
(define y (list 'c 'd))
(define z (append x y))
z
(cdr x)

#+end_src

#+RESULTS[599a42a776d817b9e96d8c4cab693f8e4c6bc1d4]:
#+begin_src scheme
(b)
#+end_src


The second append, done with ~append!~ , modifies ~x~.

#+name: exercise-3-12-part2
#+header: :imagemagick yes :iminoptions -density 300 :imoutoptions -geometry 1000
#+header: :fit yes :headers '("\\usepackage{tikz} \\usetikzlibrary{positioning,fit,petri,arrows,calc}")
#+header: :buffer on
#+begin_src latex :results raw file :exports both :file exercise-3-12-part2.png

\begin{tikzpicture}[inner sep=0mm,>=stealth',very thick,color=blue!99,
      font=\sffamily,
      node distance=20mm,
      pics/cons cell/.style n args={3}{code={
      \coordinate (origin);
      \node[anchor=east,minimum size=10mm,inner sep=0] (#1-car) at(0,0) {};
      \node[anchor=west,minimum size=10mm,inner sep=0] (#1-cdr) at(0,0) {};
      \node[name=#1-box,fit=(#1-car) (#1-cdr),draw,shape=rectangle,rounded
 corners=0.5mm]  {};
      \draw[shorten <=1pt, shorten >=1pt] (#1-box.south -| origin) -- (#1-box.north -| origin);
      \if#2t
      % \path node[shape=circle,fill,draw,radius=2mm] at (#1-car.center) {};
      \filldraw (#1-car.center) circle[radius=0.66mm] ;
      \else
      \draw[shorten <=1pt] (#1-car.south west) to (#1-car.north east);
      \fi
      \if#3t
      \filldraw (#1-cdr.center) circle[radius=0.66mm] ;
      \else
      \draw[shorten >=1pt] (#1-cdr.south west) to (#1-cdr.north east);
      \fi
      }},
      pics/cons element/.style n args={2}{code={
      \node [minimum size=10mm,inner sep=0,rounded corners=1mm, draw, shape=rectangle] (#1) {#2};
      }},
      box/.style={draw,rectangle,inner sep=#1},box/.default=2mm,
      ]
\node (x) {x};
\node[right=200mm of x] {};
\pic[right=of x] {cons cell={cell-a}{t}{t}};
\draw[->] (x) to (cell-a-box);
\pic[below=of cell-a-car] {cons element={a}{a}};
\pic[right=of cell-a-cdr] {cons cell={cell-b}{t}{t}};
\pic[below=of cell-b-car] {cons element={b}{b}};
\draw[->] (cell-a-cdr.center) to (cell-b-box);
\draw[->] (cell-a-car.center) to (a);
\draw[->] (cell-b-car.center) to (b);

\node[right=of cell-b-box] (y) {y};
\pic[right=of y] {cons cell={cell-c}{t}{t}};
\draw[->] (y) to (cell-c-box);
\pic[below=of cell-c-car] {cons element={c}{c}};
\pic[right=of cell-c-cdr] {cons cell={cell-d}{t}{f}};
\pic[below=of cell-d-car] {cons element={d}{d}};
\draw[->] (cell-c-cdr.center) to (cell-d-box);
\draw[->] (cell-c-car.center) to (c);
\draw[->] (cell-d-car.center) to (d);
%\draw (cell-b-cdr.center) -- controls (5cm,1cm) and (6cm,1cm) -- (cell-c-box.center);
\draw[->] (cell-b-cdr.center) .. controls ($ (y.north) + (0,5mm) $) .. (cell-c-box);

\node[above=of cell-a-car] (w) {w};
\draw[->] (w) to (cell-a-car);

\end{tikzpicture}
#+end_src

#+RESULTS[f93c38a68777fae982df6f9569595101011bf8b1]: exercise-3-12-part2
[[file:exercise-3-12-part2.png]]


Therefore, the answer is the following:

#+begin_src scheme :exports both :results value scalar code
<<last-pair>>
(define (append! x y)
(set-cdr! (last-pair x) y)
x)

(define x (list 'a 'b))
(define y (list 'c 'd))
(define w (append! x y))
w
(cdr x)
#+end_src

#+RESULTS[eb8f6fca44ef4f38110986b35ab4d3f96cc32615]:
#+begin_src scheme
(b c d)
#+end_src

*** DONE Exercise 3.13 ~make-cycle~
    CLOSED: [2019-11-29 Fri 12:09]

This thing is called a "circular list".

#+begin_src scheme :exports both :results value scalar code
<<last-pair>>
(define (make-cycle x)
(set-cdr! (last-pair x) x)
x)
(define z (make-cycle (list 'a 'b 'c)))
z

#+end_src

#+RESULTS[dc977c8b00a197bf712259f04a4a7fb218084b8c]:
#+begin_src scheme
(a b c...
#+end_src

#+name: exercise-3-13
#+header: :imagemagick yes :iminoptions -density 300 :imoutoptions -geometry 1000
#+header: :fit yes :headers '("\\usepackage{tikz} \\usetikzlibrary{positioning,fit,petri,arrows,calc}")
#+header: :buffer on
#+begin_src latex :results raw file :exports both :file exercise-3-12.png

\begin{tikzpicture}[inner sep=0mm,>=stealth',very thick,color=blue!99,
      font=\sffamily,
      node distance=20mm,
      pics/cons cell/.style n args={3}{code={
      \coordinate (origin);
      \node[anchor=east,minimum size=10mm,inner sep=0] (#1-car) at(0,0) {};
      \node[anchor=west,minimum size=10mm,inner sep=0] (#1-cdr) at(0,0) {};
      \node[name=#1-box,fit=(#1-car) (#1-cdr),draw,shape=rectangle,rounded
 corners=0.5mm]  {};
      \draw[shorten <=1pt, shorten >=1pt] (#1-box.south -| origin) -- (#1-box.north -| origin);
      \if#2t
      % \path node[shape=circle,fill,draw,radius=2mm] at (#1-car.center) {};
      \filldraw (#1-car.center) circle[radius=0.66mm] ;
      \else
      \draw[shorten <=1pt] (#1-car.south west) to (#1-car.north east);
      \fi
      \if#3t
      \filldraw (#1-cdr.center) circle[radius=0.66mm] ;
      \else
      \draw[shorten >=1pt] (#1-cdr.south west) to (#1-cdr.north east);
      \fi
      }},
      pics/cons element/.style n args={2}{code={
      \node [minimum size=10mm,inner sep=0,rounded corners=1mm, draw, shape=rectangle] (#1) {#2};
      }},
      box/.style={draw,rectangle,inner sep=#1},box/.default=2mm,
      ]
\node (z) {z};
\node[right=200mm of z] {};
\pic[right=of z] {cons cell={cell-a}{t}{t}};
\draw[->] (z) to (cell-a-box);
\pic[below=of cell-a-car] {cons element={a}{a}};
\pic[right=of cell-a-cdr] {cons cell={cell-b}{t}{t}};
\pic[below=of cell-b-car] {cons element={b}{b}};
\draw[->] (cell-a-cdr.center) to (cell-b-box);
\draw[->] (cell-a-car.center) to (a);
\draw[->] (cell-b-car.center) to (b);
\pic[right=of cell-b-box] {cons cell={cell-c}{t}{t}};
\pic[below=of cell-c-car] {cons element={c}{c}};
\draw[->] (cell-c-car.center) to (c);
\draw[->] (cell-b-cdr.center) to (cell-c-box);
\draw[->] (cell-c-cdr.center) .. controls ($ (cell-c-cdr.center) + (0,30mm) $)
and ($ (cell-a-car.center) + (0,30mm) $) .. (cell-a-car);

\end{tikzpicture}
#+end_src

#+RESULTS[dd327beb81bb66603a38e3b89145c384341db6f7]: exercise-3-13
[[file:exercise-3-12.png]]

*** DONE Exercise 3.14 ~mystery~
    CLOSED: [2019-11-29 Fri 21:23]

#+begin_src scheme :exports both :results output scalar code
  (define (mystery x)
    (define (loop x y)
      (if (null? x)
	  y
	  (let ((temp (cdr x)))
	    (set-cdr! x y)
	    (loop temp x))))
    (loop x '()))
(define v (list 'a 'b 'c 'd))
(show #t "initial v: " v "\n")
(define w (mystery v))
(show #t "w: " w "\n")
(show #t "what remains of v: " v "\n")
#+end_src

#+RESULTS[b1913fa14d71d4f40f6629a62b6d27a41c462e44]:
#+begin_src scheme
initial v: (a b c d)
w: (d c b a)
what remains of v: (a)
#+end_src

The ~mystery~ procedure is roughly equivalent to ~(reverse x)~, except
that it works in constant space, whereas an ordinary ~reverse~
additionally uses as much space as ~x~ occupies.

Let us plot ~v~ before the operation.

#+name: exercise-3-14-part1
#+header: :imagemagick yes :iminoptions -density 300 :imoutoptions -geometry 1000
#+header: :fit yes :headers '("\\usepackage{tikz} \\usetikzlibrary{positioning,fit,petri,arrows,calc}")
#+header: :buffer on
#+begin_src latex :results raw file :exports both :file exercise-3-14-part1.png

\begin{tikzpicture}[inner sep=0mm,>=stealth',very thick,color=blue!99,
      font=\sffamily,
      node distance=20mm,
      pics/cons cell/.style n args={3}{code={
      \coordinate (origin);
      \node[anchor=east,minimum size=10mm,inner sep=0] (#1-car) at(0,0) {};
      \node[anchor=west,minimum size=10mm,inner sep=0] (#1-cdr) at(0,0) {};
      \node[name=#1-box,fit=(#1-car) (#1-cdr),draw,shape=rectangle,rounded
 corners=0.5mm]  {};
      \draw[shorten <=1pt, shorten >=1pt] (#1-box.south -| origin) -- (#1-box.north -| origin);
      \if#2t
      \filldraw (#1-car.center) circle[radius=0.66mm] ;
      \else
      \draw[shorten <=1pt] (#1-car.south west) to (#1-car.north east);
      \fi
      \if#3t
      \filldraw (#1-cdr.center) circle[radius=0.66mm] ;
      \else
      \draw[shorten >=1pt] (#1-cdr.south west) to (#1-cdr.north east);
      \fi
      }},
      pics/cons element/.style n args={2}{code={
      \node [minimum size=10mm,inner sep=0,rounded corners=1mm, draw, shape=rectangle] (#1) {#2};
      }},
      box/.style={draw,rectangle,inner sep=#1},box/.default=2mm,
      ]

\node (v) {v};
\pic[right=of v] {cons cell={cell-a-2}{t}{t}};
\draw[->] (v) to (cell-a-2-box);
\pic[below=of cell-a-2-car] {cons element={a2}{a}};
\pic[right=of cell-a-2-cdr] {cons cell={cell-b-2}{t}{t}};
\pic[below=of cell-b-2-car] {cons element={b2}{b}};
\pic[right=of cell-b-2-cdr] {cons cell={cell-c-2}{t}{t}};
\pic[below=of cell-c-2-car] {cons element={c2}{c}};
\pic[right=of cell-c-2-cdr] {cons cell={cell-d-2}{t}{f}};
\pic[below=of cell-d-2-car] {cons element={d2}{d}};


\draw[->] (cell-a-2-cdr.center) to (cell-b-2-box);
\draw[->] (cell-a-2-car.center) to (a2);
\draw[->] (cell-b-2-car.center) to (b2);
\draw[->] (cell-b-2-cdr.center) to (cell-c-2-box);
\draw[->] (cell-c-2-car.center) to (c2);
\draw[->] (cell-c-2-cdr.center) to (cell-d-2-box);
\draw[->] (cell-d-2-car.center) to (d2);


\end{tikzpicture}
#+end_src

#+RESULTS[7ac3e8ad4b90ee0489bc8258c9181123e71a0d4e]: exercise-3-14-part1
[[file:exercise-3-14-part1.png]]


~mystery~ reverses the list, so the diagram would be:

#+name: exercise-3-14-part2
#+header: :imagemagick yes :iminoptions -density 300 :imoutoptions -geometry 1000
#+header: :fit yes :headers '("\\usepackage{tikz} \\usetikzlibrary{positioning,fit,petri,arrows,calc}")
#+header: :buffer on
#+begin_src latex :results raw file :exports both :file exercise-3-14-part2.png

\begin{tikzpicture}[inner sep=0mm,>=stealth',very thick,color=blue!99,
      font=\sffamily,
      node distance=20mm,
      pics/cons cell/.style n args={3}{code={
      \coordinate (origin);
      \node[anchor=east,minimum size=10mm,inner sep=0] (#1-car) at(0,0) {};
      \node[anchor=west,minimum size=10mm,inner sep=0] (#1-cdr) at(0,0) {};
      \node[name=#1-box,fit=(#1-car) (#1-cdr),draw,shape=rectangle,rounded
 corners=0.5mm]  {};
      \draw[shorten <=1pt, shorten >=1pt] (#1-box.south -| origin) -- (#1-box.north -| origin);
      \if#2t
      \filldraw (#1-car.center) circle[radius=0.66mm] ;
      \else
      \draw[shorten <=1pt] (#1-car.south west) to (#1-car.north east);
      \fi
      \if#3t
      \filldraw (#1-cdr.center) circle[radius=0.66mm] ;
      \else
      \draw[shorten >=1pt] (#1-cdr.south west) to (#1-cdr.north east);
      \fi
      }},
      pics/cons element/.style n args={2}{code={
      \node [minimum size=10mm,inner sep=0,rounded corners=1mm, draw, shape=rectangle] (#1) {#2};
      }},
      box/.style={draw,rectangle,inner sep=#1},box/.default=2mm,
      ]

\node (w) {w};
\pic[right=of w] {cons cell={cell-a-2}{t}{t}};
\draw[->] (w) to (cell-a-2-box);
\pic[below=of cell-a-2-car] {cons element={a2}{d}};
\pic[right=of cell-a-2-cdr] {cons cell={cell-b-2}{t}{t}};
\pic[below=of cell-b-2-car] {cons element={b2}{c}};
\pic[right=of cell-b-2-cdr] {cons cell={cell-c-2}{t}{t}};
\pic[below=of cell-c-2-car] {cons element={c2}{b}};
\pic[right=of cell-c-2-cdr] {cons cell={cell-d-2}{t}{f}};
\pic[below=of cell-d-2-car] {cons element={d2}{a}};


\draw[->] (cell-a-2-cdr.center) to (cell-b-2-box);
\draw[->] (cell-a-2-car.center) to (a2);
\draw[->] (cell-b-2-car.center) to (b2);
\draw[->] (cell-b-2-cdr.center) to (cell-c-2-box);
\draw[->] (cell-c-2-car.center) to (c2);
\draw[->] (cell-c-2-cdr.center) to (cell-d-2-box);
\draw[->] (cell-d-2-car.center) to (d2);

\node[above=of cell-d-2-car] (v) {v};
\draw[->] (v) to (cell-d-2-car);

\end{tikzpicture}
#+end_src

#+RESULTS[00a2772912f6d9c70d8767cc7ac8578b172df4e0]: exercise-3-14-part2
[[file:exercise-3-14-part2.png]]

~v~ still points to the cell containing ~'x~, but now the ~car~ of
this cell is an empty list.

*** DONE Exercise 3.15 ~set-to-wow!~
    CLOSED: [2019-12-01 Sun 19:59]

#+begin_src scheme :exports both :results output scalar code
(define (set-to-wow! x)
   (set-car! (car x) 'wow)
    x)
(define x (list 'a 'b))
(define z1 (cons x x))
(define z2 (cons (list 'a 'b) (list 'a 'b)))
(show #t "The structures are: \n" z1 "\n" z2 "\n")
(set-to-wow! z1)
(show #t "Modified z1: " z1 "\n")
(set-to-wow! z2)
(show #t "Modifier z2: " z2 "\n")
#+end_src

#+RESULTS[b67a500b9c23ec28b6ebfb4553f954095fab0e97]:
#+begin_src scheme
The structures are: 
((a b) a b)
((a b) a b)
Modified z1: ((wow b) wow b)
Modifier z2: ((wow b) a b)
#+end_src

First let us draw ~z1~ after ~set-to-wow!~.

#+name: exercise-3-15-part1
#+header: :imagemagick yes :iminoptions -density 300 :imoutoptions -geometry 1000
#+header: :fit yes :headers '("\\usepackage{tikz} \\usetikzlibrary{positioning,fit,petri,arrows,calc,graphs}")
#+header: :buffer on
#+begin_src latex :results raw file :exports both :file exercise-3-15-part1.png

\begin{tikzpicture}[inner sep=0mm,>=stealth',very thick,color=blue!99,
      font=\sffamily,
      node distance=20mm,
      pics/cons cell/.style n args={3}{code={
      \coordinate (origin);
      \node[anchor=east,minimum size=10mm,inner sep=0] (#1!car) at(0,0) {};
      \node[anchor=west,minimum size=10mm,inner sep=0] (#1!cdr) at(0,0) {};
      \node[name=#1!box,fit=(#1!car) (#1!cdr),draw,shape=rectangle,rounded
 corners=0.5mm]  {};
      \draw[shorten <=1pt, shorten >=1pt] (#1!box.south -| origin) -- (#1!box.north -| origin);
      \if#2t
      \filldraw (#1!car.center) circle[radius=0.66mm] ;
      \else
      \draw[shorten <=1pt] (#1!car.south west) to (#1!car.north east);
      \fi
      \if#3t
      \filldraw (#1!cdr.center) circle[radius=0.66mm] ;
      \else
      \draw[shorten >=1pt] (#1!cdr.south west) to (#1!cdr.north east);
      \fi
      }},
      pics/cons element/.style n args={2}{code={
      \node [minimum size=10mm,inner sep=0,rounded corners=1mm, draw, shape=rectangle] (#1) {#2};
      }},
      box/.style={draw,rectangle,inner sep=#1},box/.default=2mm,
      ]

\matrix[row sep=10mm,column sep=20mm] {

\node (z1!var) {z1}; & \pic{cons cell={z1}{t}{t}}; &  \\
\node (x) {x};   & \pic{cons cell={list1}{t}{t}}; & \pic{cons cell={list2}{t}{f}}; \\
                 & \pic[below=5mm of list1!car]{cons element={a}{wow}}; & \pic[below=5mm of list2!car]{cons element={b}{b}};\\
};

\node[right=200mm of z1!var] {};

\graph[use existing nodes]
{
z1!var -> z1!box ;
z1!car.center -> list1!car;
z1!cdr.center -> list1!cdr;
list1!cdr.center -> list2!box;
list1!car.center -> a;
list2!car.center -> b;
x -> list1!box;
};
%\draw[->] (z1-var) -- (x);
\end{tikzpicture}


#+end_src

#+RESULTS[cb324a0c4d0748dc613424f66ab087fdfd289d30]: exercise-3-15-part1
[[file:exercise-3-15-part1.png]]

Next we shall plot ~z2~ after ~set-to-wow!~.

#+name: exercise-3-15-part2
#+header: :imagemagick yes :iminoptions -density 300 :imoutoptions -geometry 1000
#+header: :fit yes :headers '("\\usepackage{tikz} \\usetikzlibrary{positioning,fit,petri,arrows,calc,graphs}")
#+header: :buffer on
#+begin_src latex :results raw file :exports both :file exercise-3-15-part2.png

\begin{tikzpicture}[inner sep=0mm,>=stealth',very thick,color=blue!99,
      font=\sffamily,
      node distance=20mm,
      pics/cons cell/.style n args={3}{code={
      \coordinate (origin);
      \node[anchor=east,minimum size=10mm,inner sep=0] (#1!car) at(0,0) {};
      \node[anchor=west,minimum size=10mm,inner sep=0] (#1!cdr) at(0,0) {};
      \node[name=#1!box,fit=(#1!car) (#1!cdr),draw,shape=rectangle,rounded
 corners=0.5mm]  {};
      \draw[shorten <=1pt, shorten >=1pt] (#1!box.south -| origin) -- (#1!box.north -| origin);
      \if#2t
      \filldraw (#1!car.center) circle[radius=0.66mm] ;
      \else
      \draw[shorten <=1pt] (#1!car.south west) to (#1!car.north east);
      \fi
      \if#3t
      \filldraw (#1!cdr.center) circle[radius=0.66mm] ;
      \else
      \draw[shorten >=1pt] (#1!cdr.south west) to (#1!cdr.north east);
      \fi
      }},
      pics/cons element/.style n args={2}{code={
      \node [minimum size=10mm,inner sep=0,rounded corners=1mm, draw, shape=rectangle] (#1) {#2};
      }},
      box/.style={draw,rectangle,inner sep=#1},box/.default=2mm,
      ]

\matrix[row sep=20mm,column sep=20mm] {
                     & \pic[xshift=-5mm]{cons element={wow}{wow}};   & \\
\node (z2!var) {z2}; & \pic{cons cell={z21}{t}{t}}; & \pic{cons cell={z22}{t}{f}}; \\
                     & \pic[xshift=-5mm]{cons element={a}{a}};   & \pic[xshift=-5mm]{cons element={b}{b}}; \\
                     & \pic{cons cell={z23}{t}{t}}; & \pic{cons cell={z24}{t}{f}};\\
};

\node[right=200mm of z2!var] {};

\graph[use existing nodes]
{
z2!var -> z21!box ;
z21!car.center -> wow;
z21!cdr.center -> z22!box;
z22!car.center -> b;
z23!car.center -> a;
z23!cdr.center -> z24!box;
z24!car.center -> b;
};
%\draw[->] (z1-var) -- (x);
\end{tikzpicture}


#+end_src

#+RESULTS[1f7ce8ef4e1530e2657a3e797f42098ba9af71ad]: exercise-3-15-part2
[[file:exercise-3-15-part2.png]]


The picture should explain the result of ~set-to-wow!~ fairly well.

*** DONE Exercise 3.16 ~count-pairs~
    CLOSED: [2019-12-02 Mon 00:05]

#+begin_src scheme :exports both :results output scalar code
(define (count-pairs x)
(if (not (pair? x))
0
(+ (count-pairs (car x))
(count-pairs (cdr x))
1)))
(show #t "Return three: " (count-pairs (list 'a 'b 'c)) "\n")
(show #t "Return four: " (count-pairs (let ((x (list 'a 'b 'c)))
                          (set-car! (cdr x) (cddr x)) x)) "\n")
(show #t "Return seven: " (count-pairs (let ((x (list 'a 'b 'c)))
                          (set-car!  x (cdr x))
                          (set-car!  (cdr x) (cddr x))
                          x)) "\n")
 (show #t "Never return: "
          (let ((x (list 'a 'b 'c)))
             (set-cdr! (cddr x) x)
            x) "\n")

#+end_src

#+RESULTS[e45b5c421053bd66402cc6c3ebd9ac32fb82a525]:
#+begin_src scheme
Return three: 3
Return four: 4
Return seven: 7
Never return: #0=(a b c . #0#)
#+end_src

#+name: exercise-3-16
#+header: :imagemagick yes :iminoptions -density 300 :imoutoptions -geometry 1000
#+header: :fit yes :headers '("\\usepackage{tikz} \\usetikzlibrary{positioning,fit,petri,arrows,calc,graphs}")
#+header: :buffer on
#+begin_src latex :results raw file :exports both :file exercise-3-16.png

\begin{tikzpicture}[inner sep=0mm,>=stealth',very thick,color=blue!99,
      font=\sffamily,
      node distance=20mm,
      pics/cons cell/.style n args={3}{code={
      \coordinate (origin);
      \node[anchor=east,minimum size=10mm,inner sep=0] (#1!car) at(0,0) {};
      \node[anchor=west,minimum size=10mm,inner sep=0] (#1!cdr) at(0,0) {};
      \node[name=#1!box,fit=(#1!car) (#1!cdr),draw,shape=rectangle,rounded
 corners=0.5mm]  {};
      \draw[shorten <=1pt, shorten >=1pt] (#1!box.south -| origin) -- (#1!box.north -| origin);
      \if#2t
      % \path node[shape=circle,fill,draw,radius=2mm] at (#1-car.center) {};
      \filldraw (#1!car.center) circle[radius=0.66mm] ;
      \else
      \draw[shorten <=1pt] (#1!car.south west) to (#1!car.north east);
      \fi
      \if#3t
      \filldraw (#1!cdr.center) circle[radius=0.66mm] ;
      \else
      \draw[shorten >=1pt] (#1!cdr.south west) to (#1!cdr.north east);
      \fi
      }},
      pics/cons element/.style n args={2}{code={
      \node [xshift=-5mm,minimum size=10mm,inner sep=0,rounded corners=1mm, draw, shape=rectangle] (#1) {#2};
      }},
      box/.style={draw,rectangle,inner sep=#1},box/.default=2mm,
      ]
\matrix[row sep=10mm,column sep=20mm] {
\pic{cons cell={cell1}{t}{t}}; & \pic{cons cell={cell2}{t}{t}}; & \pic{cons cell={cell3}{t}{f}}; \\
\pic{cons element={a}{a}};     & \pic{cons element={b}{b}};     & \pic{cons element={c}{d}}; \\
\pic{cons cell={cell4}{t}{t}}; & \pic{cons cell={cell5}{t}{t}}; & \pic{cons cell={cell6}{t}{f}}; \\
\pic{cons element={a2}{a}};    &                                & \pic{cons element={c2}{c}}; \\
\pic{cons cell={cell7}{t}{t}}; & \pic{cons cell={cell8}{t}{t}}; & \pic{cons cell={cell9}{t}{f}}; \\
                               &                                & \pic{cons element={c3}{c}}; \\
\pic{cons cell={cell10}{t}{t}}; & \pic{cons cell={cell11}{t}{t}}; & \pic{cons cell={cell12}{t}{t}}; \\
\pic{cons element={a4}{a}};     & \pic{cons element={b4}{b}};     & \pic{cons element={c4}{d}}; \\
};
\node[right=200mm of cell1!box] {};

\graph[use existing nodes,
skip loop/.style={to path={-- ++(0,#1) -| (\tikztotarget)}}]
{
cell1!cdr.center -> cell2!box;
cell1!car.center -> a;
cell2!car.center -> b;
cell2!cdr.center -> cell3!box;
cell3!car.center -> c;
cell4!cdr.center -> cell5!box;
cell4!car.center -> a2;
cell5!car.center ->[skip loop=10mm] cell6!car;
cell5!cdr.center -> cell6!box;
cell6!car.center -> c2;
cell7!cdr.center -> cell8!box;
cell7!car.center ->[skip loop=-10mm] cell8!car;
cell8!cdr.center -> cell9!box;
cell8!car.center ->[skip loop=10mm] cell9!car;
cell9!car.center -> c3;
cell10!car.center -> a4;
cell10!cdr.center -> cell11!box;
cell11!car.center -> b4;
cell11!cdr.center -> cell12!box;
cell12!car.center -> c4;
cell12!cdr.center ->[skip loop=10mm] cell10!car;
};

\end{tikzpicture}
#+end_src

#+RESULTS[392ba46556092e8f063652f0f5e09ccf755cfa02]: exercise-3-16
[[file:exercise-3-16.png]]

*** DONE Exercise 3.17 Real ~count-pairs~
    CLOSED: [2019-12-02 Mon 00:47]

This is an inefficient solution, because it uses an O(n) lookup.

#+begin_src scheme :exports both :results output scalar code
      (define (count-pairs s)
	(define my-set (list))
	(define (count-pairs-loop x)
	   (cond ((not (pair? x)) 0)
		 ((memq x my-set) 0)
		 (else (begin
			 (set! my-set (append my-set (list x)))
			 (+ (count-pairs-loop (car x))
			    (count-pairs-loop (cdr x))
			    1)))))
	(set! my-set (list))
	(count-pairs-loop s))
    (show #t "Returned three: " (count-pairs (list 'a 'b 'c)) "\n")
    (show #t "Returned four: " (count-pairs (let ((x (list 'a 'b 'c)))
			      (set-car! (cdr x) (cddr x)) x)) "\n")
    (show #t "Returned seven: " (count-pairs (let ((x (list 'a 'b 'c)))
			      (set-car!  x (cdr x))
			      (set-car!  (cdr x) (cddr x))
			      x)) "\n")
    (show #t "Never returned: "
	      (count-pairs (let ((x (list 'a 'b 'c)))
		 (set-cdr! (cddr x) x)
		x)) "\n")

#+end_src

#+RESULTS[c83a39254e25051340181a829086836126ce6b12]:
#+begin_src scheme
Returned three: 3
Returned four: 3
Returned seven: 3
Never returned: 3
#+end_src

*** DONE Exercise 3.18 Finding cycles
    CLOSED: [2019-12-02 Mon 01:04]

Still not a very efficient solution, but it works.

#+begin_src scheme :exports both :results output scalar code
  (define (is-cyclic? y)
    (define seen-elements (list))
    (define (is-s-l x)
      (cond ((not (pair? x)) #f)
	    ((null? x) #f)
	    ((memq x seen-elements) #t)
	    (else (begin
		    (set! seen-elements (append seen-elements (list x)))
		    (is-s-l (cdr x))))))
    (set! seen-elements (list))
    (is-s-l y))
  (show #t "Returned three: " (is-cyclic? (list 'a 'b 'c)) "\n")
  (show #t "Returned four: " (is-cyclic? (let ((x (list 'a 'b 'c)))
					   (set-car! (cdr x) (cddr x)) x)) "\n")
  (show #t "Returned seven: " (is-cyclic? (let ((x (list 'a 'b 'c)))
					    (set-car!  x (cdr x))
					    (set-car!  (cdr x) (cddr x))
					    x)) "\n")
  (show #t "Never returned: "
	(is-cyclic? (let ((x (list 'a 'b 'c)))
		      (set-cdr! (cddr x) x)
		      x)) "\n")

#+end_src

#+RESULTS[fb697bfaf41389ceba6aa14397c7f870a1ea5474]:
#+begin_src scheme
Returned three: #f
Returned four: #f
Returned seven: #f
Never returned: #t
#+end_src

*** DONE Exercise 3.19 Efficient finding cycles
    CLOSED: [2019-12-02 Mon 23:29]

The idea that we are going to explore in this exercise is slightly
similar to the dynamic programming. This will not be efficient at all,
but will eventually find not just whether the list has a cycle, but
also the length of the cycle.

#+begin_src scheme :exports both :results output scalar code
    (define (is-cyclic? l)
      (let loop ((starting-elem 0)
		 (cycle-len 1))
	(cond ((or (not (pair? (drop l starting-elem)))
		  (not (pair? (drop l (+ starting-elem cycle-len)))))
	       #f)
	      ((eq?  (drop l starting-elem)
		     (drop l (+ starting-elem cycle-len))) #t)
	      ((> starting-elem 0) (loop (- starting-elem 1) (+ cycle-len 1)))
	      (else (loop cycle-len 1)))))

    (show #t "Returned three: " (is-cyclic? (list 'a 'b 'c)) "\n")
    (show #t "Returned four: " (is-cyclic? (let ((x (list 'a 'b 'c)))
					     (set-car! (cdr x) (cddr x)) x)) "\n")
    (show #t "Returned seven: " (is-cyclic? (let ((x (list 'a 'b 'c)))
					      (set-car!  x (cdr x))
					      (set-car!  (cdr x) (cddr x))
					      x)) "\n")
    (show #t "Never returned: "
	  (is-cyclic? (let ((x (list 'a 'b 'c)))
			(set-cdr! (cddr x) x)
			x)) "\n")

#+end_src

#+RESULTS[573823e4e11ca6d42a34a01da84e928f469259db]:
#+begin_src scheme
Returned three: #f
Returned four: #f
Returned seven: #f
Never returned: #t
#+end_src

The not very clever idea used here is that we can check if an element
~x~ is a start of a loop of length ~n~. Therefore we can iterate over
all possible values of ~x~ and ~n~. This exercise uses the ~(scheme
list)~ standard library from R7RS.

This algorithm clearly only uses O(1) memory, since we only remember
the number of the starting element and the cycle length.

*** DONE Exercise 3.20 Procedural ~set-car!~
    CLOSED: [2019-12-03 Tue 14:40]

I am excluding the definitions from the diagram, they are cumbersome.

#+name: exercise-3-20
#+header: :imagemagick yes :iminoptions -density 300 :imoutoptions -geometry 1000
#+header: :fit yes :headers '("\\usepackage{tikz} \\usetikzlibrary{positioning,fit,petri,arrows,calc}")
#+header: :buffer on
#+begin_src latex :results raw file :exports both :file exercise-3-20.png
  \begin{tikzpicture}[inner sep=0mm,>=stealth',very thick,color=blue!99,
       font=\sffamily,pics/two dots/.style={code={
       \node [draw,minimum size=5mm,circle,colored tokens={blue!99}]
       (#1-left) {};
      \node [draw,minimum size=5mm,circle,colored tokens={blue!99},
      right=0pt of #1-left]
	  (#1-right) {};
      \node [rectangle, fit=(#1-left) (#1-right)] (#1){};
      }},
      every pin edge/.style={<-,very thick},
      box/.style={draw,rectangle,inner sep=#1},box/.default=2mm,
      node distance=4mm]



    \node (x-global)  {x:};
    \node (fake1) [right=100mm of x-global] {};
    \node (z-global) [above=3mm of x-global.west,anchor=west] {z:};
  %
    \node (g env) [box, fit=(z-global) (fake1) (x-global),
    pin={[text width=1cm,pin distance=10mm]left:global env}]
    { };

  \path (g env.south west) -- (g env.south east)
  node [pos=2/8] (fake2-7) {}
  node (x-var)  [below=6mm of fake2-7] {\vphantom{l}x:17}
  node (y-var) [below=of x-var.west,anchor=west] {\vphantom{l}y:2}
  node (setx1) [below=of y-var.west,anchor=west] {\vphantom{l}set-x!: ...}
  node (sety1) [below=of setx1.west,anchor=west] {\vphantom{l}set-y!: ...}
  node (E1-env) [box,
      pin={[pin distance=5mm]left:E1},align=left,
      fit=(x-var) (y-var) (setx1) (sety1)]
      {}
  edge [->] (g env.south -| E1-env.north) ;

  \path (g env.south west) -- (g env.south east)
  node[pos=1/16] (anchor1) {}
  coordinate[below=50 mm of anchor1] (aux)
      (aux) pic{two dots=x-dispatch}
      (x-dispatch) edge [<-, to path={|- (\tikztotarget)}] (x-global.east);
  \draw[->] (x-dispatch-right.center) -|  (E1-env.south);
  \node [below=5mm of x-dispatch-left, align=left,font=\ttfamily]
  {\noindent parameters:\vphantom{l}m \\
  body:\\
(cond \\ ((eq? m 'car) x) \\
((eq? m 'cdr) y) \\
((eq? m 'set-car!) set-x!) \\
((eq? m 'set-cdr!) set-y!) \\
(else \\
(error "Undefined operation: CONS" m))) \\
  }
      edge [<-] (x-dispatch-left.center);

  \path (g env.south west) -- (g env.south east)
  node [pos=9/16] (fake-8) {}
  node (x-var)  [below=6mm of fake-8] {\vphantom{l}x:}
  node (y-var) [below=of x-var.west,anchor=west] {\vphantom{l}y:}
  node (setx1) [below=of y-var.west,anchor=west] {\vphantom{l}set-x!: ...}
  node (sety1) [below=of setx1.west,anchor=west] {\vphantom{l}set-y!: ...}
  node (E2-env) [box,
      pin={[pin distance=5mm]left:E2},align=left,
      fit=(x-var) (y-var) (setx1) (sety1)]
      {}
  edge [->] (g env.south -| E2-env.north) ;
  \draw[->] (x-var.east)  ++(1mm,0) -- ++(0,5mm) -| ($ (x-dispatch.north) + (1mm,0) $);
  \draw[->] (y-var.east) -- ++(0,6mm) -| ($ (x-dispatch.north) + (2mm,0) $);

  \path (g env.south west) -- (g env.south east)
  node[pos=12/16] (anchor) {}
  coordinate[below=50 mm of anchor]  (aux)
      (aux) pic{two dots=z-dispatch}
      (z-dispatch) edge [<-, to path={|- (\tikztotarget)}] (z-global.east);
  \draw[->] (z-dispatch-right.center) -- ++(0,7mm) -|  (E2-env.south);
  \node [below=5mm of z-dispatch-left, align=left,font=\ttfamily]
  {\noindent parameters:\vphantom{l}m \\
  body:\\
(cond \\ ((eq? m 'car) x) \\
((eq? m 'cdr) y) \\
((eq? m 'set-car!) set-x!) \\
((eq? m 'set-cdr!) set-y!) \\
(else \\
(error "Undefined operation: CONS" m))) \\
  }
      edge [<-] (z-dispatch-left.center);


  \end{tikzpicture}
#+end_src

#+RESULTS[066dd4a9a83807d806a6cd92b2eabb62f937dc0e]: exercise-3-20
[[file:exercise-3-20.png]]

I am only drawing the final environment, but the idea should be quite obvious.

*** DONE Exercise 3.21 queues
    CLOSED: [2019-12-03 Tue 15:10]

#+name: queue
#+begin_src scheme :exports code :results none
  (define (front-ptr queue) (car queue))
  (define (rear-ptr queue)
    (cdr queue))
  (define (set-front-ptr! queue item)
    (set-car! queue item))
  (define (set-rear-ptr! queue item)
    (set-cdr! queue item))
  (define (empty-queue? queue)
    (null? (front-ptr queue)))
  (define (make-queue) (cons '() '()))
  (define (front-queue queue)
    (if (empty-queue? queue)
	(error "FRONT called with an empty queue" queue)
	(car (front-ptr queue))))
  (define (insert-queue! queue item)
    (let ((new-pair (cons item '())))
      (cond ((empty-queue? queue)
	     (set-front-ptr! queue new-pair)
	     (set-rear-ptr! queue new-pair)
	     queue)
	    (else
	     (set-cdr! (rear-ptr queue) new-pair)
	     (set-rear-ptr! queue new-pair)
	     queue))))
  (define (delete-queue! queue)
    (cond ((empty-queue? queue)
	   (error "DELETE! called with an empty queue" queue))
	  (else (set-front-ptr! queue (cdr (front-ptr queue)))
		queue)))
#+end_src

#+begin_src scheme :exports both :results output scalar code
<<queue>>
(define q1 (make-queue))
(show #t "(insert-queue! q1 'a) = " (insert-queue! q1 'a) "\n")
(show #t "(insert-queue! q1 'b) = " (insert-queue! q1 'b) "\n")
(show #t "(delete-queue! q1)    = " (delete-queue! q1)    "\n")
(show #t "insert " (insert-queue! q1 'c) "\n")
(show #t "(delete-queue! q1)    = " (delete-queue! q1)    "\n")

#+end_src

#+RESULTS[30957e03437aa0225a3e23e76b9a4115cab093b1]:
#+begin_src scheme
(insert-queue! q1 'a) = ((a) a)
(insert-queue! q1 'b) = ((a b) b)
(delete-queue! q1)    = ((b) b)
insert ((b c) c)
(delete-queue! q1)    = ((c) c)
#+end_src

I dare to say that this printed representation is correct, because it
not just displays the queue, but also shows what the end pointer marks.

Indeed, the queue is just a pair of a list and the final
pair. Moreover, even if the queue is empty, the last pair is not
destroyed, and therefore is displayed.

#+name: print-queue
#+begin_src scheme :exports code :results none
<<queue>>
(define (print-queue queue)
  (display (car queue)))
#+end_src

#+begin_src scheme :exports both :results output scalar code
<<queue>>
<<print-queue>>
(define q1 (make-queue))
(print-queue (insert-queue! q1 'a))
(newline)
(print-queue (insert-queue! q1 'b))
(newline)
(print-queue (delete-queue! q1))
(newline)
(print-queue (delete-queue! q1))
#+end_src

#+RESULTS[7339cf0f38ed0ae14119932da07c647c7a7e0f84]:
#+begin_src scheme
(a)
(a b)
(b)
()
#+end_src

Everything is fine.

*** DONE Exercise 3.22 procedural queue
    CLOSED: [2019-12-03 Tue 22:13]

#+name: procedural-queue
#+begin_src scheme :exports both :results output scalar code
    (define (make-queue)
      (let ((front-ptr (list))
	    (rear-ptr #f))
	(define (front)
	  (if (null? front-ptr)
	      (error "FRONT called with an empty queue" queue)
	      (car front-ptr)))
	(define (insert! x)
	  (let ((new-pair (cons x (list))))
	    (cond ((null? front-ptr)
		   (set! front-ptr new-pair)
		   (set! rear-ptr  new-pair))
		  (else
		   (set-cdr! rear-ptr new-pair)
		   (set! rear-ptr new-pair)))))
	(define (delete!)
	  (if (not (null? front-ptr))
	      (set! front-ptr (cdr front-ptr))
	      (error "Queue already empty" front-ptr)))
	(define (dispatch m)
	  (cond ((eq? m 'empty-queue) (null? front-ptr))
		((eq? m 'front) (front))
		((eq? m 'insert!) insert!)
		((eq? m 'delete!) delete!)
                ((eq? m 'print) (display front-ptr))
		(else
		 (error "Undefined operation: queue" m)))  )
	dispatch))
  (define (front-queue z)
    (z 'front))
  (define (empty-queue? z)
    (z 'empty-queue))
  (define (insert-queue! q z)
    ((q 'insert!) z)
    q)
  (define (delete-queue! q)
    ((q 'delete!))
    q)
  (define (print-queue q)
    (q 'print)
    (newline))

  (define q1 (make-queue))
  (empty-queue? q1)
  (insert-queue! q1 'a)
  (print-queue q1)
  (insert-queue! q1 'b)
  (print-queue q1)
  (delete-queue! q1)
  (print-queue q1)
  (delete-queue! q1)
  (print-queue q1)
#+end_src

#+RESULTS[961a3fa44be8ca8916df924fdd25fbf62e04d769]: procedural-queue
#+begin_src scheme
(a)
(a b)
(b)
()
#+end_src

Well, makes sense. Not a very hard exercise.

*** DONE Exercise 3.23 dequeue
    CLOSED: [2019-12-03 Tue 23:24]

#+name: dequeue
#+begin_src scheme :exports both :results result scalar code
  (define (front-ptr deque) (car deque))
  (define (rear-ptr deque)
    (cdr deque))
  (define (set-front-ptr! deque item)
    (set-car! deque item))
  (define (set-rear-ptr! deque item)
    (set-cdr! deque item))
  (define (empty-deque? deque)
    (null? (front-ptr deque)))
  (define (make-deque) (cons '() '()))
  (define (get-item list-elem)
    (cdr list-elem))
  (define (get-backlink list-elem)
    (car list-elem))
  (define (front-deque deque)
    (if (empty-deque? deque)
	(error "FRONT called with an empty deque" deque)
	(get-item (car (front-ptr deque)))))
  (define (rear-deque deque)
    (if (empty-deque? deque)
	(error "REAR called with an empty deque" deque)
	(get-item (car (rear-ptr deque)))))
  (define (rear-insert-deque! deque item)
    (let ((new-pair (cons (cons #f item) '())))
      (cond ((empty-deque? deque)
	     (set-front-ptr! deque new-pair)
	     (set-rear-ptr! deque new-pair)
	     deque)
	    (else
	     (set-cdr! (rear-ptr deque) new-pair)
             (set-car! new-pair (rear-ptr deque))
	     (set-rear-ptr! deque new-pair)
	     deque))))
  (define (front-delete-deque! deque)
    (cond ((empty-deque? deque)
	   (error "FRONT-DELETE! called with an empty deque" deque))
	  (else (set-front-ptr! deque (cdr (front-ptr deque)))
                (set-car! (car (front-ptr deque)) '())
		deque)))
  (define (front-insert-deque! deque item)
    (let ((new-pair (cons (cons '() item) '())))
      (cond ((empty-deque? deque)
	     (set-front-ptr! deque new-pair)
	     (set-rear-ptr! deque new-pair)
	     deque)
	    (else
	     (set-cdr! new-pair (front-ptr deque))
             (set-car! (car (front-ptr deque)) new-pair)
             (set-front-ptr! deque new-pair)
            deque))))
  (define (rear-delete-deque! deque)
    (cond ((empty-deque? deque)
	   (error "REAR-DELETE! called with an empty deque" deque))
	  (else (set-rear-ptr! deque (caar (rear-ptr deque)))
                (if (not (null? (rear-ptr deque)))
                    (set-cdr! (rear-ptr deque) (list))
                    (set-front-ptr! deque '()))
		deque)))
(define (print-deque q)
  (display q))


(define dq1 (make-deque))
(front-insert-deque! dq1 'a)
(rear-insert-deque!  dq1 'b)
(front-delete-deque! dq1)
(rear-delete-deque!  dq1)
(empty-deque? dq1)
#+end_src

#+RESULTS[69ae24c038a36d28a9e8c4c86fc71918f92082fb]: dequeue
#+begin_src scheme
#t
#+end_src

*** Remark Table operations
Actually, these table operations are first required in the chapter 2,
Exercise-2.73. In order to avoid look-aheads, I am introducing this
pseudo-chapter so that the appropriate code could be tangled in.

#+name: put-and-get
#+begin_src scheme :exports code :results none
     (define (make-table)
       (let ((local-table (list '*table*)))
         (define (lookup key-1 key-2)
           (let ((subtable (assoc key-1 (cdr local-table))))
             (if subtable
                 (let ((record (assoc key-2 (cdr subtable))))
                   (if record
                       (cdr record)
                       false))
                 false)))
         (define (insert! key-1 key-2 value)
           (let ((subtable (assoc key-1 (cdr local-table))))
             (if subtable
                 (let ((record (assoc key-2 (cdr subtable))))
                   (if record
                       (set-cdr! record value)
                       (set-cdr! subtable
                                 (cons (cons key-2 value)
                                       (cdr subtable)))))
                 (set-cdr! local-table
                           (cons (list key-1
                                       (cons key-2 value))
                                 (cdr local-table)))))
           'ok)
         (define (dispatch m)
           (cond ((eq? m 'lookup-proc) lookup)
                 ((eq? m 'insert-proc!) insert!)
                 (else (error "Unknown operation -- TABLE" m))))
         dispatch))

     (define operation-table (make-table))
     (define get (operation-table 'lookup-proc))
     (define put (operation-table 'insert-proc!))
     (define coercion-table (make-table))
     (define get-coercion (coercion-table 'lookup-proc))
     (define put-coercion (coercion-table 'insert-proc!))

#+end_src


*** DONE Exercise 3.24 tolerant tables
    CLOSED: [2019-12-04 Wed 18:07]

#+begin_src scheme :exports both :results output scalar code
  (define false #f)
  (define (make-table . o)
    (let ((same-key? (if (null? o) equal? (car o))))
      (let ((local-table (list '*table*)))
	(define (lookup key-1 key-2)
	  (let ((subtable
		 (assoc key-1 (cdr local-table) same-key?)))
	    (if subtable
		(let ((record
		       (assoc key-2 (cdr subtable) same-key?)))
		  (if record (cdr record) false))
		false)))
	(define (insert! key-1 key-2 value)
	  (let ((subtable
		 (assoc key-1 (cdr local-table) same-key?)))
	    (if subtable
		(let ((record
		       (assoc key-2 (cdr subtable) same-key?)))
		  (if record
		      (set-cdr! record value)
		      (set-cdr! subtable
				(cons (cons key-2 value)
				      (cdr subtable)))))
		(set-cdr! local-table
			  (cons (list key-1 (cons key-2 value))
				(cdr local-table)))))
	  'ok)
	(define (dispatch m)
	  (cond ((eq? m 'lookup-proc) lookup)
		((eq? m 'insert-proc!) insert!)
		(else (error "Unknown operation: TABLE" m))))
	dispatch)))
  (define (parity-checker a b)
    (if (= (remainder a 2) (remainder b 2))
        #t
        #f)) #;("not a very useful table")
  (define operation-table (make-table parity-checker))
  (define get (operation-table 'lookup-proc))
  (define put (operation-table 'insert-proc!))
  (put 1 2 (lambda () (display "test1") (newline)))
  ((get 3 4))
#+end_src

#+RESULTS[a4c9a0c952abad4adffe92ba65b4aa6d9be75fff]:
#+begin_src scheme
test1
#+end_src

This exercise would have been much-much harder with schemes lower than
version 7, as the ~assoc~ procedure doesn't take a comparator procedure.

*** DONE Exercise 3.25 multilevel tables
    CLOSED: [2019-12-06 Fri 20:35]

This exercise illustrates that it is never pays off to save on data
structures. The two-level structure is not flexible, so we are just using
nested tables.

#+begin_src scheme :exports both :results output scalar code
(display "Starting\n")
	 (define (make-table)
           (let ((local-table (list)))
	     (define (lookup key-list)
	       (let ((subtable (assoc (car key-list) local-table)))
		 (if subtable
		     (if (null? (cdr key-list))
                         (cdr subtable)
                         (((cdr subtable) 'lookup-proc) (cdr key-list)))
		     #f)))
	     (define (insert! key-list value)
	       (let* ((key (car key-list))
                      (subtable (assoc key local-table)))
                  (if subtable
                     (if (null? (cdr key-list))
                         (set-cdr! subtable value)
                         (if (procedure? (cdr subtable))
                             (((cdr subtable) 'insert-proc!) (cdr key-list) value)
                             (let ((subsubtable (make-table)))
                                  ((subsubtable 'insert-proc!) (cdr key-list) value)
                                  (set-cdr! subtable subsubtable))))
                     (set! local-table
                           (cons
                              (cons key
                                 (if (null? (cdr key-list))
                                    value
                                    (let ((subsubtable (make-table)))
                                       ((subsubtable 'insert-proc!)
                                        (cdr key-list) value) subsubtable)))
                              local-table)))))
	     (define (dispatch m)
	       (cond ((eq? m 'lookup-proc) lookup)
		     ((eq? m 'insert-proc!) insert!)
                     (else (error "Unknown operation -- TABLE" m))))
	     dispatch))

	 (define operation-table (make-table))
	 (define get (operation-table 'lookup-proc))
	 (define put (operation-table 'insert-proc!))

  (display (put (list 'key1 'key2 'key3) 'test-value))
  (newline)
  (display (get (list 'key1 'key2 'key3)))
#+end_src

#+RESULTS[751f067909516793f7fdfd4df8247d2aa1146787]:
#+begin_src scheme
Starting
#<undef>
test-value
#+end_src

*** DONE Exercise 3.26 binary tree table
    CLOSED: [2019-12-06 Fri 20:53]

It is easy to implement a table lookup system based on an ordered set of
keys. A binary search tree is an easy example. In such a tree, every node
represents a key (with some payload value). The left child always has its key
ordered less than the right one, in every node. Searching is thus easy, you
start from the top of the tree, and follow right or left, depending whether
the key you are searching for is greater or less than the one you are looking
for.

This should clearly require \(O(\log n)\) steps if the tree is well
balanced. Insertion, if implemented naively, may work according to the same
scheme. However, if we try to insert a long list of successive numbers, we
will get a very deep and very thin tree, which will reduce the problem to the
implementation based on lists.


The problem happens if the tree is _not_ well balanced. Several re-balancing
algorithms exist, that for example AVL-trees and RB-trees. Those are usually
applied on ~insert!~, when the tree's "badness" metric exceeds some value.

*** DONE Exercise 3.27 memoization
    CLOSED: [2019-12-07 Sat 16:08]

It is very straightforward why plain ~(memoize fib)~ would not work. Because
every call to the same function should be snapped with a call to the
memoizer. That is the memoization only rememebers a call with which it is
associated. Since ~fib~ calls ~fib~ again, not ~memo-fib~, only the final
result would be remembered.

We want to make a diagram for ~(memo-fib 3)~.

#+name: exercise-3-27
#+header: :imagemagick yes :iminoptions -density 300 :imoutoptions -geometry 1000
#+header: :fit yes :headers '("\\usepackage{tikz} \\usetikzlibrary{positioning,fit,petri,arrows,calc}")
#+header: :buffer on
#+begin_src latex :results raw file :exports both :file exercise-3-27.png
\begin{tikzpicture}[inner sep=0mm,>=stealth',very thick,color=blue!99,
       font=\sffamily,pics/two dots/.style={code={
       \node [draw,minimum size=5mm,circle,colored tokens={blue!99}]
       (#1-left) {};
      \node [draw,minimum size=5mm,circle,colored tokens={blue!99},
      right=0pt of #1-left]
	  (#1-right) {};
      \node [rectangle, fit=(#1-left) (#1-right)] (#1){};
      }},
      every pin edge/.style={<-,very thick},
      box/.style={draw,rectangle,inner sep=#1},box/.default=2mm,
      node distance=4mm]

    \node (memoize-global)  {memoize: <...>};
    \node (fake1) [right=100mm of memoize-global] {};
    \node (memo-fib-global) [below=4mm of memoize-global.west,anchor=west] {memo-fib:};

    \node (g env) [box, fit=(memoize-global) (fake1) (memo-fib-global),
    pin={[text width=1cm,pin distance=10mm]left:global env}]
    { };
    \path
     node[below=2cm of memo-fib-global.west, anchor=west,align=left] (var-f) {f: lambda (n) <...>\\
      (fib implementation,\\ uses memo-fib)}
     node[box,draw, minimum size=1cm, fit=(var-f),pin=left:E1] (E1-env) {}
     ($ (E1-env.north west)!0.9!(E1-env.north east) $) coordinate (aux3);
     \draw[->] (aux3) -- (aux3 |- g env.south);

     \node[below=2cm of var-f.west, anchor=west] (table-var) {table: \#<procedure dispatch>}
     node[right=7cm of table-var] (fake2) {};
     \node[box,draw, fit=(table-var) (fake2),pin=left:E2] (E2-env) {};
     \path ($ (E2-env.north west)!0.1!(E2-env.north east) $) coordinate (aux2);
     \draw[->] (aux2) -- (aux2 |- E1-env.south);
     \path coordinate[below=1.5cm of table-var.west] (aux)
     (aux)  pic{two dots=memo-fib};
     \draw[->] (memo-fib-right.center) to (E2-env.south -| memo-fib-right.center);
     \node[below=10mm of memo-fib-left,align=left,anchor=north]
     {parameters: x\\
     body: <table lookup,\\ or uses f>}
     edge[<-] (memo-fib-left.center);
     \draw[<-,to path={-- ++(-2cm,0) |- ($ (\tikztotarget) - (0,1cm) $)}
                       -- (\tikztotarget)]
     (memo-fib.west) to (memo-fib-global.east);
     \path ($ (E2-env.south west)!0.2!(E2-env.south east) $) node(fake) {}
      node [box,below=1cm of fake] (fake2) {n: 3} edge[->] (fake)
      node [below=5mm of fake2] {<memo-fib...>};
     \path ($ (E2-env.south west)!0.4!(E2-env.south east) $) node(fake) {}
      node [box,below=1cm of fake] (fake2) {n: 2} edge[->] (fake)
      node [below=5mm of fake2] {<memo-fib...>};
     \path ($ (E2-env.south west)!0.6!(E2-env.south east) $) node(fake) {}
      node [box,below=1cm of fake] (fake2) {n: 1} edge[->] (fake)
      node [below=5mm of fake2] {<memo-fib...>};

\end{tikzpicture}
#+end_src

#+RESULTS[d7322af0a3a994e3469fbedc6cd8df07ed57b5ef]: exercise-3-27
[[file:exercise-3-27.png]]

I am not sure this is very explanatory, but seems to do the job...


*** Circuit simulation code

I am separating the circuit simulation code into a separate section, because
it is all very messy and scattered, and would be interfering with just
solving exercises.

#+name: circuit-simulator-1
#+begin_src scheme :exports code :results none
(define current-time 'placeholder)
(define delay #f)
  (define (get-signal wire) (wire 'get-signal))
  (define (set-signal! wire new-value)
    ((wire 'set-signal!) new-value))
  (define (add-action! wire action-procedure)
    ((wire 'add-action!) action-procedure))

  (define (call-each procedures)
    (if (null? procedures)
	'done
	(begin ((car procedures))
	       (call-each (cdr procedures)))))

  (define (make-wire)
    (let ((signal-value 0) (action-procedures '()))
      (define (set-my-signal! new-value)
	(if (not (= signal-value new-value))
	    (begin (set! signal-value new-value)
		   (call-each action-procedures))
	    'done))
      (define (accept-action-procedure! proc)
	(set! action-procedures
	  (cons proc action-procedures))
	(proc))
      (define (dispatch m)
	(cond ((eq? m 'get-signal) signal-value)
	      ((eq? m 'set-signal!) set-my-signal!)
	      ((eq? m 'add-action!) accept-action-procedure!)
	      (else (error "Unknown operation: WIRE" m))))
      dispatch))

  (define a (make-wire))
  (define b (make-wire))
  (define c (make-wire))
  (define d (make-wire))
  (define e (make-wire))
  (define s (make-wire))

  (define (half-adder a b s c)
    (let ((d (make-wire)) (e (make-wire)))
      (or-gate a b d)
      (and-gate a b c)
      (inverter c e)
      (and-gate d e s)
      'ok))

  (define (full-adder a b c-in sum c-out)
    (let ((s (make-wire)) (c1 (make-wire)) (c2 (make-wire)))
      (half-adder b c-in s c1)
      (half-adder a s sum c2)
      (or-gate c1 c2 c-out)
      'ok))

  (define (inverter input output)
    (define (invert-input)
      (let ((new-value (logical-not (get-signal input))))
        #;(show #t "Inverter-delay=" inverter-delay "\n")
	(after-delay inverter-delay
		     (lambda () (set-signal! output new-value)))))
    (add-action! input invert-input) 'ok)
  (define (logical-not s)
    (cond ((= s 0) 1)
	  ((= s 1) 0)
	  (else (error "Invalid signal" s))))

  (define (after-delay delayd action)
    (add-to-agenda! (+ delayd (current-time the-agenda))
		    action
		    the-agenda))

  (define (propagate)
    #;(show #t "propagate: agenda=" (displayed the-agenda) "\n")
    (if (empty-agenda? the-agenda)
	'done
	(let ((first-item (first-agenda-item the-agenda)))
	  (first-item)
	  (remove-first-agenda-item! the-agenda)
	  (propagate))))

  (define (probe name wire)
    (add-action! wire
		 (lambda ()
		   (newline)
		   (display name) (display " ")
                   (display "time= ")
		   (display (current-time the-agenda))
		   (display "  New-value = ")
		   (display (get-signal wire)))))

  <<queue>>

  (define (make-time-segment time queue)
    (cons time queue))
  (define (segment-time s) (car s))
  (define (segment-queue s) (cdr s))

  (define (make-agenda) (list 0))
  (define (current-time agenda) (car agenda))
  (define (set-current-time! agenda time)
    (set-car! agenda time))
  (define (segments agenda) (cdr agenda))
  (define (set-segments! agenda segments)
    (set-cdr! agenda segments))
  (define (first-segment agenda) (car (segments agenda)))
  (define (rest-segments agenda) (cdr (segments agenda)))

  (define (empty-agenda? agenda)
    (null? (segments agenda)))

  (define (add-to-agenda! time action agenda)
    (define (belongs-before? segments)
      (or (null? segments)
	 (< time (segment-time (car segments)))))
    (define (make-new-time-segment time action)
      (let ((q (make-queue)))
	(insert-queue! q action)
	(make-time-segment time q)))
    (define (add-to-segments! segments)
      (if (= (segment-time (car segments)) time)
	  (insert-queue! (segment-queue (car segments))
			 action)
	  (let ((rest (cdr segments)))
	    (if (belongs-before? rest)
		(set-cdr!
		 segments
		 (cons (make-new-time-segment time action)
		       (cdr segments)))
		(add-to-segments! rest)))))
    (let ((segments (segments agenda)))
      (if (belongs-before? segments)
	  (set-segments!
	   agenda
	   (cons (make-new-time-segment time action)
		 segments))
	  (add-to-segments! segments))))

  (define (remove-first-agenda-item! agenda)
    (let ((q (segment-queue (first-segment agenda))))
      (delete-queue! q)
      (if (empty-queue? q)
	  (set-segments! agenda (rest-segments agenda)))))

  (define (first-agenda-item agenda)
    (if (empty-agenda? agenda)
	(error "Agenda is empty: FIRST-AGENDA-ITEM")
	(let ((first-seg (first-segment agenda)))
          #;(show #t "f-a-i:current-time=" (car agenda) "\n")
	  (set-current-time! agenda
			     (segment-time first-seg))
	  (front-queue (segment-queue first-seg)))))

  (define (logical-and s1 s2)
    (cond ((and (= 1 s1) (= s2 1)) 1)
	  (else 0)))
  (define (and-gate a1 a2 output)
    (define (and-action-procedure)
      (let ((new-value
	     (logical-and (get-signal a1) (get-signal a2))))
        #;(show #t "And-gate-delay=" and-gate-delay "\n")
	(after-delay
	 and-gate-delay
	 (lambda () (set-signal! output new-value)))))
    (add-action! a1 and-action-procedure)
    (add-action! a2 and-action-procedure)
    'ok)

  <<or-gate-primitive>>

  #;(display "Done defining the circuit simulator.\n")
  'done-defining-circuit-simulator
#+end_src

For example, the procedure ~logical-and~ is not implemented
anywhere, so we will need to write it ourselves.

#+begin_src scheme :exports both :results output scalar code
    <<circuit-simulator-1>>
    (define the-agenda (make-agenda))
    (define inverter-delay 2)
    (define and-gate-delay 3)
    (define or-gate-delay 5)

    (define input-1 (make-wire))
    (define input-2 (make-wire))
    (define sum (make-wire))
    (define carry (make-wire))
    (show #t "(probe 'sum sum):\n")
    (probe 'sum sum)
    (show #t "\n(probe 'carry carry):\n")
    (probe 'carry carry)
    (show #t "\n(half-adder input-1 input-2 sum carry):\n")
    (half-adder input-1 input-2 sum carry)
    (show #t "\n(set-signal! input-1 1):\n")
    (set-signal! input-1 1)
    (show #t "\n(propagate):\n")
    (propagate)
    (show #t "\n(set-signal! input-2 1):\n")
    (set-signal! input-2 1)
    (show #t "\n(propagate):\n")
    (propagate)
#+end_src

#+RESULTS[9956b02667961e2c12ae08fcaa62002b3b4295c3]:
#+begin_src scheme
(probe 'sum sum):

sum time= 0  New-value = 0
(probe 'carry carry):

carry time= 0  New-value = 0
(half-adder input-1 input-2 sum carry):

(set-signal! input-1 1):

(propagate):

sum time= 8  New-value = 1
(set-signal! input-2 1):

(propagate):

carry time= 11  New-value = 1
sum time= 16  New-value = 0
#+end_src



*** DONE Exercise 3.28 primitive or-gate
    CLOSED: [2019-12-08 Sun 23:43]

In this exercise, there is one caveat that makes life of programmers
miserable. That is, 0 does not represent a false value in scheme. So
writing a readable code was a bit difficult, and the code below is
probably not correct.

#+name: or-gate-primitive
#+begin_src scheme :exports code :results none
(define (logical-or s1 s2)
    (cond ((or (= s1 1) (= s2 1)) 1)
	  (else 0)))
(define (or-gate a1 a2 output)
    (define (or-action-procedure)
      (let ((new-value
	     (logical-or (get-signal a1) (get-signal a2))))
        #;(show #t "or-gate-delay=" or-gate-delay "\n")
	(after-delay
	 or-gate-delay
	 (lambda () (set-signal! output new-value)))))
    (add-action! a1 or-action-procedure)
    (add-action! a2 or-action-procedure)
    'ok)
#+end_src

This code is used in the previous section. [[Circuit simulation code
]]

*** DONE Exercise 3.29 Compound or-gate
    CLOSED: [2019-12-08 Sun 23:45]

\( \vee (a,b) = \wedge(\neg a, \neg b)\)

#+name: or-gate-procedural
#+begin_src scheme :exports code :results none
(define (or-gate a b c)
    (let ((d (make-wire)) (e (make-wire)))
      (inverter a d)
      (inverter b e)
      (and-gate d e c)
      'ok))
#+end_src

I have no idea how slow this works, and we don't have a simulation routine
to check. But the delay should be the sum of the and-gate delay and just one
of the inverter delays (because the two inverters work in parallel).

*** DONE Exercise 3.30 ripple-carry adder
    CLOSED: [2019-12-08 Sun 23:58]

#+begin_src scheme :exports both :results output scalar code
<<circuit-simulator-1>>
<<or-gate-primitive>>

    (define the-agenda (make-agenda))
    (define inverter-delay 2)
    (define and-gate-delay 3)
    (define or-gate-delay 5)

  (define (make-wire-list n my-list)
    (if (= n 0)
	my-list
	(make-wire-list (- n 1) (cons (make-wire) my-list))))
  (define test-length 2)
  (define A (make-wire-list test-length '()))
  (define B (make-wire-list test-length '()))
  (define S (make-wire-list test-length '()))
  (define C (make-wire))

  (define (ripple-carry-adder a b s c)
    (let ((A_n (car a))
	  (B_n (car b))
	  (S_n (car s))
	  (C_n-1 (make-wire)))
      (full-adder A_n B_n c S_n C_n-1)
      (if (null? (cdr a))
	  C_n-1
	  (ripple-carry-adder (cdr a) (cdr b) (cdr s) C_n-1))))
  (define C_out (ripple-carry-adder A B S C))

  (probe 'C_out C_out)
  (set-signal! (list-ref A 1) 1)
  (set-signal! (list-ref A 0) 1)
  (set-signal! (list-ref B 1) 1)
  (propagate)
#+end_src

#+RESULTS[d663e2b237d64a6b7b5b781bd7a53fc622844471]:
#+begin_src scheme

C_out time= 0  New-value = 0
C_out time= 16  New-value = 1
#+end_src

This ripple-carry-adder is not very efficient. Also, bits are represented in
the little-ending format. Also, we can still not test it, since the
simulation function is not given.

*** DONE Exercise 3.31 Initial propagation
    CLOSED: [2019-12-09 Mon 00:16]

Initial propagation is needed for in initial intermediate values of
the wires to be consistent.

In particular, look at the inverter gate. If we don't run
initialisation, then at time 0, the gate would have it's input as 0
(which is a normal state for a newly-created wire), and it's output as
0 too. But this condition for an inverter is wrong.

*** DONE Exercise 3.32 Order matters
CLOSED: [2019-12-09 Mon 00:26]

The problem with adding operations in a standard list is that the
intermediate results are getting in the execution after the final
ones.

In this particular example, changing (0,1) to (1,0), we have to go
through (1,1). And it doesn't matter than we are going to (1,0) after,
because the simulation for (1,1) will be in the queue later.

*** Constraint propagation system

In this section I will place common code for the constraint
propagation system, because it is quite big.

#+name: constraints-system
#+begin_src scheme :exports code :results none
  (define false #f)
  (define true #t)
  (define (adder a1 a2 sum)
    (define (process-new-value)
      (cond ((and (has-value? a1) (has-value? a2))
	     (set-value! sum
			 (+ (get-value a1) (get-value a2))
			 me))
	    ((and (has-value? a1) (has-value? sum))
	     (set-value! a2
			 (- (get-value sum) (get-value a1))
			 me))
	    ((and (has-value? a2) (has-value? sum))
	     (set-value! a1
			 (- (get-value sum) (get-value a2))
			 me))))
    (define (process-forget-value)
      (forget-value! sum me)
      (forget-value! a1 me)
      (forget-value! a2 me)
      (process-new-value))
    (define (me request)
      (cond ((eq? request 'I-have-a-value)
	     (process-new-value))
	    ((eq? request 'I-lost-my-value) (process-forget-value))
	    (else (error "Unknown request: ADDER" request))))
    (connect a1 me)
    (connect a2 me)
    (connect sum me)
    me)

  (define (inform-about-value constraint)
    (constraint 'I-have-a-value))
  (define (inform-about-no-value constraint)
    (constraint 'I-lost-my-value))

  (define (multiplier m1 m2 product)
    (define (process-new-value)
      (cond ((or (and (has-value? m1) (= (get-value m1) 0))
		 (and (has-value? m2) (= (get-value m2) 0)))
	     (set-value! product 0 me))
	    ((and (has-value? m1) (has-value? m2))
	     (set-value! product
			 (* (get-value m1) (get-value m2))
			 me))
	    ((and (has-value? product) (has-value? m1))
	     (set-value! m2
			 (/ (get-value product)
			    (get-value m1))
			 me))
	    ((and (has-value? product) (has-value? m2))
	     (set-value! m1
			 (/ (get-value product)
			    (get-value m2))
			 me))))
    (define (process-forget-value)
      (forget-value! product me)
      (forget-value! m1 me)
      (forget-value! m2 me)
      (process-new-value))
    (define (me request)
      (cond ((eq? request 'I-have-a-value)
	     (process-new-value))
	    ((eq? request 'I-lost-my-value) (process-forget-value))
	    (else (error "Unknown request: MULTIPLIER"
			 request))))
    (connect m1 me)
    (connect m2 me)
    (connect product me)
    me)

  (define (constant value connector)
    (define (me request)
      (error "Unknown request: CONSTANT" request))
    (connect connector me)
    (set-value! connector value me)
    me)

  (define (probe name connector)
    (define (print-probe value)
      (newline) (display "Probe: ") (display name)
      (display " = ") (display value))
    (define (process-new-value)
      (print-probe (get-value connector)))
    (define (process-forget-value) (print-probe "?"))
    (define (me request)
      (cond ((eq? request 'I-have-a-value)
	     (process-new-value))
	    ((eq? request 'I-lost-my-value) (process-forget-value))
	    (else (error "Unknown request: PROBE" request))))
    (connect connector me)
    me)

  (define (make-connector)
    (let ((value false) (informant false) (constraints '()))
      (define (set-my-value newval setter)
	(cond ((not (has-value? me))
	       (set! value newval)
	       (set! informant setter)
	       (for-each-except setter
				inform-about-value
				constraints))
	      ((not (= value newval))
	       (error "Contradiction" (list value newval)))
	      (else 'ignored)))
      (define (forget-my-value retractor)
	(if (eq? retractor informant)
	    (begin (set! informant false)
		   (for-each-except retractor
				    inform-about-no-value
				    constraints))
	    'ignored))
      (define (connect new-constraint)
	(if (not (memq new-constraint constraints))
	    (set! constraints
	      (cons new-constraint constraints)))
	(if (has-value? me)
	    (inform-about-value new-constraint))
	'done)
      (define (me request)
	(cond ((eq? request 'has-value?)
	       (if informant true false))
	      ((eq? request 'value) value)
	      ((eq? request 'set-value!) set-my-value)
	      ((eq? request 'forget) forget-my-value)
	      ((eq? request 'connect) connect)
	      (else (error "Unknown operation: CONNECTOR"
			   request))))
      me))

  (define (for-each-except exception procedure list)
    (define (loop items)
      (cond ((null? items) 'done)
	    ((eq? (car items) exception) (loop (cdr items)))
	    (else (procedure (car items))
			 (loop (cdr items)))))
    (loop list))

  (define (has-value? connector)
    (connector 'has-value?))
  (define (get-value connector)
    (connector 'value))
  (define (set-value! connector new-value informant)
    ((connector 'set-value!) new-value informant))
  (define (forget-value! connector retractor)
    ((connector 'forget) retractor))
  (define (connect connector new-constraint)
    ((connector 'connect) new-constraint))

#+end_src


#+begin_src scheme :exports both :results output scalar code
  <<constraints-system>>
  (define (celsius-fahrenheit-converter c f)
    (let ((u (make-connector))
	  (v (make-connector))
	  (w (make-connector))
	  (x (make-connector))
	  (y (make-connector)))
      (multiplier c w u)
      (multiplier v x u)
      (adder v y f)
      (constant 9 w)
      (constant 5 x)
      (constant 32 y)
      'ok))

  (define C (make-connector))
  (define F (make-connector))

  (celsius-fahrenheit-converter C F)
  (probe "Celsius temp" C)
  (probe "Fahrenheit temp" F)

  (set-value! C 25 'user)
  #;(set-value! F 212 'user) #;("errors")
  (forget-value! C 'user)
  (set-value! F 212 'user)

#+end_src

#+RESULTS[c6aaa50c8f8d27d2bf84c66f7baa0026378e2160]:
#+begin_src scheme

Probe: Celsius temp = 25
Probe: Fahrenheit temp = 77
Probe: Celsius temp = ?
Probe: Fahrenheit temp = ?
Probe: Fahrenheit temp = 212
Probe: Celsius temp = 100
#+end_src

*** DONE Exercise 3.33 averager constraint
    CLOSED: [2019-12-18 Wed 11:29]

#+name: constraints-averager
#+begin_src scheme :exports code :results none
(define (averager a b c)
    (define (process-new-value)
      (cond
	    ((and (has-value? a) (has-value? b))
	     (set-value! c
			 (/ (+ (get-value a) (get-value b)) 2)
			 me))
	    ((and (has-value? c) (has-value? a))
	     (set-value! b
			 (- (* 2 (get-value product))
			    (get-value a))
			 me))
	    ((and (has-value? c) (has-value? b))
	     (set-value! a
			 (- (* 2 (get-value c))
			    (get-value b))
			 me))))
    (define (process-forget-value)
      (forget-value! c me)
      (forget-value! a me)
      (forget-value! b me)
      (process-new-value))
    (define (me request)
      (cond ((eq? request 'I-have-a-value)
	     (process-new-value))
	    ((eq? request 'I-lost-my-value) (process-forget-value))
	    (else (error "Unknown request: AVERAGER"
			 request))))
    (connect a me)
    (connect b me)
    (connect c me)
    me)

#+end_src

#+begin_src scheme :exports both :results output scalar code
<<constraints-system>>
<<constraints-averager>>

(define localA (make-connector))
(define localB (make-connector))
(define localC (make-connector))
(averager localA localB localC)

(probe "localA: " localA)
(probe "localB: " localB)
(probe "localC: " localC)
(set-value! localA 25 'user)
(set-value! localB 27 'user)
(guard (err
         (else (show #t "\nExpected failure: " (displayed err) "\n")))
  (set-value! localC 22 'user))
(forget-value! localA 'user)
(set-value! localC 22 'user)
#+end_src

#+RESULTS[2e4422fbb30a935dcc1a546317c582c7dd9abe6e]:
#+begin_src scheme

Probe: localA:  = 25
Probe: localB:  = 27
Probe: localC:  = 26
Expected failure: {Exception #19 user "Contradiction" ((26 22)) #f #f}

Probe: localA:  = ?
Probe: localC:  = ?
Probe: localC:  = 22
Probe: localA:  = 17
#+end_src

*** DONE Exercise 3.34 Wrong squarer
    CLOSED: [2019-12-18 Wed 12:30]

The problem with this system is that the inversion procedure wouldn't
work. That is, the multiplier has three connections, and every two
define the third one. This is not the case with the squarer, as in the
formula \( a \cdot a = b \), if we are given \(b\), we immediately get
the value on both of the connectors leading to \(a\).

*** DONE Exercise 3.35 Correct squarer
    CLOSED: [2019-12-18 Wed 12:47]

#+name: constraints-squarer
#+begin_src scheme :exports code :results none
          (define (squarer a b)
            (define (process-new-value)
              (if (has-value? b)
                  (if (< (get-value b) 0)
                      (error "square less than 0 -- SQUARER" (get-value b))
                      (set-value! a
                                  (sqrt (get-value b))
                                  me))
                  (if (has-value? a)
                      (set-value! b
                                  (* (get-value a) (get-value a))
                                  me))))
            (define (process-forget-value)
               (forget-value! b me)
               (forget-value! a me))
            (define (me request)
                (cond ((eq? request 'I-have-a-value)
	                 (process-new-value))
	              ((eq? request 'I-lost-my-value)
                         (process-forget-value))
	    (else (error "Unknown request: SQUARER" request))))
            (connect a me)
            (connect b me)
            me)
#+end_src


#+begin_src scheme :exports both :results output scalar code
<<constraints-squarer>>
<<constraints-system>>

(define localA (make-connector))
(define localB (make-connector))
(squarer localA localB)
(probe "localA: " localA)
(probe "localB: " localB)
(set-value! localA 25 'user)
(guard (err
         (else (show #t "\nExpected failure: " (displayed err))))
  (set-value! localB 22 'user))
(forget-value! localA 'user)
(set-value! localB 22 'user)
#+end_src

#+RESULTS[f8c37048abf98025bc414a8e7d290dead8ae02f1]:
#+begin_src scheme

Probe: localA:  = 25
Probe: localB:  = 625
Expected failure: {Exception #19 user "Contradiction" ((625 22)) #f #f}
Probe: localA:  = ?
Probe: localB:  = ?
Probe: localB:  = 22
Probe: localA:  = 4.69041575982343
#+end_src

*** DONE Exercise 3.36 Connector environment diagram                   :tikz:
    CLOSED: [2019-12-21 Sat 20:27]

We are studying the following code:

#+begin_src scheme :exports code :results none
(define a (make-connector))
(define b (make-connector))
(set-value! a 10 'user)
#+end_src

#+name: exercise-3-36
#+header: :imagemagick yes :iminoptions -density 300 :imoutoptions -geometry 1000
#+header: :fit yes :headers '("\\usepackage{tikz} \\usetikzlibrary{positioning,fit,petri,arrows,calc,matrix,quotes}")
#+header: :buffer on
#+begin_src latex :results raw file :exports both :file exercise-3-36.png
\begin{tikzpicture}[inner sep=0mm,>=stealth',very thick,color=blue!99,
       every node/.style={font=\sffamily,align=left},
       font=\sffamily,pics/two dots/.style={code={
       \node [draw,minimum size=5mm,circle,colored tokens={blue!99}]
       (#1-left) {};
      \node [draw,minimum size=5mm,circle,colored tokens={blue!99},
      right=0pt of #1-left]
	  (#1-right) {};
      \node [rectangle, fit=(#1-left) (#1-right)] (#1){};
      }},
      every pin edge/.style={<-,very thick},
      box/.style={draw,rectangle,inner sep=#1},box/.default=2mm,
      envi/.style={matrix of nodes, align=left,
                  every node/.style={anchor=west},
                  inner sep={0.7mm},
                  execute at end cell={\vphantom{()}},
                  draw},
      node distance=4mm]

    \node (a-global)  {a:};
    \node (fake1) [right=150mm of a-global] {};
    \node (b-global) [below=4mm of a-global.west,anchor=west] {b:};
    \node (iov-global) [below=4mm of b-global.west,anchor=west] {inform-about-value:};
    \node (sv-global) [below=4mm of iov-global.west,anchor=west] {set-value!:};

    \node (g-env) [box, fit=(a-global) (fake1) (b-global) (iov-global) (sv-global),
    pin={[text width=1cm,pin distance=10mm]left:global env}]
    { };
     \path ($ (g-env.south west)!0.3!(g-env.south east) $) coordinate (fake1)
      coordinate[below=1cm of fake1] (fake) (fake) pic{two dots=set-to-value}
      (set-to-value) edge[<-,to path={|- (\tikztotarget)}] (sv-global.east)
      (set-to-value-right.center) edge[->] (fake1 -| set-to-value-right.center);

     \path ($ (g-env.south west)!0.5!(g-env.south east) $) coordinate (fake1)
      coordinate[below=1cm of fake1] (fake) (fake) pic{two dots=i-a-v}
      (i-a-v) edge[<-,to path={|- (\tikztotarget)}] (iov-global.east)
      (i-a-v-right.center) edge[->] (fake1 -| i-a-v-right.center);


     \path ($ (g-env.south west)!0.1!(g-env.south east) $) node(fake) {};
     \matrix (a) [envi,
                  below=of fake]
     {
       value: 10\\
       informant: 'user\\
       constraints: '() \\
       |(a-set-my-value)| set-my-value: \\
       |(a-forget-my-value)| forget-my-value: \\
       |(a-connect)| connect: \\
       |(a-me)| me:\\
     } edge[->] (fake);

     \path coordinate[right=2.5cm of a-me] (aux)
      (aux) pic{two dots=amev}
      (amev) edge [<-] (a-me) (amev-right.center)
             edge [->,to path={|- (\tikztotarget)}] ($ (a.east)$)
             node[below=0.5cm of amev-left] {parameters: newvalue\\
                                             \phantom{parameters: }setter\\
                                             body: ... }
             edge[<-] (amev-left.center);
     \draw[->] (a-global.east) to[to path={  -| (\tikztotarget)}] (amev);

     \path ($ (g-env.south west)!0.9!(g-env.south east) $) node(fake) {};
     \matrix (b) [ below=of fake,envi]
     {
       value: \#f\\
       informant: \#f\\
       constraints: '() \\
       |(b-set-my-value)| set-my-value: <...>\\
       |(b-forget-my-value)| forget-my-value: <...> \\
       |(b-connect)| connect: <...> \\
       |(b-me)| me:\\
     } edge[->] (fake);

     \path coordinate[right=40mm of b-me] (aux)
      (aux) pic{two dots=bmev}
      (bmev) edge [<-] (b-me)
             (bmev-right.center)
                edge [->,to path={|- (\tikztotarget)}]
                  ($ (b.east) + (0,0mm)$)
             node[below=0.5cm of bmev-left] {parameters: newvalue\\
                                             \phantom{parameters: }setter\\
                                             body: ... }
             edge[<-] (bmev-left.center);

     \draw[->] (b-global.east) to[to path={-| (\tikztotarget)}] (bmev);

     \matrix (smv) [below=2cm of a, envi]
     {
       newval: 10\\
       setter: 'user\\
     } edge[->] (a)
     ($ (a.south)!0.5!(smv.north) $) node[anchor=east]
      {(set-my-value 10 'user)};

     \matrix (fee) [below=2cm of smv,envi]
     {
      exception: 'user\\
      |(pp)| procedure:\\
      constraints: '()\\
      loop: <...> \\
     } edge[->] (smv)
      (pp.east) edge[->, to path={-| (\tikztotarget)}] (i-a-v)
     ($ (smv.south)!0.5!(fee.north)$) node[anchor=east]
     {(for-each-except\\
       'user \\
       inform-about-value \\
       '())};
     \matrix (loop) [below=1cm of fee, envi]
     {
       items: '()\\
     } edge[->] (fee)
     ($ (fee.south)!0.5!(loop.north) $) node[anchor=east]
     {(loop '())}
     node[below=of loop,anchor=north]
     {(cond\\
        ((null? items)\\
          'done)\\
        ((eq? (car items) exception)\\
        (loop (cdr items)))\\
        (else\\
        (procedure (car items))\\
        (loop (cdr items))))};

\end{tikzpicture}
#+end_src

#+RESULTS[c7b1a37973c076a619c7d2ff7d46a940ff93f249]: exercise-3-36
[[file:exercise-3-36.png]]

Not as much of a difficult drawing exercise, still took me about 5
hours. Drawing is hard.

*** DONE Exercise 3.37 Expression-based constraints
    CLOSED: [2019-12-21 Sat 21:20]

#+name: constraints-expressions
#+begin_src scheme :exports code :results none
  (define (c+ x y)
    (let ((z (make-connector)))
      (adder x y z)
      z))
  (define (c* x y)
    (let ((z (make-connector)))
      (multiplier x y z)
      z))
  (define (cv value)
    (let ((z (make-connector)))
      (constant value z)
      z))
  (define (c/ x y)
    (let ((z (make-connector)))
      (multiplier y z x)
      z))
#+end_src


#+begin_src scheme :exports both :results output scalar code
<<constraints-system>>
<<constraints-expressions>>
  (define (celsius-fahrenheit-converter x)
    (c+
     (c*
      (c/ (cv 9) (cv 5))
      x)
     (cv 32)))
  (define C (make-connector))
  (define F (celsius-fahrenheit-converter C))
(probe "Celsius temp" C)
(probe "Fahrenheit temp" F)
(set-value! F 212 'user)

#+end_src

#+RESULTS[661b556142a3f56630492a584fe475dadb3499ff]:
#+begin_src scheme

Probe: Fahrenheit temp = 212
Probe: Celsius temp = 100
#+end_src

This turned out to be a very easy task. The only trick here really is
to use the multiplies as a divider.

*** DONE Exercise 3.38 Timing
    CLOSED: [2019-12-21 Sat 22:48]

The three users to the following:

Peter: (set! balance (+ balance 10))
Paul: (set! balance (- balance 20))
Mary: (set! balance (- balance (/ balance 2)))

**** a
The three possible code orderings are the following:

#+begin_src scheme :exports both :results value scalar code
(define balance 100)
(set! balance (+ balance 10))
(set! balance (- balance 20))
(set! balance (- balance (/ balance 2)))
balance
#+end_src

#+RESULTS[d011e9cf2afb73a51bbf1a8742ea0b813c5b241f]:
#+begin_src scheme
45
#+end_src

#+begin_src scheme :exports both :results value scalar code
(define balance 100)
(set! balance (- balance 20))
(set! balance (- balance (/ balance 2)))
(set! balance (+ balance 10))
balance
#+end_src

#+RESULTS[82a55a515cb0088ccd71e8bef550313a5f8905fe]:
#+begin_src scheme
50
#+end_src

#+begin_src scheme :exports both :results value scalar code
(define balance 100)
(set! balance (- balance (/ balance 2)))
(set! balance (- balance 20))
(set! balance (+ balance 10))
balance
#+end_src

#+RESULTS[026e3bcae0df7d7eca552112f5a18a0a7223f48e]:
#+begin_src scheme
40
#+end_src

**** b

#+begin_src plantuml :exports both :file exercise-3-38.png
@startuml
skinparam monochrome true
actor "   Peter   " as Peter
actor "   Paul   "  as Paul
actor "   Mary   "  as Mary
entity "   Bank   " as Bank
rnote over Bank: $100
Mary -> Bank: Access\n balance
Bank -> Mary: $100
note over Mary: $100
Paul -> Bank: Access\n balance
Bank -> Paul: $100
note over Paul: $100
Peter -> Bank: Access\n balance
Bank -> Paul: $100
note over Mary: $100/2=$50
Mary -> Bank: set-balance! $50
rnote over Bank: $50
note over Paul: $100-$20=$80
Paul -> Bank: set-balance! $80
rnote over Bank: $80
note over Peter: $100+$10=$110
Peter -> Bank: set-balance! $110
rnote over Bank: $110
@enduml
#+end_src

#+RESULTS[7c4e62e909ca211ba7affddddcb720bf53ae6b15]:
[[file:exercise-3-38.png]]

Obviously, the values of 50, 80 and 110 are wrong. Any of those can
end up as the final value, depending on the timing of ~set-balance!~.
*** Implementing ~(parallel-execute)~ and serializers

#+name: parallel-execute
#+begin_src scheme :exports code :results none
(define (parallel-execute . forms)
  (let ((myo (open-output-string)))
    (define (create-threads . forms)
    (if (null? forms)
	(list)
	(let ((ctxi (thread-start!
		     (make-thread
		      (lambda () (parameterize ((current-output-port myo))
				((car forms))))))))
	  (cons ctxi (apply create-threads (cdr forms))))))
  (define (wait-threads thread-list)
    (if (null? thread-list)
	#t
	(begin (thread-join! (car thread-list))
	       (wait-threads (cdr thread-list)))))
  (wait-threads (apply create-threads forms))
  (display (get-output-string myo))))

#+end_src

#+begin_src scheme :exports both :results output scalar code
<<parallel-execute>>
(parallel-execute
  (lambda () (thread-sleep! 3) (display "hello1") (newline))
  (lambda () (display "hello2") (newline)))
(display "hello3\n")
#+end_src

#+RESULTS[de1674d1f51df9fffb895feda77a2c3a793b3f4d]:
#+begin_src scheme
hello2
hello1
hello3
#+end_src

#+begin_src scheme :exports both :results value scalar code
<<parallel-execute>>
(define x 10)
(parallel-execute
(lambda () (thread-sleep! 1) (set! x (* x x)))
(lambda () (set! x (+ x 1))))
x
#+end_src

#+RESULTS[07d93e7773db8fba631a9de1e9b443a7ae3c2bd3]:
#+begin_src scheme
121
#+end_src

#+name: make-serializer
#+begin_src scheme :exports code :results none
  (define false #f)
  (define true #t)
  (define central-old-mutex (make-mutex 'global-srfi-18-mutex))
  (set! make-mutex #f)
  (define (test-and-set! cell)
    (mutex-lock! central-old-mutex)
    (let ((output (if (car cell) true (begin (set-car! cell true) false))))
      (mutex-unlock! central-old-mutex)
      output))

  (define (make-mutex)
    (let ((cell (list false)))
      (define (the-mutex m)
	(cond ((eq? m 'acquire)
	       (if (test-and-set! cell)
		   (the-mutex 'acquire)))
	      ((eq? m 'release) (clear! cell))))
      the-mutex))
  (define (clear! cell) (set-car! cell false))

  (define (make-serializer)
    (let ((mutex (make-mutex)))
      (lambda (p)
	(define (serialized-p . args)
	  (mutex 'acquire)
	  (let ((val (apply p args)))
	    (mutex 'release)
	    val))
	serialized-p)))

#+end_src

#+name: make-parallel-account
#+begin_src scheme :exports code :results none
  (define (make-account balance)
    (define (withdraw amount)
      (if (>= balance amount)
	  (begin (set! balance (- balance amount))
		 balance)
	  "Insufficient funds"))
    (define (deposit amount)
      (set! balance (+ balance amount))
      balance)
    (let ((protected (make-serializer)))
      (define (dispatch m)
	(cond ((eq? m 'withdraw) (protected withdraw))
	      ((eq? m 'deposit) (protected deposit))
	      ((eq? m 'balance) balance)
	      (else (error "Unknown request: MAKE-ACCOUNT"
			   m))))
      dispatch))
#+end_src

*** DONE Exercise 3.39 Serializer
    CLOSED: [2019-12-23 Mon 05:11]

The original code is the following:

#+begin_src scheme :exports code :results none
(define x 10)
(parallel-execute
(lambda () (set! x (* x x)))
(lambda () (set! x (+ x 1))))
#+end_src

The original five outcomes were the following:

 - 101: P1 sets x to 100 and then P2 increments x to 101.
 - 121: P2 increments x to 11 and then P1 sets x to x * x .
 - 110: P2 changes x from 10 to 11 between the two times that
   P1 accesses the value of x during the evaluation of (* x x) .
 - 11:  P2 accesses x , then P1 sets x to 100, then P2 sets x .
 - 100: P1 accesses x (twice), then P2 sets x to 11, then P1 sets x .

We are serializing one of the branches:

#+begin_src scheme :exports code :results none
  (define x 10)
  (define s (make-serializer))
  (parallel-execute
   (lambda () (set! x ((s (lambda () (* x x))))))
   (s (lambda () (set! x (+ x 1)))))
#+end_src

In this case, the additive branch is fully serialized, and the
multiplicative had assignment and multiplication detached. The options
121 and 101 still remain, as they don't depend on the internal
serialization. The branch resulting in 110 is disabled, because the
read access to ~x~ is guaranteed to be sequential. The branch
resulting in 11 is also disabled, since accessing and setting is
guaranteed too happen together in the second branch. The branch
resulting in 100 remains a possible option, since the computation of
~(* x x)~ and the assignment are not guaranteed to happen in order.

So in the end, the three remaining options are:

 - 101: P1 sets x to 100 and then P2 increments x to 101.
 - 121: P2 increments x to 11 and then P1 sets x to x * x .
 - 100: P1 accesses x (twice), then P2 sets x to 11, then P1 sets x .

*** DONE Exercise 3.40 Three parallel multiplications
    CLOSED: [2019-12-29 Sun 04:32]

**** Part 1

#+begin_src scheme :exports code :results none
(define x 10)
(parallel-execute (lambda () (set! x (* x x)))
                  (lambda () (set! x (* x x x))))
#+end_src

Here there are two read operations and one write operation in the
first thread, and three read operations and one write operation in the
second branch.

So we need to find the number of unique interleavings of two
sequences: (1 2 3 4) and (a b c). The total number of interleavings is
\(C_{x+y}^{x}\), which is 35, although it doesn't mean that all
interleavings produce different outcomes.

Those sequences can be generated algorithmically:
https://math.stackexchange.com/questions/628120/number-of-possible-interleavings-of-two-strings-of-lengths-m-and-n
https://stackoverflow.com/questions/36260956/all-possible-ways-to-interleave-two-strings

It should be also possible to write a scheme macro to serialize
~parallel-execute~. And it should also be possible to do it
efficiently.

However, at the moment it seems rather feasible to write out
all possible serializations (interleavings) by hand.

In total this makes the following sequences:

| #op | 1      | 2      | 3       | 4       | 5       | 6       | 7       | Result     |
|-----+--------+--------+---------+---------+---------+---------+---------+------------|
|   1 | 1 read | 1 read | 1 write | 2 read  | 2 read  | 2 read  | 2 write | 1 00 00 00 |
|   2 | 1 read | 1 read | 2 read  | 1 write | 2 read  | 2 read  | 2 write | 1 00 00 0  |
|   3 | 1 read | 1 read | 2 read  | 2 read  | 1 write | 2 read  | 2 write | 1 00 00    |
|   4 | 1 read | 1 read | 2 read  | 2 read  | 2 read  | 1 write | 2 write | 1 00 0     |
|   5 | 1 read | 1 read | 2 read  | 2 read  | 2 read  | 2 write | 1 write | 1 00       |
|   6 | 1 read | 2 read | 1 read  | 1 write | 2 read  | 2 read  | 2 write | 1 00 00 0  |
|   7 | 1 read | 2 read | 1 read  | 2 read  | 1 write | 2 read  | 2 write | 1 00 00    |
|   8 | 1 read | 2 read | 1 read  | 2 read  | 2 read  | 1 write | 2 write | 1 00 0     |
|   9 | 1 read | 2 read | 1 read  | 2 read  | 2 read  | 2 write | 1 write | 1 00       |
|  10 | 1 read | 2 read | 2 read  | 1 read  | 1 write | 2 read  | 2 write | 1 00 00    |
|  11 | 1 read | 2 read | 2 read  | 1 read  | 2 read  | 1 write | 2 write | 1 00 0     |
|  12 | 1 read | 2 read | 2 read  | 1 read  | 2 read  | 2 write | 1 write | 1 00       |
|  13 | 1 read | 2 read | 2 read  | 2 read  | 1 read  | 1 write | 2 write | 1 00 0     |
|  14 | 1 read | 2 read | 2 read  | 2 read  | 1 read  | 2 write | 1 write | 1 00       |
|  15 | 1 read | 2 read | 2 read  | 2 read  | 2 write | 1 read  | 1 write | 1 00 00    |
|  16 | 2 read | 1 read | 1 read  | 1 write | 2 read  | 2 read  | 2 write | 1 00 00 0  |
|  17 | 2 read | 1 read | 1 read  | 2 read  | 1 write | 2 read  | 2 write | 1 00 00    |
|  18 | 2 read | 1 read | 1 read  | 2 read  | 2 read  | 1 write | 2 write | 1 00 0     |
|  19 | 2 read | 1 read | 1 read  | 2 read  | 2 read  | 2 write | 1 write | 1 00       |
|  20 | 2 read | 1 read | 2 read  | 1 read  | 1 write | 2 read  | 2 write | 1 00 00    |
|  21 | 2 read | 1 read | 2 read  | 1 read  | 2 read  | 1 write | 2 write | 1 00 0     |
|  22 | 2 read | 1 read | 2 read  | 1 read  | 2 read  | 2 write | 1 write | 1 00       |
|  23 | 2 read | 1 read | 2 read  | 2 read  | 1 read  | 1 write | 2 write | 1 00 0     |
|  24 | 2 read | 1 read | 2 read  | 2 read  | 1 read  | 2 write | 1 write | 1 00       |
|  25 | 2 read | 1 read | 2 read  | 2 read  | 2 write | 1 read  | 1 write | 1 00 00    |
|  26 | 2 read | 2 read | 1 read  | 1 read  | 1 write | 2 read  | 2 write | 1 00 00    |
|  27 | 2 read | 2 read | 1 read  | 1 read  | 2 read  | 1 write | 2 write | 1 00 0     |
|  28 | 2 read | 2 read | 1 read  | 1 read  | 2 read  | 2 write | 1 write | 1 00       |
|  29 | 2 read | 2 read | 1 read  | 2 read  | 1 read  | 1 write | 2 write | 1 00 0     |
|  30 | 2 read | 2 read | 1 read  | 2 read  | 1 read  | 2 write | 1 write | 1 00       |
|  31 | 2 read | 2 read | 1 read  | 2 read  | 2 write | 1 read  | 1 write | 1 00 00    |
|  32 | 2 read | 2 read | 2 read  | 1 read  | 1 read  | 1 write | 2 write | 1 00 0     |
|  33 | 2 read | 2 read | 2 read  | 1 read  | 1 read  | 2 write | 1 write | 1 00       |
|  34 | 2 read | 2 read | 2 read  | 1 read  | 2 write | 1 read  | 1 write | 1 00 00    |
|  35 | 2 read | 2 read | 2 read  | 2 write | 1 read  | 1 read  | 1 write | 1 00 00 00 |

So the total set of ~x~ values is ~(100, 1000, 10000, 100000,
1000000)~.

It would not have been to hard to generate all those read/write
sequences, but I wonder, how would I generate all possible codes to
check the outcomes?

**** Part 2

When the two serialized procedures are used:

#+begin_src scheme :exports code :results none
(define x 10)
(define s (make-serializer))
(parallel-execute (s (lambda () (set! x (* x x))))
                  (s (lambda () (set! x (* x x x)))))
#+end_src

Only two outcomes are left: when the first function runs, and when the
second function runs, which is either \(100^3\), or \(1000^2\), which is
both 1000000.

*** DONE Exercise 3.41 Better protected account
    CLOSED: [2020-01-02 Thu 10:02]

I don't think that Ben's concern is valid. It may indeed happen that
the value of ~balance~ changes between the time when the value is
queried and the time it is returned, however wrapping a value in a
protective serialized lambda does not solve this issue. Rather the
whole call to the ~balance~ getter would need to be serialized.

*** DONE Exercise 3.42 Saving on serializers
    CLOSED: [2020-01-02 Thu 10:35]

This exercise seems to be dealing with a thing called reentrancy,
which seems to be quite implementation-dependent. The version I wrote
would be asking to acquire the mutex any way, so I don't see how a
race condition can appear here.

#+begin_src scheme :exports both :results value scalar code
<<parallel-execute>>
<<make-serializer>>
<<make-parallel-account>>
 (let ((acc (make-account 100)))
   (parallel-execute
     (lambda () (thread-sleep! 0.1) ((acc 'withdraw) 10))
     (lambda () ((acc 'withdraw) 20)))
   (acc 'balance))

#+end_src

#+RESULTS[767b75bf6a2dd6db1cbac1a899d7b4d71527ad78]:
#+begin_src scheme
70
#+end_src

*** DONE Exercise 3.43 Multiple serializations
    CLOSED: [2020-01-02 Thu 11:33]

#+name: unsafe-change
#+begin_src scheme :exports code :results none
  (define (exchange account1 account2)
    (let ((difference (- (account1 'balance)
			 (account2 'balance))))
      ((account1 'withdraw) difference)
      ((account2 'deposit) difference)))
#+end_src

It seems to be quite obvious that this code works correctly in a
single-threaded case. Any inconsistency would arise from an incorrect
order of mutations, but with one thread, this never happens.

For the parallel case, the following erroneous behaviour may happen:

#+begin_src plantuml :exports both :file exercise-3-43-1.png
@startuml
skinparam monochrome true
actor "   Peter   " as Peter

entity "   Account 1   " as acc1
entity "   Account 2   " as acc2
entity "   Account 3   " as acc3
actor "   Paul   "  as Paul
rnote over acc1: $10
rnote over acc2: $20
rnote over acc3: $30
rnote over Peter: Exchange\n 1 and 2
rnote over Paul: Exchange\n 2 and 3
Peter -> acc1: balance
acc1 -> Peter: 10
Peter -> acc2: balance
acc2 -> Peter: 20
rnote over Peter: difference=-10


Paul -> acc2: balance
acc2 -> Paul: 20
Paul -> acc3: balance
acc3 -> Paul: 30
rnote over Paul: difference=-10


Peter -> acc1: withdraw -10
rnote over acc1: $20

Paul -> acc2: withdraw -10
rnote over acc2: $30
Paul -> acc3: deposit -10
rnote over acc3: $20

Peter -> acc2: deposit -10
rnote over acc2: $20

@enduml
#+end_src

#+RESULTS[ff820166d8e5f959fa4c1469658a03887c6e5ab9]:
[[file:exercise-3-43-1.png]]

Even though every balance query is immediately followed by a response,
still, incorrect ordering of mutations leads to the final accounts'
states as $20, $20, $20.

A fully non-synchronized version would be more disastrous:

#+begin_src plantuml :exports both :file exercise-3-43-2.png
@startuml
skinparam monochrome true
actor "   Peter   " as Peter

entity "   Account 1   " as acc1
entity "   Account 2   " as acc2
entity "   Account 3   " as acc3
actor "   Paul   "  as Paul
rnote over acc1: $10
rnote over acc2: $20
rnote over acc3: $30
rnote over Peter: Exchange\n 1 and 2
rnote over Paul: Exchange\n 2 and 3
Peter -> acc1: balance
acc1 -> Peter: 10
Peter -> acc2: balance

Paul -> acc2: balance
acc2 -> Paul: 20
Paul -> acc3: balance
acc3 -> Paul: 30
rnote over Paul: difference=-10


acc2 -> Peter: 20
rnote over Peter: difference=-10
Peter -> acc1: withdraw -10
rnote over acc1: $20


Peter -> acc2: deposit -10
Paul -> acc2: withdraw -10
rnote over acc2: $30
rnote over acc2: $10


Paul -> acc3: deposit -10
rnote over acc3: $20

@enduml
#+end_src

#+RESULTS[5175647b68bd142cf87c2e91a455de4c786aa167]:
[[file:exercise-3-43-2.png]]

Depending on the order of writing the balance variable in the account
2, the value may be wrong in different ways.

*** DONE Exercise 3.44 Transfer money
    CLOSED: [2020-01-02 Thu 11:40]

I think that Louis is wrong here. The problem with exchanging amounts
is that the next value of account A depends on the previous value of
an account B. However, in this case the dependency is not so
strict. The next value of an account A only depends on the amount
~amount~. The dependency would be back though, if there may be not
enough money on the account B. Then the operation could fail,
depending on the order of execution.

*** DONE Exercise 3.45 new plus old serializers
    CLOSED: [2020-01-02 Thu 11:46]

The problem with Louis' suggestion is that the same mutex would be
acquired twice. That is, we would attempt to serialize an already
serialized procedure, and would get in a deadlock.

That is, we would have something like ~(balance-serializer
(balance-serializer withdraw))~, which would attempt to obtain the
same lock twice, and thus will wait forever.

*** DONE Exercise 3.46 broken test-and-set!
    CLOSED: [2020-01-02 Thu 11:56]

#+begin_src plantuml :exports both :file exercise-3-46.png
@startuml
skinparam monochrome true
control "  Process 1   " as p1

entity "   Mutex   " as m
control "  Process 2   "  as p2
rnote over m: false
p1 -> m: test-and-set!
p2 -> m: test-and-set!
rnote over m: set-car! cell true
rnote over m: set-car! cell true
rnote over m: true
m -> p1: false
m -> p2: false
rnote over p1: acquired
rnote over p2: acquired

@enduml
#+end_src

#+RESULTS[d80066b4d31cfdf42bde17de5548dcbf682db738]:
[[file:exercise-3-46.png]]

*** DONE Exercise 3.47 semaphores
    CLOSED: [2020-01-03 Fri 12:59]
**** a: In terms of mutexes
     CLOSED: [2020-01-03 Fri 12:38]

#+begin_src scheme :exports both :results output scalar code
  <<parallel-execute>>
  <<make-serializer>>
    (define (make-semaphore max-count)
      (let ((count 0)
	    (mutex (make-mutex)))
	(define (the-semaphore op)
	  (cond ((eq? op 'acquire)
		 (begin
		   (mutex 'acquire)
		   (if (= count max-count)
		       (begin
			 (mutex 'release)
			 (the-semaphore 'acquire))
		       (begin
			 (set! count (+ 1 count))
			 (mutex 'release)))))
		((eq? op 'release)
		 (begin
		   (mutex 'acquire)
		   (set! count (max 0 (- count 1)))
		   (mutex 'release)
		   'released)))) the-semaphore))

  (define test-semaphore (make-semaphore 2))
  (parallel-execute
       (lambda () (test-semaphore 'acquire)
	     (thread-sleep! 3)
	     (show #t "Hello1: " (current-second) "\n")
	     (test-semaphore 'release))
       (lambda () (test-semaphore 'acquire)
	     (thread-sleep! 3)
             (show #t "Hello2: " (current-second) "\n")
	     (test-semaphore 'release))
       (lambda () (test-semaphore 'acquire)
	     (thread-sleep! 3)
             (show #t "Hello3: " (current-second) "\n")
	     (test-semaphore 'release)))

#+end_src

#+RESULTS[ccd45f30b648069ee4fc9a93a98b5c9549ee7481]:
#+begin_src scheme
Hello1: Hello2: 1590552520.0544121590552520.054457

Hello3: 1590552523.060265
#+end_src

On my machine, the output from threads 1 and 2 is interleaved, while
the output from thread 3 is separate. I consider this to be a proof of
the fact that my code works as expected.

**** b: In terms of test-and-set! operations
     CLOSED: [2020-01-03 Fri 12:59]

#+begin_src scheme :exports both :results output scalar code
  <<parallel-execute>>
  <<make-serializer>>
    (define (make-semaphore max-count)
      (let ((count 0)
            (cell (list false)))
	(define (the-semaphore op)
	  (cond ((eq? op 'acquire)
		 (begin
                   (if (test-and-set! cell)
                       (the-semaphore 'acquire))
		   (if (= count max-count)
		       (begin
			 (clear! cell)
			 (the-semaphore 'acquire))
		       (begin
			 (set! count (+ 1 count))
			 (clear! cell)))))
		((eq? op 'release)
		 (begin
                   (if (test-and-set! cell)
                       (the-semaphore 'release))
		   (set! count (max 0 (- count 1)))
		   (clear! cell)
		   'released)))) the-semaphore))

  (define test-semaphore (make-semaphore 2))
  (parallel-execute
       (lambda () (test-semaphore 'acquire)
	     (thread-sleep! 1)
	     (show #t "Hello1: " (current-second) "\n")
	     (test-semaphore 'release))
       (lambda () (test-semaphore 'acquire)
	     (thread-sleep! 1)
             (show #t "Hello2: " (current-second) "\n")
	     (test-semaphore 'release))
       (lambda () (test-semaphore 'acquire)
	     (thread-sleep! 1)
             (show #t "Hello3: " (current-second) "\n")
	     (test-semaphore 'release)))

#+end_src

#+RESULTS[f738e838ec5d9613ae72258996b911b73d1d493f]:
#+begin_src scheme
Hello1: Hello2: 1590552541.6935221590552541.693582

Hello3: 1590552542.702554
#+end_src

Also seems to be working fine.

*** DONE Exercise 3.48 serialized-exchange deadlock
    CLOSED: [2020-01-03 Fri 13:30]

#+begin_src scheme :exports code :results none
  (define (make-account-and-serializer balance)
    (define (withdraw amount)
      (if (>= balance amount)
	  (begin (set! balance (- balance amount))
		 balance)
	  "Insufficient funds"))
    (define (deposit amount)
      (set! balance (+ balance amount))
      balance)
    (let ((balance-serializer (make-serializer)))
      (define (dispatch m)
	(cond ((eq? m 'withdraw) withdraw)
	      ((eq? m 'deposit) deposit)
	      ((eq? m 'balance) balance)
	      ((eq? m 'serializer) balance-serializer)
	      (else (error "Unknown request: MAKE-ACCOUNT" m))))
      dispatch))

  (define (deposit account amount)
    (let ((s (account 'serializer))
	  (d (account 'deposit)))
      ((s d) amount)))
  (define (exchange account1 account2)
    (let ((difference (- (account1 'balance)
			 (account2 'balance))))
      ((account1 'withdraw) difference)
      ((account2 'deposit) difference)))
  (define (serialized-exchange account1 account2)
    (let ((serializer1 (account1 'serializer))
	  (serializer2 (account2 'serializer)))
      ((serializer1 (serializer2 exchange))
       account1
       account2)))

#+end_src

The following code will thus get stuck in a deadlock:

#+begin_src scheme :exports code :results none
(define a1 (make-account-and-serializer 20))
(define a2 (make-account-and-serializer 30))

(parallel-execute
  (lambda () (serialized-exchange a1 a2))
  (lambda () (serialized-exchange a2 a1)))
#+end_src


We add serial numbers to resources:

#+begin_src scheme :exports both :results output scalar code
    <<make-serializer>>
    <<parallel-execute>>
    (define (make-account-and-serializer balance serial)
      (define (withdraw amount)
	(if (>= balance amount)
	    (begin (set! balance (- balance amount))
		   balance)
	    "Insufficient funds"))
      (define (deposit amount)
	(set! balance (+ balance amount))
	balance)
      (let ((balance-serializer (make-serializer)))
	(define (dispatch m)
	  (cond ((eq? m 'withdraw) withdraw)
		((eq? m 'deposit) deposit)
		((eq? m 'balance) balance)
		((eq? m 'serializer) balance-serializer)
                ((eq? m 'order) serial)
		(else (error "Unknown request: MAKE-ACCOUNT" m))))
	dispatch))

    (define (deposit account amount)
      (let ((s (account 'serializer))
	    (d (account 'deposit)))
	((s d) amount)))

    (define (exchange account1 account2)
      (let ((difference (- (account1 'balance)
			   (account2 'balance))))
	((account1 'withdraw) difference)
	((account2 'deposit) difference)))

    (define (serialized-exchange account1 account2)
      (let ((serializer1 (account1 'serializer))
	    (serializer2 (account2 'serializer)))
	(if (< (account1 'order) (account2 'order))
	    ((serializer1 (serializer2 exchange))
	     account1
	     account2)
	    ((serializer2 (serializer1 exchange))
	     account2
	     account1))))
  (define a1 (make-account-and-serializer 20 1))
  (define a2 (make-account-and-serializer 30 2))

(show #t "Balance start: " (a1 'balance) " " (a2 'balance) "\n")

  (parallel-execute
    (lambda () (serialized-exchange a1 a2))
    (lambda () (serialized-exchange a2 a1)))
(show #t "Balance end: " (a1 'balance) " " (a2 'balance) "\n")
#+end_src

#+RESULTS[93c5ac33a97be8258101f856c3ffdabe9d609b94]:
#+begin_src scheme
Balance start: 20 30
Balance end: 20 30
#+end_src

Exchange seems to go fine.

This works, because if mutexes are ordered, both all parallel
processes will try to access the same mutex first.

*** DONE Exercise 3.49 When numbering accounts doesn't work
    CLOSED: [2020-01-03 Fri 13:41]
The case suggested by the hint of the exercise is the following:
Suppose we need to transfer the money from account a1 to some other
account, that is recorded as a list inside account a1, and then remove
this "pending transfer" from the list of transfers of account a1. To
do this, we would need to first lock the account a1 to get the pointer
to account a2, and _then_ lock a2. However, it may very well be that
the account a2 has a smaller serial number than a1.

We could, however, unlock a1, lock a2, then lock a1 again, and check
that the pending transaction from a1 to a2 is still needed.

*** Streams common

#+name: streams-common
#+begin_src scheme :exports code :results none
  (define-syntax cons-stream
    (syntax-rules ()
      ((cons-stream a b) (cons a (delay b)))))
  (define (stream-car stream) (car stream))
  (define (stream-cdr stream) (force (cdr stream)))
  (define (stream-ref s n)
    (if (= n 0)
	(stream-car s)
	(stream-ref (stream-cdr s) (- n 1))))

  (define (stream-map proc s)
    (if (stream-null? s)
	the-empty-stream
	(cons-stream (proc (stream-car s))
		     (stream-map proc (stream-cdr s)))))
  (define stream-null? null?)
  (define the-empty-stream '())
  (define (stream-for-each proc s)
    (if (stream-null? s)
	'done
	(begin (proc (stream-car s))
	       (stream-for-each proc (stream-cdr s)))))
  (define (display-stream s)
    (stream-for-each display-line s))

  (define (display-line x)
    #;(newline)
    #;(display x)
    (show #t (pretty x)))
  (define (stream-enumerate-interval low high)
    (if (> low high)
	the-empty-stream
	(cons-stream
	 low
	 (stream-enumerate-interval (+ low 1) high))))
  (define (stream-filter pred stream)
    (cond ((stream-null? stream) the-empty-stream)
	  ((pred (stream-car stream))
	   (cons-stream (stream-car stream)
			(stream-filter pred
				       (stream-cdr stream))))
	  (else (stream-filter pred (stream-cdr stream)))))

#+end_src

#+begin_src scheme :exports both :results output scalar code
<<streams-common>>
(display (cons-stream 2 3))
(newline)
(display (stream-car (cons-stream 2 3)))
(newline)
(display (stream-cdr (cons-stream 2 3)))
(newline)
(display-stream (cons-stream 2 (cons-stream 3 the-empty-stream)))
#+end_src

#+RESULTS[4a3dd4d5a27998b632ca2c029cbdcd3c43e2087c]:
#+begin_src scheme
(2 (#f . #<procedure #f>) promise)
2
3
2
3
#+end_src

NOTE: As far as I understand, ~(delay)~ and ~(force)~ are using
memoization inside by default in R^7 RS, so we needn't care about it
ourselves.

*** DONE Exercise 3.50 stream-map multiple arguments
    CLOSED: [2020-01-03 Fri 21:18]

#+name: streams-multimap
#+begin_src scheme :exports code :results none
  (define (stream-map proc . argstreams)
    (if (stream-null? (car argstreams))
	the-empty-stream
	(cons-stream
	 (apply proc (map stream-car argstreams))
	 (apply stream-map
		(cons proc (map stream-cdr argstreams))))))

#+end_src


#+begin_src scheme :exports both :results output scalar code
<<streams-common>>
<<streams-multimap>>
(display-stream (stream-map list (cons-stream 'one the-empty-stream)
                                 (cons-stream 'two the-empty-stream)))
#+end_src

#+RESULTS[4a24a883cf9ffe32952f54938ac5c4041e612321]:
#+begin_src scheme
(one two)
#+end_src

Apparently, works.

*** DONE Exercise 3.51 stream-show
    CLOSED: [2020-01-03 Fri 21:28]

#+begin_src scheme :exports both :results output scalar code
  <<streams-common>>
  (define (show x)
    (display-line x)
    x)
  (define x (stream-map show (stream-enumerate-interval 0 10)))
  (stream-ref x 5)
  (newline) (display "next call to stream-ref:")
  (stream-ref x 7)
  (stream-ref x 7)
#+end_src

#+RESULTS[6e8ca163b7ab982c8aaa1fdbd1a0d18ec3f7ee3f]:
#+begin_src scheme
0
1
2
3
4
5

next call to stream-ref:6
7
#+end_src

Why does it only print 6 and 7 on the second call? The answer is --
memoization. Since ~force~ already knows the result of calls to
~(stream-ref 5)~, it doesn't call ~show~ on them again.

*** DONE Exercise 3.52 streams with mind-boggling
    CLOSED: [2020-01-03 Fri 22:17]

#+begin_src scheme :exports both :results output scalar code
<<streams-common>>
  (define sum 0)
  (show #t "debug1: " sum "\n")
  (define (accum x)
    (set! sum (+ x sum))
    sum)
  (show #t "debug2: " sum "\n")
  (define seq (stream-map accum (stream-enumerate-interval 1 20)))
  (show #t "debug3 (stream-map forces a stream once): " sum "\n")
  (define y (stream-filter even? seq))
  (show #t "debug4 1+2+3: " sum "\n")
  (define z (stream-filter (lambda (x) (= (remainder x 5) 0))
			   seq))
  (show #t "debug5 adds 4, as all lower are already evaluated: " sum "\n")
  (stream-ref y 7)
  (show #t "debug6 adds sums that are even up to 20: " sum "\n")
  (display-stream z)
  (show #t "\ndebug7: " sum "\n")
#+end_src

#+RESULTS[c90cc2d0a15697e54610829190a47f405080472d]:
#+begin_src scheme
debug1: 0
debug2: 0
debug3 (stream-map forces a stream once): 1
debug4 1+2+3: 6
debug5 adds 4, as all lower are already evaluated: 10
debug6 adds sums that are even up to 20: 136
10
15
45
55
105
120
190
210

debug7: 210
#+end_src

#+begin_src scheme :exports both :results output scalar code
(define delay #f)
(define force #f)
(define-syntax delay
  (syntax-rules ()
   ((delay x) (lambda () x))))
(define (force delayed-object) (delayed-object))
<<streams-common>>
  (define sum 0)
  (show #t "debug1: " sum "\n")
  (define (accum x)
    (set! sum (+ x sum))
    sum)
  (show #t "debug2: " sum "\n")
  (define seq (stream-map accum (stream-enumerate-interval 1 20)))
  (show #t "debug3: " sum "\n")
  (define y (stream-filter even? seq))
  (show #t "debug4: " sum "\n")
  (define z (stream-filter (lambda (x) (= (remainder x 5) 0))
			   seq))
  (show #t "debug5: " sum "\n")
  (stream-ref y 7)
  (show #t "debug6: " sum "\n")
  (display-stream z)
  (show #t "\ndebug7: " sum "\n")
#+end_src

#+RESULTS[785ab156cc90e363ea13020c699ee7af94943144]:
#+begin_src scheme
debug1: 0
debug2: 0
debug3: 1
debug4: 6
debug5: 15
debug6: 162
15
180
230
305

debug7: 362
#+end_src

The difference here, again, lies in memoization. In the first example,
sum is only evaluated once for every number from 1 to 20, in the
second, every time ~force~ is called. Every call to ~force~ adds to
the ~sum~. I find it hard to find when exactly things are added to the
sum. This can be debugged by adding a print to the ~accum~ procedure,
but the general rule seems to be: don't use mutation together with
lazy lists.

*** Some more tools for streams

#+name: streams-2
#+begin_src scheme :exports code :results none
  (define (add-streams s1 s2)
    (stream-map + s1 s2))
  (define ones (cons-stream 1 ones))
  (define zeros (cons-stream 0 zeros))
  (define integers (cons-stream 1 (add-streams ones integers)))
  (define (scale-stream stream factor)
    (stream-map (lambda (x) (* x factor)) stream))

#+end_src
*** DONE Exercise 3.53 stream power of two
    CLOSED: [2020-01-03 Fri 22:40]

Before running the code, I make a hypothesis that the stream
represents powers of two, because each element is the previous one,
doubled.

#+begin_src scheme :exports both :results value scalar code
<<streams-common>>
<<streams-multimap>>
<<streams-2>>
(define s (cons-stream 1 (add-streams s s)))
(stream-ref s 6)
#+end_src

#+RESULTS[1081db5f83335b36e26b0c366bd6acbae6a5f309]:
#+begin_src scheme
64
#+end_src

*** DONE Exercise 3.54 mul-streams
    CLOSED: [2020-01-03 Fri 22:47]

#+name: streams-mul
#+begin_src scheme :exports code :results none
  (define (mul-streams s1 s2)
    (stream-map * s1 s2))
#+end_src

#+begin_src scheme :exports both :results value scalar code
<<streams-common>>
<<streams-multimap>>
<<streams-2>>
<<streams-mul>>
(define factorials
  (cons-stream 1 (mul-streams factorials integers)))
(stream-ref factorials 5)
#+end_src

#+RESULTS[c47872b7676506593a60efe121f5156f7a11b110]:
#+begin_src scheme
120
#+end_src

*** DONE Exercise 3.55 streams partial-sums
    CLOSED: [2020-01-03 Fri 23:05]

#+name: streams-partial-sums
#+begin_src scheme :exports code :results none
(define (partial-sums s)
  (define ps (cons-stream (stream-car s) (add-streams ps (stream-cdr s))))
  ps)
#+end_src

#+begin_src scheme :exports both :results value scalar code
<<streams-common>>
<<streams-multimap>>
<<streams-2>>
<<streams-partial-sums>>
(define ps (partial-sums integers))
(list (stream-ref ps 0)
(stream-ref ps 1)
(stream-ref ps 2)
(stream-ref ps 3)
(stream-ref ps 4))

#+end_src

#+RESULTS[0df2a1ede3b798ce55755b735ac4eb75db5c99b6]:
#+begin_src scheme
(1 3 6 10 15)
#+end_src

*** DONE Exercise 3.56 Hamming's streams-merge
    CLOSED: [2020-01-03 Fri 23:26]

#+name: streams-merge
#+begin_src scheme :exports code :results none
          (define (merge s1 s2)
            (cond ((stream-null? s1) s2)
                  ((stream-null? s2) s1)
                  (else
                   (let ((s1car (stream-car s1))
                         (s2car (stream-car s2)))
                     (cond ((< s1car s2car)
                            (cons-stream s1car (merge (stream-cdr s1) s2)))
                           ((> s1car s2car)
                            (cons-stream s2car (merge s1 (stream-cdr s2))))
                           (else
                            (cons-stream s1car
                                         (merge (stream-cdr s1)
                                                (stream-cdr s2)))))))))

#+end_src

#+begin_src scheme :exports both :results value scalar code
<<streams-common>>
<<streams-multimap>>
<<streams-2>>
<<streams-merge>>
(define S (cons-stream 1 (merge (scale-stream S 2)
                                (merge (scale-stream S 3)
                                       (scale-stream S 5)))))
(stream-ref S 5)
#+end_src

#+RESULTS[81590ef8b3fa955760d28e89d02450ecc4dd4483]:
#+begin_src scheme
6
#+end_src

*** DONE Exercise 3.57 exponential additions fibs
    CLOSED: [2020-01-03 Fri 23:36]

The definition of ~fibs~ is the following:

#+begin_src scheme :exports code :results none
  (define fibs
    (cons-stream 0
		 (cons-stream 1
			      (add-streams (stream-cdr fibs)
					   fibs))))
#+end_src

With memoization, every step just requires \(O(n)\) additions, because
every ~stream-cdr~ would only add two already computed values.

Without memoization, every step would require computing all previous
values of the Fibonacci sequence from scratch. It is not hard to
notice that the element number N would require computing numbers N-1
and N-2, so every step would roughly double the number
operations. Thus the total number would be \(O(2^n)\).

*** DONE Exercise 3.58 Cryptic stream
    CLOSED: [2020-01-03 Fri 23:50]
This cryptic stream approximates a rational fraction by a decimal
(radix) one.

#+begin_src scheme :exports both :results output scalar code
  <<streams-common>>
  (define (expand num den radix)
    (cons-stream
     (quotient (* num radix) den)
     (expand (remainder (* num radix) den) den radix)))
  (do ((i 0 (+ i 1)))
      ((= i 5) #t)
    (show #t (stream-ref (expand 1 7 10) i)))
  (newline)
  (show #t (/ 1.0 7.0) "\n")
  (do ((i 0 (+ i 1)))
      ((= i 5) #t)
    (show #t (stream-ref (expand 3 8 10) i)))
  (newline)
  (show #t (/ 3.0 8.0) "\n")

#+end_src

#+RESULTS[d05efe05e0b0beaf4f1495e10bb087f2249bdbeb]:
#+begin_src scheme
14285
0.14285714285714285
37500
0.375
#+end_src

*** DONE Exercise 3.59 power series
    CLOSED: [2020-01-04 Sat 09:58]

**** integrate series
     CLOSED: [2020-01-04 Sat 09:49]

#+name: streams-integrate-series
#+begin_src scheme :exports code :results none
(define (div-streams s1 s2)
  (stream-map / s1 s2))

(define (integrate-series s)
 (div-streams s integers))

#+end_src

#+begin_src scheme :exports both :results output scalar code
<<streams-common>>
<<streams-multimap>>
<<streams-2>>
<<streams-integrate-series>>

(define test (integrate-series ones))

(do ((i 0 (+ i 1)))
      ((= i 5) #t)
    (show #t (stream-ref test i) " "))

#+end_src

#+RESULTS[a132b572a71833bb51b4e1fa2fb1d566895329bf]:
#+begin_src scheme
1 1/2 1/3 1/4 1/5 
#+end_src

**** exponential series
     CLOSED: [2020-01-04 Sat 09:58]

#+name: streams-sin-cos
#+begin_src scheme :exports code :results none
(define exp-series
  (cons-stream 1 (integrate-series exp-series)))
(define cosine-series
  (cons-stream 1 (integrate-series (scale-stream sine-series -1))))
(define sine-series
  (cons-stream 0 (integrate-series cosine-series)))
#+end_src

#+begin_src scheme :exports both :results output scalar code
<<streams-common>>
<<streams-multimap>>
<<streams-2>>
<<streams-integrate-series>>
<<streams-sin-cos>>

(do ((i 0 (+ i 1)))
      ((= i 5) #t)
    (show #t (stream-ref cosine-series i) " "))
(newline)
(do ((i 0 (+ i 1)))
      ((= i 5) #t)
    (show #t (stream-ref sine-series i) " "))
#+end_src

#+RESULTS[86f498fe8be8f46fdcaccce1ab2410542ff44ed3]:
#+begin_src scheme
1 0 -1/2 0 1/24 
0 1 0 -1/6 0 
#+end_src

*** DONE Exercise 3.60 mul-series
    CLOSED: [2020-01-04 Sat 11:07]
Let's write out a formula first:

\(S = \sum_{i=0}^{\infty}a_i \cdot \sum_{j=0}^{\infty}b_j = a_0 \cdot b_0 + b_0 \cdot
\sum_{i=1}^{\infty}a_i + \sum_{i=0}^{\infty}a_i \cdot \sum_{j=1}^{\infty}b_j\)

#+name: streams-mul-series
#+begin_src scheme :exports code :results none
(define (mul-series s1 s2)
  (cons-stream (* (stream-car s1) (stream-car s2))
                (add-streams (scale-stream (stream-cdr s1) (stream-car s2))
                             (mul-series s1 (stream-cdr s2)))))
#+end_src

#+begin_src scheme :exports both :results output scalar code
<<streams-common>>
<<streams-multimap>>
<<streams-2>>
<<streams-integrate-series>>
<<streams-sin-cos>>
<<streams-mul-series>>
<<streams-partial-sums>>
(define sum-of-sine-and-cosine
 (partial-sums (add-streams (mul-series sine-series sine-series)
                            (mul-series cosine-series cosine-series))))
(do ((i 0 (+ i 1)))
      ((= i 10) #t)
    (show #t (inexact (stream-ref sum-of-sine-and-cosine i)) " "))

#+end_src

#+RESULTS[23280968a50201b3257279fe6bf1a9d298ac81c1]:
#+begin_src scheme
1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 
#+end_src

Converges to 1 quite fast.

*** DONE Exercise 3.61 power-series-inversion
    CLOSED: [2020-01-04 Sat 13:13]

#+name: streams-invert-unit-series
#+begin_src scheme :exports code :results none
(define (invert-unit-series S)
    (if (not (= 1 (stream-car S)))
        (error "First term must be 1 -- INVERT-UNIT-SERIES" (stream-car S))
        (let ((Sr (stream-cdr S)))
            (define X
                (cons-stream
                    1
                    (mul-series
                        (scale-stream Sr -1)
                        X)))
            X)))

#+end_src


#+begin_src scheme :exports both :results output scalar code
<<streams-common>>
<<streams-multimap>>
<<streams-2>>
<<streams-integrate-series>>
<<streams-sin-cos>>
<<streams-mul-series>>
<<streams-partial-sums>>
<<streams-invert-unit-series>>

(define test (partial-sums (mul-series ones (invert-unit-series ones))))
#;("Should give a series with partial sums converging to 1")
(do ((i 0 (+ i 1)))
      ((= i 10) #t)
    (show #t (inexact (stream-ref test i)) " "))

#+end_src

#+RESULTS[7337bf3046c1f7088b455e4ed332973252261d4e]:
#+begin_src scheme
1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 
#+end_src

Okay, this exercise gave me hell of a lot of pain. Why on it is so
dependent on the implementation of ~mul-series~?

So this exercise has been solved with the help of the GitHub user
ypeels:
https://github.com/ypeels/sicp/blob/master/exercises/3.61-invert-unit-series.scm

*** DONE Exercise 3.62 div-series
    CLOSED: [2020-01-04 Sat 13:21]

#+name: streams-div-series
#+begin_src scheme :exports code :results none
(define (div-series s1 s2)
  (let* ((scale-factor (stream-car s2))
         (scaled-s2 (scale-stream s2 (/ 1 scale-factor)))
         (scaled-s1 (scale-stream s1 scale-factor))
         (inverted-s2 (invert-unit-series scaled-s2)))
   (mul-series scaled-s1 inverted-s2)))
#+end_src

#+begin_src scheme :exports both :results output scalar code
<<streams-common>>
<<streams-multimap>>
<<streams-2>>
<<streams-integrate-series>>
<<streams-sin-cos>>
<<streams-mul-series>>
<<streams-partial-sums>>
<<streams-invert-unit-series>>
<<streams-div-series>>

(define test (div-series ones exp-series))
#;("Should give a series with partial sums converging to 1")
(do ((i 0 (+ i 1)))
      ((= i 10) #t)
    (show #t (inexact (stream-ref test i)) " "))

#+end_src

#+RESULTS[6bad44138bca584aa7c04c2c48bddc046ff5b3a8]:
#+begin_src scheme
1.0 0.0 0.5 0.3333333333333333 0.375 0.36666666666666664 0.3680555555555556 0.3678571428571429 0.36788194444444444 0.36787918871252206 
#+end_src

Well, not sure this is correct, but it runs.

*** DONE Exercise 3.63 sqrt-stream
    CLOSED: [2020-01-04 Sat 20:32]

#+name: streams-sqrt-stream
#+begin_src scheme :exports code :results none
     (define (average x y)
       (/ (+ x y) 2))
  (define (sqrt-improve guess x)
    (average guess (/ x guess)))

  (define (sqrt-stream x)
    (cons-stream 1.0
		 (stream-map (lambda (guess)
			       (sqrt-improve guess x))
			     (sqrt-stream x))))
#+end_src

The problem with the second definition is that ~(sqrt-stream x)~, as
it is called each time, creates a new stream. Since this streams are
not ~eq?~, memoization doesn't work. In the first implementation, the
same ~guesses~ is used, and thus, calls to the lambda are cached
(memoized).

If ~delay~ didn't use memoization, performance would be same for both
implementations.
*** DONE Exercise 3.64 stream-limit
    CLOSED: [2020-01-06 Mon 09:38]

#+name: streams-stream-limit
#+begin_src scheme :exports code :results none
(define (stream-limit stream tolerance)
  (let ((a1 (stream-car stream))
        (a2 (stream-car (stream-cdr stream))))
    (if (< (abs (- a1 a2)) tolerance)
      a2
      (stream-limit (stream-cdr stream) tolerance))))

#+end_src

#+name: streams-sqrt
#+begin_src scheme :exports code :results none
  (define (sqrt x tolerance)
    (stream-limit (sqrt-stream x) tolerance))
#+end_src

#+begin_src scheme :exports both :results output scalar code
<<streams-common>>
<<streams-multimap>>
<<streams-2>>
<<streams-stream-limit>>
<<streams-sqrt-stream>>
<<streams-sqrt>>

(show #t "Test sqrt of 17: " (sqrt 17 0.001) "\n")

#+end_src

#+RESULTS[7ce5d41f7264af9ba057a211af91f38438837da3]:
#+begin_src scheme
Test sqrt of 17: 4.123105625617805
#+end_src

Seems to be working. I copied some of the ~sqrt~-related code from the
earlier chapters instead of tangling, because it seems too slow.

*** DONE Exercise 3.65 approximating logarithm
    CLOSED: [2020-01-06 Mon 10:34]

First let's make sure that the pi-stream is working.

#+name: streams-print-n
#+begin_src scheme :exports code :results none

  (define (stream-sublist-n stream n)
    (cond ((null? stream) '())
          ((= n 0) '())
          (else (cons (stream-car stream)
                      (stream-sublist-n (stream-cdr stream) (- n 1))))))

  (define (stream-print-n stream n)
    (cond ((null? stream) (display "No more elements"))
          ((= n 0) 'printed)
          (else (begin
                   (display (stream-car stream))
                   (display " ")
                   (stream-print-n (stream-cdr stream) (- n 1))))))

#+end_src

#+name: streams-pi-summands
#+begin_src scheme :exports code :results none
     (define (pi-summands n)
       (cons-stream (/ 1.0 n)
                    (stream-map - (pi-summands (+ n 2)))))
     (define pi-stream
       (scale-stream (partial-sums (pi-summands 1)) 4))
#+end_src

#+begin_src scheme :exports both :results output scalar code
<<streams-common>>
<<streams-multimap>>
<<streams-2>>
<<streams-partial-sums>>
<<streams-pi-summands>>
<<streams-print-n>>
(show #t (pretty (stream-sublist-n pi-stream 10)))

#+end_src

#+RESULTS[33401a55df96ec459f41978f91f6ebd0c9a480ad]:
#+begin_src scheme
(4.0                2.666666666666667  3.466666666666667  2.8952380952380956
 3.3396825396825403 2.9760461760461765 3.2837384837384844 3.017071817071818
 3.2523659347188767 3.0418396189294032)
#+end_src

Now let us do the same for the logarithm of 2.

#+name: streams-log-summands
#+begin_src scheme :exports code :results none
     (define (log-summands n)
       (cons-stream (/ 1.0 n)
                    (stream-map - (log-summands (+ n 1)))))
     (define log-stream
       (partial-sums (log-summands 1)))
#+end_src

#+name: streams-euler-tableau
#+begin_src scheme :exports code :results none
     (define (euler-transform s)
       (let ((s0 (stream-ref s 0))
             (s1 (stream-ref s 1))
             (s2 (stream-ref s 2)))
         (cons-stream (- s2 (/ (square (- s2 s1))
                               (+ s0 (* -2 s1) s2)))
                      (euler-transform (stream-cdr s)))))
     (define (make-tableau transform s)
       (cons-stream s
                    (make-tableau transform
                                  (transform s))))
     (define (accelerated-sequence transform s)
       (stream-map stream-car
                   (make-tableau transform s)))
#+end_src

#+begin_src scheme :exports both :results output scalar code
<<streams-common>>
<<streams-multimap>>
<<streams-2>>
<<streams-partial-sums>>
<<streams-print-n>>
<<streams-log-summands>>
<<streams-euler-tableau>>
(do ((i 0 (+ i 1)))
  ((= i 10) #t)
  (show #t (stream-ref (log-summands 1) i) " "))
(newline)
(show #t (pretty (stream-sublist-n log-stream 10)))
(newline)
(show #t (pretty (stream-sublist-n (euler-transform log-stream) 10)))
(newline)
(show #t (pretty (stream-sublist-n (accelerated-sequence euler-transform log-stream) 10)))

#+end_src

#+RESULTS[f10feab036cfb86075ddb265ebbcabc774c7f265]:
#+begin_src scheme
1.0 -0.5 0.3333333333333333 -0.25 0.2 -0.16666666666666666 0.14285714285714285 -0.125 0.1111111111111111 -0.1 
(1.0                0.5                0.8333333333333333 0.5833333333333333
 0.7833333333333332 0.6166666666666666 0.7595238095238095 0.6345238095238095
 0.7456349206349207 0.6456349206349207)

(0.7                0.6904761904761905 0.6944444444444444 0.6924242424242424
 0.6935897435897436 0.6928571428571428 0.6933473389355742 0.6930033416875522
 0.6932539682539683 0.6930657506744464)

(1.0                0.7                0.6932773109243697 0.6931488693329254
 0.6931471960735491 0.6931471806635636 0.6931471805604039 0.6931471805599445
 0.6931471805599427 0.6931471805599454)
#+end_src

The first stream seems to be converging quite slowly, needing about 10
steps for 0.01 precision. The "accelerated" sequence converges in
three steps, which seems to be super fast. Proper convergence analysis
would require a bit more of a mathematical analysis.

*** DONE Exercise 3.66 lazy pairs
    CLOSED: [2020-01-06 Mon 22:55]

#+name: streams-interleave
#+begin_src scheme :exports code :results none
  (define (interleave s1 s2)
    (if (stream-null? s1)
	s2
	(cons-stream (stream-car s1)
		     (interleave s2 (stream-cdr s1)))))
#+end_src

#+name: streams-pairs
#+begin_src scheme :exports code :results none
  (define (pairs s t)
    (cons-stream
     (list (stream-car s) (stream-car t))
     (interleave
      (stream-map (lambda (x) (list (stream-car s) x))
		  (stream-cdr t))
      (pairs (stream-cdr s) (stream-cdr t)))))
#+end_src

#+begin_src scheme :exports both :results output scalar code
<<streams-common>>
<<streams-multimap>>
<<streams-2>>
<<streams-partial-sums>>
<<streams-print-n>>
<<streams-interleave>>
<<streams-pairs>>

(show #t (pretty (stream-sublist-n (pairs integers integers) 100)))

#+end_src

#+RESULTS[653e1ec24f28ee0f8efc75aee195083f319b8491]:
#+begin_src scheme
((1 1)  (1 2)  (2 2)  (1 3)  (2 3)  (1 4)  (3 3)  (1 5)  (2 4)  (1 6)  (3 4)
 (1 7)  (2 5)  (1 8)  (4 4)  (1 9)  (2 6)  (1 10) (3 5)  (1 11) (2 7)  (1 12)
 (4 5)  (1 13) (2 8)  (1 14) (3 6)  (1 15) (2 9)  (1 16) (5 5)  (1 17) (2 10)
 (1 18) (3 7)  (1 19) (2 11) (1 20) (4 6)  (1 21) (2 12) (1 22) (3 8)  (1 23)
 (2 13) (1 24) (5 6)  (1 25) (2 14) (1 26) (3 9)  (1 27) (2 15) (1 28) (4 7)
 (1 29) (2 16) (1 30) (3 10) (1 31) (2 17) (1 32) (6 6)  (1 33) (2 18) (1 34)
 (3 11) (1 35) (2 19) (1 36) (4 8)  (1 37) (2 20) (1 38) (3 12) (1 39) (2 21)
 (1 40) (5 7)  (1 41) (2 22) (1 42) (3 13) (1 43) (2 23) (1 44) (4 9)  (1 45)
 (2 24) (1 46) (3 14) (1 47) (2 25) (1 48) (6 7)  (1 49) (2 26) (1 50) (3 15)
 (1 51))
#+end_src

The logic behind the ordering can be seen from the kind of a
"probabilistic analysis". Let's imagine a table with columns indexed
by the elements of the first stream, and rows indexed by the second
stream. Every call to "interleave" takes a row of a table, and another
instance of the "pairs". This means that the frequency, with which
elements of every row appear in the output is \(2^{-n}\), where n is
the number of the row. Therefore the number of a pair (a,b) should be
something like \(b \cdot a^{n} \).

*** DONE Exercise 3.67 all possible pairs
    CLOSED: [2020-01-06 Mon 23:09]

Seems not too hard. Just add in one more interleave.

#+name: streams-pairs-full
#+begin_src scheme :exports code :results none
  (define (pairs s t)
    (if (or (null? s) (null? t))
	'()
	(cons-stream
	 (list (stream-car s) (stream-car t))
	 (interleave
	  (stream-map (lambda (x) (list (stream-car s) x))
		      (stream-cdr t))
	  (interleave
	   (stream-map (lambda (x) (list x (stream-car t)))
		       (stream-cdr s))
	   (pairs (stream-cdr s) (stream-cdr t)))))))
#+end_src

#+begin_src scheme :exports both :results output scalar code
<<streams-common>>
<<streams-multimap>>
<<streams-2>>
<<streams-partial-sums>>
<<streams-print-n>>
<<streams-interleave>>
<<streams-pairs-full>>

(stream-print-n (pairs integers integers) 20)
(newline)
(stream-print-n (pairs (cons-stream '() '()) integers) 10)
(newline)
(stream-print-n (pairs '() integers) 10)
(newline)
(stream-print-n (pairs integers '()) 10)

#+end_src

#+RESULTS[a2b06cf46381675c6caf9e7fa8eb75c615f466d6]:
#+begin_src scheme
(1 1) (1 2) (2 1) (1 3) (2 2) (1 4) (3 1) (1 5) (2 3) (1 6) (4 1) (1 7) (3 2) (1 8) (5 1) (1 9) (2 4) (1 10) (6 1) (1 11) 
(() 1) (() 2) (() 3) (() 4) (() 5) (() 6) (() 7) (() 8) (() 9) (() 10) 
No more elements
No more elements
#+end_src

*** DONE Exercise 3.68 pairs-louis
    CLOSED: [2020-01-06 Mon 23:26]

#+name: streams-pairs-louis
#+begin_src scheme :exports code :results none
  (define (pairs s t)
    (interleave
      (stream-map (lambda (x) (list (stream-car s) x))
		  t)
      (pairs (stream-cdr s) (stream-cdr t))))
#+end_src

#+begin_src scheme :exports both :results output scalar code
<<streams-common>>
<<streams-multimap>>
<<streams-2>>
<<streams-partial-sums>>
<<streams-print-n>>
<<streams-interleave>>
<<streams-pairs-louis>>

(stream-print-n (pairs integers integers) 30)

#+end_src

#+RESULTS[05d202ca2644c003b8a306a2333de30cfd3320b0]:
#+begin_src scheme
ERROR: out of stack space
> 
#+end_src

This is expected. Remember, the second argument to ~cons-stream~ is
not evaluated, it's delayed. If we don't separate the first pair from
the rest, ~interleave~ would run indefinitely.

*** DONE Exercise 3.69 triples
    CLOSED: [2020-02-17 Mon 20:10]

#+name: streams-triples
#+begin_src scheme :exports code :results none
  (define (triples s t u)
    (cons-stream
     (list (stream-car s) (stream-car t) (stream-car u))
     (interleave
      (stream-map (lambda (x) (cons (stream-car s) x))
		  (pairs (stream-cdr t) (stream-cdr u)))
      (triples (stream-cdr s) (stream-cdr t) (stream-cdr u)))))
#+end_src

#+begin_src scheme :exports both :results output scalar code
    <<streams-common>>
    <<streams-multimap>>
    <<streams-2>>
    <<streams-partial-sums>>
    <<streams-print-n>>
    <<streams-interleave>>
    <<streams-pairs>>
    <<streams-triples>>

(stream-print-n (triples integers integers integers) 10)
#+end_src

#+RESULTS[9d71e064611733e0e76315c0aafabc8441b4e589]:
#+begin_src scheme
(1 1 1) (1 2 2) (2 2 2) (1 2 3) (2 3 3) (1 3 3) (3 3 3) (1 2 4) (2 3 4) (1 3 4) 
#+end_src

#+begin_src shell :exports both :results output scalar code :shebang "#! /usr/bin/chibi-scheme -xscheme.r5rs"
    <<streams-common>>
    <<streams-multimap>>
    <<streams-2>>
    <<streams-partial-sums>>
    <<streams-print-n>>
    <<streams-interleave>>
    <<streams-pairs>>
    <<streams-triples>>

  (display "Starting triples test\n")
    (stream-print-n
    (stream-filter
	   (lambda (triple)
	       (let ((i (car triple))
		     (j (cadr triple))
		     (k (caddr triple)))
		(= (* k k) (+ (* i i) (* j j)))))
    (triples integers integers integers))
	4)
  (display "\nTriple test ended")
#+end_src

#+RESULTS[6128e62c2a9be0a046cb48feec75fdc600270c77]:
#+begin_src shell
Starting triples test
(3 4 5) (6 8 10) (5 12 13) (9 12 15) 
Triple test ended
#+end_src



Seems to be working fine.

*** DONE Exercise 3.70 merge-weighted
    CLOSED: [2020-01-07 Tue 11:58]

#+name: streams-merge-weighted
#+begin_src scheme :exports code :results none
  (define (merge-weighted s1 s2 weight)
    (cond ((stream-null? s1) s2)
	  ((stream-null? s2) s1)
	  (else
	   (let ((s1car (stream-car s1))
		 (s2car (stream-car s2)))
	     (cond ((< (weight s1car) (weight s2car))
		    (cons-stream s1car (merge-weighted (stream-cdr s1) s2 weight)))
		   ((> (weight s1car) (weight s2car))
		    (cons-stream s2car (merge-weighted s1 (stream-cdr s2) weight)))
		   (else
		    (cons-stream s1car
				 (merge-weighted (stream-cdr s1)
						 s2
                                                 weight))))))))

#+end_src

#+name: streams-pairs-weighted
#+begin_src scheme :exports code :results none
  (define (pairs-weighted s t weight)
    (cons-stream
     (list (stream-car s) (stream-car t))
     (merge-weighted
      (stream-map (lambda (x) (list (stream-car s) x))
		  (stream-cdr t))
      (pairs-weighted (stream-cdr s) (stream-cdr t) weight)
      weight)))
#+end_src

#+begin_src scheme :exports code :results output scalar code
<<streams-common>>
<<streams-multimap>>
<<streams-2>>
<<streams-partial-sums>>
<<streams-print-n>>
<<streams-interleave>>
<<streams-merge-weighted>>
<<streams-pairs-weighted>>

(show #t (pretty (stream-sublist-n
  (pairs-weighted
    integers
    integers
    (lambda (p) (+ (car p) (cadr p))))
 100)))
(newline)
(show #t (pretty (stream-sublist-n
  (pairs-weighted
    (stream-filter (lambda (x) (and (not (= 0 (remainder x 2)))
                              (not (= 0 (remainder x 3)))
                              (not (= 0 (remainder x 5))))) integers)
    (stream-filter (lambda (x) (and (not (= 0 (remainder x 2)))
                              (not (= 0 (remainder x 3)))
                              (not (= 0 (remainder x 5))))) integers)
    (lambda (p) (+ (* 2 (car p)) (* 3 (cadr p) (* 5 (car p) (cadr p))))))
 100)))

#+end_src

#+RESULTS[bd9b3276dd4dc7d8718fb1e4d656fc4139f3d664]:
#+begin_src scheme
((1 1)   (1 2)   (1 3)   (2 2)   (1 4)   (2 3)   (1 5)   (2 4)   (3 3)
 (1 6)   (2 5)   (3 4)   (1 7)   (2 6)   (3 5)   (4 4)   (1 8)   (2 7)
 (3 6)   (4 5)   (1 9)   (2 8)   (3 7)   (4 6)   (5 5)   (1 10)  (2 9)
 (3 8)   (4 7)   (5 6)   (1 11)  (2 10)  (3 9)   (4 8)   (5 7)   (6 6)
 (1 12)  (2 11)  (3 10)  (4 9)   (5 8)   (6 7)   (1 13)  (2 12)  (3 11)
 (4 10)  (5 9)   (6 8)   (7 7)   (1 14)  (2 13)  (3 12)  (4 11)  (5 10)
 (6 9)   (7 8)   (1 15)  (2 14)  (3 13)  (4 12)  (5 11)  (6 10)  (7 9)
 (8 8)   (1 16)  (2 15)  (3 14)  (4 13)  (5 12)  (6 11)  (7 10)  (8 9)
 (1 17)  (2 16)  (3 15)  (4 14)  (5 13)  (6 12)  (7 11)  (8 10)  (9 9)
 (1 18)  (2 17)  (3 16)  (4 15)  (5 14)  (6 13)  (7 12)  (8 11)  (9 10)
 (1 19)  (2 18)  (3 17)  (4 16)  (5 15)  (6 14)  (7 13)  (8 12)  (9 11)
 (10 10))

((1 1)   (1 7)   (1 11)  (1 13)  (1 17)  (7 7)   (1 19)  (1 23)  (1 29)
 (7 11)  (1 31)  (7 13)  (11 11) (1 37)  (1 41)  (1 43)  (11 13) (7 17)
 (13 13) (1 47)  (1 49)  (7 19)  (1 53)  (11 17) (1 59)  (7 23)  (1 61)
 (13 17) (11 19) (1 67)  (13 19) (17 17) (1 71)  (1 73)  (11 23) (7 29)
 (1 77)  (17 19) (1 79)  (7 31)  (19 19) (13 23) (1 83)  (1 89)  (1 91)
 (17 23) (11 29) (1 97)  (7 37)  (19 23) (1 101) (11 31) (1 103) (13 29)
 (1 107) (7 41)  (1 109) (23 23) (13 31) (1 113) (7 43)  (1 119) (17 29)
 (1 121) (11 37) (7 47)  (19 29) (1 127) (17 31) (7 49)  (1 131) (1 133)
 (13 37) (19 31) (11 41) (1 137) (1 139) (23 29) (7 53)  (11 43) (1 143)
 (13 41) (23 31) (1 149) (1 151) (17 37) (13 43) (11 47) (7 59)  (29 29)
 (1 157) (1 161) (19 37) (7 61)  (11 49) (1 163) (29 31) (1 167) (1 169)
 (17 41))
#+end_src

Cannot say I understand what the second sequence signifies, but meh.

*** DONE Exercise 3.71 Ramanujan numbers
    CLOSED: [2020-01-07 Tue 12:49]

#+begin_src scheme :exports both :results output scalar code
<<streams-common>>
<<streams-multimap>>
<<streams-2>>
<<streams-partial-sums>>
<<streams-print-n>>
<<streams-interleave>>
<<streams-merge-weighted>>
<<streams-pairs-weighted>>

(define cubic-pairs
  (pairs-weighted
    integers
    integers
    (lambda (p) (+ (expt (car p) 3) (expt (cadr p) 3)))))

(define sums-of-cubes
   (stream-map (lambda (x) (+ (expt (car x) 3)
                          (expt (cadr x) 3)))
               cubic-pairs))
(show #t "debug: sums-of-cubes: " )
(stream-print-n sums-of-cubes 20)
(newline)
(define (first-repetition s)
 (if (= (stream-car s) (stream-car (stream-cdr s)))
    s
    (first-repetition (stream-cdr s))))
(define (filter-repetitions s)
  (cons-stream (stream-car (first-repetition s))
               (filter-repetitions
                 (stream-cdr (stream-cdr (first-repetition s))))))
(newline)
 #;(display (stream-car (filter-repetitions s)))
(stream-print-n (filter-repetitions sums-of-cubes) 6)
#+end_src

#+RESULTS[4e102cb7d6cfde519a5a18c5a6ec3f6c462315ec]:
#+begin_src scheme
debug: sums-of-cubes: 2 9 16 28 35 54 65 72 91 126 128 133 152 189 217 224 243 250 280 341 

1729 4104 13832 20683 32832 39312 
#+end_src


This solution is not very good, because it would fail to distinguish
the Ramanujan 2-numbers from the Ramanujan 4-numbers, but I am too
lazy to fix it.

*** DONE Exercise 3.72 Ramanujan 3-numbers
    CLOSED: [2020-01-08 Wed 10:27]
WARNING: The code below is quite slow. On my machine it takes more time than
geiser's default ~geiser-connection-timeout~ permits.
Refer to "Setting chibi arguments." for more information.

#+begin_src scheme :exports both :results output scalar code
<<streams-common>>
<<streams-multimap>>
<<streams-2>>
<<streams-partial-sums>>
<<streams-print-n>>
<<streams-interleave>>
<<streams-merge-weighted>>
<<streams-pairs-weighted>>

(define sum-squares
   (lambda (x) (+ (expt (car x) 2) (expt (cadr x) 2))))

(define square-pairs
  (pairs-weighted
    integers
    integers
    sum-squares))

(show #t "square-pairs, first 20: ")
(stream-print-n square-pairs 20)
(newline)
(define sums-of-squares
   (stream-map sum-squares square-pairs))

(show #t "20 sums of squares" "\n")

(stream-print-n sums-of-squares 20)

(define (first-repetition s)
 (if (and (= (sum-squares (stream-car s))
             (sum-squares (stream-car (stream-cdr s))))
          (= (sum-squares (stream-car (stream-cdr s)))
             (sum-squares (stream-car (stream-cdr (stream-cdr s))))))
    s
    (first-repetition (stream-cdr s))))

(define (filter-repetitions s)
  (cons-stream (first-repetition s)
               (filter-repetitions
                 (stream-cdr (stream-cdr (stream-cdr (first-repetition s)))))))
(display " \n")
(show #t "first-repetition= ") 

(stream-print-n (stream-car (filter-repetitions square-pairs)) 3)
(newline)
(stream-print-n (stream-car (stream-cdr (filter-repetitions square-pairs))) 3)
(newline)

#+end_src

#+RESULTS[c3fa816e5de5721fcdf374a1f083d6ce08ca7e8a]:
#+begin_src scheme
square-pairs, first 20: (1 1) (1 2) (2 2) (1 3) (2 3) (1 4) (3 3) (2 4) (3 4) (1 5) (2 5) (4 4) (3 5) (1 6) (2 6) (4 5) (3 6) (1 7) (5 5) (4 6) 
20 sums of squares
2 5 8 10 13 17 18 20 25 26 29 32 34 37 40 41 45 50 50 52  
first-repetition= (1 18) (6 17) (10 15) 
(5 20) (8 19) (13 16) 
#+end_src

*** DONE Figure 3.32 The integral procedure viewed as a signal-processing system :plantuml:
    CLOSED: [2020-01-08 Wed 10:59]

#+begin_src plantuml :exports both :file figure-3-32.png
@startuml
skinparam monochrome true
skinparam componentStyle uml2
component [scale: dt] as scale
component [add] as add
component [cons] as cons
interface input as input
interface "initial-value" as initialvalue
interface " " as fake
interface integral as integral
input -> scale
scale -> add
add   -> cons
initialvalue ..> cons
cons - fake
fake -> add
fake -> integral
@enduml
#+end_src

#+RESULTS[9d304b5f50bacb4597fdfe5d67fe8f513c708f87]:
[[file:figure-3-32.png]]

*** DONE Exercise 3.73 RC-circuit
    CLOSED: [2020-01-08 Wed 13:09]

#+name: streams-integral
#+begin_src scheme :exports code :results none
(define (integral integrand initial-value dt)
 (define int
   (cons-stream initial-value
                (add-streams (scale-stream integrand dt)
                int)))
 int)
#+end_src

#+begin_src scheme :exports both :results output scalar code
<<streams-common>>
<<streams-multimap>>
<<streams-2>>
<<streams-partial-sums>>
<<streams-print-n>>
<<streams-interleave>>
<<streams-merge-weighted>>
<<streams-pairs-weighted>>
<<streams-integral>>

(define (RC R C dt)
  (define (model v_0 s)
   (add-streams
      (scale-stream (integral s v_0 dt) (/ 1 C))
      (scale-stream s R)))
 model)

(define RC1 (RC 5 1 0.5))

(stream-print-n (RC1 0 ones) 30)

#+end_src

#+RESULTS[ade0d8b5aeb47254b0874101b926842ccc6c28ea]:
#+begin_src scheme
5 5.5 6.0 6.5 7.0 7.5 8.0 8.5 9.0 9.5 10.0 10.5 11.0 11.5 12.0 12.5 13.0 13.5 14.0 14.5 15.0 15.5 16.0 16.5 17.0 17.5 18.0 18.5 19.0 19.5 
#+end_src

Hm... is that all?

*** DONE Exercise 3.74 zero-crossings
    CLOSED: [2020-01-08 Wed 16:50]

#+begin_src scheme :exports both :results output scalar code
<<streams-common>>
<<streams-multimap>>
<<streams-2>>
<<streams-partial-sums>>
<<streams-print-n>>
<<streams-interleave>>
<<streams-merge-weighted>>
<<streams-pairs-weighted>>
<<streams-integral>>


(define (sign-change-detector v1 v2)
  (cond ((and (< v1 0) (> v2 0))  1)
        ((and (> v1 0) (< v2 0)) -1)
        (else 0)))

 (define (make-zero-crossings input-stream last-value)
    (cons-stream
     (sign-change-detector
      (stream-car input-stream)
      last-value)
     (make-zero-crossings
      (stream-cdr input-stream)
      (stream-car input-stream))))
(define sense-data (interleave ones (interleave ones (interleave ones (scale-stream ones -1)))))

(define zero-crossings
    (make-zero-crossings sense-data 0))

(stream-print-n (make-zero-crossings sense-data 0) 50)
(newline)

(define zero-crossings
(stream-map sign-change-detector
            sense-data
            (cons-stream 0 sense-data)))
(stream-print-n zero-crossings 50)
#+end_src

#+RESULTS[d44301ad7408a49249395417581bebe935e94255]:
#+begin_src scheme
0 0 0 0 0 0 0 1 -1 0 0 0 0 0 0 1 -1 0 0 0 0 0 0 1 -1 0 0 0 0 0 0 1 -1 0 0 0 0 0 0 1 -1 0 0 0 0 0 0 1 -1 0 
0 0 0 0 0 0 0 1 -1 0 0 0 0 0 0 1 -1 0 0 0 0 0 0 1 -1 0 0 0 0 0 0 1 -1 0 0 0 0 0 0 1 -1 0 0 0 0 0 0 1 -1 0 
#+end_src

Huh, didn't think about it.

*** DONE Exercise 3.75 filtering signals
    CLOSED: [2020-01-08 Wed 18:11]

This exercise is confusing. The detector needs to be applied to _two_averaged_ values.


#+begin_src scheme :exports both :results output scalar code
<<streams-common>>
<<streams-multimap>>
<<streams-2>>
<<streams-partial-sums>>
<<streams-print-n>>
<<streams-interleave>>
<<streams-merge-weighted>>
<<streams-pairs-weighted>>
<<streams-integral>>


(define (sign-change-detector v1 v2)
  (cond ((and (< v1 0) (> v2 0))  1)
        ((and (> v1 0) (< v2 0)) -1)
        (else 0)))

  (define (make-zero-crossings input-stream last-value last-avpt)
    (let ((avpt (/ (+ (stream-car input-stream)
		      last-value)
		   2)))
      (cons-stream
       (sign-change-detector avpt last-avpt)
       (make-zero-crossings
	(stream-cdr input-stream) (stream-car input-stream) avpt))))

(define sense-data (interleave (scale-stream ones -1) (interleave ones (interleave ones (scale-stream ones 5)))))

(define zero-crossings
    (make-zero-crossings sense-data 0 0))

(stream-print-n (make-zero-crossings sense-data 0 0) 50)

#+end_src

#+RESULTS[e541ea0a09339709b2cfd591bb48f1b43b54915d]:
#+begin_src scheme
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
#+end_src

Well, seems to be working.

*** DONE Exercise 3.76 stream-smooth
    CLOSED: [2020-01-08 Wed 19:56]

#+name: streams-smooth
#+begin_src scheme :exports code :results none
(define (smooth s smoothener)
 (cons-stream (smoothener (stream-car s) (stream-car (stream-cdr s)))
    (smooth (stream-cdr s) smoothener)))
#+end_src

#+begin_src scheme :exports both :results output scalar code
  <<streams-common>>
  <<streams-multimap>>
  <<streams-2>>
  <<streams-partial-sums>>
  <<streams-print-n>>
  <<streams-interleave>>
  <<streams-smooth>>
  (stream-print-n (smooth integers (lambda (x y) (/ (+ x y ) 2))) 5)
  (newline)
  (define (sign-change-detector v1 v2)
    (cond ((and (< v1 0) (> v2 0))  1)
	  ((and (> v1 0) (< v2 0)) -1)
	  (else 0)))
  (define (make-zero-crossings stream)
    (cons-stream
       (sign-change-detector (stream-car stream)
                             (stream-car (stream-cdr stream)))
       (make-zero-crossings  (stream-cdr stream))))
  (define sense-data (interleave (scale-stream ones -1) (interleave ones (interleave ones (scale-stream ones 5)))))

  (define zero-crossings
      (make-zero-crossings sense-data))

  (stream-print-n zero-crossings 50)


#+end_src

#+RESULTS[4a35f26b46e39c6aec2f4df9d6be739657d819ef]:
#+begin_src scheme
3/2 5/2 7/2 9/2 11/2 
1 -1 1 -1 1 -1 1 -1 1 -1 1 -1 1 -1 1 -1 1 -1 1 -1 1 -1 1 -1 1 -1 1 -1 1 -1 1 -1 1 -1 1 -1 1 -1 1 -1 1 -1 1 -1 1 -1 1 -1 1 -1 
#+end_src

Seems to be working.

*** COMMENT Delayed integration

#+begin_src scheme :exports both :results output scalar code
  <<streams-common>>
  <<streams-multimap>>
  <<streams-2>>
  (define (integral delayed-integrand initial-value dt)
    (define int
      (cons-stream
       initial-value
       (let ((integrand (force delayed-integrand)))
	 (add-streams (scale-stream integrand dt) int))))
    int)
  (define (solve f y0 dt)
    (define y (integral (delay dy) y0 dt))
    (define dy (stream-map f y))
    y)
  (display (stream-ref (solve (lambda (y) y) 1 0.001) 1000))
#+end_src

#+RESULTS[20239ac6b53dd4020630f39a599782ca53794cf4]:
#+begin_src scheme
2.716923932235896
#+end_src

*** DONE Exercise 3.77 Streams integral
    CLOSED: [2020-01-08 Wed 20:51]

#+name: streams-integral-explicit
#+begin_src scheme :exports code :results none
  (define (integral integrand initial-value dt)
    (cons-stream
     initial-value
     (if (stream-null? (force integrand))
	 the-empty-stream
	 (let ((nv (force integrand)))
                 (integral (delay (stream-cdr nv))
		   (+ (* dt (stream-car nv))
		      initial-value)
		   dt)))))
#+end_src

#+begin_src scheme :exports both :results output scalar code
  <<streams-common>>
  <<streams-multimap>>
  <<streams-2>>
  <<streams-integral-explicit>>
  (define (solve f y0 dt)
    (define y (integral (delay dy) y0 dt))
    (define dy (stream-map f y))
    y)
  (display (stream-ref (solve (lambda (y) y) 1 0.001) 1000))
#+end_src

#+RESULTS[2b4d9282eb02f7d74fedb85b85324b0fee8639c5]:
#+begin_src scheme
2.716923932235896
#+end_src

*** DONE Exercise 3.78 second order differential equation
    CLOSED: [2020-01-08 Wed 21:47]

#+begin_src scheme :exports both :results output scalar code
  <<streams-common>>
  <<streams-multimap>>
  <<streams-2>>
  <<streams-integral-explicit>>
  <<streams-print-n>>
(define (solve-2nd y0 dy0 dt a b)
  (define y   (integral (delay dy)  y0 dt))
  (define dy  (integral (delay ddy) dy0 dt))
  (define ddy (add-streams (scale-stream y b)
                          (scale-stream dy a)))
  y)
(show #t (pretty (stream-sublist-n (solve-2nd 10 -10 0.001 20 -30) 20)))
#+end_src

#+RESULTS[1ba641ac0aaa1a4c6fb976c6de916e908da7c975]:
#+begin_src scheme
(10                9.99              9.9795            9.9684903
 9.956961021       9.944902101711    9.932303295205589 9.919154165507019
 9.905444084115622 9.891162226471431 9.876297568351834 9.860838882203051
 9.844774733404241 9.828093476462989 9.81078325114091  9.792831978508096
 9.77422735692509  9.75495685795107  9.735007722176862 9.71436695498143)
#+end_src

*** DONE Exercise 3.79 general second-order ode
    CLOSED: [2020-01-08 Wed 21:57]

#+begin_src scheme :exports both :results output scalar code
  <<streams-common>>
  <<streams-multimap>>
  <<streams-2>>
  <<streams-integral-explicit>>
  <<streams-print-n>>
  <<streams-mul>>
(define (solve-2nd y0 dy0 dt f)
  (define y   (integral (delay dy)  y0 dt))
  (define dy  (integral (delay ddy) dy0 dt))
  (define ddy (f y dy))
  y)
(show #t (pretty (stream-sublist-n (solve-2nd 10 -10 0.001 (lambda (s1 s2) (mul-streams s1 s2))) 20)))
#+end_src

#+RESULTS[3d2127191c2f17550c958769729a3da0f57981af]:
#+begin_src scheme
(10                9.99              9.9799            9.969699101
 9.959396398048069 9.948990980247782 9.938481930766933 9.92786832684759
 9.917149239817473 9.906323735102736 9.895390872242148 9.88434970490271
 9.873199280896765 9.861938642200586 9.85056682497453  9.83908285958474
 9.827485770626463 9.815774576948995 9.803948291682303 9.792005922265352)
#+end_src

Cool. As long as ~f~ is implemented in terms of streams, it works.

*** DONE Figure 3.36 A series RLC circuit
    CLOSED: [2020-01-08 Wed 23:21]

#+name: figure-3-36
#+header: :imagemagick yes :iminoptions -density 300 :imoutoptions -geometry 300
#+header: :fit yes :headers '("\\usepackage{tikz} \\usetikzlibrary{positioning,fit,petri,arrows,calc,matrix,quotes,circuits.ee.IEC}")
#+header: :buffer on
#+begin_src latex :results raw file :exports both :file figure-3-36.png
\begin{tikzpicture}
[color=blue,
circuit ee IEC,
semithick,
every info/.style={font=\footnotesize},
small circuit symbols,
set resistor graphic=var resistor IEC graphic,
set diode graphic=var diode IEC graphic,
set make contact graphic= var make contact IEC graphic,
circuit declare annotation={direct polarity}{1cm}
{(0.5cm,0.25cm) node {-} (-0.5cm,0.25cm) node {+}},
circuit declare annotation={invert polarity}{1cm}
{(0.5cm,0.25cm) node {+} (-0.5cm,0.25cm) node {-}}
]
\draw (0,0) to [capacitor={info={\(v_C\)},info'={C},invert polarity},
                current direction'={near end,info=\(i_C\)}] ++(up:2)
            to [current direction={near start,info'={\(i_R\)}},
               resistor={info={\(v_R\)},info'={R},direct polarity}]  ++(right:5)
            to [current direction={very near start, info'={\(i_L\)}},
                inductor={info={\(v_L\)},info'={L},direct polarity}]  ++(down:2)
            -- (0,0);
\end{tikzpicture}
#+end_src
#+attr_latex: :width 250pt
#+RESULTS[2ba30f2330b5794b23a641bce756e5f3735e2216]: figure-3-36
[[file:figure-3-36.png]]

*** DONE Exercise 3.80 RLC circuit
    CLOSED: [2020-01-08 Wed 23:40]

#+begin_src scheme :exports both :results output scalar code
  <<streams-common>>
  <<streams-multimap>>
  <<streams-2>>
  <<streams-integral-explicit>>
  <<streams-print-n>>
  <<streams-mul>>
(define (RLC R L C dt)
  (define (producer vc0 il0)
    (define vc (integral (delay dvc) vc0 dt))
    (define il (integral (delay dil) il0 dt))
    (define dvc (scale-stream il (/ -1 C)))
    (define dil (add-streams
                   (scale-stream il (/ (* -1 R) L))
                   (scale-stream vc (/ 1 L))))
    (cons vc il))
   producer)
(define rlc-model (RLC 1 1 0.2 0.1))
(define pair-of-streams (rlc-model 10 0))
(show #t (pretty (stream-sublist-n (car pair-of-streams) 20)))
(newline)
(show #t (pretty (stream-sublist-n (cdr pair-of-streams) 20)))
#+end_src

#+RESULTS[7a4cb399a7d312b53f1a0f3892a7a1894aa20c59]:
#+begin_src scheme
(10                  10                  9.5
 8.55                7.220000000000001   5.5955
 3.77245             1.8519299999999999  -0.0651605000000004
 -1.8831384500000004 -3.5160605800000004 -4.8915335745
 -5.95365624055      -6.66498996127      -7.0075074978905
 -6.982523782785449  -6.609663064296379  -5.924962228516943
 -4.978248323100632  -3.829957696800105)

(0                     1.0                   1.9
 2.66                  3.249                 3.6461
 3.84104               3.834181              3.6359559
 3.2658442599999997    2.750945989           2.1242453320999997
 1.4226674414399998    0.6850350732409998    -0.049967430210100305
 -0.7457214369781403   -1.3694016715588713   -1.893427810832622
 -2.296581252601054    -2.5647479596510117)
#+end_src

Works? I can't believe it.

*** DONE Exercise 3.81  renerator-in-streams
    CLOSED: [2020-01-09 Thu 00:37]

#+begin_src scheme :exports both :results output scalar code
  <<streams-common>>
  <<streams-multimap>>
  <<streams-2>>
  <<streams-partial-sums>>
  <<streams-print-n>>
  <<streams-interleave>>
  <<streams-smooth>>

  (define generates (cons-stream 'generate generates))
  (define resets (cons-stream 100 resets))
  (define double-resets (interleave generates (interleave generates resets)))

  (define (random-stream-processor rs seed)
    (define (rand-update x)
	(remainder (+ (* x 29)
		      71)
		   13))
    (let ((seed (if (eq? (stream-car rs) 'generate)
                    seed
                    (stream-car rs))))
       (cons-stream (rand-update seed)
                    (random-stream-processor
                        (stream-cdr rs)
                        (rand-update seed))))
    )
  (define my-rand (random-stream-processor double-resets 3))
  (stream-print-n my-rand 20)
#+end_src

#+RESULTS[0fad508a75879366b97095611c47f56eb886bc37]:
#+begin_src scheme
2 12 3 7 1 9 7 7 1 9 7 7 1 9 7 7 1 9 7 7 
#+end_src

Working? Seems to be working. And no assignment used.

*** DONE Exercise 3.82 streams Monte-Carlo
    CLOSED: [2020-01-09 Thu 09:42]

#+begin_src scheme :exports both :results output scalar code
  <<random>>
  <<streams-common>>
  <<streams-multimap>>
  <<streams-2>>

(define (random-in-range low high)
      (let ((range (- high low)))
      (+ low (random range))))
  (show #t "Test 01: " (random-in-range 1 2000) "\n")

  (define (is-inside-circle? x y radius)
    (if (< (+ (expt (- x 1000) 2) (expt (- y 1000) 2)) (expt radius 2))
	#t
	#f))

(define (make-integral-estimator P x1 x2 y1 y2)
   (define (iter sum-in sum-out)
     (let* ((in?a (P (random-in-range x1 x2) (random-in-range y1 y2)))
            (sum-in (if in?a (+ 1 sum-in) sum-in))
            (sum-out (if in?a sum-out (+ 1 sum-out))))
         (cons-stream  (/ sum-in (+ sum-in sum-out))
           (iter sum-in sum-out))))
   (iter 1 1))
(define pi-estimator
       (scale-stream (make-integral-estimator
           (lambda (x y) (is-inside-circle? x y 1000))
           1
           2000
           1
           2000) 4))
  (define (estimate-pi trials)
    (inexact (stream-ref pi-estimator trials)))



(show #t "Test 02: " (estimate-pi 100100) "\n")
#+end_src

#+RESULTS[7ecaf28d585314e74f2522f10f349ab3beaa73e7]:
#+begin_src scheme
Test 01: 514
Test 02: 3.1428828306843952
#+end_src

Well, works. Random numbers are not obtained from a stream, and are a
little bit not modular in this respect, but hey, they task is done as
a stream.

** Chapter 4: Metalinguistic Abstraction [80/80]

This chapter started as a bit of a mess. Because it uses quite a bit
of input-output, and the standard ob-scheme interface is not very open
to this, I had to be inventive, that is, I repurposed SRFI-22 and
ob-shell, and transformed the final runnable piece of code into a
scheme-shell script, so that I could feed input into it as if it was a
shell block.

This took me about 8 working hours to figure out.

*** 4.1 The Metacircular Evaluator [24/24]
[2020-01-09 Thu 15:46]


**** 4.1.1 The Core of the Evaluator
**** DONE Exercise 4.1 list-of-values ordered
     CLOSED: [2020-01-09 Thu 20:11]

#+name: s-list-of-values-left-to-right
#+begin_src scheme :exports code :results none
     (define (list-of-values exps env)
       (if (no-operands? exps)
           '()
           (let* ((p1 (eval (first-operand exps) env))
                  (p2 (list-of-values (rest-operands exps) env)))
              (cons p1 p2))))
#+end_src

#+name: s-list-of-values-right-to-left
#+begin_src scheme :exports code :results none
     (define (list-of-values exps env)
       (if (no-operands? exps)
           '()
           (let* ((p2 (list-of-values (rest-operands exps) env))
                  (p1 (eval (first-operand exps) env)))
              (cons p1 p2))))
#+end_src

#+name: s-input-test4
#+begin_quote
(define a (cons (display "left") (display "right")))
(exit)
#+end_quote

#+header: :stdin s-input-test4
#+begin_src shell :shebang "#! /usr/bin/chibi-scheme" :results output scalar code :exports both
<<s-glue1>>
<<s-apply>>
<<s-eval>>

<<s-list-of-values-left-to-right>>
<<s-standard-if>>
<<s-sequences>>
<<s-assignment>>
<<s-define>>
<<s-syntax>>
<<s-application>>
<<s-cond>>
<<s-truefalse>>
<<s-compound-procedures>>
<<s-environments>>
<<s-primitive-procedures>>
<<s-driver-loop>>
<<s-glue2>>

(driver-loop)

#+end_src

#+RESULTS[b53f0666e4b1f9be3b5c49c16d634897585f6fc8]:
#+begin_src shell

;;; M-Eval input:
(define a (cons (display "left") (display "right")))leftright
;;; M-Eval value:
ok
;;; M-Eval input:
(exit)
#+end_src

#+header: :stdin s-input-test4
#+begin_src shell :shebang "#! /usr/bin/chibi-scheme" :results output scalar code :exports both
<<s-glue1>>
<<s-apply>>
<<s-eval>>

<<s-list-of-values-right-to-left>>
<<s-standard-if>>
<<s-sequences>>
<<s-assignment>>
<<s-define>>
<<s-syntax>>
<<s-application>>
<<s-cond>>
<<s-truefalse>>
<<s-compound-procedures>>
<<s-environments>>
<<s-primitive-procedures>>
<<s-driver-loop>>
<<s-glue2>>

(driver-loop)

#+end_src

#+RESULTS[6219dac3cf87c871a2583afe02372d7c2dec1090]:
#+begin_src shell

;;; M-Eval input:
(define a (cons (display "left") (display "right")))rightleft
;;; M-Eval value:
ok
;;; M-Eval input:
(exit)
#+end_src

**** Common code of the evaluator

#+name: s-eval
#+begin_src scheme :exports code :results none
   (define (eval exp env)
       (cond ((self-evaluating? exp) exp)
             ((variable? exp) (lookup-variable-value exp env))
             ((quoted? exp) (text-of-quotation exp))
             ((assignment? exp) (eval-assignment exp env))
             ((definition? exp) (eval-definition exp env))
             ((if? exp) (eval-if exp env))
             ((lambda? exp)
              (make-procedure (lambda-parameters exp)
                              (lambda-body exp)
                              env))
             ((begin? exp)
              (eval-sequence (begin-actions exp) env))
             ((cond? exp) (eval (cond->if exp) env))
             ((application? exp)
              (apply (eval (operator exp) env)
                     (list-of-values (operands exp) env)))
             (else
              (error "Unknown expression type -- EVAL" exp))))
#+end_src


#+name: s-apply
#+begin_src scheme :exports code :results none
     (define (apply procedure arguments)
       (cond ((primitive-procedure? procedure)
              (apply-primitive-procedure procedure arguments))
             ((compound-procedure? procedure)
              (eval-sequence
                (procedure-body procedure)
                (extend-environment
                  (procedure-parameters procedure)
                  arguments
                  (procedure-environment procedure))))
             (else
              (error
               "Unknown procedure type -- APPLY" procedure))))
#+end_src


#+name: s-list-of-values
#+begin_src scheme :exports code :results none
     (define (list-of-values exps env)
       (if (no-operands? exps)
           '()
           (cons (eval (first-operand exps) env)
                 (list-of-values (rest-operands exps) env))))
#+end_src

#+name: s-standard-if
#+begin_src scheme :exports code :results none
  (define (eval-if exp env)
    (if (true? (eval (if-predicate exp) env))
	(eval (if-consequent exp) env)
	(eval (if-alternative exp) env)))
#+end_src

#+name: s-sequences
#+begin_src scheme :exports code :results none
     (define (eval-sequence exps env)
       (cond ((last-exp? exps) (eval (first-exp exps) env))
             (else (eval (first-exp exps) env)
                   (eval-sequence (rest-exps exps) env))))
#+end_src

#+name: s-assignment
#+begin_src scheme :exports code :results none
     (define (eval-assignment exp env)
       (set-variable-value! (assignment-variable exp)
                            (eval (assignment-value exp) env)
                            env)
       'ok)
#+end_src

#+name: s-define
#+begin_src scheme :exports code :results none
     (define (eval-definition exp env)
       (define-variable! (definition-variable exp)
                         (eval (definition-value exp) env)
                         env)
       'ok)
#+end_src
**** 4.1.2 Representing Expressions

***** Common code for expressions
#+name: s-syntax
#+begin_src scheme :exports code :results none
(define false #f)
(define true  #t)
          (define (self-evaluating? exp)
            (cond ((number? exp) true)
                  ((string? exp) true)
                  ((eq? #t exp) true)
                  ((eq? #f exp) true)
                  (else false)))
          (define (variable? exp) (symbol? exp))
          (define (quoted? exp)
            (tagged-list? exp 'quote))

          (define (text-of-quotation exp) (cadr exp))
          (define (tagged-list? exp tag)
            (if (pair? exp)
                (eq? (car exp) tag)
                false))
          (define (assignment? exp)
            (tagged-list? exp 'set!))

          (define (assignment-variable exp) (cadr exp))

          (define (assignment-value exp) (caddr exp))
          (define (definition? exp)
            (tagged-list? exp 'define))

          (define (definition-variable exp)
            (if (symbol? (cadr exp))
                (cadr exp)
                (caadr exp)))

          (define (definition-value exp)
            (if (symbol? (cadr exp))
                (caddr exp)
                (make-lambda (cdadr exp)
                             (cddr exp))))
          (define (lambda? exp) (tagged-list? exp 'lambda))

          (define (lambda-parameters exp) (cadr exp))

          (define (lambda-body exp) (cddr exp))
          (define (make-lambda parameters body)
            (cons 'lambda (cons parameters body)))
          (define (if? exp) (tagged-list? exp 'if))

          (define (if-predicate exp) (cadr exp))

          (define (if-consequent exp) (caddr exp))

          (define (if-alternative exp)
            (if (not (null? (cdddr exp)))
                (cadddr exp)
                'false))
          (define (make-if predicate consequent alternative)
            (list 'if predicate consequent alternative))
          (define (begin? exp) (tagged-list? exp 'begin))

          (define (begin-actions exp) (cdr exp))

          (define (last-exp? seq) (null? (cdr seq)))

          (define (first-exp seq) (car seq))

          (define (rest-exps seq) (cdr seq))
          (define (sequence->exp seq)
            (cond ((null? seq) seq)
                  ((last-exp? seq) (first-exp seq))
                  (else (make-begin seq))))

          (define (make-begin seq) (cons 'begin seq))
#+end_src

#+name: s-application
#+begin_src scheme :exports code :results none
          (define (application? exp) (pair? exp))

          (define (operator exp) (car exp))

          (define (operands exp) (cdr exp))

          (define (no-operands? ops) (null? ops))

          (define (first-operand ops) (car ops))

          (define (rest-operands ops) (cdr ops))
#+end_src

#+name: s-cond
#+begin_src scheme :exports code :results none

     (define (cond? exp) (tagged-list? exp 'cond))

     (define (cond-clauses exp) (cdr exp))

     (define (cond-else-clause? clause)
       (eq? (cond-predicate clause) 'else))

     (define (cond-predicate clause) (car clause))

     (define (cond-actions clause) (cdr clause))

     (define (cond->if exp)
       (expand-clauses (cond-clauses exp)))

     (define (expand-clauses clauses)
       (if (null? clauses)
           'false
           (let ((first (car clauses))
                 (rest (cdr clauses)))
             (if (cond-else-clause? first)
                 (if (null? rest)
                     (sequence->exp (cond-actions first))
                     (error "ELSE clause isn't last -- COND->IF"
                            clauses))
                 (make-if (cond-predicate first)
                          (sequence->exp (cond-actions first))
                          (expand-clauses rest))))))

#+end_src

#+RESULTS: s-cond

Some tests.

#+header: :stdin s-input-test5
#+begin_src shell :shebang "#! /usr/bin/chibi-scheme" :results output scalar code :exports both
<<s-glue1>>
<<s-apply>>
<<put-and-get>>
<<s-eval>>
<<s-list-of-values-left-to-right>>
<<s-standard-if>>
<<s-sequences>>
<<s-assignment>>
<<s-define>>
<<s-syntax>>
<<s-application>>
<<s-cond>>
<<s-truefalse>>
<<s-compound-procedures>>
<<s-environments>>
<<s-primitive-procedures>>
<<s-driver-loop>>
<<s-glue2>>

(driver-loop)

#+end_src

#+RESULTS[2bf9ff8f57232deab34dcba3c3bb130db239821d]:
#+begin_src shell

;;; M-Eval input:
"hello"
;;; M-Eval value:
"hello"
;;; M-Eval input:
1
;;; M-Eval value:
1
;;; M-Eval input:
#t
;;; M-Eval value:
#t
;;; M-Eval input:
#f
;;; M-Eval value:
#f
;;; M-Eval input:
(if #t "true" "false")
;;; M-Eval value:
"true"
;;; M-Eval input:
(if #f "true" "false")
;;; M-Eval value:
"false"
;;; M-Eval input:
(if (quote ()) "true" "false")
;;; M-Eval value:
"true"
;;; M-Eval input:
(quote ())
;;; M-Eval value:
()
;;; M-Eval input:
(quote test-symbol)
;;; M-Eval value:
test-symbol
;;; M-Eval input:
(define a (quote ()))
;;; M-Eval value:
ok
;;; M-Eval input:
a
;;; M-Eval value:
()
;;; M-Eval input:
(set! a 1)
;;; M-Eval value:
ok
;;; M-Eval input:
a
;;; M-Eval value:
1
;;; M-Eval input:
(define b (lambda (x) (display "test-lambda\n")))
;;; M-Eval value:
ok
;;; M-Eval input:
(begin "One" (if "" "two" (quote ())) "end begin")
;;; M-Eval value:
"end begin"
;;; M-Eval input:
(cond (#f "clause 1") (#f (quote clause2)) (#t "clause 3") (else "else clause"))
;;; M-Eval value:
"clause 3"
;;; M-Eval input:
(cond (#f "clause 1") (#f (quote clause2)) (#f "clause 3") (else "else clause"))
;;; M-Eval value:
"else clause"
;;; M-Eval input:
(exit)
#+end_src

***** DONE Exercise 4.2 application before assignments
      CLOSED: [2020-01-09 Thu 20:41]
****** a
Obviously, this won't work, because almost everything in Scheme is a pair!
So far we haven't cared about the disjointness of types, therefore, since
~(define x 3)~ is a list, it is also a pair, and formally an application.
****** b
If we define an application as:

#+name: s-application-with-call
#+begin_src scheme :exports code :results none
          (define (application? exp) (tagged-list? exp 'call))

          (define (operator exp) (cadr exp))

          (define (operands exp) (cddr exp))

          (define (no-operands? ops) (null? ops))

          (define (first-operand ops) (car ops))

          (define (rest-operands ops) (cdr ops))

#+end_src

This should work. But this example is not practical, so we won't test it.



***** DONE Exercise 4.3 data-directed eval
      CLOSED: [2020-01-09 Thu 21:24]

#+name: s-data-driven-eval
#+begin_src scheme :exports code :results none
  (define (eval . o) (display "in the wrong eval"))
  (define (special-form-maybe exp) (if (and (pair? exp) (symbol? (car exp)))
                              (get 'eval (car exp))
                              #f))

  (define (eval exp env)
    (cond ((self-evaluating? exp) exp)
	  ((variable? exp) (lookup-variable-value exp env))
          ((special-form-maybe exp) => (lambda (x)  (x exp env)))
          ((application? exp) (apply (eval (operator exp) env)
                                     (list-of-values (operands exp) env)))
	  (else
	   (error "data-directed-eval: unknown operation" exp))))

  (put 'eval 'quote (lambda (exp env) (text-of-quotation exp)))
  (put 'eval 'set! (lambda (exp env) (eval-assignment exp env)))
  (put 'eval 'define (lambda (exp env) (eval-definition exp env)))
  (put 'eval 'if (lambda (exp env) (eval-if exp env)))
  (put 'eval 'lambda (lambda (exp env) (make-procedure (lambda-parameters exp)
			   (lambda-body exp)
			   env)))
  (put 'eval 'begin (lambda (exp env) (eval-sequence (begin-actions exp) env)))

  #;(put 'eval 'call (lambda (exp env) (apply (eval (operator exp) env)
                             (list-of-values (operands exp) env))))
  (put 'eval 'cond (lambda (exp env) (eval (cond->if exp) env)))

#+end_src


#+name: s-input-test5
#+begin_example
"hello"
1
#t
#f
(if #t "true" "false")
(if #f "true" "false")
(if '() "true" "false")
'()
'test-symbol
(define a '())
a
(set! a 1)
a
(define b (lambda (x) (display "test-lambda\n")))
(begin "One" (if "" "two" '()) "end begin")
(cond (#f "clause 1") (#f 'clause2) (#t "clause 3") (else "else clause"))
(cond (#f "clause 1") (#f 'clause2) (#f "clause 3") (else "else clause"))
(exit)
#+end_example

#+header: :stdin s-input-test5
#+begin_src shell :shebang "#! /usr/bin/chibi-scheme" :results output scalar code :exports both
<<s-glue1>>
<<s-apply>>
<<put-and-get>>
<<s-data-driven-eval>>
<<s-list-of-values-left-to-right>>
<<s-standard-if>>
<<s-sequences>>
<<s-assignment>>
<<s-define>>
<<s-syntax>>
<<s-application>>
<<s-cond>>
<<s-truefalse>>
<<s-compound-procedures>>
<<s-environments>>
<<s-primitive-procedures>>
<<s-driver-loop>>
<<s-glue2>>

(driver-loop)

#+end_src

#+RESULTS[14c0c99b7fa7993e3b2301d7f0f79b414837ceb0]:
#+begin_src shell

;;; M-Eval input:
"hello"
;;; M-Eval value:
"hello"
;;; M-Eval input:
1
;;; M-Eval value:
1
;;; M-Eval input:
#t
;;; M-Eval value:
#t
;;; M-Eval input:
#f
;;; M-Eval value:
#f
;;; M-Eval input:
(if #t "true" "false")
;;; M-Eval value:
"true"
;;; M-Eval input:
(if #f "true" "false")
;;; M-Eval value:
"false"
;;; M-Eval input:
(if (quote ()) "true" "false")
;;; M-Eval value:
"true"
;;; M-Eval input:
(quote ())
;;; M-Eval value:
()
;;; M-Eval input:
(quote test-symbol)
;;; M-Eval value:
test-symbol
;;; M-Eval input:
(define a (quote ()))
;;; M-Eval value:
ok
;;; M-Eval input:
a
;;; M-Eval value:
()
;;; M-Eval input:
(set! a 1)
;;; M-Eval value:
ok
;;; M-Eval input:
a
;;; M-Eval value:
1
;;; M-Eval input:
(define b (lambda (x) (display "test-lambda\n")))
;;; M-Eval value:
ok
;;; M-Eval input:
(begin "One" (if "" "two" (quote ())) "end begin")
;;; M-Eval value:
"end begin"
;;; M-Eval input:
(cond (#f "clause 1") (#f (quote clause2)) (#t "clause 3") (else "else clause"))
;;; M-Eval value:
"clause 3"
;;; M-Eval input:
(cond (#f "clause 1") (#f (quote clause2)) (#f "clause 3") (else "else clause"))
;;; M-Eval value:
"else clause"
;;; M-Eval input:
(exit)
#+end_src


Well, put and get work, so this should work in general. Let's see if we can
test it later.


***** DONE Exercise 4.4 eval-and and eval-or
      CLOSED: [2020-01-09 Thu 22:14]

#+name: s-eval-and
#+begin_src scheme :exports code :results none
(define (logical-actions exp) (cdr exp))
(define (eval-and-sequence exps env)
       (if (null? exps)
            ""
            (let ((candidate (eval (first-exp exps) env)))
             (if (not (true? candidate))
                 false
                (if (null? (rest-exps exps))
                   candidate
                   (eval-and-sequence (rest-exps exps) env))))))
(define (eval-and exp env)
  (eval-and-sequence (logical-actions exp) env))
(define (eval-or-sequence exps env)
       (if (null? exps)
            false
            (let ((candidate (eval (first-exp exps) env)))
             (if (true? candidate)
                 candidate
                (if (null? (rest-exps exps))
                   candidate
                   (eval-or-sequence (rest-exps exps) env))))))
(define (eval-or exp env)
  (eval-or-sequence (logical-actions exp) env))

(put 'eval 'and eval-and)
(put 'eval 'or eval-or)

#+end_src


#+name: s-input-test-and-or
#+begin_example
"hello"
1
#t
#f
(if #t "true" "false")
(if #f "true" "false")
(if '() "true" "false")
'()
'test-symbol
(define a '())
a
(set! a 1)
a
(define b (lambda (x) (display "test-lambda\n")))
(begin "One" (if "" "two" '()) "end begin")
(cond (#f "clause 1") (#f 'clause2) (#t "clause 3") (else "else clause"))
(cond (#f "clause 1") (#f 'clause2) (#f "clause 3") (else "else
clause"))
(and #t #f)
(and #f #f)
(or #t #f)
(or #f #f)
(exit)
#+end_example


#+header: :stdin s-input-test-and-or
#+begin_src shell :shebang "#! /usr/bin/chibi-scheme" :results output scalar code :exports both
  <<s-glue1>>
  <<s-apply>>
  <<put-and-get>>
  <<s-data-driven-eval>>
  <<s-list-of-values-left-to-right>>
  <<s-standard-if>>
  <<s-sequences>>
  <<s-assignment>>
  <<s-define>>
  <<s-syntax>>
  <<s-application>>
  <<s-cond>>
  <<s-truefalse>>
  <<s-compound-procedures>>
  <<s-environments>>
  <<s-primitive-procedures>>
  <<s-driver-loop>>
  <<s-eval-and>>
  <<s-glue2>>

  (driver-loop)

#+end_src

#+RESULTS[6ce1a0f93d2bcd3ccb5a1288c58a48462f57038c]:
#+begin_src shell

;;; M-Eval input:
"hello"
;;; M-Eval value:
"hello"
;;; M-Eval input:
1
;;; M-Eval value:
1
;;; M-Eval input:
#t
;;; M-Eval value:
#t
;;; M-Eval input:
#f
;;; M-Eval value:
#f
;;; M-Eval input:
(if #t "true" "false")
;;; M-Eval value:
"true"
;;; M-Eval input:
(if #f "true" "false")
;;; M-Eval value:
"false"
;;; M-Eval input:
(if (quote ()) "true" "false")
;;; M-Eval value:
"true"
;;; M-Eval input:
(quote ())
;;; M-Eval value:
()
;;; M-Eval input:
(quote test-symbol)
;;; M-Eval value:
test-symbol
;;; M-Eval input:
(define a (quote ()))
;;; M-Eval value:
ok
;;; M-Eval input:
a
;;; M-Eval value:
()
;;; M-Eval input:
(set! a 1)
;;; M-Eval value:
ok
;;; M-Eval input:
a
;;; M-Eval value:
1
;;; M-Eval input:
(define b (lambda (x) (display "test-lambda\n")))
;;; M-Eval value:
ok
;;; M-Eval input:
(begin "One" (if "" "two" (quote ())) "end begin")
;;; M-Eval value:
"end begin"
;;; M-Eval input:
(cond (#f "clause 1") (#f (quote clause2)) (#t "clause 3") (else "else clause"))
;;; M-Eval value:
"clause 3"
;;; M-Eval input:
(cond (#f "clause 1") (#f (quote clause2)) (#f "clause 3") (else "else\nclause"))
;;; M-Eval value:
"else\nclause"
;;; M-Eval input:
(and #t #f)
;;; M-Eval value:
#f
;;; M-Eval input:
(and #f #f)
;;; M-Eval value:
#f
;;; M-Eval input:
(or #t #f)
;;; M-Eval value:
#t
;;; M-Eval input:
(or #f #f)
;;; M-Eval value:
#f
;;; M-Eval input:
(exit)
#+end_src



***** DONE Exercise 4.5 cond with arrow
      CLOSED: [2020-01-22 Wed 16:36]

Notice. I spent a lot of time trying to solve this exercise with only
the tools available so far. I failed. Unless testing works, it is not
possible to make sure that the code I wrote to solve exercises is
correct. I will do the chapter parsing in two passes. And this
exercise will have forward references.

#+name: s-cond-with-arrow
#+begin_src scheme :exports code :results none
     (define (cond? exp) (tagged-list? exp 'cond))

     (define (cond-clauses exp) (cdr exp))

     (define (cond-else-clause? clause)
       (eq? (cond-predicate clause) 'else))

     (define (cond-predicate clause) (car clause))

     (define (cond-actions clause) (cdr clause))

     (define (cond-actions-arrow? cond-actions)
          (cond ((null? cond-actions) #f)
                ((eq? '=> (car cond-actions)) #t)
                (else #f)))
     (define (cond-actions-arrow-action cond-actions)
          (cadr cond-actions))
     (define (cond->if exp)
       (expand-clauses (cond-clauses exp)))

     (define (expand-clauses clauses)
       (if (null? clauses)
           'false
           (let ((first (car clauses))
                 (rest (cdr clauses)))
             (if (cond-else-clause? first)
                 (if (null? rest)
                     (sequence->exp (cond-actions first))
                     (error "ELSE clause isn't last -- COND->IF"
                            clauses))
                 (if (not (cond-actions-arrow? (cond-actions first)))
                    (make-if (cond-predicate first)
                              (sequence->exp (cond-actions first))
                          (expand-clauses rest))
                    (list (make-lambda (list 'test-res)
                             (list (make-if 'test-res
                                 (list (cond-actions-arrow-action (cond-actions first)) 'test-res)
                                 (expand-clauses rest))))
                                       (cond-predicate first))
                     )))))

#+end_src

#+name: s-input-test-cond-arrow
#+begin_example
"hello"
1
#t
#f
(if #t "true" "false")
(if #f "true" "false")
(if '() "true" "false")
'()
'test-symbol
(define a '())
a
(set! a 1)
a
(define b (lambda (x) (display "test-lambda\n")))
(begin "One" (if "" "two" '()) "end begin")
(cond (#f "clause 1") (#f 'clause2) (#t "clause 3") (else "else clause"))
(cond (#f "clause 1") (#f 'clause2) (#f "clause 3") (else "else
clause"))
(and #t #f)
(and #f #f)
(or #t #f)
(or #f #f)
"testing cond with arrow"

(define cadr (lambda (x) (car (cdr x))))

(cond ((assoc 'b '((a 1) (b 2))) => cadr)
   (else false))
(exit)
#+end_example


#+header: :stdin s-input-test-cond-arrow
#+begin_src shell :shebang "#! /usr/bin/chibi-scheme" :results output scalar code :exports both
<<s-glue1>>
<<s-apply>>
<<put-and-get>>
<<s-data-driven-eval>>
<<s-list-of-values-left-to-right>>
<<s-standard-if>>
<<s-sequences>>
<<s-assignment>>
<<s-define>>
<<s-syntax>>
<<s-application>>
<<s-cond-with-arrow>>
<<s-truefalse>>
<<s-compound-procedures>>
<<s-environments>>
<<s-primitive-procedures>>
<<s-driver-loop>>
<<s-eval-and>>
<<s-glue2>>

(driver-loop)

#+end_src

#+RESULTS[d4ca62fe54494bbba15a3e7c4a1945505081bc22]:
#+begin_src shell

;;; M-Eval input:
"hello"
;;; M-Eval value:
"hello"
;;; M-Eval input:
1
;;; M-Eval value:
1
;;; M-Eval input:
#t
;;; M-Eval value:
#t
;;; M-Eval input:
#f
;;; M-Eval value:
#f
;;; M-Eval input:
(if #t "true" "false")
;;; M-Eval value:
"true"
;;; M-Eval input:
(if #f "true" "false")
;;; M-Eval value:
"false"
;;; M-Eval input:
(if (quote ()) "true" "false")
;;; M-Eval value:
"true"
;;; M-Eval input:
(quote ())
;;; M-Eval value:
()
;;; M-Eval input:
(quote test-symbol)
;;; M-Eval value:
test-symbol
;;; M-Eval input:
(define a (quote ()))
;;; M-Eval value:
ok
;;; M-Eval input:
a
;;; M-Eval value:
()
;;; M-Eval input:
(set! a 1)
;;; M-Eval value:
ok
;;; M-Eval input:
a
;;; M-Eval value:
1
;;; M-Eval input:
(define b (lambda (x) (display "test-lambda\n")))
;;; M-Eval value:
ok
;;; M-Eval input:
(begin "One" (if "" "two" (quote ())) "end begin")
;;; M-Eval value:
"end begin"
;;; M-Eval input:
(cond (#f "clause 1") (#f (quote clause2)) (#t "clause 3") (else "else clause"))
;;; M-Eval value:
"clause 3"
;;; M-Eval input:
(cond (#f "clause 1") (#f (quote clause2)) (#f "clause 3") (else "else\nclause"))
;;; M-Eval value:
"else\nclause"
;;; M-Eval input:
(and #t #f)
;;; M-Eval value:
#f
;;; M-Eval input:
(and #f #f)
;;; M-Eval value:
#f
;;; M-Eval input:
(or #t #f)
;;; M-Eval value:
#t
;;; M-Eval input:
(or #f #f)
;;; M-Eval value:
#f
;;; M-Eval input:
"testing cond with arrow"
;;; M-Eval value:
"testing cond with arrow"
;;; M-Eval input:
(define cadr (lambda (x) (car (cdr x))))
;;; M-Eval value:
ok
;;; M-Eval input:
(cond ((assoc (quote b) (quote ((a 1) (b 2)))) => cadr) (else false))
;;; M-Eval value:
2
;;; M-Eval input:
(exit)
#+end_src



***** DONE Exercise 4.6 Implementing let
      CLOSED: [2020-01-22 Wed 17:03]

#+name: s-let-implementation
#+begin_src scheme :exports code :results none
(define (let? exp) (tagged-list? exp 'let))

(define (let-bindings exp)
  (cadr exp))
(define (let-bindings-variables l)
  (map car l))
(define (let-bindings-expressions l)
  (map cadr l))
(define (let-contents exp)
    (cddr exp))
(define (let->combination exp)
  (cons
     (make-lambda
          (let-bindings-variables (let-bindings exp))
          (let-contents exp))
     (let-bindings-expressions (let-bindings exp))))
#+end_src

#+name: s-let-installation
#+begin_src scheme :exports code :results none
(put 'eval 'let (lambda (exp env) (eval (let->combination exp) env)))
#+end_src

#+name: s-let
#+begin_src scheme :exports code :results none
<<s-let-implementation>>
<<s-let-installation>>
#+end_src

#+name: s-input-test-let
#+begin_example
"hello"
1
#t
#f
(if #t "true" "false")
(if #f "true" "false")
(if '() "true" "false")
'()
'test-symbol
(define a '())
a
(set! a 1)
a
(define b (lambda (x) (display "test-lambda\n")))
(begin "One" (if "" "two" '()) "end begin")
(cond (#f "clause 1") (#f 'clause2) (#t "clause 3") (else "else clause"))
(cond (#f "clause 1") (#f 'clause2) (#f "clause 3") (else "else
clause"))
(and #t #f)
(and #f #f)
(or #t #f)
(or #f #f)
"testing cond with arrow"

(define cadr (lambda (x) (car (cdr x))))

(cond ((assoc 'b '((a 1) (b 2))) => cadr)
   (else false))
"let test1"
(let () "Let1")
"let test2"
(let ((a "Let2")) a)
"let test3"
(let ((a "Let2") (b "Let3")) a (cons a b))
(exit)
#+end_example


#+header: :stdin s-input-test-let
#+begin_src shell :shebang "#! /usr/bin/chibi-scheme" :results output scalar code :exports both
<<s-glue1>>
<<s-apply>>
<<put-and-get>>
<<s-data-driven-eval>>
<<s-list-of-values-left-to-right>>
<<s-standard-if>>
<<s-sequences>>
<<s-assignment>>
<<s-define>>
<<s-syntax>>
<<s-application>>
<<s-cond-with-arrow>>
<<s-truefalse>>
<<s-compound-procedures>>
<<s-environments>>
<<s-primitive-procedures>>
<<s-driver-loop>>
<<s-eval-and>>
<<s-let>>
<<s-glue2>>

(driver-loop)

#+end_src

#+RESULTS[02d43c7543b794c4ea5d60a91fd12c60ce89f00e]:
#+begin_src shell

;;; M-Eval input:
"hello"
;;; M-Eval value:
"hello"
;;; M-Eval input:
1
;;; M-Eval value:
1
;;; M-Eval input:
#t
;;; M-Eval value:
#t
;;; M-Eval input:
#f
;;; M-Eval value:
#f
;;; M-Eval input:
(if #t "true" "false")
;;; M-Eval value:
"true"
;;; M-Eval input:
(if #f "true" "false")
;;; M-Eval value:
"false"
;;; M-Eval input:
(if (quote ()) "true" "false")
;;; M-Eval value:
"true"
;;; M-Eval input:
(quote ())
;;; M-Eval value:
()
;;; M-Eval input:
(quote test-symbol)
;;; M-Eval value:
test-symbol
;;; M-Eval input:
(define a (quote ()))
;;; M-Eval value:
ok
;;; M-Eval input:
a
;;; M-Eval value:
()
;;; M-Eval input:
(set! a 1)
;;; M-Eval value:
ok
;;; M-Eval input:
a
;;; M-Eval value:
1
;;; M-Eval input:
(define b (lambda (x) (display "test-lambda\n")))
;;; M-Eval value:
ok
;;; M-Eval input:
(begin "One" (if "" "two" (quote ())) "end begin")
;;; M-Eval value:
"end begin"
;;; M-Eval input:
(cond (#f "clause 1") (#f (quote clause2)) (#t "clause 3") (else "else clause"))
;;; M-Eval value:
"clause 3"
;;; M-Eval input:
(cond (#f "clause 1") (#f (quote clause2)) (#f "clause 3") (else "else\nclause"))
;;; M-Eval value:
"else\nclause"
;;; M-Eval input:
(and #t #f)
;;; M-Eval value:
#f
;;; M-Eval input:
(and #f #f)
;;; M-Eval value:
#f
;;; M-Eval input:
(or #t #f)
;;; M-Eval value:
#t
;;; M-Eval input:
(or #f #f)
;;; M-Eval value:
#f
;;; M-Eval input:
"testing cond with arrow"
;;; M-Eval value:
"testing cond with arrow"
;;; M-Eval input:
(define cadr (lambda (x) (car (cdr x))))
;;; M-Eval value:
ok
;;; M-Eval input:
(cond ((assoc (quote b) (quote ((a 1) (b 2)))) => cadr) (else false))
;;; M-Eval value:
2
;;; M-Eval input:
"let test1"
;;; M-Eval value:
"let test1"
;;; M-Eval input:
(let () "Let1")
;;; M-Eval value:
"Let1"
;;; M-Eval input:
"let test2"
;;; M-Eval value:
"let test2"
;;; M-Eval input:
(let ((a "Let2")) a)
;;; M-Eval value:
"Let2"
;;; M-Eval input:
"let test3"
;;; M-Eval value:
"let test3"
;;; M-Eval input:
(let ((a "Let2") (b "Let3")) a (cons a b))
;;; M-Eval value:
("Let2" . "Let3")
;;; M-Eval input:
(exit)
#+end_src

***** DONE Exercise 4.7 Implementing let*
      CLOSED: [2020-01-22 Wed 18:09]

I assume that plain ~let~ is already implemented in Exercise 4.6.

#+name: s-let-star-implementation
#+begin_src scheme :exports code :results none

  (define (let-bindings-first b)
    (car b))
  (define (let-bindings-rest b)
    (cdr b))

  (define (make-let bindings body)
    (cons 'let (cons bindings body)))
  #;(let* ((a 1) (b (cons a 1))) b)
  (define (let*->nested-lets exp)
    (define (let*-unfold blist body)
      (if (null? blist)
	  body
	  (list (make-let (list (let-bindings-first blist))
		    (let*-unfold (let-bindings-rest blist) body)))))
    (car (let*-unfold (let-bindings exp) (let-contents exp)))
  )
#+end_src

#+name: s-let-star-installation
#+begin_src scheme :exports code :results none
  (put 'eval 'let* (lambda (exp env) (eval (let*->nested-lets exp) env)))
#+end_src

#+name: s-let-star
#+begin_src scheme :exports code :results none
<<s-let-star-implementation>>
<<s-let-star-installation>>
#+end_src

#+name: s-input-test-let-star
#+begin_example
"hello"
1
#t
#f
(if #t "true" "false")
(if #f "true" "false")
(if '() "true" "false")
'()
'test-symbol
(define a '())
a
(set! a 1)
a
(define b (lambda (x) (display "test-lambda\n")))
(begin "One" (if "" "two" '()) "end begin")
(cond (#f "clause 1") (#f 'clause2) (#t "clause 3") (else "else clause"))
(cond (#f "clause 1") (#f 'clause2) (#f "clause 3") (else "else
clause"))
(and #t #f)
(and #f #f)
(or #t #f)
(or #f #f)
"testing cond with arrow"

(define cadr (lambda (x) (car (cdr x))))

(cond ((assoc 'b '((a 1) (b 2))) => cadr)
   (else false))
"let test1"
(let () "Let1")
"let test2"
(let ((a "Let2")) a)
"let test3"
(let ((a "Let2") (b "Let3")) a (cons a b))
(let* ((a 1) (b (cons a 1))) b)
(exit)
#+end_example

#+header: :stdin s-input-test-let-star
#+begin_src shell :shebang "#! /usr/bin/chibi-scheme" :results output scalar code :exports both
<<s-glue1>>
<<s-apply>>
<<put-and-get>>
<<s-data-driven-eval>>
<<s-list-of-values-left-to-right>>
<<s-standard-if>>
<<s-sequences>>
<<s-assignment>>
<<s-define>>
<<s-syntax>>
<<s-application>>
<<s-cond-with-arrow>>
<<s-truefalse>>
<<s-compound-procedures>>
<<s-environments>>
<<s-primitive-procedures>>
<<s-driver-loop>>
<<s-eval-and>>
<<s-let>>
<<s-let-star>>
<<s-glue2>>


#;(display (let*->nested-lets '(let* ((a 1) (b (cons a 1)) (c 3) (d 4)) b)))
(driver-loop)

#+end_src

#+RESULTS[8a771858cf140e359b9780ba76df233568765bc3]:
#+begin_src shell

;;; M-Eval input:
"hello"
;;; M-Eval value:
"hello"
;;; M-Eval input:
1
;;; M-Eval value:
1
;;; M-Eval input:
#t
;;; M-Eval value:
#t
;;; M-Eval input:
#f
;;; M-Eval value:
#f
;;; M-Eval input:
(if #t "true" "false")
;;; M-Eval value:
"true"
;;; M-Eval input:
(if #f "true" "false")
;;; M-Eval value:
"false"
;;; M-Eval input:
(if (quote ()) "true" "false")
;;; M-Eval value:
"true"
;;; M-Eval input:
(quote ())
;;; M-Eval value:
()
;;; M-Eval input:
(quote test-symbol)
;;; M-Eval value:
test-symbol
;;; M-Eval input:
(define a (quote ()))
;;; M-Eval value:
ok
;;; M-Eval input:
a
;;; M-Eval value:
()
;;; M-Eval input:
(set! a 1)
;;; M-Eval value:
ok
;;; M-Eval input:
a
;;; M-Eval value:
1
;;; M-Eval input:
(define b (lambda (x) (display "test-lambda\n")))
;;; M-Eval value:
ok
;;; M-Eval input:
(begin "One" (if "" "two" (quote ())) "end begin")
;;; M-Eval value:
"end begin"
;;; M-Eval input:
(cond (#f "clause 1") (#f (quote clause2)) (#t "clause 3") (else "else clause"))
;;; M-Eval value:
"clause 3"
;;; M-Eval input:
(cond (#f "clause 1") (#f (quote clause2)) (#f "clause 3") (else "else\nclause"))
;;; M-Eval value:
"else\nclause"
;;; M-Eval input:
(and #t #f)
;;; M-Eval value:
#f
;;; M-Eval input:
(and #f #f)
;;; M-Eval value:
#f
;;; M-Eval input:
(or #t #f)
;;; M-Eval value:
#t
;;; M-Eval input:
(or #f #f)
;;; M-Eval value:
#f
;;; M-Eval input:
"testing cond with arrow"
;;; M-Eval value:
"testing cond with arrow"
;;; M-Eval input:
(define cadr (lambda (x) (car (cdr x))))
;;; M-Eval value:
ok
;;; M-Eval input:
(cond ((assoc (quote b) (quote ((a 1) (b 2)))) => cadr) (else false))
;;; M-Eval value:
2
;;; M-Eval input:
"let test1"
;;; M-Eval value:
"let test1"
;;; M-Eval input:
(let () "Let1")
;;; M-Eval value:
"Let1"
;;; M-Eval input:
"let test2"
;;; M-Eval value:
"let test2"
;;; M-Eval input:
(let ((a "Let2")) a)
;;; M-Eval value:
"Let2"
;;; M-Eval input:
"let test3"
;;; M-Eval value:
"let test3"
;;; M-Eval input:
(let ((a "Let2") (b "Let3")) a (cons a b))
;;; M-Eval value:
("Let2" . "Let3")
;;; M-Eval input:
(let* ((a 1) (b (cons a 1))) b)
;;; M-Eval value:
(1 . 1)
;;; M-Eval input:
(exit)
#+end_src

Huh. Seems to be working. Why the question then? It seems that
implementing it as a derived expression is okay...

***** DONE Exercise 4.8 Implementing named let
      CLOSED: [2020-01-22 Wed 19:50]

#+name: s-let-named
#+begin_src scheme :exports code :results none
(define (is-named-let? exp)
  (if (symbol? (cadr exp))
      #t
      #f))
(define (let-named-name exp)
   (cadr exp))
(define (let-named-bindings exp)
   (caddr exp))
(define (let-named-body exp)
   (cdddr exp))
(define (process-let exp env)
  (eval (if (is-named-let? exp)
           (let->named exp)
           (let->combination exp))
        env))
  (define (let->named exp)
    (make-begin
      (list (list 'define
           (let-named-name exp)
           (make-lambda
	    (let-bindings-variables (let-named-bindings exp))
	    (let-named-body exp)))
       (cons (let-named-name exp)
             (let-bindings-expressions (let-named-bindings exp))
         ))))

(put 'eval 'let process-let)
#+end_src

#+name: s-input-test-let-named
#+begin_example
"hello"
1
#t
#f
(if #t "true" "false")
(if #f "true" "false")
(if '() "true" "false")
'()
'test-symbol
(define a '())
a
(set! a 1)
a
(define b (lambda (x) (display "test-lambda\n")))
(begin "One" (if "" "two" '()) "end begin")
(cond (#f "clause 1") (#f 'clause2) (#t "clause 3") (else "else clause"))
(cond (#f "clause 1") (#f 'clause2) (#f "clause 3") (else "else
clause"))
(and #t #f)
(and #f #f)
(or #t #f)
(or #f #f)
"testing cond with arrow"

(define cadr (lambda (x) (car (cdr x))))

(cond ((assoc 'b '((a 1) (b 2))) => cadr)
   (else false))
"let test1"
(let () "Let1")
"let test2"
(let ((a "Let2")) a)
"let test3"
(let ((a "Let2") (b "Let3")) a (cons a b))
(let* ((a 1) (b (cons a 1))) b)
(define (fib n)
  (let fib-iter ((a 1)
                 (b 0)
                 (count n))
     (if (= count 0)
        b
        (fib-iter (+ a b) a (- count 1)))))
(fib 10)
(exit)
#+end_example

#+header: :stdin s-input-test-let-named
#+begin_src shell :shebang "#! /usr/bin/chibi-scheme" :results output scalar code :exports both
<<s-glue1>>
<<s-apply>>
<<put-and-get>>
<<s-data-driven-eval>>
<<s-list-of-values-left-to-right>>
<<s-standard-if>>
<<s-sequences>>
<<s-assignment>>
<<s-define>>
<<s-syntax>>
<<s-application>>
<<s-cond-with-arrow>>
<<s-truefalse>>
<<s-compound-procedures>>
<<s-environments>>
<<s-primitive-procedures>>
<<s-driver-loop>>
<<s-eval-and>>
<<s-let>>
<<s-let-star>>
<<s-let-named>>
<<s-glue2>>

(driver-loop)

#+end_src

#+RESULTS[dd39ce6ea78dd15c2b890145e5187019e4a68174]:
#+begin_src shell

;;; M-Eval input:
"hello"
;;; M-Eval value:
"hello"
;;; M-Eval input:
1
;;; M-Eval value:
1
;;; M-Eval input:
#t
;;; M-Eval value:
#t
;;; M-Eval input:
#f
;;; M-Eval value:
#f
;;; M-Eval input:
(if #t "true" "false")
;;; M-Eval value:
"true"
;;; M-Eval input:
(if #f "true" "false")
;;; M-Eval value:
"false"
;;; M-Eval input:
(if (quote ()) "true" "false")
;;; M-Eval value:
"true"
;;; M-Eval input:
(quote ())
;;; M-Eval value:
()
;;; M-Eval input:
(quote test-symbol)
;;; M-Eval value:
test-symbol
;;; M-Eval input:
(define a (quote ()))
;;; M-Eval value:
ok
;;; M-Eval input:
a
;;; M-Eval value:
()
;;; M-Eval input:
(set! a 1)
;;; M-Eval value:
ok
;;; M-Eval input:
a
;;; M-Eval value:
1
;;; M-Eval input:
(define b (lambda (x) (display "test-lambda\n")))
;;; M-Eval value:
ok
;;; M-Eval input:
(begin "One" (if "" "two" (quote ())) "end begin")
;;; M-Eval value:
"end begin"
;;; M-Eval input:
(cond (#f "clause 1") (#f (quote clause2)) (#t "clause 3") (else "else clause"))
;;; M-Eval value:
"clause 3"
;;; M-Eval input:
(cond (#f "clause 1") (#f (quote clause2)) (#f "clause 3") (else "else\nclause"))
;;; M-Eval value:
"else\nclause"
;;; M-Eval input:
(and #t #f)
;;; M-Eval value:
#f
;;; M-Eval input:
(and #f #f)
;;; M-Eval value:
#f
;;; M-Eval input:
(or #t #f)
;;; M-Eval value:
#t
;;; M-Eval input:
(or #f #f)
;;; M-Eval value:
#f
;;; M-Eval input:
"testing cond with arrow"
;;; M-Eval value:
"testing cond with arrow"
;;; M-Eval input:
(define cadr (lambda (x) (car (cdr x))))
;;; M-Eval value:
ok
;;; M-Eval input:
(cond ((assoc (quote b) (quote ((a 1) (b 2)))) => cadr) (else false))
;;; M-Eval value:
2
;;; M-Eval input:
"let test1"
;;; M-Eval value:
"let test1"
;;; M-Eval input:
(let () "Let1")
;;; M-Eval value:
"Let1"
;;; M-Eval input:
"let test2"
;;; M-Eval value:
"let test2"
;;; M-Eval input:
(let ((a "Let2")) a)
;;; M-Eval value:
"Let2"
;;; M-Eval input:
"let test3"
;;; M-Eval value:
"let test3"
;;; M-Eval input:
(let ((a "Let2") (b "Let3")) a (cons a b))
;;; M-Eval value:
("Let2" . "Let3")
;;; M-Eval input:
(let* ((a 1) (b (cons a 1))) b)
;;; M-Eval value:
(1 . 1)
;;; M-Eval input:
(define (fib n) (let fib-iter ((a 1) (b 0) (count n)) (if (= count 0) b (fib-iter (+ a b) a (- count 1)))))
;;; M-Eval value:
ok
;;; M-Eval input:
(fib 10)
;;; M-Eval value:
55
;;; M-Eval input:
(exit)
#+end_src

***** DONE Exercise 4.9 Implementing until
      CLOSED: [2020-01-23 Thu 18:06]

I am implementing the dumbest possible ~until~ loop in the world. The
syntax is the following: (until (<variable> <test>) <body>),
where <variable> is a symbol to which a "loop exit procedure" will be
bound within the body of a loop, and he <test> is a procedure,
provided by the user which takes no arguments. The body is evaluates
as if it is a "begin" sequence. At the end of the sequence, the <test>
procedure is evaluated and if it evaluates to a true (in the sense of
~(true?)~) value, the loop is exited.

#+name: s-until
#+begin_src scheme :exports code :results none

  (define (make-named-let name bindings body)
    (cons 'let (cons name (cons bindings body))))
  (define (until-test-name exp)
    (caadr exp))
  (define (until-test-proc exp)
    (cadadr exp))
  (define (until-body exp)
    (cddr exp))
  (define (until->begin exp)
    (make-named-let
	(until-test-name exp)
	'()
	 (append (until-body exp) (list (make-if (list 'not (list (until-test-proc exp)))
			       (list (until-test-name exp))
			       #t)))))

  (put 'eval 'until (lambda (exp env) (eval (until->begin exp) env)))

#+end_src

#+name: s-input-until
#+begin_example
"hello"
1
#t
#f
(if #t "true" "false")
(if #f "true" "false")
(if '() "true" "false")
'()
'test-symbol
(define a '())
a
(set! a 1)
a
(define b (lambda (x) (display "test-lambda\n")))
(begin "One" (if "" "two" '()) "end begin")
(cond (#f "clause 1") (#f 'clause2) (#t "clause 3") (else "else clause"))
(cond
  (#f "clause 1")
  (#f 'clause2)
  (#f "clause 3")
  (else "else
      clause"))
(and #t #f)
(and #f #f)
(or #t #f)
(or #f #f)
"testing cond with arrow"

(define cadr (lambda (x) (car (cdr x))))

(cond ((assoc 'b '((a 1) (b 2))) => cadr)
   (else false))
"let test1"
(let () "Let1")
"let test2"
(let ((a "Let2")) a)
"let test3"
(let ((a "Let2") (b "Let3")) a (cons a b))
(let* ((a 1) (b (cons a 1))) b)
"fibonacci test"
(define (fib n)
  (let fib-iter ((a 1)
                 (b 0)
                 (count n))
     (if (= count 0)
        b
        (fib-iter (+ a b) a (- count 1)))))
(fib 10)
(define x 100)
(define x 0)
(until (loop (lambda () (= x 5)))
  (set! x (+ x 1)))
x
(exit)
#+end_example


#+header: :stdin s-input-until
#+begin_src shell :shebang "#! /usr/bin/chibi-scheme" :results output scalar code :exports both
<<s-glue1>>
<<s-apply>>
<<put-and-get>>
<<s-data-driven-eval>>
<<s-list-of-values-left-to-right>>
<<s-standard-if>>
<<s-sequences>>
<<s-assignment>>
<<s-define>>
<<s-syntax>>
<<s-application>>
<<s-cond-with-arrow>>
<<s-truefalse>>
<<s-compound-procedures>>
<<s-environments>>
<<s-primitive-procedures>>
<<s-driver-loop>>
<<s-eval-and>>
<<s-let>>
<<s-let-star>>
<<s-let-named>>
<<s-until>>
<<s-glue2>>

(display (until->begin '(until (loop (lambda () (= x 5)))
  (set! x (+ x 1)))))
(driver-loop)

#+end_src

#+RESULTS[364f38120a5f075b79f211f7e331c7182686e297]:
#+begin_src shell
(let loop () (set! x (+ x 1)) (if (not ((lambda () (= x 5)))) (loop) #t))
;;; M-Eval input:
"hello"
;;; M-Eval value:
"hello"
;;; M-Eval input:
1
;;; M-Eval value:
1
;;; M-Eval input:
#t
;;; M-Eval value:
#t
;;; M-Eval input:
#f
;;; M-Eval value:
#f
;;; M-Eval input:
(if #t "true" "false")
;;; M-Eval value:
"true"
;;; M-Eval input:
(if #f "true" "false")
;;; M-Eval value:
"false"
;;; M-Eval input:
(if (quote ()) "true" "false")
;;; M-Eval value:
"true"
;;; M-Eval input:
(quote ())
;;; M-Eval value:
()
;;; M-Eval input:
(quote test-symbol)
;;; M-Eval value:
test-symbol
;;; M-Eval input:
(define a (quote ()))
;;; M-Eval value:
ok
;;; M-Eval input:
a
;;; M-Eval value:
()
;;; M-Eval input:
(set! a 1)
;;; M-Eval value:
ok
;;; M-Eval input:
a
;;; M-Eval value:
1
;;; M-Eval input:
(define b (lambda (x) (display "test-lambda\n")))
;;; M-Eval value:
ok
;;; M-Eval input:
(begin "One" (if "" "two" (quote ())) "end begin")
;;; M-Eval value:
"end begin"
;;; M-Eval input:
(cond (#f "clause 1") (#f (quote clause2)) (#t "clause 3") (else "else clause"))
;;; M-Eval value:
"clause 3"
;;; M-Eval input:
(cond (#f "clause 1") (#f (quote clause2)) (#f "clause 3") (else "else\n      clause"))
;;; M-Eval value:
"else\n      clause"
;;; M-Eval input:
(and #t #f)
;;; M-Eval value:
#f
;;; M-Eval input:
(and #f #f)
;;; M-Eval value:
#f
;;; M-Eval input:
(or #t #f)
;;; M-Eval value:
#t
;;; M-Eval input:
(or #f #f)
;;; M-Eval value:
#f
;;; M-Eval input:
"testing cond with arrow"
;;; M-Eval value:
"testing cond with arrow"
;;; M-Eval input:
(define cadr (lambda (x) (car (cdr x))))
;;; M-Eval value:
ok
;;; M-Eval input:
(cond ((assoc (quote b) (quote ((a 1) (b 2)))) => cadr) (else false))
;;; M-Eval value:
2
;;; M-Eval input:
"let test1"
;;; M-Eval value:
"let test1"
;;; M-Eval input:
(let () "Let1")
;;; M-Eval value:
"Let1"
;;; M-Eval input:
"let test2"
;;; M-Eval value:
"let test2"
;;; M-Eval input:
(let ((a "Let2")) a)
;;; M-Eval value:
"Let2"
;;; M-Eval input:
"let test3"
;;; M-Eval value:
"let test3"
;;; M-Eval input:
(let ((a "Let2") (b "Let3")) a (cons a b))
;;; M-Eval value:
("Let2" . "Let3")
;;; M-Eval input:
(let* ((a 1) (b (cons a 1))) b)
;;; M-Eval value:
(1 . 1)
;;; M-Eval input:
"fibonacci test"
;;; M-Eval value:
"fibonacci test"
;;; M-Eval input:
(define (fib n) (let fib-iter ((a 1) (b 0) (count n)) (if (= count 0) b (fib-iter (+ a b) a (- count 1)))))
;;; M-Eval value:
ok
;;; M-Eval input:
(fib 10)
;;; M-Eval value:
55
;;; M-Eval input:
(define x 100)
;;; M-Eval value:
ok
;;; M-Eval input:
(define x 0)
;;; M-Eval value:
ok
;;; M-Eval input:
(until (loop (lambda () (= x 5))) (set! x (+ x 1)))
;;; M-Eval value:
#t
;;; M-Eval input:
x
;;; M-Eval value:
5
;;; M-Eval input:
(exit)
#+end_src

***** DONE Exercise 4.10 Modifying syntax
      CLOSED: [2020-02-06 Thu 22:08]
Well, I don't see much point in this exercise. It certainly doesn't
let us replace parentheses with brackets, but well, we could extend
the functionality of some forms. Anyway, so far I have just decided to
quickly modify ~if~ to work like ~unless~.



#+name: s-input-modifying-syntax
#+begin_example
"hello"
1
#t
#f
(if #t "true" "false")
(if #f "true" "false")
(if '() "true" "false")
;(exit)
'()
'test-symbol
(define a '())
a
(set! a 1)
a
(define b (lambda (x) (display "test-lambda\n")))
(begin "One" (if "" "two" '()) "end begin")
(cond (#f "clause 1") (#f 'clause2) (#t "clause 3") (else "else clause"))
(cond
  (#f "clause 1")
  (#f 'clause2)
  (#f "clause 3")
  (else "else
      clause"))
(and #t #f)
(and #f #f)
(or #t #f)
(or #f #f)
"testing cond with arrow"

(define cadr (lambda (x) (car (cdr x))))

(cond ((assoc 'b '((a 1) (b 2))) => cadr)
   (else false))
"let test1"
(let () "Let1")
"let test2"
(let ((a "Let2")) a)
"let test3"
(let ((a "Let2") (b "Let3")) a (cons a b))
(let* ((a 1) (b (cons a 1))) b)
(define (fib n)
  (let fib-iter ((a 1)
                 (b 0)
                 (count n))
     (if (= count 0)
        b
        (fib-iter (+ a b) a (- count 1)))))
(fib 10)
(define x 100)
(define x 0)
x
(exit)
#+end_example

#+name: s-input-modifying-syntax-conditionals
#+begin_src scheme :exports code :results none
  (define (eval-if exp env)
    (if (true? (eval (if-predicate exp) env))
	(eval (if-alternative exp) env)
        (eval (if-consequent exp) env)))
#+end_src

#+header: :stdin s-input-modifying-syntax
#+begin_src shell :shebang "#! /usr/bin/chibi-scheme" :results output scalar code :exports both
<<s-glue1>>
<<s-apply>>
<<put-and-get>>
<<s-data-driven-eval>>
<<s-list-of-values-left-to-right>>
<<s-input-modifying-syntax-conditionals>>
<<s-sequences>>
<<s-assignment>>
<<s-define>>
<<s-syntax>>
<<s-application>>
<<s-cond-with-arrow>>
<<s-truefalse>>
<<s-compound-procedures>>
<<s-environments>>
<<s-primitive-procedures>>
<<s-driver-loop>>
<<s-eval-and>>
<<s-let>>
<<s-let-star>>
<<s-let-named>>
<<s-until>>
<<s-glue2>>


(driver-loop)

#+end_src

#+RESULTS[92734116e2d9f3733c4cb0a9b12b3755f0955046]:
#+begin_src shell

;;; M-Eval input:
"hello"
;;; M-Eval value:
"hello"
;;; M-Eval input:
1
;;; M-Eval value:
1
;;; M-Eval input:
#t
;;; M-Eval value:
#t
;;; M-Eval input:
#f
;;; M-Eval value:
#f
;;; M-Eval input:
(if #t "true" "false")
;;; M-Eval value:
"false"
;;; M-Eval input:
(if #f "true" "false")
;;; M-Eval value:
"true"
;;; M-Eval input:
(if (quote ()) "true" "false")
;;; M-Eval value:
"false"
;;; M-Eval input:
(quote ())
;;; M-Eval value:
()
;;; M-Eval input:
(quote test-symbol)
;;; M-Eval value:
test-symbol
;;; M-Eval input:
(define a (quote ()))
;;; M-Eval value:
ok
;;; M-Eval input:
a
;;; M-Eval value:
()
;;; M-Eval input:
(set! a 1)
;;; M-Eval value:
ok
;;; M-Eval input:
a
;;; M-Eval value:
1
;;; M-Eval input:
(define b (lambda (x) (display "test-lambda\n")))
;;; M-Eval value:
ok
;;; M-Eval input:
(begin "One" (if "" "two" (quote ())) "end begin")
;;; M-Eval value:
"end begin"
;;; M-Eval input:
(cond (#f "clause 1") (#f (quote clause2)) (#t "clause 3") (else "else clause"))
;;; M-Eval value:
"clause 1"
;;; M-Eval input:
(cond (#f "clause 1") (#f (quote clause2)) (#f "clause 3") (else "else\n      clause"))
;;; M-Eval value:
"clause 1"
;;; M-Eval input:
(and #t #f)
;;; M-Eval value:
#f
;;; M-Eval input:
(and #f #f)
;;; M-Eval value:
#f
;;; M-Eval input:
(or #t #f)
;;; M-Eval value:
#t
;;; M-Eval input:
(or #f #f)
;;; M-Eval value:
#f
;;; M-Eval input:
"testing cond with arrow"
;;; M-Eval value:
"testing cond with arrow"
;;; M-Eval input:
(define cadr (lambda (x) (car (cdr x))))
;;; M-Eval value:
ok
;;; M-Eval input:
(cond ((assoc (quote b) (quote ((a 1) (b 2)))) => cadr) (else false))
;;; M-Eval value:
#f
;;; M-Eval input:
"let test1"
;;; M-Eval value:
"let test1"
;;; M-Eval input:
(let () "Let1")
;;; M-Eval value:
"Let1"
;;; M-Eval input:
"let test2"
;;; M-Eval value:
"let test2"
;;; M-Eval input:
(let ((a "Let2")) a)
;;; M-Eval value:
"Let2"
;;; M-Eval input:
"let test3"
;;; M-Eval value:
"let test3"
;;; M-Eval input:
(let ((a "Let2") (b "Let3")) a (cons a b))
;;; M-Eval value:
("Let2" . "Let3")
;;; M-Eval input:
(let* ((a 1) (b (cons a 1))) b)
;;; M-Eval value:
(1 . 1)
;;; M-Eval input:
(define (fib n) (let fib-iter ((a 1) (b 0) (count n)) (if (= count 0) b (fib-iter (+ a b) a (- count 1)))))
;;; M-Eval value:
ok
;;; M-Eval input:
(fib 10)
;;; M-Eval value:
0
;;; M-Eval input:
(define x 100)
;;; M-Eval value:
ok
;;; M-Eval input:
(define x 0)
;;; M-Eval value:
ok
;;; M-Eval input:
x
;;; M-Eval value:
0
;;; M-Eval input:
(exit)
#+end_src



**** 4.1.3 Evaluator Data Structures

***** Common code for the Evaluator
#+name: s-truefalse
#+begin_src scheme :exports code :results none
  (define (true? v)  (not (false? v)))
  (define (false? v)      (eq? v #f))
#+end_src

#+name: s-compound-procedures
#+begin_src scheme :exports code :results none
  (define (make-procedure parameters body env)
    (list 'procedure parameters body env))
  (define (compound-procedure? p)
    (tagged-list? p 'procedure))
  (define (procedure-parameters p) (cadr p))
  (define (procedure-body p) (caddr p))
  (define (procedure-environment p) (cadddr p))
#+end_src

#+name: s-environments
#+begin_src scheme :exports code :results none
     (define (enclosing-environment env) (cdr env))
     (define (first-frame env) (car env))
     (define the-empty-environment '())
     (define (make-frame variables values)
       (cons variables values))
     (define (frame-variables frame) (car frame))
     (define (frame-values frame) (cdr frame))
     (define (add-binding-to-frame! var val frame)
       (set-car! frame (cons var (car frame)))
       (set-cdr! frame (cons val (cdr frame))))
     (define (extend-environment vars vals base-env)
       (if (= (length vars) (length vals))
           (cons (make-frame vars vals) base-env)
           (if (< (length vars) (length vals))
               (error "Too many arguments supplied" vars vals)
               (error "Too few arguments supplied" vars vals))))
     (define (lookup-variable-value var env)
       (define (env-loop env)
         (define (scan vars vals)
           (cond ((null? vars)
                  (env-loop (enclosing-environment env)))
                 ((eq? var (car vars))
                  (car vals))
                 (else (scan (cdr vars) (cdr vals)))))
         (if (eq? env the-empty-environment)
             (error "Unbound variable" var)
             (let ((frame (first-frame env)))
               (scan (frame-variables frame)
                     (frame-values frame)))))
       (env-loop env))
     (define (set-variable-value! var val env)
       (define (env-loop env)
         (define (scan vars vals)
           (cond ((null? vars)
                  (env-loop (enclosing-environment env)))
                 ((eq? var (car vars))
                  (set-car! vals val))
                 (else (scan (cdr vars) (cdr vals)))))
         (if (eq? env the-empty-environment)
             (error "Unbound variable -- SET!" var)
             (let ((frame (first-frame env)))
               (scan (frame-variables frame)
                     (frame-values frame)))))
       (env-loop env))
     (define (define-variable! var val env)
       (let ((frame (first-frame env)))
         (define (scan vars vals)
           (cond ((null? vars)
                  (add-binding-to-frame! var val frame))
                 ((eq? var (car vars))
                  (set-car! vals val))
                 (else (scan (cdr vars) (cdr vals)))))
         (scan (frame-variables frame)
               (frame-values frame))))

#+end_src

***** DONE Exercise 4.11 Environment as a list of bindings
      CLOSED: [2020-02-11 Tue 06:58]

It was sort of a bit weird from the start to have two separate
lists. This exercise just implements a more common logic.

The tests for this exercise should be the same as for the previous one
(and maybe even the later ones), so that shouldn't be much of a problem.

Tests:

#+name: s-input-list-of-bindings
#+begin_example
"hello"
1
#t
#f
(if #t "true" "false")
(if #f "true" "false")
(if '() "true" "false")
'()
'test-symbol
(define a '())
a
(set! a 1)
a
(define b (lambda (x) (display "test-lambda\n")))
(begin "One" (if "" "two" '()) "end begin")
(cond (#f "clause 1") (#f 'clause2) (#t "clause 3") (else "else clause"))
(cond
  (#f "clause 1")
  (#f 'clause2)
  (#f "clause 3")
  (else "else
      clause"))
(and #t #f)
(and #f #f)
(or #t #f)
(or #f #f)
"testing cond with arrow"

(define cadr (lambda (x) (car (cdr x))))

(cond ((assoc 'b '((a 1) (b 2))) => cadr)
   (else false))
"let test1"
(let () "Let1")
"let test2"
(let ((a "Let2")) a)
"let test3"
(let ((a "Let2") (b "Let3")) a (cons a b))
(let* ((a 1) (b (cons a 1))) b)
(define (fib n)
  (let fib-iter ((a 1)
                 (b 0)
                 (count n))
     (if (= count 0)
        b
        (fib-iter (+ a b) a (- count 1)))))
(fib 10)
(define x 100)
(define x 0)
(until (loop (lambda () (= x 5)))
  (set! x (+ x 1)))
x
(exit)
#+end_example


#+name: s-environments-list-of-bindings
#+begin_src scheme :exports code :results none
     (define (enclosing-environment env) (cdr env))
     (define (first-frame env) (car env))
     (define the-empty-environment '())
     (define make-binding cons)
     (define binding-var car)
     (define binding-val cdr)
     (define (make-frame variables values)
       (cons 'frame-tag (map make-binding variables values)))
     (define (frame-bindings frame) (cdr frame))
     (define (frame-variables frame) (map binding-var (frame-bindings frame)))
     (define (frame-values frame) (map binding-val (frame-bindings frame)))
     (define (add-binding-to-frame! var val frame)
       (error "disabled")
       (set-box! frame (cons (make-binding var val) (unbox frame))))
     (define (extend-environment vars vals base-env)
       (if (= (length vars) (length vals))
           (cons (make-frame vars vals) base-env)
           (if (< (length vars) (length vals))
               (error "Too many arguments supplied" vars vals)
               (error "Too few arguments supplied" vars vals))))
     (define (lookup-variable-value var env)
       (define (env-loop env)
         (define (scan vars vals)
           (cond ((null? vars)
                  (env-loop (enclosing-environment env)))
                 ((eq? var (car vars))
                  (car vals))
                 (else (scan (cdr vars) (cdr vals)))))
         (if (eq? env the-empty-environment)
             (error "Unbound variable" var)
             (let ((frame (first-frame env)))
               (scan (frame-variables frame)
                     (frame-values frame)))))
       (env-loop env))
     (define (set-variable-value! var val env)
       (define (env-loop env)
         (define (scan bindings)
           (cond ((null? bindings)
                   (env-loop (enclosing-environment env)))
                 ((eq? var (caar bindings))
                   (set-cdr! (car bindings) val))
                 (else (scan (cdr bindings)))))
         (if (eq? env the-empty-environment)
             (error "Unbound variable -- SET!" var)
             (let ((frame (first-frame env)))
               (scan (frame-bindings frame)))))
       (env-loop env))
     (define (define-variable! var val env)
       (let ((frame (first-frame env)))
         (define (scan subframe)
           (cond ((null? subframe)
                   #;(add-binding-to-frame! var val (box frame))
                   (set-cdr! frame (cons (make-binding var val) (frame-bindings frame))))
                 ((eq? var (caar subframe))
                   (set-cdr! (car subframe) val))
                 (else (scan (cdr subframe)))))
         (scan (frame-bindings frame))))

#+end_src

Note that the :stdin header is the same as in the "Exercise 4.9
Implementing until".

#+header: :stdin s-input-list-of-bindings
#+begin_src shell :shebang "#! /usr/bin/chibi-scheme" :results output scalar code :exports both
<<s-glue1>>
<<s-apply>>
<<put-and-get>>
<<s-data-driven-eval>>
<<s-list-of-values-left-to-right>>
<<s-standard-if>>
<<s-sequences>>
<<s-assignment>>
<<s-define>>
<<s-syntax>>
<<s-application>>
<<s-cond-with-arrow>>
<<s-truefalse>>
<<s-compound-procedures>>
<<s-environments-list-of-bindings>>
<<s-primitive-procedures>>
<<s-driver-loop>>
<<s-eval-and>>
<<s-let>>
<<s-let-star>>
<<s-let-named>>
<<s-until>>
<<s-glue2>>

(driver-loop)

#+end_src

#+RESULTS[19b04623fe3f210cdc80820b134ba71db642255e]:
#+begin_src shell

;;; M-Eval input:
"hello"
;;; M-Eval value:
"hello"
;;; M-Eval input:
1
;;; M-Eval value:
1
;;; M-Eval input:
#t
;;; M-Eval value:
#t
;;; M-Eval input:
#f
;;; M-Eval value:
#f
;;; M-Eval input:
(if #t "true" "false")
;;; M-Eval value:
"true"
;;; M-Eval input:
(if #f "true" "false")
;;; M-Eval value:
"false"
;;; M-Eval input:
(if (quote ()) "true" "false")
;;; M-Eval value:
"true"
;;; M-Eval input:
(quote ())
;;; M-Eval value:
()
;;; M-Eval input:
(quote test-symbol)
;;; M-Eval value:
test-symbol
;;; M-Eval input:
(define a (quote ()))
;;; M-Eval value:
ok
;;; M-Eval input:
a
;;; M-Eval value:
()
;;; M-Eval input:
(set! a 1)
;;; M-Eval value:
ok
;;; M-Eval input:
a
;;; M-Eval value:
1
;;; M-Eval input:
(define b (lambda (x) (display "test-lambda\n")))
;;; M-Eval value:
ok
;;; M-Eval input:
(begin "One" (if "" "two" (quote ())) "end begin")
;;; M-Eval value:
"end begin"
;;; M-Eval input:
(cond (#f "clause 1") (#f (quote clause2)) (#t "clause 3") (else "else clause"))
;;; M-Eval value:
"clause 3"
;;; M-Eval input:
(cond (#f "clause 1") (#f (quote clause2)) (#f "clause 3") (else "else\n      clause"))
;;; M-Eval value:
"else\n      clause"
;;; M-Eval input:
(and #t #f)
;;; M-Eval value:
#f
;;; M-Eval input:
(and #f #f)
;;; M-Eval value:
#f
;;; M-Eval input:
(or #t #f)
;;; M-Eval value:
#t
;;; M-Eval input:
(or #f #f)
;;; M-Eval value:
#f
;;; M-Eval input:
"testing cond with arrow"
;;; M-Eval value:
"testing cond with arrow"
;;; M-Eval input:
(define cadr (lambda (x) (car (cdr x))))
;;; M-Eval value:
ok
;;; M-Eval input:
(cond ((assoc (quote b) (quote ((a 1) (b 2)))) => cadr) (else false))
;;; M-Eval value:
2
;;; M-Eval input:
"let test1"
;;; M-Eval value:
"let test1"
;;; M-Eval input:
(let () "Let1")
;;; M-Eval value:
"Let1"
;;; M-Eval input:
"let test2"
;;; M-Eval value:
"let test2"
;;; M-Eval input:
(let ((a "Let2")) a)
;;; M-Eval value:
"Let2"
;;; M-Eval input:
"let test3"
;;; M-Eval value:
"let test3"
;;; M-Eval input:
(let ((a "Let2") (b "Let3")) a (cons a b))
;;; M-Eval value:
("Let2" . "Let3")
;;; M-Eval input:
(let* ((a 1) (b (cons a 1))) b)
;;; M-Eval value:
(1 . 1)
;;; M-Eval input:
(define (fib n) (let fib-iter ((a 1) (b 0) (count n)) (if (= count 0) b (fib-iter (+ a b) a (- count 1)))))
;;; M-Eval value:
ok
;;; M-Eval input:
(fib 10)
;;; M-Eval value:
55
;;; M-Eval input:
(define x 100)
;;; M-Eval value:
ok
;;; M-Eval input:
(define x 0)
;;; M-Eval value:
ok
;;; M-Eval input:
(until (loop (lambda () (= x 5))) (set! x (+ x 1)))
;;; M-Eval value:
#t
;;; M-Eval input:
x
;;; M-Eval value:
5
;;; M-Eval input:
(exit)
#+end_src

***** DONE Exercise 4.12 Better abstractions for setting a value
      CLOSED: [2020-02-11 Tue 19:40]

We need to rewrite
 - set-variable-value!
 - define-variable!
 - lookup-variable-value

#+name: s-input-list-of-bindings-better-abstractions
#+begin_example
"hello"
1
#t
#f
(if #t "true" "false")
(if #f "true" "false")
(if '() "true" "false")
'()
'test-symbol
(define a '())
a
(set! a 1)
a
(define b (lambda (x) (display "test-lambda\n")))
(begin "One" (if "" "two" '()) "end begin")
(cond (#f "clause 1") (#f 'clause2) (#t "clause 3") (else "else clause"))
(cond
  (#f "clause 1")
  (#f 'clause2)
  (#f "clause 3")
  (else "else
      clause"))
(and #t #f)
(and #f #f)
(or #t #f)
(or #f #f)
"testing cond with arrow"

(define cadr (lambda (x) (car (cdr x))))

(cond ((assoc 'b '((a 1) (b 2))) => cadr)
   (else false))
"let test1"
(let () "Let1")
"let test2"
(let ((a "Let2")) a)
"let test3"
(let ((a "Let2") (b "Let3")) a (cons a b))
(let* ((a 1) (b (cons a 1))) b)
(define (fib n)
  (let fib-iter ((a 1)
                 (b 0)
                 (count n))
     (if (= count 0)
        b
        (fib-iter (+ a b) a (- count 1)))))
(fib 10)
(define x 100)
(define x 0)
(until (loop (lambda () (= x 5)))
  (set! x (+ x 1)))
x
(exit)
#+end_example


#+name: s-environments-list-of-bindings-better-abstractions
#+begin_src scheme :exports code :results none
     (define (enclosing-environment env) (cdr env))
     (define (first-frame env) (car env))
     (define the-empty-environment '())
     (define make-binding cons)
     (define binding-var car)
     (define binding-val cdr)
     (define (make-frame variables values)
       (cons 'frame-tag (map make-binding variables values)))
     (define (frame-bindings frame) (cdr frame))
     (define (frame-variables frame) (map binding-var (frame-bindings frame)))
     (define (frame-values frame) (map binding-val (frame-bindings frame)))

     (define (extend-environment vars vals base-env)
       (if (= (length vars) (length vals))
           (cons (make-frame vars vals) base-env)
           (if (< (length vars) (length vals))
               (error "Too many arguments supplied" vars vals)
               (error "Too few arguments supplied" vars vals))))
     (define (go-through-bindings bindings var todo-found todo-notfound)
       (define (scan bindings)
           (cond ((null? bindings)
                  (todo-notfound))
                 ((eq? var (caar bindings))
                  (todo-found (car bindings)))
                 (else (scan (cdr bindings)))))
       (scan bindings))
     (define (go-through-environment env var found-action error-message)
         (if (eq? env the-empty-environment)
             (error error-message var)
             (let ((frame (first-frame env)))
               (go-through-bindings
                    (frame-bindings frame)
                    var
                    found-action
                    (lambda () (go-through-environment
                              (enclosing-environment env)
                              var
                              found-action
                              error-message))))))
     (define (lookup-variable-value var env)
       (go-through-environment
            env
            var
            (lambda (x) (cdr x))
            "Unbound variable -- lookup-variable-value"))
     (define (set-variable-value! var val env)
        (go-through-environment
            env
            var
            (lambda (x) (set-cdr! x val))
            "Unbound variable -- SET!"))
     (define (define-variable! var val env)
       (let ((frame (first-frame env)))
         (go-through-bindings
                    (frame-bindings frame)
                    var
                    (lambda (x) (set-cdr! x val))
                    (lambda () (set-cdr! frame
                              (cons
                                 (make-binding var val)
                                 (frame-bindings frame)))))))

#+end_src

#+header: :stdin s-input-list-of-bindings-better-abstractions
#+begin_src shell :shebang "#! /usr/bin/chibi-scheme" :results output scalar code :exports both
<<s-glue1>>
<<s-apply>>
<<put-and-get>>
<<s-data-driven-eval>>
<<s-list-of-values-left-to-right>>
<<s-standard-if>>
<<s-sequences>>
<<s-assignment>>
<<s-define>>
<<s-syntax>>
<<s-application>>
<<s-cond-with-arrow>>
<<s-truefalse>>
<<s-compound-procedures>>
<<s-environments-list-of-bindings-better-abstractions>>
<<s-primitive-procedures>>
<<s-driver-loop>>
<<s-eval-and>>
<<s-let>>
<<s-let-star>>
<<s-let-named>>
<<s-until>>
<<s-glue2>>

(driver-loop)

#+end_src

#+RESULTS[82c535e2591eed569a2a3513d454970b5a266d43]:
#+begin_src shell

;;; M-Eval input:
"hello"
;;; M-Eval value:
"hello"
;;; M-Eval input:
1
;;; M-Eval value:
1
;;; M-Eval input:
#t
;;; M-Eval value:
#t
;;; M-Eval input:
#f
;;; M-Eval value:
#f
;;; M-Eval input:
(if #t "true" "false")
;;; M-Eval value:
"true"
;;; M-Eval input:
(if #f "true" "false")
;;; M-Eval value:
"false"
;;; M-Eval input:
(if (quote ()) "true" "false")
;;; M-Eval value:
"true"
;;; M-Eval input:
(quote ())
;;; M-Eval value:
()
;;; M-Eval input:
(quote test-symbol)
;;; M-Eval value:
test-symbol
;;; M-Eval input:
(define a (quote ()))
;;; M-Eval value:
ok
;;; M-Eval input:
a
;;; M-Eval value:
()
;;; M-Eval input:
(set! a 1)
;;; M-Eval value:
ok
;;; M-Eval input:
a
;;; M-Eval value:
1
;;; M-Eval input:
(define b (lambda (x) (display "test-lambda\n")))
;;; M-Eval value:
ok
;;; M-Eval input:
(begin "One" (if "" "two" (quote ())) "end begin")
;;; M-Eval value:
"end begin"
;;; M-Eval input:
(cond (#f "clause 1") (#f (quote clause2)) (#t "clause 3") (else "else clause"))
;;; M-Eval value:
"clause 3"
;;; M-Eval input:
(cond (#f "clause 1") (#f (quote clause2)) (#f "clause 3") (else "else\n      clause"))
;;; M-Eval value:
"else\n      clause"
;;; M-Eval input:
(and #t #f)
;;; M-Eval value:
#f
;;; M-Eval input:
(and #f #f)
;;; M-Eval value:
#f
;;; M-Eval input:
(or #t #f)
;;; M-Eval value:
#t
;;; M-Eval input:
(or #f #f)
;;; M-Eval value:
#f
;;; M-Eval input:
"testing cond with arrow"
;;; M-Eval value:
"testing cond with arrow"
;;; M-Eval input:
(define cadr (lambda (x) (car (cdr x))))
;;; M-Eval value:
ok
;;; M-Eval input:
(cond ((assoc (quote b) (quote ((a 1) (b 2)))) => cadr) (else false))
;;; M-Eval value:
2
;;; M-Eval input:
"let test1"
;;; M-Eval value:
"let test1"
;;; M-Eval input:
(let () "Let1")
;;; M-Eval value:
"Let1"
;;; M-Eval input:
"let test2"
;;; M-Eval value:
"let test2"
;;; M-Eval input:
(let ((a "Let2")) a)
;;; M-Eval value:
"Let2"
;;; M-Eval input:
"let test3"
;;; M-Eval value:
"let test3"
;;; M-Eval input:
(let ((a "Let2") (b "Let3")) a (cons a b))
;;; M-Eval value:
("Let2" . "Let3")
;;; M-Eval input:
(let* ((a 1) (b (cons a 1))) b)
;;; M-Eval value:
(1 . 1)
;;; M-Eval input:
(define (fib n) (let fib-iter ((a 1) (b 0) (count n)) (if (= count 0) b (fib-iter (+ a b) a (- count 1)))))
;;; M-Eval value:
ok
;;; M-Eval input:
(fib 10)
;;; M-Eval value:
55
;;; M-Eval input:
(define x 100)
;;; M-Eval value:
ok
;;; M-Eval input:
(define x 0)
;;; M-Eval value:
ok
;;; M-Eval input:
(until (loop (lambda () (= x 5))) (set! x (+ x 1)))
;;; M-Eval value:
#t
;;; M-Eval input:
x
;;; M-Eval value:
5
;;; M-Eval input:
(exit)
#+end_src

You can see that in practice we have implemented two abstractions over
the environment data structure: the function to go through all frames,
~go-through-environment~ and the function to go through every binding
in a frame ~go-through-bindings~.

***** DONE Exercise 4.13 Implementing ~make-unbound!~
      CLOSED: [2020-02-12 Wed 08:52]

The problem with ~make-unbound!~ is that there is not common
definition for it. In this case, I think that the most straightforward
approach is to unbind the most recent _one_ binding and err if not
even a single binding exists. This way every call to ~make-unbound!~
will have an effect, but not all bindings will be destroyed.

We will need to make sure that all the previous tests pass in this section.

#+name: s-input-make-unbound
#+begin_example
"hello"
1
#t
#f
(if #t "true" "false")
(if #f "true" "false")
(if '() "true" "false")
'()
'test-symbol
(define a '())
a
(set! a 1)
a
(define b (lambda (x) (display "test-lambda\n")))
(begin "One" (if "" "two" '()) "end begin")
(cond (#f "clause 1") (#f 'clause2) (#t "clause 3") (else "else clause"))
(cond
  (#f "clause 1")
  (#f 'clause2)
  (#f "clause 3")
  (else "else
      clause"))
(and #t #f)
(and #f #f)
(or #t #f)
(or #f #f)
"testing cond with arrow"

(define cadr (lambda (x) (car (cdr x))))

(cond ((assoc 'b '((a 1) (b 2))) => cadr)
   (else false))
"let test1"
(let () "Let1")
"let test2"
(let ((a "Let2")) a)
"let test3"
(let ((a "Let2") (b "Let3")) a (cons a b))
(let* ((a 1) (b (cons a 1))) b)
(define (fib n)
  (let fib-iter ((a 1)
                 (b 0)
                 (count n))
     (if (= count 0)
        b
        (fib-iter (+ a b) a (- count 1)))))
(fib 10)
(define x 100)
(define x 0)
(until (loop (lambda () (= x 5)))
  (set! x (+ x 1)))
x
(make-unbound! x)

(define y 1)
(let ((z 5))
 (make-unbound! y))
y
(exit)
#+end_example

#+name: s-make-unbound
#+begin_src scheme :exports code :results none
    (define (make-unbound-var exp)
      (cadr exp))
    (define (make-unbound! exp env)
      (let ((var (make-unbound-var exp)))
	(define (env-loop env)
	  (define (scan bindings)
	    (cond ((null? (cdr bindings))
		   (env-loop (enclosing-environment env)))
		  ((eq? var (caadr bindings))
		   (set-cdr! bindings (cddr bindings)))
		  (else (scan (cdr bindings)))))
	  (if (eq? env the-empty-environment)
	      (error "make-unbound!:No binding found" var)
	      (let ((frame (first-frame env)))
		(scan frame))))
	(env-loop env))
       'ok)

    (put 'eval 'make-unbound! make-unbound!)

#+end_src


#+header: :stdin s-input-make-unbound
#+begin_src shell :shebang "#! /usr/bin/chibi-scheme" :results output scalar code :exports both
<<s-glue1>>
<<s-apply>>
<<put-and-get>>
<<s-data-driven-eval>>
<<s-list-of-values-left-to-right>>
<<s-standard-if>>
<<s-sequences>>
<<s-assignment>>
<<s-define>>
<<s-syntax>>
<<s-application>>
<<s-cond-with-arrow>>
<<s-truefalse>>
<<s-compound-procedures>>
<<s-environments-list-of-bindings-better-abstractions>>
<<s-primitive-procedures>>
<<s-driver-loop>>
<<s-eval-and>>
<<s-let>>
<<s-let-star>>
<<s-let-named>>
<<s-until>>
<<s-make-unbound>>
<<s-glue2>>

(driver-loop)

#+end_src

#+RESULTS[65d71b487ee15efcd28f26caa9baec0c489d6f1b]:
#+begin_src shell
ERROR: Unbound variable -- lookup-variable-value: y
  called from <anonymous> on line 382 of file /tmp/babel-CuVd5j/sh-script-NgoWuW
  called from driver-loop on line 380 of file /tmp/babel-CuVd5j/sh-script-NgoWuW
  called from <anonymous> on line 1289 of file /usr/lib64/chibi/init-7.scm
  called from <anonymous> on line 280 of file /usr/lib64/chibi/init-7.scm
  called from <anonymous> on line 817 of file /usr/lib64/chibi/init-7.scm

;;; M-Eval input:
"hello"
;;; M-Eval value:
"hello"
;;; M-Eval input:
1
;;; M-Eval value:
1
;;; M-Eval input:
#t
;;; M-Eval value:
#t
;;; M-Eval input:
#f
;;; M-Eval value:
#f
;;; M-Eval input:
(if #t "true" "false")
;;; M-Eval value:
"true"
;;; M-Eval input:
(if #f "true" "false")
;;; M-Eval value:
"false"
;;; M-Eval input:
(if (quote ()) "true" "false")
;;; M-Eval value:
"true"
;;; M-Eval input:
(quote ())
;;; M-Eval value:
()
;;; M-Eval input:
(quote test-symbol)
;;; M-Eval value:
test-symbol
;;; M-Eval input:
(define a (quote ()))
;;; M-Eval value:
ok
;;; M-Eval input:
a
;;; M-Eval value:
()
;;; M-Eval input:
(set! a 1)
;;; M-Eval value:
ok
;;; M-Eval input:
a
;;; M-Eval value:
1
;;; M-Eval input:
(define b (lambda (x) (display "test-lambda\n")))
;;; M-Eval value:
ok
;;; M-Eval input:
(begin "One" (if "" "two" (quote ())) "end begin")
;;; M-Eval value:
"end begin"
;;; M-Eval input:
(cond (#f "clause 1") (#f (quote clause2)) (#t "clause 3") (else "else clause"))
;;; M-Eval value:
"clause 3"
;;; M-Eval input:
(cond (#f "clause 1") (#f (quote clause2)) (#f "clause 3") (else "else\n      clause"))
;;; M-Eval value:
"else\n      clause"
;;; M-Eval input:
(and #t #f)
;;; M-Eval value:
#f
;;; M-Eval input:
(and #f #f)
;;; M-Eval value:
#f
;;; M-Eval input:
(or #t #f)
;;; M-Eval value:
#t
;;; M-Eval input:
(or #f #f)
;;; M-Eval value:
#f
;;; M-Eval input:
"testing cond with arrow"
;;; M-Eval value:
"testing cond with arrow"
;;; M-Eval input:
(define cadr (lambda (x) (car (cdr x))))
;;; M-Eval value:
ok
;;; M-Eval input:
(cond ((assoc (quote b) (quote ((a 1) (b 2)))) => cadr) (else false))
;;; M-Eval value:
2
;;; M-Eval input:
"let test1"
;;; M-Eval value:
"let test1"
;;; M-Eval input:
(let () "Let1")
;;; M-Eval value:
"Let1"
;;; M-Eval input:
"let test2"
;;; M-Eval value:
"let test2"
;;; M-Eval input:
(let ((a "Let2")) a)
;;; M-Eval value:
"Let2"
;;; M-Eval input:
"let test3"
;;; M-Eval value:
"let test3"
;;; M-Eval input:
(let ((a "Let2") (b "Let3")) a (cons a b))
;;; M-Eval value:
("Let2" . "Let3")
;;; M-Eval input:
(let* ((a 1) (b (cons a 1))) b)
;;; M-Eval value:
(1 . 1)
;;; M-Eval input:
(define (fib n) (let fib-iter ((a 1) (b 0) (count n)) (if (= count 0) b (fib-iter (+ a b) a (- count 1)))))
;;; M-Eval value:
ok
;;; M-Eval input:
(fib 10)
;;; M-Eval value:
55
;;; M-Eval input:
(define x 100)
;;; M-Eval value:
ok
;;; M-Eval input:
(define x 0)
;;; M-Eval value:
ok
;;; M-Eval input:
(until (loop (lambda () (= x 5))) (set! x (+ x 1)))
;;; M-Eval value:
#t
;;; M-Eval input:
x
;;; M-Eval value:
5
;;; M-Eval input:
(make-unbound! x)
;;; M-Eval value:
ok
;;; M-Eval input:
(define y 1)
;;; M-Eval value:
ok
;;; M-Eval input:
(let ((z 5)) (make-unbound! y))
;;; M-Eval value:
ok
;;; M-Eval input:
y
#+end_src

Seems to be working fine.


**** 4.1.4 Running the Evaluator as a Program
***** DONE Exercise 4.14 meta map versus built-in map
      CLOSED: [2020-02-12 Wed 08:58]
Things go wrong because the definitions of ~lambda~ differ in the
metacircular scheme and in the underlying scheme. The underlying
scheme's ~map~ expects an underlying procedure as an argument, whereas
the metacircular scheme expects a metacircular procedure. Because the
underlying scheme doesn't know how to evaluate meta-procedures, it
fails. That is, it uses the underlying ~eval~ for evaluation, not our
own ~eval~.
**** Common code for the Evaluator and primitive-procedure

Warning! There are two modifications which I had to make in order to
make the code runnable.

The first one: the code example from SICP section 4.1.4 simply cannot
work, since ~(setup-environment)~ is called "before" the functions
used inside of it are defined. So I have to move those above.

The second one: in the driver loop ~(driver-loop)~, the book assumes that we are typing
in the commands in the interpreter. In the case of this work, org-mode
does it for us, and it doesn't echo the characters, so I added a line
to do it manually.

#+name: s-primitive-procedures
#+begin_src scheme :exports code :results none
     (define primitive-procedures
       (list (list 'car car)
             (list 'cdr cdr)
             (list 'cons cons)
             (list 'cadr cadr)
             (list 'null? null?)
             (list 'exit exit)
             (list 'display display)
             (list 'newline newline)
             (list 'assoc assoc)
             (list '= =)
             (list '< <)
             (list '> >)
             (list '+ +)
             (list '- -)
             (list 'not not)
             (list '* *)
             (list 'current-second current-second)
             (list 'list list)
             (list 'underlying-cons cons)
             (list 'underlying-car car)
             (list 'underlying-cdr cdr)
             (list 'eq? eq?)
             (list 'equal? equal?)
             (list 'pair? pair?)
             (list 'error error)
             (list 'random-integer random-integer)
             (list 'even? even?)
             (list 'remainder remainder)
             (list 'square square)
             (list '/ /)
             (list 'member member)
             (list 'abs abs)
             (list 'cdar cdar)
             (list 'cdadr cdadr)
             (list 'caar caar)
             (list 'caadr caadr)
             (list 'cddr cddr)
             (list 'cdddr cdddr)
             (list 'caddr caddr)
             (list 'cadddr cadddr)
             (list 'set-car! set-car!)
             (list 'set-cdr! set-cdr!)
             (list 'memq memq)
             (list 'read read)
             (list 'show show)
             (list 'pretty pretty)
             (list 'number? number?)
             (list 'string? string?)
             (list 'symbol? symbol?)
             ))

     (define (primitive-procedure-names)
       (map car
            primitive-procedures))
     (define (primitive-procedure-objects)
       (map (lambda (proc) (list 'primitive (cadr proc)))
            primitive-procedures))
     (define (setup-environment)
       (let ((initial-env
              (extend-environment (primitive-procedure-names)
                                  (primitive-procedure-objects)
                                  the-empty-environment)))
         (define-variable! 'true true initial-env)
         (define-variable! 'false false initial-env)
         initial-env))
     #;(define the-global-environment (setup-environment))
     (define (primitive-procedure? proc)
       (tagged-list? proc 'primitive))

     (define (primitive-implementation proc) (cadr proc))

     (define (apply-primitive-procedure proc args)
       (apply-in-underlying-scheme
        (primitive-implementation proc) args))
#+end_src

I added ~(user-print input)~ after the ~let~, because I am writing
this in a "literate style", so input is not entered from the keyboard
(and thus not announced by the input method), so I have to duplicate
it myself.

#+name: s-driver-loop
#+begin_src scheme :exports code :results none
  (define input-prompt ";;; M-Eval input:")
  (define output-prompt ";;; M-Eval value:")
  (define (driver-loop)
    (prompt-for-input input-prompt)
    (let ((input (read)))
      (user-print input)
      (let ((output (eval input the-global-environment)))
	(announce-output output-prompt)
	(user-print output)))
    (driver-loop))
  <<s-user-prompt-print>>
#+end_src

#+name: s-user-prompt-print
#+begin_src scheme :exports code :results none
  (define (prompt-for-input string)
    (newline) #;(newline) (display string) (newline))
  (define (announce-output string)
    (newline) (display string) (newline))
  (define (user-print object)
    (if (compound-procedure? object)
	#;(display (list 'compound-procedure
		       (procedure-parameters object)
		       (procedure-body object)
		       '<procedure-env>))
	#;(display object)
        (show #t (pretty (list 'compound-procedure
		       (procedure-parameters object)
		       (procedure-body object)
		       '<procedure-env>)))
        (show #t (pretty object))))

#+end_src

#+name: s-input-test1
#+begin_example
"test
"
#+end_example

#+header: :stdin s-input-test1
#+begin_src shell :shebang "#! /usr/bin/chibi-scheme" :results output scalar code :exports both
(import (scheme small))
(define a (read))
(display a)
#+end_src

#+RESULTS[8240def1760a9bf3bed3bb84cee44ad684349377]:
#+begin_src shell
test
#+end_src

#+NAME: s-input-test2
#+BEGIN_EXAMPLE
(exit)
#+END_EXAMPLE


#+header: :stdin s-input-test2
#+begin_src shell :shebang "#! /usr/bin/chibi-scheme" :results output scalar code :exports both
(import (scheme small))
(display "Try evaluate\n")
(define a (read))
(eval a)
#+end_src

#+RESULTS[bce45cf1322f5e90766e1acee82bf152ded71c6a]:
#+begin_src shell
Try evaluate
#+end_src

#+name: s-glue1
#+begin_src scheme :exports code :results none
  (import (scheme small))
  (import (srfi 159))
  (import (srfi 27))
  (define apply-in-underlying-scheme apply)
  (define apply 'not-initialized)
#+end_src

#+name: s-glue2
#+begin_src scheme :exports code :results none
(define the-global-environment (setup-environment))
#+end_src

#+NAME: s-input-test3
#+BEGIN_EXAMPLE
(define (append x y)
  (if (null? x)
      y
    (cons (car x) (append (cdr x) y))))
(append '(a b c) '(d e f))
(exit)
#+END_EXAMPLE

#+header: :stdin s-input-test3
#+begin_src shell :shebang "#! /usr/bin/chibi-scheme" :results output scalar code :exports both
<<s-glue1>>
<<s-apply>>
<<s-eval>>
<<s-list-of-values>>
<<s-standard-if>>
<<s-sequences>>
<<s-assignment>>
<<s-define>>
<<s-syntax>>
<<s-application>>
<<s-cond>>
<<s-truefalse>>
<<s-compound-procedures>>
<<s-environments>>
<<s-primitive-procedures>>
<<s-driver-loop>>
<<s-glue2>>

(driver-loop)

#+end_src

#+RESULTS[65b127829184f39733b365f9510d8aee2d22096c]:
#+begin_src shell

;;; M-Eval input:
(define (append x y) (if (null? x) y (cons (car x) (append (cdr x) y))))
;;; M-Eval value:
ok
;;; M-Eval input:
(append (quote (a b c)) (quote (d e f)))
;;; M-Eval value:
(a b c d e f)
;;; M-Eval input:
(exit)
#+end_src

**** 4.1.5 Data as Programs
***** DONE Exercise 4.15 The ~halts?~ predicate
      CLOSED: [2020-02-12 Wed 09:24]
This seems to be a very simple diagonalisation argument.

Clearly, ~(try p)~ itself as a procedure halts on ~p~'s that run
forever, and runs forever on ~p~'s that eventually halt. Now if ~(try
try)~ halts, then the internal ~if~ should run ~(run-forever)~, a
contradiction! And otherwise, if it doesn't halt, that predicate
should return #f and the procedure should return. Also a
contradiction.

This is a very common technique of finding contradictions in problem
definitions.

**** 4.1.6 Internal Definitions
***** DONE Exercise 4.16 Simultaneous internal definitions
      CLOSED: [2020-02-12 Wed 13:17]

For the sake of exercise, I used the ~let-values~ + ~values~
constructions in one of the functions written. This is one of the
features not available during the writing of the SICP.

#+name: s-internal-definitions
#+begin_src scheme :exports code :results none
  (define (lookup-variable-value var env)
    (go-through-environment
     env
     var
     (lambda (x)
       (let ((y (cdr x)))
	 (if (eq? y '*unassigned*)
	     (error "Unassigned" (car x)))
	 y))
     "Unbound variable -- lookup-variable-value"))
  (define (is-define? l)
    (and (list? l) (not (null? l)) (eq? (car l) 'define)))
  (define (no-out-of-order-defines? body non-define-found)
    (cond ((null? body) #t)
	  ((not (list? body)) #t)
	  ((and non-define-found (is-define? (car body))) #f)
	  (else (no-out-of-order-defines? (cdr body)
					  (or non-define-found (not (is-define? (car body))))))))
  (define (split-body body)
    (define (split-loop body d)
      (if (is-define? (car body))
	  (split-loop (cdr body) (cons (car body) d))
	  (values d body)))
    (split-loop body (list)))
  (define (scan-out-defines body)
    (if (not (no-out-of-order-defines? body #f))
	(error "define is only allowed at the beginning of a block" body))
    (let-values (((defines operations) (split-body body)))
      (if (null? defines)
	  body
	  (let ((defines-names (map definition-variable defines))
		(defines-bodies (map definition-value defines)))
	    (let ((let-header (map (lambda (x) (list x ''*unassigned*)) defines-names))
		  (let-body (append
			     (map (lambda (x y) (list 'set! x y)) defines-names defines-bodies)
			     operations)))
	      (list (make-let let-header let-body)))))))

  (define (make-procedure parameters body env)
    (list 'procedure parameters (scan-out-defines body) env))

#+end_src

As far as I understand, adding the "parallel define" transformation
into ~make-procedure~ is better, because it just rewrites the source
once.

#+name: s-input-internal-definitions
#+begin_example
"hello"
1
#t
#f
(if #t "true" "false")
(if #f "true" "false")
(if '() "true" "false")
'()
'test-symbol
(define a '())
a
(set! a 1)
a
(define b (lambda (x) (display "test-lambda\n")))
(begin "One" (if "" "two" '()) "end begin")
(cond (#f "clause 1") (#f 'clause2) (#t "clause 3") (else "else clause"))
(cond
  (#f "clause 1")
  (#f 'clause2)
  (#f "clause 3")
  (else "else
      clause"))
(and #t #f)
(and #f #f)
(or #t #f)
(or #f #f)
"testing cond with arrow"

(define cadr (lambda (x) (car (cdr x))))

(cond ((assoc 'b '((a 1) (b 2))) => cadr)
   (else false))
"let test1"
(let () "Let1")
"let test2"
(let ((a "Let2")) a)
"let test3"
(let ((a "Let2") (b "Let3")) a (cons a b))
(let* ((a 1) (b (cons a 1))) b)
(define (fib n)
  (let fib-iter ((a 1)
                 (b 0)
                 (count n))
     (if (= count 0)
        b
        (fib-iter (+ a b) a (- count 1)))))
(fib 10)
(define x 100)
(define x 0)
(until (loop (lambda () (= x 5)))
  (set! x (+ x 1)))
x
(make-unbound! x)
(define y 1)
(let ((z 5))
(make-unbound! y))
(let ()
  (let ((x 'test))
  'another-let-test))
(define (test1)
  (define (test2)
    (display "test2")
    'ok2)
  (define (test3)
    (display "test3")
    'ok3)
  (test2)
  (test3))
(test1)
(exit)
#+end_example

#+header: :stdin s-input-internal-definitions
#+begin_src shell :shebang "#! /usr/bin/chibi-scheme" :results output scalar code :exports both
<<s-glue1>>
<<s-apply>>
<<put-and-get>>
<<s-data-driven-eval>>
<<s-list-of-values-left-to-right>>
<<s-standard-if>>
<<s-sequences>>
<<s-assignment>>
<<s-define>>
<<s-syntax>>
<<s-application>>
<<s-cond-with-arrow>>
<<s-truefalse>>
<<s-compound-procedures>>
<<s-environments-list-of-bindings-better-abstractions>>
<<s-primitive-procedures>>
<<s-driver-loop>>
<<s-eval-and>>
<<s-let>>
<<s-let-star>>
<<s-let-named>>
<<s-until>>
<<s-make-unbound>>
<<s-internal-definitions>>
<<s-glue2>>

(driver-loop)

#+end_src

#+RESULTS[d54dd2dbf7a1c0855aeef9dcbd7be27253e84bed]:
#+begin_src shell

;;; M-Eval input:
"hello"
;;; M-Eval value:
"hello"
;;; M-Eval input:
1
;;; M-Eval value:
1
;;; M-Eval input:
#t
;;; M-Eval value:
#t
;;; M-Eval input:
#f
;;; M-Eval value:
#f
;;; M-Eval input:
(if #t "true" "false")
;;; M-Eval value:
"true"
;;; M-Eval input:
(if #f "true" "false")
;;; M-Eval value:
"false"
;;; M-Eval input:
(if (quote ()) "true" "false")
;;; M-Eval value:
"true"
;;; M-Eval input:
(quote ())
;;; M-Eval value:
()
;;; M-Eval input:
(quote test-symbol)
;;; M-Eval value:
test-symbol
;;; M-Eval input:
(define a (quote ()))
;;; M-Eval value:
ok
;;; M-Eval input:
a
;;; M-Eval value:
()
;;; M-Eval input:
(set! a 1)
;;; M-Eval value:
ok
;;; M-Eval input:
a
;;; M-Eval value:
1
;;; M-Eval input:
(define b (lambda (x) (display "test-lambda\n")))
;;; M-Eval value:
ok
;;; M-Eval input:
(begin "One" (if "" "two" (quote ())) "end begin")
;;; M-Eval value:
"end begin"
;;; M-Eval input:
(cond (#f "clause 1") (#f (quote clause2)) (#t "clause 3") (else "else clause"))
;;; M-Eval value:
"clause 3"
;;; M-Eval input:
(cond (#f "clause 1") (#f (quote clause2)) (#f "clause 3") (else "else\n      clause"))
;;; M-Eval value:
"else\n      clause"
;;; M-Eval input:
(and #t #f)
;;; M-Eval value:
#f
;;; M-Eval input:
(and #f #f)
;;; M-Eval value:
#f
;;; M-Eval input:
(or #t #f)
;;; M-Eval value:
#t
;;; M-Eval input:
(or #f #f)
;;; M-Eval value:
#f
;;; M-Eval input:
"testing cond with arrow"
;;; M-Eval value:
"testing cond with arrow"
;;; M-Eval input:
(define cadr (lambda (x) (car (cdr x))))
;;; M-Eval value:
ok
;;; M-Eval input:
(cond ((assoc (quote b) (quote ((a 1) (b 2)))) => cadr) (else false))
;;; M-Eval value:
2
;;; M-Eval input:
"let test1"
;;; M-Eval value:
"let test1"
;;; M-Eval input:
(let () "Let1")
;;; M-Eval value:
"Let1"
;;; M-Eval input:
"let test2"
;;; M-Eval value:
"let test2"
;;; M-Eval input:
(let ((a "Let2")) a)
;;; M-Eval value:
"Let2"
;;; M-Eval input:
"let test3"
;;; M-Eval value:
"let test3"
;;; M-Eval input:
(let ((a "Let2") (b "Let3")) a (cons a b))
;;; M-Eval value:
("Let2" . "Let3")
;;; M-Eval input:
(let* ((a 1) (b (cons a 1))) b)
;;; M-Eval value:
(1 . 1)
;;; M-Eval input:
(define (fib n) (let fib-iter ((a 1) (b 0) (count n)) (if (= count 0) b (fib-iter (+ a b) a (- count 1)))))
;;; M-Eval value:
ok
;;; M-Eval input:
(fib 10)
;;; M-Eval value:
55
;;; M-Eval input:
(define x 100)
;;; M-Eval value:
ok
;;; M-Eval input:
(define x 0)
;;; M-Eval value:
ok
;;; M-Eval input:
(until (loop (lambda () (= x 5))) (set! x (+ x 1)))
;;; M-Eval value:
#t
;;; M-Eval input:
x
;;; M-Eval value:
5
;;; M-Eval input:
(make-unbound! x)
;;; M-Eval value:
ok
;;; M-Eval input:
(define y 1)
;;; M-Eval value:
ok
;;; M-Eval input:
(let ((z 5)) (make-unbound! y))
;;; M-Eval value:
ok
;;; M-Eval input:
(let () (let ((x (quote test))) (quote another-let-test)))
;;; M-Eval value:
another-let-test
;;; M-Eval input:
(define (test1) (define (test2) (display "test2") (quote ok2)) (define (test3) (display "test3") (quote ok3)) (test2) (test3))
;;; M-Eval value:
ok
;;; M-Eval input:
(test1)test2test3
;;; M-Eval value:
ok3
;;; M-Eval input:
(exit)
#+end_src

Seems to be working. Note that we need to wrap the result of
~scan-out-defines~ into a list. (But I don't remember why.)

***** DONE Exercise 4.17 Environment with simultaneous definitions
      CLOSED: [2020-02-12 Wed 14:09]

Without scanning, the bindings are created in the same frame as <vars>.

#+name: exercise-4-17-noscan
#+header: :imagemagick yes :iminoptions -density 300 :imoutoptions -geometry 1000
#+header: :fit yes :headers '("\\usepackage{tikz} \\usetikzlibrary{positioning,fit,petri,arrows,calc,matrix,quotes}")
#+header: :buffer on
#+begin_src latex :results raw file :exports both :file exercise-4-17-1.png
\begin{tikzpicture}[inner sep=0mm,>=stealth',very thick,color=blue!99,
       every node/.style={font=\sffamily,align=left},
       font=\sffamily,pics/two dots/.style={code={
       \node [draw,minimum size=5mm,circle,colored tokens={blue!99}]
       (#1-left) {};
      \node [draw,minimum size=5mm,circle,colored tokens={blue!99},
      right=0pt of #1-left]
	  (#1-right) {};
      \node [rectangle, fit=(#1-left) (#1-right)] (#1){};
      }},
      every pin edge/.style={<-,very thick},
      box/.style={draw,rectangle,inner sep=#1},box/.default=2mm,
      envi/.style={matrix of nodes, align=left,
                  every node/.style={anchor=west},
                  inner sep={0.7mm},
                  execute at end cell={\vphantom{()}},
                  draw},
      node distance=4mm]

    \node (a-global)  {a:};
    \node (fake1) [right=50mm of a-global] {};
    \node (g-env) [box, fit=(a-global) (fake1),
    pin={[text width=1cm,pin distance=10mm]left:global env}]
    { };
     \path ($ (g-env.south west)!0.7!(g-env.south east) $) coordinate (fake1)
      coordinate[below=1cm of fake1] (fake) (fake) pic{two dots=a}
      (a) edge[<-,to path={|- (\tikztotarget)}] (a-global.east)
      (a-right.center) edge[->] (fake1 -| a-right.center);

     \path ($ (g-env.south west)!0.2!(g-env.south east) $) node(fake) {};
     \matrix (a) [envi,
                  below=of fake]
     {
       vars: <...>\\
       u: <e1> \\
       v: <e2> \\
     } edge[->] (fake);


\end{tikzpicture}
#+end_src

#+RESULTS[410dc9ad8e24daa633c523f20fc597eec754bc67]: exercise-4-17-noscan
[[file:exercise-4-17-1.png]]


Since scanning expands ~define~'s into a let, and ~let~ expands to a
~lambda~ call, there should be one more frame.

#+name: exercise-4-17-scan
#+header: :imagemagick yes :iminoptions -density 300 :imoutoptions -geometry 1000
#+header: :fit yes :headers '("\\usepackage{tikz} \\usetikzlibrary{positioning,fit,petri,arrows,calc,matrix,quotes}")
#+header: :buffer on
#+begin_src latex :results raw file :exports both :file exercise-4-17-2.png
\begin{tikzpicture}[inner sep=0mm,>=stealth',very thick,color=blue!99,
       every node/.style={font=\sffamily,align=left},
       font=\sffamily,pics/two dots/.style={code={
       \node [draw,minimum size=5mm,circle,colored tokens={blue!99}]
       (#1-left) {};
      \node [draw,minimum size=5mm,circle,colored tokens={blue!99},
      right=0pt of #1-left]
	  (#1-right) {};
      \node [rectangle, fit=(#1-left) (#1-right)] (#1){};
      }},
      every pin edge/.style={<-,very thick},
      box/.style={draw,rectangle,inner sep=#1},box/.default=2mm,
      envi/.style={matrix of nodes, align=left,
                  every node/.style={anchor=west},
                  inner sep={0.7mm},
                  execute at end cell={\vphantom{()}},
                  draw},
      node distance=4mm]

    \node (a-global)  {a:};
    \node (fake1) [right=50mm of a-global] {};
    \node (g-env) [box, fit=(a-global) (fake1),
    pin={[text width=1cm,pin distance=10mm]left:global env}]
    { };
     \path ($ (g-env.south west)!0.7!(g-env.south east) $) coordinate (fake1)
      coordinate[below=1cm of fake1] (fake) (fake) pic{two dots=a}
      (a) edge[<-,to path={|- (\tikztotarget)}] (a-global.east)
      (a-right.center) edge[->] (fake1 -| a-right.center);

     \path ($ (g-env.south west)!0.3!(g-env.south east) $) node(fake) {};
     \matrix (frame1) [envi,
                  below=of fake]
     {
       vars: <...>\\
     } edge[->] (fake);

     \matrix (frame2) [envi,
                  below=of frame1]
     {
       u: <e1> \\
       v: <e2> \\
     } edge[->] (frame1);


\end{tikzpicture}
#+end_src

#+RESULTS[f390a812cf0a9a255f2c8446cd1e7408a80f9203]: exercise-4-17-scan
[[file:exercise-4-17-2.png]]

This additional frame shouldn't make a difference because... well, the only
case when a difference can appear is when a the variables in the two frames
somehow collide. But since a "compliant" program has all the defines in the
beginning of a block, and since there are no operations local to the upper
frame (that is the scanning trick moves all the body of the original
procedure one frame down), adding a frame is exactly the same thing as just
adding two more bindings into the old frame.

If we evaluate ~define~'s sequentially and all ~define~'s are at the top of
a block, we can make a special case in analysing lambda expressions. That is,
since we know that all non-top-level defines will be at the top of a block,
we can extract them while evaluating a lambda expression, and add them to the
frame in advance.

***** DONE Exercise 4.18 Alternative scanning
      CLOSED: [2020-02-12 Wed 14:35]

Let us write down the rewritten code explicitly.

The text case:
#+begin_src scheme :exports code :results none
(lambda (f y0 dt)
  (let ((y '*unassigned*) (dy '*unassigned*))
    (set! y (integral (delay dy) y0 dt))
    (set! dy (stream-map f y))
    y))
#+end_src

The exercise case:
#+begin_src scheme :exports code :results none
(lambda (f y0 dt)
  (let ((y '*unassigned*) (dy '*unassigned*))
    (let ((a (integral (delay dy) y0 dt)) (b (stream-map f y)))
     (set! y a)
     (set! dy b))
    y))
#+end_src

Well, it seems to me that there is a problem in the second case. That is,
when ~stream-map~ is applied, ~y~ has a value of ~'*unassigned*~. And even
though it is changed later, ~stream-map~ already got the wrong value.

This doesn't happen in the first (text) rewriting case, because then y is
initialised to a correct value before ~stream-map~ is executed.

***** DONE Exercise 4.19 Mutual simultaneous definitions
      CLOSED: [2020-02-12 Wed 19:52]

Let's first check what the scheme used for this document does.

#+begin_src scheme :exports both :results output scalar code
  (let ((a 1))
    (define (f x)
      (define b (+ a x))
      (define a 5)
      (+ a b))
    (f 10))
#+end_src

#+RESULTS[c1d34683d09485a06ed7de92355d5e19f931818c]:
#+begin_src scheme

Output (exception): {Exception #19 type "invalid type, expected Number" (#<undef>) #<procedure f> (#f . 4)} 
Stack trace:
  called from <anonymous> on line 817 of file /usr/lib64/chibi/init-7.scm
  called from <anonymous> on line 280 of file /usr/lib64/chibi/init-7.scm
  called from <anonymous> on line 1206 of file /usr/lib64/chibi/init-7.scm
  called from <anonymous> on line 817 of file /usr/lib64/chibi/init-7.scm
  called from f on line 4
  called from <anonymous> on line 817 of file /usr/lib64/chibi/init-7.scm
  called from call-with-current-continuation on line 844 of file /usr/lib64/chibi/init-7.scm
  called from <anonymous> on line 817 of file /usr/lib64/chibi/init-7.scm
  called from <anonymous> on line 280 of file /usr/lib64/chibi/init-7.scm
  called from <anonymous> on line 280 of file /usr/lib64/chibi/init-7.scm
  called from <anonymous> on line 817 of file /usr/lib64/chibi/init-7.scm
  called from call-with-current-continuation on line 844 of file /usr/lib64/chibi/init-7.scm
  called from geiser:eval on line 25 of file /usr/lib64/chibi/scheme/misc-macros.scm
#+end_src

So in this example we see that the scheme behaves the way MIT scheme behaves.

I think that what Ben is proposing is in no way worse than what the other
parties are proposing, as in general "simultaneity" is a wrong concept in
this world, and we should not pretend that it exists.

The concerns raised in this section would make more sense had we had early
binding. But this is not the case. Ben's case is intuitive and thus should be
supported.

Regarding the method which which Eva's approach can be implemented, there may
be used a rather brute force method. Try running all of the definitions under
an exception handler, sieving out the ones which success. Repeat until you
have not defines left, or until the set of defines stops decreasing.

***** DONE Exercise 4.20 letrec
      CLOSED: [2020-02-13 Thu 00:49]
****** a Implementation

#+name: s-letrec
#+begin_src scheme :exports code :results none
  (define (letrec-bindings exp)
    (cadr exp))
  (define (letrec-names exp)
    (map car (letrec-bindings exp)))
  (define (letrec-bodies exp)
    (map cadr (letrec-bindings exp)))
  (define (letrec-operations exp)
    (cddr exp))
  (define (letrec->let exp)
    (let ((let-header (map (lambda (x) (list x ''*unassigned*)) (letrec-names exp)))
	  (let-body (append
		     (map (lambda (x y) (list 'set! x y))
			  (letrec-names exp) (letrec-bodies exp))
		     (letrec-operations exp))))
      (make-let let-header let-body)))

  (put 'eval 'letrec (lambda (exp env) (eval (letrec->let exp) env)))
#+end_src

#+name: s-input-letrec
#+begin_example
"hello"
1
#t
#f
(if #t "true" "false")
(if #f "true" "false")
(if '() "true" "false")
'()
'test-symbol
(define a '())
a
(set! a 1)
a
(define b (lambda (x) (display "test-lambda\n")))
(begin "One" (if "" "two" '()) "end begin")
(cond (#f "clause 1") (#f 'clause2) (#t "clause 3") (else "else clause"))
(cond
  (#f "clause 1")
  (#f 'clause2)
  (#f "clause 3")
  (else "else
      clause"))
(and #t #f)
(and #f #f)
(or #t #f)
(or #f #f)
"testing cond with arrow"

(define cadr (lambda (x) (car (cdr x))))

(cond ((assoc 'b '((a 1) (b 2))) => cadr)
   (else false))
"let test1"
(let () "Let1")
"let test2"
(let ((a "Let2")) a)
"let test3"
(let ((a "Let2") (b "Let3")) a (cons a b))
(let* ((a 1) (b (cons a 1))) b)
(define (fib n)
  (let fib-iter ((a 1)
                 (b 0)
                 (count n))
     (if (= count 0)
        b
        (fib-iter (+ a b) a (- count 1)))))
(fib 10)
(define x 100)
(define x 0)
(until (loop (lambda () (= x 5)))
  (set! x (+ x 1)))
x
(make-unbound! x)
(define y 1)
(let ((z 5))
(make-unbound! y))
(let ()
  (let ((x 'test))
  'another-let-test))
(define (test1)
  (define (test2)
    (display "test2")
    'ok2)
  (define (test3)
    (display "test3")
    'ok3)
  (test2)
  (test3))
(test1)
(letrec
    ((fact (lambda (n)
            (if (= n 1) 1 (* n (fact (- n 1)))))))
  (fact 10))
(exit)
#+end_example

#+header: :stdin s-input-letrec
#+begin_src shell :shebang "#! /usr/bin/chibi-scheme" :results output scalar code :exports both
<<s-glue1>>
<<s-apply>>
<<put-and-get>>
<<s-data-driven-eval>>
<<s-list-of-values-left-to-right>>
<<s-standard-if>>
<<s-sequences>>
<<s-assignment>>
<<s-define>>
<<s-syntax>>
<<s-application>>
<<s-cond-with-arrow>>
<<s-truefalse>>
<<s-compound-procedures>>
<<s-environments-list-of-bindings-better-abstractions>>
<<s-primitive-procedures>>
<<s-driver-loop>>
<<s-eval-and>>
<<s-let>>
<<s-let-star>>
<<s-let-named>>
<<s-until>>
<<s-make-unbound>>
<<s-internal-definitions>>
<<s-letrec>>
<<s-glue2>>

(driver-loop)

#+end_src

#+RESULTS[1893cbd84eeef47a01e3496f668998fc237c70c5]:
#+begin_src shell

;;; M-Eval input:
"hello"
;;; M-Eval value:
"hello"
;;; M-Eval input:
1
;;; M-Eval value:
1
;;; M-Eval input:
#t
;;; M-Eval value:
#t
;;; M-Eval input:
#f
;;; M-Eval value:
#f
;;; M-Eval input:
(if #t "true" "false")
;;; M-Eval value:
"true"
;;; M-Eval input:
(if #f "true" "false")
;;; M-Eval value:
"false"
;;; M-Eval input:
(if (quote ()) "true" "false")
;;; M-Eval value:
"true"
;;; M-Eval input:
(quote ())
;;; M-Eval value:
()
;;; M-Eval input:
(quote test-symbol)
;;; M-Eval value:
test-symbol
;;; M-Eval input:
(define a (quote ()))
;;; M-Eval value:
ok
;;; M-Eval input:
a
;;; M-Eval value:
()
;;; M-Eval input:
(set! a 1)
;;; M-Eval value:
ok
;;; M-Eval input:
a
;;; M-Eval value:
1
;;; M-Eval input:
(define b (lambda (x) (display "test-lambda\n")))
;;; M-Eval value:
ok
;;; M-Eval input:
(begin "One" (if "" "two" (quote ())) "end begin")
;;; M-Eval value:
"end begin"
;;; M-Eval input:
(cond (#f "clause 1") (#f (quote clause2)) (#t "clause 3") (else "else clause"))
;;; M-Eval value:
"clause 3"
;;; M-Eval input:
(cond (#f "clause 1") (#f (quote clause2)) (#f "clause 3") (else "else\n      clause"))
;;; M-Eval value:
"else\n      clause"
;;; M-Eval input:
(and #t #f)
;;; M-Eval value:
#f
;;; M-Eval input:
(and #f #f)
;;; M-Eval value:
#f
;;; M-Eval input:
(or #t #f)
;;; M-Eval value:
#t
;;; M-Eval input:
(or #f #f)
;;; M-Eval value:
#f
;;; M-Eval input:
"testing cond with arrow"
;;; M-Eval value:
"testing cond with arrow"
;;; M-Eval input:
(define cadr (lambda (x) (car (cdr x))))
;;; M-Eval value:
ok
;;; M-Eval input:
(cond ((assoc (quote b) (quote ((a 1) (b 2)))) => cadr) (else false))
;;; M-Eval value:
2
;;; M-Eval input:
"let test1"
;;; M-Eval value:
"let test1"
;;; M-Eval input:
(let () "Let1")
;;; M-Eval value:
"Let1"
;;; M-Eval input:
"let test2"
;;; M-Eval value:
"let test2"
;;; M-Eval input:
(let ((a "Let2")) a)
;;; M-Eval value:
"Let2"
;;; M-Eval input:
"let test3"
;;; M-Eval value:
"let test3"
;;; M-Eval input:
(let ((a "Let2") (b "Let3")) a (cons a b))
;;; M-Eval value:
("Let2" . "Let3")
;;; M-Eval input:
(let* ((a 1) (b (cons a 1))) b)
;;; M-Eval value:
(1 . 1)
;;; M-Eval input:
(define (fib n) (let fib-iter ((a 1) (b 0) (count n)) (if (= count 0) b (fib-iter (+ a b) a (- count 1)))))
;;; M-Eval value:
ok
;;; M-Eval input:
(fib 10)
;;; M-Eval value:
55
;;; M-Eval input:
(define x 100)
;;; M-Eval value:
ok
;;; M-Eval input:
(define x 0)
;;; M-Eval value:
ok
;;; M-Eval input:
(until (loop (lambda () (= x 5))) (set! x (+ x 1)))
;;; M-Eval value:
#t
;;; M-Eval input:
x
;;; M-Eval value:
5
;;; M-Eval input:
(make-unbound! x)
;;; M-Eval value:
ok
;;; M-Eval input:
(define y 1)
;;; M-Eval value:
ok
;;; M-Eval input:
(let ((z 5)) (make-unbound! y))
;;; M-Eval value:
ok
;;; M-Eval input:
(let () (let ((x (quote test))) (quote another-let-test)))
;;; M-Eval value:
another-let-test
;;; M-Eval input:
(define (test1) (define (test2) (display "test2") (quote ok2)) (define (test3) (display "test3") (quote ok3)) (test2) (test3))
;;; M-Eval value:
ok
;;; M-Eval input:
(test1)test2test3
;;; M-Eval value:
ok3
;;; M-Eval input:
(letrec ((fact (lambda (n) (if (= n 1) 1 (* n (fact (- n 1))))))) (fact 10))
;;; M-Eval value:
3628800
;;; M-Eval input:
(exit)
#+end_src


****** b Environment

#+begin_src scheme :exports both :results output scalar code
  (define (f x)
    (let ((even?
	      (lambda (n)
		(if (= n 0)
		    #t
		    (odd? (- n 1)))))
	     (odd?
	      (lambda (n)
		(if (= n 0)
		    #f
		    (even? (- n 1))))))
      (odd? x)))
  (display (f 5))
#+end_src

#+RESULTS[0c0fd224cffa4a1f02b6a2a0bba844325713f41a]:
#+begin_src scheme
#t
#+end_src

This actually shouldn't be working. Perhaps, it works because ~let~ in the
underlying scheme is not implemented as straightforwardly as we did.

#+name: exercise-4-20-letrec
#+header: :imagemagick yes :iminoptions -density 300 :imoutoptions -geometry 1000
#+header: :fit yes :headers '("\\usepackage{tikz} \\usetikzlibrary{positioning,fit,petri,arrows,calc,matrix,quotes}")
#+header: :buffer on
#+begin_src latex :results raw file :exports both :file exercise-4-20-letrec.png
\begin{tikzpicture}[inner sep=0mm,>=stealth',very thick,color=blue!99,
       every node/.style={font=\sffamily,align=left},
       font=\sffamily,pics/two dots/.style={code={
       \node [draw,minimum size=5mm,circle,colored tokens={blue!99}]
       (#1-left) {};
      \node [draw,minimum size=5mm,circle,colored tokens={blue!99},
      right=0pt of #1-left]
	  (#1-right) {};
      \node [rectangle, fit=(#1-left) (#1-right)] (#1){};
      }},
      every pin edge/.style={<-,very thick},
      box/.style={draw,rectangle,inner sep=#1},box/.default=2mm,
      envi/.style={matrix of nodes, align=left,
                  every node/.style={anchor=west},
                  inner sep={0.7mm},
                  execute at end cell={\vphantom{()}},
                  draw},
      node distance=4mm]

    \node (f-global)  {f:};
    \node (fake1) [right=150mm of f-global] {};
    \node (g-env) [box, fit=(f-global) (fake1),
    pin={[text width=1cm,pin distance=10mm]left:global env}]
    { };
     \path ($ (g-env.south west)!0.1!(g-env.south east) $) coordinate (fake1)
      coordinate[below=1cm of fake1] (fake) (fake) pic{two dots=f}
      (f) edge[<-,to path={|- (\tikztotarget)}] (f-global.east)
      (f-right.center) edge[->] (fake1 -| f-right.center);

     \node[below=1 cm of f-left]
       {
        ((lambda (even? odd?) \\
   (set! even? (lambda (n) ...)\\
   (set! odd? (lambda (n) ...) \\
   (even? x))                  \\
 *unassigned* *unassigned*)\\  } edge [<-] (f-left.center);


     \path ($ (g-env.south west)!0.7!(g-env.south east) $) node(fake) {};
     \matrix (call-to-f) [envi,
                  below=of fake, minimum width=50mm]
     {
       |(even-c)| even?: \\
       |(odd-c)| odd?: \\
     } edge[->] (fake);

     \path ($ (call-to-f.south west)!0.1!(call-to-f.south east) $) coordinate (fake1)
      coordinate[below=1cm of fake1] (fake) (fake) pic{two dots=even}
      (even) edge[<-,to path={|- ($ (\tikztotarget) + (0,2mm) $)} -| (\tikztotarget)]
                          ($ (even-c.center) + (5mm,0) $)
      (even-right.center) edge[->] (fake1 -| even-right.center);

     \path ($ (call-to-f.south west)!0.7!(call-to-f.south east) $) coordinate (fake1)
      coordinate[below=1cm of fake1] (fake) (fake) pic{two dots=odd}
      (odd) edge[<-,to path={|- ($ (\tikztotarget) $)} -| (\tikztotarget)]
                          ($ (odd-c.center) + (5mm,0) $)
      (odd-right.center) edge[->] (fake1 -| odd-right.center);


\end{tikzpicture}
#+end_src

#+RESULTS[1d1c1bf46670f7c206884252f091c729761d1fe4]: exercise-4-20-letrec
[[file:exercise-4-20-letrec.png]]


#+name: exercise-4-20-let
#+header: :imagemagick yes :iminoptions -density 300 :imoutoptions -geometry 1000
#+header: :fit yes :headers '("\\usepackage{tikz} \\usetikzlibrary{positioning,fit,petri,arrows,calc,matrix,quotes}")
#+header: :buffer on
#+begin_src latex :results raw file :exports both :file exercise-4-20-let.png
\begin{tikzpicture}[inner sep=0mm,>=stealth',very thick,color=blue!99,
       every node/.style={font=\sffamily,align=left},
       font=\sffamily,pics/two dots/.style={code={
       \node [draw,minimum size=5mm,circle,colored tokens={blue!99}]
       (#1-left) {};
      \node [draw,minimum size=5mm,circle,colored tokens={blue!99},
      right=0pt of #1-left]
	  (#1-right) {};
      \node [rectangle, fit=(#1-left) (#1-right)] (#1){};
      }},
      every pin edge/.style={<-,very thick},
      box/.style={draw,rectangle,inner sep=#1},box/.default=2mm,
      envi/.style={matrix of nodes, align=left,
                  every node/.style={anchor=west},
                  inner sep={0.7mm},
                  execute at end cell={\vphantom{()}},
                  draw},
      node distance=4mm]

    \node (f-global)  {f:};
    \node (fake1) [right=150mm of f-global] {};
    \node (g-env) [box, fit=(f-global) (fake1),
    pin={[text width=1cm,pin distance=10mm]left:global env}]{ };

     \path ($ (g-env.south west)!0.1!(g-env.south east) $) coordinate (fake1)
      coordinate[below=1cm of fake1] (fake) (fake) pic{two dots=f}
      (f) edge[<-,to path={|- (\tikztotarget)}] (f-global.east)
      (f-right.center) edge[->] (fake1 -| f-right.center);

     \node[below=1 cm of f-left]
       {
        parameter: x \\
         ((lambda (even? odd?)\\
            (even? x))        \\
          (lambda (n) (if (equal? n ...))\\
          (lambda (n) (if (equal? n ...)))\\
       } edge [<-] (f-left.center);
     \path ($ (g-env.south west)!0.7!(g-env.south east) $) node(fake) {};
     \matrix (call-to-f) [envi,
                  below=of fake, minimum width=50mm,
                      pin={[text width=1cm,pin distance=10mm]left:E1}]
     {
       x: 5 \\
     } edge[->] (fake);


     \path ($ (call-to-f.south west)!0.5!(call-to-f.south east) $) node(fake) {};
     \matrix (call-to-let) [envi,
                  below=of fake, minimum width=50mm]
     {
       |(even-c)| even?: \\
       |(odd-c)| odd?: \\
     } edge[->] (fake);

     \path ($ (call-to-let.south west)!0.1!(call-to-let.south east) $) coordinate (fake1)
      coordinate[below=1cm of fake1] (fake) (fake) pic{two dots=even}
      (even) edge[<-,to path={|- ($ (\tikztotarget) + (0,2mm) $)} -| (\tikztotarget)]
                          ($ (even-c.center) + (5mm,0) $)
      (even-right.center) edge[->] (call-to-f.south -| even-right.center);

     \path ($ (call-to-let.south west)!0.7!(call-to-let.south east) $) coordinate (fake1)
      coordinate[below=1cm of fake1] (fake) (fake) pic{two dots=odd}
      (odd) edge[<-,to path={|- ($ (\tikztotarget) $)} -| (\tikztotarget)]
                          ($ (odd-c.center) + (5mm,0) $)
      (odd-right.center) edge[->] (call-to-f.south -| odd-right.center);

\end{tikzpicture}
#+end_src

#+RESULTS[6f0e73a47c4c29bf1a2bbf9b1035187cd8e50e31]: exercise-4-20-let
[[file:exercise-4-20-let.png]]

~even?~ and ~odd?~ are created outside of the let's lambda expression, and
that is why they cannot access each other's bindings.

***** DONE Exercise 4.21 Y-combinator
      CLOSED: [2020-02-13 Thu 01:07]
****** a Evaluating the Y combinator

#+begin_src scheme :exports both :results value scalar code
  ((lambda (n)
     ((lambda (fact) (fact fact n))
      (lambda (ft k) (if (= k 1) 1 (* k (ft ft (- k 1)))))))
   10)
#+end_src

#+RESULTS[c166d51829357dd1c9381a0db2902da6045d3526]:
#+begin_src scheme
3628800
#+end_src

Seems to be working indeed.

****** b Implementing ~even?~ and ~odd?~

#+begin_src scheme :exports both :results value scalar code
(define true #t)
(define false #f)
  (define (f x)
    ((lambda (even? odd?) (even? even? odd? x))
     (lambda (ev? od? n)
       (if (= n 0) true (od? ev? od? (- n 1))))
     (lambda (ev? od? n)
       (if (= n 0) false (ev? ev? od? (- n 1))))))
  (f 6)
#+end_src

#+RESULTS[867a7180c1c5356758922bca2484201ff32133ef]:
#+begin_src scheme
#t
#+end_src

This task is very easy. Since we don't have the actual frame to put our
bindings, we need to throw them down with every call.

**** 4.1.7 Separating Syntactic Analysis from Execution
***** Common analysis code

#+name: s-analyze-eval
#+begin_src scheme :exports code :results none
  (define (eval exp env) ((analyze exp) env))
  (define (analyze exp)
    (cond ((self-evaluating? exp) (analyze-self-evaluating exp))
	  ((quoted? exp) (analyze-quoted exp))
	  ((variable? exp) (analyze-variable exp))
	  ((assignment? exp) (analyze-assignment exp))
	  ((definition? exp) (analyze-definition exp))
	  ((if? exp) (analyze-if exp))
	  ((lambda? exp) (analyze-lambda exp))
	  ((begin? exp) (analyze-sequence (begin-actions exp)))
	  ((cond? exp) (analyze (cond->if exp)))
	  ((application? exp) (analyze-application exp))
	  (else (error "Unknown expression type: ANALYZE" exp))))

#+end_src

#+name: s-analyze-expressions
#+begin_src scheme :exports code :results none
  (define (analyze-self-evaluating exp)
    (lambda (env) exp))
  (define (analyze-quoted exp)
    (let ((qval (text-of-quotation exp)))
      (lambda (env) qval)))
  (define (analyze-variable exp)
    (lambda (env) (lookup-variable-value exp env)))
  (define (analyze-assignment exp)
    (let ((var (assignment-variable exp))
	  (vproc (analyze (assignment-value exp))))
      (lambda (env)
	(set-variable-value! var (vproc env) env)
	'ok)))
  (define (analyze-definition exp)
    (let ((var (definition-variable exp))
	  (vproc (analyze (definition-value exp))))
      (lambda (env)
	(define-variable! var (vproc env) env)
	'ok)))
  (define (analyze-if exp)
    (let ((pproc (analyze (if-predicate exp)))
	  (cproc (analyze (if-consequent exp)))
	  (aproc (analyze (if-alternative exp))))
      (lambda (env) (if (true? (pproc env))
		   (cproc env)
		   (aproc env)))))
  (define (analyze-lambda exp)
    (let ((vars (lambda-parameters exp))
	  (bproc (analyze-sequence (lambda-body exp))))
      (lambda (env) (make-procedure vars bproc env))))
#+end_src

*NOTE* The following two blocks use ~(map analyze exps)~ as a sequencing
operation, thus the "new" interpreter doesn't need a ~list-of-values~
function. However, it may be an interesting exercise to implement a
right-to-left analysis of the arguments.

#+name: s-analyze-sequence
#+begin_src scheme :exports code :results none
  (define (analyze-sequence exps)
    (define (sequentially proc1 proc2)
      (lambda (env) (proc1 env) (proc2 env)))
    (define (loop first-proc rest-procs)
      (if (null? rest-procs)
	  first-proc
	  (loop (sequentially first-proc (car rest-procs))
		(cdr rest-procs))))
    (let ((procs (map analyze exps)))
      (if (null? procs) (error "Empty sequence: ANALYZE"))
      (loop (car procs) (cdr procs))))
#+end_src

#+name: s-analyze-execute
#+begin_src scheme :exports code :results none
  (define (analyze-application exp)
    (let ((fproc (analyze (operator exp)))
	  (aprocs (map analyze (operands exp))))
      (lambda (env)
	(execute-application
	 (fproc env)
	 (map (lambda (aproc) (aproc env))
	      aprocs)))))
  (define (execute-application proc args)
    (cond ((primitive-procedure? proc)
	   (apply-primitive-procedure proc args))
	  ((compound-procedure? proc)
	   ((procedure-body proc)
	    (extend-environment
	     (procedure-parameters proc)
	     args
	     (procedure-environment proc))))
	  (else
	   (error "Unknown procedure type: EXECUTE-APPLICATION"
		  proc))))
#+end_src

From these three pieces we need to assemble a working interpreter.

#+name: s-input-analyze
#+begin_example
"hello"
1
#t
#f
(if #t "true" "false")
(if #f "true" "false")
(if '() "true" "false")
'()
'test-symbol
(define a '())
a
(set! a 1)
a
(define b (lambda (x) (display "test-lambda\n")))
(begin "One" (if "" "two" '()) "end begin")
(cond (#f "clause 1") (#f 'clause2) (#t "clause 3") (else "else clause"))
(cond
  (#f "clause 1")
  (#f 'clause2)
  (#f "clause 3")
  (else "else
      clause"))
(and #t #f)
(and #f #f)
(or #t #f)
(or #f #f)
"testing cond with arrow"

(define cadr (lambda (x) (car (cdr x))))

(cond ((assoc 'b '((a 1) (b 2))) => cadr)
   (else false))
"let test1"
(let () "Let1")
"let test2"
(let ((a "Let2")) a)
"let test3"
(let ((a "Let2") (b "Let3")) a (cons a b))
(let* ((a 1) (b (cons a 1))) b)
(define (fib n)
  (let fib-iter ((a 1)
                 (b 0)
                 (count n))
     (if (= count 0)
        b
        (fib-iter (+ a b) a (- count 1)))))
(fib 10)
(define x 100)
(define x 0)
(until (loop (lambda () (= x 5)))
  (set! x (+ x 1)))
x
(make-unbound! x)
(define y 1)
(let ((z 5))
(make-unbound! y))
(let ()
  (let ((x 'test))
  'another-let-test))
(define (test1)
  (define (test2)
    (display "test2")
    'ok2)
  (define (test3)
    (display "test3")
    'ok3)
  (test2)
  (test3))
(test1)
(letrec
    ((fact (lambda (n)
            (if (= n 1) 1 (* n (fact (- n 1)))))))
  (fact 10))
(exit)
#+end_example


#+header: :stdin s-input-analyze
#+begin_src shell :shebang "#! /usr/bin/chibi-scheme" :results output scalar code :exports both
<<s-glue1>>
<<s-list-of-values-left-to-right>>
<<s-analyze-eval>>
<<s-analyze-expressions>>
<<s-analyze-sequence>>
<<s-analyze-execute>>
<<s-syntax>>
<<s-application>>
<<s-cond-with-arrow>>
<<s-truefalse>>
<<s-compound-procedures>>
<<s-environments-list-of-bindings-better-abstractions>>
<<s-primitive-procedures>>
<<s-driver-loop>>

<<s-glue2>>

(driver-loop)

#+end_src

#+RESULTS[a1ebdf141b49821e9fe2f356a6079aeca3f9b9a2]:
#+begin_src shell
ERROR: Unbound variable -- lookup-variable-value: and
  called from <anonymous> on line 73 of file /tmp/babel-CuVd5j/sh-script-k7ZJ4L
  called from <anonymous> on line 362 of file /tmp/babel-CuVd5j/sh-script-k7ZJ4L
  called from driver-loop on line 360 of file /tmp/babel-CuVd5j/sh-script-k7ZJ4L
  called from <anonymous> on line 1289 of file /usr/lib64/chibi/init-7.scm
  called from <anonymous> on line 280 of file /usr/lib64/chibi/init-7.scm
  called from <anonymous> on line 817 of file /usr/lib64/chibi/init-7.scm

;;; M-Eval input:
"hello"
;;; M-Eval value:
"hello"
;;; M-Eval input:
1
;;; M-Eval value:
1
;;; M-Eval input:
#t
;;; M-Eval value:
#t
;;; M-Eval input:
#f
;;; M-Eval value:
#f
;;; M-Eval input:
(if #t "true" "false")
;;; M-Eval value:
"true"
;;; M-Eval input:
(if #f "true" "false")
;;; M-Eval value:
"false"
;;; M-Eval input:
(if (quote ()) "true" "false")
;;; M-Eval value:
"true"
;;; M-Eval input:
(quote ())
;;; M-Eval value:
()
;;; M-Eval input:
(quote test-symbol)
;;; M-Eval value:
test-symbol
;;; M-Eval input:
(define a (quote ()))
;;; M-Eval value:
ok
;;; M-Eval input:
a
;;; M-Eval value:
()
;;; M-Eval input:
(set! a 1)
;;; M-Eval value:
ok
;;; M-Eval input:
a
;;; M-Eval value:
1
;;; M-Eval input:
(define b (lambda (x) (display "test-lambda\n")))
;;; M-Eval value:
ok
;;; M-Eval input:
(begin "One" (if "" "two" (quote ())) "end begin")
;;; M-Eval value:
"end begin"
;;; M-Eval input:
(cond (#f "clause 1") (#f (quote clause2)) (#t "clause 3") (else "else clause"))
;;; M-Eval value:
"clause 3"
;;; M-Eval input:
(cond (#f "clause 1") (#f (quote clause2)) (#f "clause 3") (else "else\n      clause"))
;;; M-Eval value:
"else\n      clause"
;;; M-Eval input:
(and #t #f)
#+end_src

This seems to be good enough. We will only need the analyzing
evaluator for the next three exercises, since the lazy part uses the
standard one, so I will not make sure that all the special forms,
including ~and~, ~or~, and ~letrec~ work.

***** DONE Exercise 4.22 Extending evaluator to support ~let~
      CLOSED: [2020-02-14 Fri 19:33]

Since the analysis is not data-driven, and we don't need to implement
a lot of special forms, let us just modify the ~analyze~ a little.

#+name: s-analyze-eval-with-let
#+begin_src scheme :exports code :results none
  (define (eval exp env) ((analyze exp) env))
  (define (analyze exp)
    (cond ((self-evaluating? exp) (analyze-self-evaluating exp))
	  ((quoted? exp) (analyze-quoted exp))
	  ((variable? exp) (analyze-variable exp))
	  ((assignment? exp) (analyze-assignment exp))
	  ((definition? exp) (analyze-definition exp))
	  ((if? exp) (analyze-if exp))
	  ((lambda? exp) (analyze-lambda exp))
	  ((begin? exp) (analyze-sequence (begin-actions exp)))
	  ((cond? exp) (analyze (cond->if exp)))
          ((let? exp) (analyze (let->combination exp)))
	  ((application? exp) (analyze-application exp))
	  (else (error "Unknown expression type: ANALYZE" exp))))

#+end_src

#+name: s-input-analyze-let
#+begin_example
"hello"
1
#t
#f
(if #t "true" "false")
(if #f "true" "false")
(if '() "true" "false")
'()
'test-symbol
(define a '())
a
(set! a 1)
a
(define b (lambda (x) (display "test-lambda\n")))
(begin "One" (if "" "two" '()) "end begin")
(cond (#f "clause 1") (#f 'clause2) (#t "clause 3") (else "else clause"))
(cond
  (#f "clause 1")
  (#f 'clause2)
  (#f "clause 3")
  (else "else
      clause"))

(define cadr (lambda (x) (car (cdr x))))

"let test1"
(let () "Let1")
"let test2"
(let ((a "Let2")) a)
"let test3"
(let ((a "Let2") (b "Let3")) a (cons a b))
"(let) testing finished"
(exit)
(let* ((a 1) (b (cons a 1))) b)
(define (fib n)
  (let fib-iter ((a 1)
                 (b 0)
                 (count n))
     (if (= count 0)
        b
        (fib-iter (+ a b) a (- count 1)))))
(fib 10)
(define x 100)
(define x 0)
(exit)
#+end_example


#+header: :stdin s-input-analyze-let
#+begin_src shell :shebang "#! /usr/bin/chibi-scheme" :results output scalar code :exports both
<<s-glue1>>
<<s-list-of-values-left-to-right>>
<<s-analyze-eval-with-let>>
<<s-let-implementation>>
<<s-analyze-expressions>>
<<s-analyze-sequence>>
<<s-analyze-execute>>
<<s-syntax>>
<<s-application>>
<<s-cond-with-arrow>>
<<s-truefalse>>
<<s-compound-procedures>>
<<s-environments-list-of-bindings-better-abstractions>>
<<s-primitive-procedures>>
<<s-driver-loop>>

<<s-glue2>>

(driver-loop)

#+end_src

#+RESULTS[576834e1fa803bf2ae6fa97cb620b17d726c4901]:
#+begin_src shell

;;; M-Eval input:
"hello"
;;; M-Eval value:
"hello"
;;; M-Eval input:
1
;;; M-Eval value:
1
;;; M-Eval input:
#t
;;; M-Eval value:
#t
;;; M-Eval input:
#f
;;; M-Eval value:
#f
;;; M-Eval input:
(if #t "true" "false")
;;; M-Eval value:
"true"
;;; M-Eval input:
(if #f "true" "false")
;;; M-Eval value:
"false"
;;; M-Eval input:
(if (quote ()) "true" "false")
;;; M-Eval value:
"true"
;;; M-Eval input:
(quote ())
;;; M-Eval value:
()
;;; M-Eval input:
(quote test-symbol)
;;; M-Eval value:
test-symbol
;;; M-Eval input:
(define a (quote ()))
;;; M-Eval value:
ok
;;; M-Eval input:
a
;;; M-Eval value:
()
;;; M-Eval input:
(set! a 1)
;;; M-Eval value:
ok
;;; M-Eval input:
a
;;; M-Eval value:
1
;;; M-Eval input:
(define b (lambda (x) (display "test-lambda\n")))
;;; M-Eval value:
ok
;;; M-Eval input:
(begin "One" (if "" "two" (quote ())) "end begin")
;;; M-Eval value:
"end begin"
;;; M-Eval input:
(cond (#f "clause 1") (#f (quote clause2)) (#t "clause 3") (else "else clause"))
;;; M-Eval value:
"clause 3"
;;; M-Eval input:
(cond (#f "clause 1") (#f (quote clause2)) (#f "clause 3") (else "else\n      clause"))
;;; M-Eval value:
"else\n      clause"
;;; M-Eval input:
(define cadr (lambda (x) (car (cdr x))))
;;; M-Eval value:
ok
;;; M-Eval input:
"let test1"
;;; M-Eval value:
"let test1"
;;; M-Eval input:
(let () "Let1")
;;; M-Eval value:
"Let1"
;;; M-Eval input:
"let test2"
;;; M-Eval value:
"let test2"
;;; M-Eval input:
(let ((a "Let2")) a)
;;; M-Eval value:
"Let2"
;;; M-Eval input:
"let test3"
;;; M-Eval value:
"let test3"
;;; M-Eval input:
(let ((a "Let2") (b "Let3")) a (cons a b))
;;; M-Eval value:
("Let2" . "Let3")
;;; M-Eval input:
"(let) testing finished"
;;; M-Eval value:
"(let) testing finished"
;;; M-Eval input:
(exit)
#+end_src

***** DONE Exercise 4.23 Analysing sequences
      CLOSED: [2020-02-14 Fri 19:40]

As has already been said, we are saving here on one more pass over the
procedure body.

Let's have a look at the following procedure:

#+begin_src scheme :exports code :results none
(define (a) (display "hello\n") (a))
#+end_src

If analysed like in the book text, at the ~execute-application~ time,
the last sub-lambda, that is the one encapsulating ~display~, would
directly call ~a~, that is one jump. Alyssa's version, on the other
hand, would be calling the lambda, and then going back to the lambda
produced by ~analyze-sequence~. That is two jumps. So the time saved
is roughly the length of the procedure per call. If a procedure is
called many times, that is a lot of work.

***** DONE Exercise 4.24 Analysis time test
      CLOSED: [2020-02-14 Fri 20:12]

We will write the same program and then interpret it with two
different interpreters.

#+name: s-input-analyze-time
#+begin_example
"starting testing"
(define (fact a b)
  (if (= a 1) b (fact (- a 1) (* a b))))
(define starttime (current-second))
(define useless (fact 100 1))
(- (current-second) starttime)


(define (simple-rec ntimes)
  (if (= ntimes 1) 'ok (simple-rec (- ntimes 1))))
(define starttime (current-second))
(simple-rec 100000)
(- (current-second) starttime)

(exit)
#+end_example


#+header: :stdin s-input-analyze-time
#+name: analyzing-speed-test
#+begin_src shell :shebang "#! /usr/bin/chibi-scheme" :results output scalar code :exports both
  <<s-glue1>>
  <<s-list-of-values-left-to-right>>
  <<s-analyze-eval-with-let>>
  <<s-let-implementation>>
  <<s-analyze-expressions>>
  <<s-analyze-sequence>>
  <<s-analyze-execute>>
  <<s-syntax>>
  <<s-application>>
  <<s-cond-with-arrow>>
  <<s-truefalse>>
  <<s-compound-procedures>>
  <<s-environments-list-of-bindings-better-abstractions>>
  <<s-primitive-procedures>>
<<s-driver-loop>>

  <<s-glue2>>

  (driver-loop)

#+end_src

#+RESULTS[8dd104eccf8e2d6940a729b050e31ed459df38db]: analyzing-speed-test
#+begin_src shell

;;; M-Eval input:
"starting testing"
;;; M-Eval value:
"starting testing"
;;; M-Eval input:
(define (fact a b) (if (= a 1) b (fact (- a 1) (* a b))))
;;; M-Eval value:
ok
;;; M-Eval input:
(define starttime (current-second))
;;; M-Eval value:
ok
;;; M-Eval input:
(define useless (fact 100 1))
;;; M-Eval value:
ok
;;; M-Eval input:
(- (current-second) starttime)
;;; M-Eval value:
0.018227100372314453
;;; M-Eval input:
(define (simple-rec ntimes) (if (= ntimes 1) (quote ok) (simple-rec (- ntimes 1))))
;;; M-Eval value:
ok
;;; M-Eval input:
(define starttime (current-second))
;;; M-Eval value:
ok
;;; M-Eval input:
(simple-rec 100000)
;;; M-Eval value:
ok
;;; M-Eval input:
(- (current-second) starttime)
;;; M-Eval value:
6.6969640254974365
;;; M-Eval input:
(exit)
#+end_src

#+header: :stdin s-input-analyze-time
#+name: original-speed-test
#+begin_src shell :shebang "#! /usr/bin/chibi-scheme" :results output scalar code :exports both
  <<s-glue1>>
  <<s-apply>>
  <<put-and-get>>
  <<s-data-driven-eval>>
  <<s-list-of-values-left-to-right>>
  <<s-standard-if>>
  <<s-sequences>>
  <<s-assignment>>
  <<s-define>>
  <<s-syntax>>
  <<s-application>>
  <<s-cond-with-arrow>>
  <<s-truefalse>>
  <<s-compound-procedures>>
  <<s-environments-list-of-bindings-better-abstractions>>
  <<s-primitive-procedures>>
  <<s-driver-loop>>
  <<s-eval-and>>
  <<s-let>>
  <<s-let-star>>
  <<s-let-named>>
  <<s-until>>
  <<s-make-unbound>>
  <<s-internal-definitions>>
  <<s-letrec>>
  <<s-glue2>>

  (driver-loop)

#+end_src

#+RESULTS[2117dc697df27493bff957422175a287e732e9fe]: original-speed-test
#+begin_src shell

;;; M-Eval input:
"starting testing"
;;; M-Eval value:
"starting testing"
;;; M-Eval input:
(define (fact a b) (if (= a 1) b (fact (- a 1) (* a b))))
;;; M-Eval value:
ok
;;; M-Eval input:
(define starttime (current-second))
;;; M-Eval value:
ok
;;; M-Eval input:
(define useless (fact 100 1))
;;; M-Eval value:
ok
;;; M-Eval input:
(- (current-second) starttime)
;;; M-Eval value:
0.011011838912963867
;;; M-Eval input:
(define (simple-rec ntimes) (if (= ntimes 1) (quote ok) (simple-rec (- ntimes 1))))
;;; M-Eval value:
ok
;;; M-Eval input:
(define starttime (current-second))
;;; M-Eval value:
ok
;;; M-Eval input:
(simple-rec 100000)
;;; M-Eval value:
ok
;;; M-Eval input:
(- (current-second) starttime)
;;; M-Eval value:
10.349020004272461
;;; M-Eval input:
(exit)
#+end_src



Wow! That's like, three times faster for a simple factorial
function. And twice faster for a function that only does one condition
check and one subtraction.

**** IMPROV Needs exercises on the (syntax-rules and low-level)    :edition3:
*** 4.2 Variations on a Scheme − Lazy Evaluation [10/10]

**** 4.2.1 Normal Order and Applicative Order
***** DONE Exercise 4.25 lazy factorial
      CLOSED: [2020-02-14 Fri 21:01]

#+begin_src scheme :exports both :results output scalar code
(define (unless condition usual-value exceptional-value)
  (if condition exceptional-value usual-value))

(define (factorial n)
  (unless (= n 1)
     (* n (factorial (- n 1)))
     1))
(show #t (factorial 10) "\n")
#+end_src

#+RESULTS[67d3ebfdc06cdb9e0a91b3e23de2b6e193f25dd0]:
#+begin_src scheme
ERROR: out of stack space
> 
#+end_src

This is logical, since ~factorial~ is entered indefinitely with
decreasing ~n~, and has no chance to stop.

#+begin_src scheme :exports both :results output scalar code
(define (unless condition usual-value exceptional-value)
  (if (force condition) (force exceptional-value) (force usual-value)))

(define (factorial n)
  (unless (delay (= n 1))
     (delay (* n (factorial (- n 1))))
     (delay 1)))
(show #t (factorial 10) "\n")
#+end_src

#+RESULTS[6c5fdead1ae6af2526bdb31dd83d4a767b9b38e0]:
#+begin_src scheme
3628800
#+end_src

Seems to be working.

***** DONE Exercise 4.26 unless as a special form
      CLOSED: [2020-02-15 Sat 04:32]

Well, I will not actually support Alyssa's side of the argument with
~unless~, because I have a better example: ~and~. And has to be a
special form, because it short-circuits. However, being able to do a
~(accumulate and l)~ would be very useful! The ~accumulate~ is a
procedure from the first chapter of this book. Unfortunately, this
doesn't work, since ~and~ is a syntax.

On the Bob's side of the argument, ~unless~ can be implemented as a
special form, indeed. And in this case, instead of deconstructing the
form myself and feeding it into an ~eval~, I will implement ~unless~
as a macro.

#+begin_src scheme :exports both :results output scalar code
(define-syntax unless
  (syntax-rules ()
    ((unless cond unexpected expected) (if cond expected unexpected))))

(if #t (display "if works\n") (error "if malfunction"))
(unless #f (display "unless works\n") (error "unless malfunction"))

#+end_src

#+RESULTS[ff44fe26d4029d1a828ec3a57f156461b071a335]:
#+begin_src scheme
if works
unless works
#+end_src


**** 4.2.2 An Interpreter with Lazy Evaluation

***** Common code

#+name: s-lazy-eval-implementation
#+begin_src scheme :exports code :results none
  (define (eval . o) (display "in the wrong eval"))
  (define (special-form-maybe exp) (if (and (pair? exp) (symbol? (car exp)))
			      (get 'eval (car exp))
			      #f))

  (define (eval exp env)
    (cond ((self-evaluating? exp) exp)
	  ((variable? exp) (lookup-variable-value exp env))
	  ((special-form-maybe exp) => (lambda (x)  (x exp env)))
	  ((application? exp) (apply (actual-value (operator exp) env)
				     (operands exp)
                                     env))
	  (else
	   (error "data-directed-eval: unknown operation" exp))))
#+end_src

#+name: s-lazy-eval-installation
#+begin_src scheme :exports code :results none
  (put 'eval 'quote (lambda (exp env) (text-of-quotation exp)))
  (put 'eval 'set! (lambda (exp env) (eval-assignment exp env)))
  (put 'eval 'define (lambda (exp env) (eval-definition exp env)))
  (put 'eval 'if (lambda (exp env) (eval-if exp env)))
  (put 'eval 'lambda (lambda (exp env) (make-procedure (lambda-parameters exp)
			   (lambda-body exp)
			   env)))
  (put 'eval 'begin (lambda (exp env) (eval-sequence (begin-actions exp) env)))

  (put 'eval 'cond (lambda (exp env) (eval (cond->if exp) env)))

#+end_src

#+name: s-lazy-eval
#+begin_src scheme :exports code :results none
<<s-lazy-eval-implementation>>
<<s-lazy-eval-installation>>
#+end_src

#+name: s-lazy-actual-value
#+begin_src scheme :exports code :results none
  (define (actual-value exp env)
    (force-it (eval exp env)))

#+end_src

#+name: s-lazy-apply
#+begin_src scheme :exports code :results none
  (define (apply procedure arguments env)
    (cond ((primitive-procedure? procedure)
	   (apply-primitive-procedure
	    procedure
	    (list-of-arg-values arguments env)))
	  ((compound-procedure? procedure)
	   (eval-sequence
	    (procedure-body procedure)
	    (extend-environment
	     (procedure-parameters procedure)
	     (list-of-delayed-args arguments env)
	     (procedure-environment procedure))))
	  (else (error "Unknown procedure type: APPLY"
		       procedure))))
  (define (list-of-arg-values exps env)
    (if (no-operands? exps)
	'()
	(cons (actual-value (first-operand exps)
			    env)
	      (list-of-arg-values (rest-operands exps)
				  env))))
  (define (list-of-delayed-args exps env)
    (if (no-operands? exps)
	'()
	(cons (delay-it (first-operand exps)
			env)
	      (list-of-delayed-args (rest-operands exps)
				    env))))
#+end_src

#+name: s-lazy-if
#+begin_src scheme :exports code :results none
  (define (eval-if exp env)
    (if (true? (actual-value (if-predicate exp) env))
	(eval (if-consequent exp) env)
	(eval (if-alternative exp) env)))
#+end_src

#+name: s-lazy-driver-loop
#+begin_src scheme :exports code :results none
  (define input-prompt ";;; L-Eval input:")
  (define output-prompt ";;; L-Eval value:")
  (define (driver-loop)
    (prompt-for-input input-prompt)
    (let ((input (read)))
      (user-print input)
      (let ((output (actual-value
                       input the-global-environment)))
	(announce-output output-prompt)
	(user-print output)))
    (driver-loop))
  (define (prompt-for-input string)
    #;(newline) #;(newline) (display string) (newline))
  (define (announce-output string)
    #;(newline) (display string) (newline))
  (define (user-print object)
    (if (compound-procedure? object)
	(show #t (pretty  (list 'compound-procedure
		       (procedure-parameters object)
		       (procedure-body object)
		       '<procedure-env>)))
	(show #t (pretty  object))))
#+end_src

#+name: s-lazy-thunks
#+begin_src scheme :exports code :results none

  (define (delay-it exp env)
    (list 'thunk exp env))
  (define (thunk? obj)
    (tagged-list? obj 'thunk))
  (define (thunk-exp thunk) (cadr
			thunk))
  (define (thunk-env thunk) (caddr thunk))
  (define (evaluated-thunk? obj)
    (tagged-list? obj 'evaluated-thunk))
  (define (thunk-value evaluated-thunk)
    (cadr evaluated-thunk))
#+end_src

#+name: s-lazy-force-it-memoizing
#+begin_src scheme :exports code :results none
  (define (force-it obj)
    (cond ((thunk? obj)
	   (let ((result (actual-value (thunk-exp obj)
				       (thunk-env obj))))
	     (set-car! obj 'evaluated-thunk)
	     (set-car! (cdr obj)
		       result)
	     (set-cdr! (cdr obj)
		       '())
	     result))
	  ((evaluated-thunk? obj) (thunk-value obj))
	  (else obj)))
#+end_src

#+name: s-lazy-force-it-nonmemoizing
#+begin_src scheme :exports code :results none
  (define (force-it obj)
    (cond ((thunk? obj)
	   (let ((result (actual-value (thunk-exp obj)
				       (thunk-env obj))))
	     result))
	  (else obj)))
#+end_src


What is important here is that we don't use the underlying scheme's
~delay~ and ~force~, which in the recent reports include memoization by
default. Since we want a more fine-grained control over memoizaion,
this doesn't fit our purpose.

#+name: s-lazy-input-test1
#+begin_example
(define (try a b) (if (= a 0) 1 b))
(try 0 (/ 1 0))
(exit)
#+end_example

#+header: :stdin s-lazy-input-test1
#+begin_src shell :shebang "#! /usr/bin/chibi-scheme" :results output scalar code :exports both
<<s-glue1>>
<<put-and-get>>
<<s-lazy-eval-implementation>>
<<s-lazy-eval-installation>>
<<s-lazy-apply>>
<<s-lazy-actual-value>>
<<s-lazy-if>>
<<s-sequences>>
<<s-assignment>>
<<s-define>>
<<s-syntax>>
<<s-application>>
<<s-cond-with-arrow>>
<<s-truefalse>>
<<s-compound-procedures>>
<<s-environments>>
<<s-primitive-procedures>>

<<s-lazy-thunks>>
<<s-lazy-force-it-memoizing>>
<<s-lazy-driver-loop>>
<<s-glue2>>

(driver-loop)

#+end_src

#+RESULTS[8985ed9cdfdab64be39a4fff0a4f4bf617426d9a]:
#+begin_src shell
;;; L-Eval input:
(define (try a b) (if (= a 0) 1 b))
;;; L-Eval value:
ok
;;; L-Eval input:
(try 0 (/ 1 0))
;;; L-Eval value:
1
;;; L-Eval input:
(exit)
#+end_src

#+header: :stdin s-lazy-input-test1
#+begin_src shell :shebang "#! /usr/bin/chibi-scheme" :results output scalar code :exports both
<<s-glue1>>
<<put-and-get>>
<<s-lazy-eval-implementation>>
<<s-lazy-eval-installation>>
<<s-lazy-apply>>
<<s-lazy-actual-value>>
<<s-lazy-if>>
<<s-sequences>>
<<s-assignment>>
<<s-define>>
<<s-syntax>>
<<s-application>>
<<s-cond-with-arrow>>
<<s-truefalse>>
<<s-compound-procedures>>
<<s-environments>>
<<s-primitive-procedures>>

<<s-lazy-thunks>>
<<s-lazy-force-it-nonmemoizing>>
<<s-lazy-driver-loop>>
<<s-glue2>>

(driver-loop)

#+end_src

#+RESULTS[7d645c910cffa102df1e9d9bddc59f7140a46a13]:
#+begin_src shell
;;; L-Eval input:
(define (try a b) (if (= a 0) 1 b))
;;; L-Eval value:
ok
;;; L-Eval input:
(try 0 (/ 1 0))
;;; L-Eval value:
1
;;; L-Eval input:
(exit)
#+end_src


Looks like at least the basic interpretation is working.

***** DONE Exercise 4.27 Working with mutation in lazy interpreters
      CLOSED: [2020-02-15 Sat 16:54]

#+name: s-lazy-input-4-27
#+begin_example
(define (try a b) (if (= a 0) 1 b))
(try 0 (/ 1 0))

(define count 0)
(define (id x) (set! count (+ count 1)) x)
(define w (id (id 10)))
count
w
count

(exit)
#+end_example

#+header: :stdin s-lazy-input-4-27
#+begin_src shell :shebang "#! /usr/bin/chibi-scheme" :results output scalar code :exports both
<<s-glue1>>
<<put-and-get>>
<<s-lazy-eval-implementation>>
<<s-lazy-eval-installation>>
<<s-lazy-apply>>
<<s-lazy-actual-value>>
<<s-lazy-if>>
<<s-sequences>>
<<s-assignment>>
<<s-define>>
<<s-syntax>>
<<s-application>>
<<s-cond-with-arrow>>
<<s-truefalse>>
<<s-compound-procedures>>
<<s-environments>>
<<s-primitive-procedures>>

<<s-lazy-thunks>>
<<s-lazy-force-it-memoizing>>
<<s-lazy-driver-loop>>
<<s-glue2>>

(driver-loop)

#+end_src

#+RESULTS[c02d702793ee221a33ca05a7819c92b989ab8147]:
#+begin_src shell
;;; L-Eval input:
(define (try a b) (if (= a 0) 1 b))
;;; L-Eval value:
ok
;;; L-Eval input:
(try 0 (/ 1 0))
;;; L-Eval value:
1
;;; L-Eval input:
(define count 0)
;;; L-Eval value:
ok
;;; L-Eval input:
(define (id x) (set! count (+ count 1)) x)
;;; L-Eval value:
ok
;;; L-Eval input:
(define w (id (id 10)))
;;; L-Eval value:
ok
;;; L-Eval input:
count
;;; L-Eval value:
1
;;; L-Eval input:
w
;;; L-Eval value:
10
;;; L-Eval input:
count
;;; L-Eval value:
2
;;; L-Eval input:
(exit)
#+end_src

Explanation: ~count~ counts the number of times that ~id~ gets
evaluated. ~id~ itself does nothing, so no matter how many times we
evaluate ~w~, which is a result of successive applications of ~id~, we
will always get 10. ~count~ is more tricky, but also quite
reasonable. ~id~ gets executed once, at the time when ~w~ is defined,
and this increases ~count~ by one. This execution returns a thunk,
since we don't use the result yet. When we display the value of ~w~,
the ~driver-loop~ uses ~actual-value~ to force the evaluation of the thunk.

***** DONE Exercise 4.28 Eval before applying
      CLOSED: [2020-02-15 Sat 17:01]

Well, a thunk is a tagged list with the 'thunk tag. A tagged list by
itself cannot be applied, what needs to be applied is some
representation of a procedure, i.e. a list with formal parameters and
the sequence of operations (a compound procedure) or a primitive procedure.

***** DONE Exercise 4.29 Lazy evaluation is slow without memoization
      CLOSED: [2020-02-15 Sat 17:51]

****** a Memoization vs no memoization

#+name: s-lazy-input-memo-slow
#+begin_example
(define (f x) (* x x))
(define g (f (f 5)))
(define (loop n state)
  (if (= n 0)
      state
      (loop (- n 1) (+ state g))))
(define starttime (current-second))
(loop 100 0)
(- (current-second) starttime)
(exit)
#+end_example

#+header: :stdin s-lazy-input-memo-slow
#+begin_src shell :shebang "#! /usr/bin/chibi-scheme" :results output scalar code :exports both
<<s-glue1>>
<<put-and-get>>
<<s-lazy-eval-implementation>>
<<s-lazy-eval-installation>>
<<s-lazy-apply>>
<<s-lazy-actual-value>>
<<s-lazy-if>>
<<s-sequences>>
<<s-assignment>>
<<s-define>>
<<s-syntax>>
<<s-application>>
<<s-cond-with-arrow>>
<<s-truefalse>>
<<s-compound-procedures>>
<<s-environments>>
<<s-primitive-procedures>>

<<s-lazy-thunks>>
<<s-lazy-force-it-memoizing>>
<<s-lazy-driver-loop>>
<<s-glue2>>

(driver-loop)

#+end_src

#+RESULTS[5a019fcf387254f39675fd2717b9b35f6b4b0f94]:
#+begin_src shell
;;; L-Eval input:
(define (f x) (* x x))
;;; L-Eval value:
ok
;;; L-Eval input:
(define g (f (f 5)))
;;; L-Eval value:
ok
;;; L-Eval input:
(define (loop n state) (if (= n 0) state (loop (- n 1) (+ state g))))
;;; L-Eval value:
ok
;;; L-Eval input:
(define starttime (current-second))
;;; L-Eval value:
ok
;;; L-Eval input:
(loop 100 0)
;;; L-Eval value:
62500
;;; L-Eval input:
(- (current-second) starttime)
;;; L-Eval value:
0.021624088287353516
;;; L-Eval input:
(exit)
#+end_src


#+header: :stdin s-lazy-input-memo-slow
#+begin_src shell :shebang "#! /usr/bin/chibi-scheme" :results output scalar code :exports both
<<s-glue1>>
<<put-and-get>>
<<s-lazy-eval-implementation>>
<<s-lazy-eval-installation>>
<<s-lazy-apply>>
<<s-lazy-actual-value>>
<<s-lazy-if>>
<<s-sequences>>
<<s-assignment>>
<<s-define>>
<<s-syntax>>
<<s-application>>
<<s-cond-with-arrow>>
<<s-truefalse>>
<<s-compound-procedures>>
<<s-environments>>
<<s-primitive-procedures>>

<<s-lazy-thunks>>
<<s-lazy-force-it-nonmemoizing>>
<<s-lazy-driver-loop>>
<<s-glue2>>

(driver-loop)

#+end_src

#+RESULTS[36bf3cf29d05a432bbb793076ee65a321ed38152]:
#+begin_src shell
;;; L-Eval input:
(define (f x) (* x x))
;;; L-Eval value:
ok
;;; L-Eval input:
(define g (f (f 5)))
;;; L-Eval value:
ok
;;; L-Eval input:
(define (loop n state) (if (= n 0) state (loop (- n 1) (+ state g))))
;;; L-Eval value:
ok
;;; L-Eval input:
(define starttime (current-second))
;;; L-Eval value:
ok
;;; L-Eval input:
(loop 100 0)
;;; L-Eval value:
62500
;;; L-Eval input:
(- (current-second) starttime)
;;; L-Eval value:
0.38291311264038086
;;; L-Eval input:
(exit)
#+end_src

An impressive difference!

What is happening here? ~g~, a thunk, is essentially a procedure in
disguise, consisting of at least tree operations. The inner ~f~
application will not be memoized, and therefore, every step in the
loop will have to do the for multiplications over and over. Therefore,
I expect this program be four times slower on a non-memoizing
interpreter than on a memoizing. It actually turned out to be almost
10 times slower.

****** b Memoization vs no memoization for a given example

#+name: s-lazy-input-memoization
#+begin_example
(define count 0)
(define (id x) (set! count (+ count 1)) x)
(define (square x) (* x x))
(square (id 10))
count
(exit)
#+end_example

#+header: :stdin s-lazy-input-memoization
#+begin_src shell :shebang "#! /usr/bin/chibi-scheme" :results output scalar code :exports both
<<s-glue1>>
<<put-and-get>>
<<s-lazy-eval-implementation>>
<<s-lazy-eval-installation>>
<<s-lazy-apply>>
<<s-lazy-actual-value>>
<<s-lazy-if>>
<<s-sequences>>
<<s-assignment>>
<<s-define>>
<<s-syntax>>
<<s-application>>
<<s-cond-with-arrow>>
<<s-truefalse>>
<<s-compound-procedures>>
<<s-environments>>
<<s-primitive-procedures>>

<<s-lazy-thunks>>
<<s-lazy-force-it-memoizing>>
<<s-lazy-driver-loop>>
<<s-glue2>>

(driver-loop)

#+end_src

#+RESULTS[7791871b0f91591f109dc5f026c8c582647637bb]:
#+begin_src shell
;;; L-Eval input:
(define count 0)
;;; L-Eval value:
ok
;;; L-Eval input:
(define (id x) (set! count (+ count 1)) x)
;;; L-Eval value:
ok
;;; L-Eval input:
(define (square x) (* x x))
;;; L-Eval value:
ok
;;; L-Eval input:
(square (id 10))
;;; L-Eval value:
100
;;; L-Eval input:
count
;;; L-Eval value:
1
;;; L-Eval input:
(exit)
#+end_src

#+header: :stdin s-lazy-input-memoization
#+begin_src shell :shebang "#! /usr/bin/chibi-scheme" :results output scalar code :exports both
<<s-glue1>>
<<put-and-get>>
<<s-lazy-eval-implementation>>
<<s-lazy-eval-installation>>
<<s-lazy-apply>>
<<s-lazy-actual-value>>
<<s-lazy-if>>
<<s-sequences>>
<<s-assignment>>
<<s-define>>
<<s-syntax>>
<<s-application>>
<<s-cond-with-arrow>>
<<s-truefalse>>
<<s-compound-procedures>>
<<s-environments>>
<<s-primitive-procedures>>

<<s-lazy-thunks>>
<<s-lazy-force-it-nonmemoizing>>
<<s-lazy-driver-loop>>
<<s-glue2>>

(driver-loop)

#+end_src

#+RESULTS[424fe9c3e9a2643525a16e8e7570bc2783a96845]:
#+begin_src shell
;;; L-Eval input:
(define count 0)
;;; L-Eval value:
ok
;;; L-Eval input:
(define (id x) (set! count (+ count 1)) x)
;;; L-Eval value:
ok
;;; L-Eval input:
(define (square x) (* x x))
;;; L-Eval value:
ok
;;; L-Eval input:
(square (id 10))
;;; L-Eval value:
100
;;; L-Eval input:
count
;;; L-Eval value:
2
;;; L-Eval input:
(exit)
#+end_src

This is quite obvious. ~x~ is a thunk, and it is forced either once
(the memoizing case) or twice (nonmemoizing case).

***** DONE Exercise 4.30 Lazy sequences
      CLOSED: [2020-02-15 Sat 21:32]

#+name: s-sequences-lazy-eager
#+begin_src scheme :exports code :results none
  (define (eval-sequence exps env)
    (cond ((last-exp? exps) (eval (first-exp exps) env))
	  (else (actual-value (first-exp exps) env)
		(eval-sequence (rest-exps exps) env))))
#+end_src

****** a Ben's ~for-each~

Ben is right about ~for-each~, at least because the ~(if (null?
items))~ forces the value of ~items~, and whatever is left unforced,
is forced by ~display~, which is a primitive procedure. So while Ben is
right, it doesn't eliminate Cy's concern.

#+name: s-lazy-input-for-each
#+begin_example
(define (for-each proc items)
  (if (null? items)
    'done
    (begin
          (proc (car items))
          (for-each proc (cdr items)))))
(for-each (lambda (x) (newline) (display x))
(list 57 321 88))
(exit)
#+end_example

#+header: :stdin s-lazy-input-for-each
#+begin_src shell :shebang "#! /usr/bin/chibi-scheme" :results output scalar code :exports both
<<s-glue1>>
<<put-and-get>>
<<s-lazy-eval-implementation>>
<<s-lazy-eval-installation>>
<<s-lazy-apply>>
<<s-lazy-actual-value>>
<<s-lazy-if>>
<<s-sequences>>
<<s-assignment>>
<<s-define>>
<<s-syntax>>
<<s-application>>
<<s-cond-with-arrow>>
<<s-truefalse>>
<<s-compound-procedures>>
<<s-environments>>
<<s-primitive-procedures>>

<<s-lazy-thunks>>
<<s-lazy-force-it-memoizing>>
<<s-lazy-driver-loop>>
<<s-glue2>>

(driver-loop)

#+end_src

#+RESULTS[1c8308a024def5c9fa93324a44e67935d667a33d]:
#+begin_src shell
;;; L-Eval input:
(define (for-each proc items)
  (if (null? items)
      'done
      (begin (proc (car items)) (for-each proc (cdr items)))))
;;; L-Eval value:
ok
;;; L-Eval input:
(for-each (lambda (x) (newline) (display x)) (list 57 321 88))

57
321
88;;; L-Eval value:
done
;;; L-Eval input:
(exit)
#+end_src


****** b Cy's example

#+name: s-lazy-input-cy-example
#+begin_example
(define (p1 x)
  (set! x (cons x '(2)))
  x)
(define (p2 x)
  (define (p e)
    e
    x)
  (p (set! x (cons x '(2)))))
(p1 1)
(p2 1)
(exit)
#+end_example

#+header: :stdin s-lazy-input-cy-example
#+begin_src shell :shebang "#! /usr/bin/chibi-scheme" :results output scalar code :exports both
<<s-glue1>>
<<put-and-get>>
<<s-lazy-eval-implementation>>
<<s-lazy-eval-installation>>
<<s-lazy-apply>>
<<s-lazy-actual-value>>
<<s-lazy-if>>
<<s-sequences>>
<<s-assignment>>
<<s-define>>
<<s-syntax>>
<<s-application>>
<<s-cond-with-arrow>>
<<s-truefalse>>
<<s-compound-procedures>>
<<s-environments>>
<<s-primitive-procedures>>
<<s-lazy-thunks>>
<<s-lazy-force-it-memoizing>>
<<s-lazy-driver-loop>>
<<s-glue2>>

(driver-loop)

#+end_src

#+RESULTS[56711a830dfd7daf2ba69fc36fadbafdae8608d2]:
#+begin_src shell
;;; L-Eval input:
(define (p1 x) (set! x (cons x '(2))) x)
;;; L-Eval value:
ok
;;; L-Eval input:
(define (p2 x) (define (p e) e x) (p (set! x (cons x '(2)))))
;;; L-Eval value:
ok
;;; L-Eval input:
(p1 1)
;;; L-Eval value:
(1 2)
;;; L-Eval input:
(p2 1)
;;; L-Eval value:
1
;;; L-Eval input:
(exit)
#+end_src

#+header: :stdin s-lazy-input-cy-example
#+begin_src shell :shebang "#! /usr/bin/chibi-scheme" :results output scalar code :exports both
<<s-glue1>>
<<put-and-get>>
<<s-lazy-eval-implementation>>
<<s-lazy-eval-installation>>
<<s-lazy-apply>>
<<s-lazy-actual-value>>
<<s-lazy-if>>
<<s-sequences-lazy-eager>>
<<s-assignment>>
<<s-define>>
<<s-syntax>>
<<s-application>>
<<s-cond-with-arrow>>
<<s-truefalse>>
<<s-compound-procedures>>
<<s-environments>>
<<s-primitive-procedures>>
<<s-lazy-thunks>>
<<s-lazy-force-it-memoizing>>
<<s-lazy-driver-loop>>
<<s-glue2>>

(driver-loop)

#+end_src

#+RESULTS[85e4b39a59a389c4cfff6c8101aecf4abbc04d73]:
#+begin_src shell
;;; L-Eval input:
(define (p1 x) (set! x (cons x '(2))) x)
;;; L-Eval value:
ok
;;; L-Eval input:
(define (p2 x) (define (p e) e x) (p (set! x (cons x '(2)))))
;;; L-Eval value:
ok
;;; L-Eval input:
(p1 1)
;;; L-Eval value:
(1 2)
;;; L-Eval input:
(p2 1)
;;; L-Eval value:
(1 2)
;;; L-Eval input:
(exit)
#+end_src

Indeed, Cy is right! In the truly lazy interpreter, every element but
last in every sequence is not guaranteed to be evaluated, because it's
results are obviously not used for anything. Indeed, side-effects with
lazy evaluation are tricky!


****** c a vs b
Well, everything is effectively eager in part [[a Ben's ~for-each~]], so
it is not surprising that nothing really changes.
****** d Own opinion
Well, the thing is that sequences are only important for
side-effects. Side-effects are a difficult topic. For example, in
Operating System's shells, all commands have a return value, which may
be checked. In scheme, on the other hand, most mutative operators
don't have a return value.

So, my response was also given on the irc://irc.freenode.net/#scheme
at 2020-02-15T13:20:59.028885UTC

#+begin_example
<lockywolf> The point is that if I write (set! x 1), it may never be
actually forced, because noone cares about its return value.  <pjb>
And results of operators such as setf are specified (to be the last
assigned value, and evaluation is specified to be left-to-right), so
you can write things like (setf a (setf b 42)) or (let ((a 0) (b 0) c)
(setf c (+ (setf a 33) (incf b))) (list a b c)) #| --> (33 1 34) |#
<pjb> lockywolf: good point. But usually, you would use x.  But if you
don't indeed, it could make it easier to the compiler to determines
it's dead code.e
<lockywolf> However, if I write (if (set! x 1)
(continuation) (error "setter broken")), it is guaranteed to be
forced.
<lockywolf> I would, and it would be a huge source of
confusion!
<lockywolf> Because accessing x still doesn't force
(set!)!
<lockywolf> Again, I am speaking about the lazy regime.
<lockywolf> To me it seems quite natural for mutators return #t if
successfully mutated, and #f if not.
<lockywolf> Then I would produce
guaranteed mutators by writing (and (set! x 1) (set! x2 0), etc.
#+end_example

***** DONE Exercise 4.31 Lazy arguments with syntax extension
      CLOSED: [2020-02-15 Sat 23:44]

a)change apply
b)add list-of-delayed-or-nondelayed-args
c)rewrite define
d)rewrite actual-value

#+name: s-compound-procedures-semilazy
#+begin_src scheme :exports code :results none
  (define (make-procedure parameters body env)
      (define (parameter-laziness p)
         (if (pair? p)
            (cadr p)
            'eager))
      (define (parameter-name p)
         (if (pair? p)
            (car p)
            p))
      (let ((qualifiers (map parameter-laziness parameters))
            (parameters (map parameter-name parameters)))
         (list 'procedure parameters body env qualifiers)))
  (define (compound-procedure? p)
    (tagged-list? p 'procedure))
  (define (procedure-parameters p) (cadr p))
  (define (procedure-body p) (caddr p))
  (define (procedure-environment p) (cadddr p))
  (define (procedure-parameters-qualifiers p) (list-ref p 4))
  (define first-lazy-qualifier car)
  (define rest-lazy-qualifiers cdr)
#+end_src

#+name: s-lazy-apply-semilazy
#+begin_src scheme :exports code :results none
  (define (apply procedure arguments env)
    (cond ((primitive-procedure? procedure)
	   (apply-primitive-procedure
	    procedure
	    (list-of-arg-values arguments env)))
	  ((compound-procedure? procedure)
	   (eval-sequence
	    (procedure-body procedure)
	    (extend-environment
	     (procedure-parameters procedure)
	     (list-of-delayed-or-nondelayed-args
                 arguments
                 env
                 (procedure-parameters-qualifiers procedure))
	     (procedure-environment procedure))))
	  (else (error "Unknown procedure type: APPLY"
		       procedure))))
  (define (list-of-arg-values exps env)
    (if (no-operands? exps)
	'()
	(cons (actual-value (first-operand exps)
			    env)
	      (list-of-arg-values (rest-operands exps)
				  env))))
  (define (list-of-delayed-args exps env)
    (if (no-operands? exps)
	'()
	(cons (delay-it (first-operand exps)
			env)
	      (list-of-delayed-args (rest-operands exps)
				    env))))
  (define (list-of-delayed-or-nondelayed-args exps env lazy-qualifiers)
      (if (no-operands? exps)
	  '()
	  (cons (cond ((eq? 'lazy-memo (first-lazy-qualifier lazy-qualifiers))
                          (delay-it (first-operand exps) env))
                      ((eq? 'lazy (first-lazy-qualifier lazy-qualifiers))
                          (delay-it-nonmemo (first-operand exps) env))
                      (else (actual-value (first-operand exps) env)))
		(list-of-delayed-or-nondelayed-args (rest-operands exps)
				      env
                                      (rest-lazy-qualifiers lazy-qualifiers)))))

#+end_src

#+name: s-lazy-thunks-semilazy
#+begin_src scheme :exports code :results none
  (define (delay-it exp env)
    (list 'thunk exp env))
  (define (delay-it-nonmemo exp env)
    (list 'nonmemoizing-thunk exp env))
  (define (thunk? obj)
    (tagged-list? obj 'thunk))
  (define (nonmemoizing-thunk? obj)
    (tagged-list? obj 'nonmemoizing-thunk))
  (define (thunk-exp thunk) (cadr
			thunk))
  (define (thunk-env thunk) (caddr thunk))
  (define (evaluated-thunk? obj)
    (tagged-list? obj 'evaluated-thunk))
  (define (thunk-value evaluated-thunk)
    (cadr evaluated-thunk))
  (define (force-it obj)
    (cond ((thunk? obj)
	   (let ((result (actual-value (thunk-exp obj)
				       (thunk-env obj))))
	     (set-car! obj 'evaluated-thunk)
	     (set-car! (cdr obj)
		       result)
	     (set-cdr! (cdr obj)
		       '())
	     result))
          ((nonmemoizing-thunk? obj)
             (actual-value (thunk-exp obj)
				       (thunk-env obj)))
	  ((evaluated-thunk? obj) (thunk-value obj))
	  (else obj)))
#+end_src

#+name: s-lazy-input-semilazy
#+begin_example
(define (f a (b lazy) c (d lazy-memo))
   (newline)
   (display a)
   (newline)
   (display b)
   (newline)
   (display b)
   (newline)
   (display c)
   (newline)
   (display d)
   (newline)
   (display d)
   (newline)
   'ok)

(f 'a (begin (display "b-l") 'b) 'c (begin (display "d-l") 'd))
(exit)
#+end_example


#+header: :stdin s-lazy-input-semilazy
#+begin_src shell :shebang "#! /usr/bin/chibi-scheme" :results output scalar code :exports both
<<s-glue1>>
<<put-and-get>>
<<s-lazy-eval-implementation>>
<<s-lazy-eval-installation>>
<<s-lazy-apply-semilazy>>
<<s-lazy-actual-value>>
<<s-lazy-if>>
<<s-sequences-lazy-eager>>
<<s-assignment>>
<<s-define>>
<<s-syntax>>
<<s-application>>
<<s-cond-with-arrow>>
<<s-truefalse>>
<<s-compound-procedures-semilazy>>
<<s-environments>>
<<s-primitive-procedures>>
<<s-lazy-thunks-semilazy>>
<<s-lazy-driver-loop>>
<<s-glue2>>

(driver-loop)
#+end_src

#+RESULTS[d4695938b8150c07d8b1be98051eb862f9dbbc99]:
#+begin_src shell
;;; L-Eval input:
(define (f a (b lazy) c (d lazy-memo))
  (newline)
  (display a)
  (newline)
  (display b)
  (newline)
  (display b)
  (newline)
  (display c)
  (newline)
  (display d)
  (newline)
  (display d)
  (newline)
  'ok)
;;; L-Eval value:
ok
;;; L-Eval input:
(f 'a (begin (display "b-l") 'b) 'c (begin (display "d-l") 'd))

a
b-lb
b-lb
c
d-ld
d
;;; L-Eval value:
ok
;;; L-Eval input:
(exit)
#+end_src

Seems to be working like charm. I feel myself immensely proud.


**** 4.2.3 Streams as Lazy Lists
***** Common code

The next code requires a fully lazy evaluator.

#+name: s-lazy-input-streams-test
#+begin_example
  (define (cons x y) (lambda (m) (m x y)))
  (define (car z) (z (lambda (p q) p)))
  (define (cdr z) (z (lambda (p q) q)))
  (define (list-ref items n)
    (if (= n 0)
	(car items)
	(list-ref (cdr items) (- n 1))))
  (define (map proc items)
    (if (null? items)
	'()
	(cons (proc (car items)) (map proc (cdr items)))))
  (define (scale-list items factor)
    (map (lambda (x) (* x factor)) items))
  (define (add-lists list1 list2)
    (cond ((null? list1) list2)
	  ((null? list2) list1)
	  (else (cons (+ (car list1) (car list2))
		      (add-lists (cdr list1) (cdr list2))))))
  (define ones (cons 1 ones))
  (define integers (cons 1 (add-lists ones integers)))
(list-ref integers 17)

(define (integral integrand initial-value dt)
(define int
(cons initial-value
(add-lists (scale-list integrand dt) int)))
int)
(define (solve f y0 dt)
(define
y (integral dy y0 dt))
(define dy (map f y))
y)
(list-ref (solve (lambda (x) x) 1 0.001) 1000)
(exit)
#+end_example

#+header: :stdin s-lazy-input-streams-test
#+begin_src shell :shebang "#! /usr/bin/chibi-scheme" :results output scalar code :exports both
<<s-glue1>>
<<put-and-get>>
<<s-lazy-eval-implementation>>
<<s-lazy-eval-installation>>
<<s-lazy-apply>>
<<s-lazy-actual-value>>
<<s-lazy-if>>
<<s-sequences>>
<<s-assignment>>
<<s-define>>
<<s-syntax>>
<<s-application>>
<<s-cond-with-arrow>>
<<s-truefalse>>
<<s-compound-procedures>>
<<s-environments>>
<<s-primitive-procedures>>
<<s-lazy-thunks>>
<<s-lazy-force-it-memoizing>>
<<s-lazy-driver-loop>>
<<s-glue2>>

(driver-loop)

#+end_src

#+RESULTS[04a5dbe63263bc52aa55cbeb41fe4c0ca3fa1707]:
#+begin_src shell
;;; L-Eval input:
(define (cons x y) (lambda (m) (m x y)))
;;; L-Eval value:
ok
;;; L-Eval input:
(define (car z) (z (lambda (p q) p)))
;;; L-Eval value:
ok
;;; L-Eval input:
(define (cdr z) (z (lambda (p q) q)))
;;; L-Eval value:
ok
;;; L-Eval input:
(define (list-ref items n)
  (if (= n 0) (car items) (list-ref (cdr items) (- n 1))))
;;; L-Eval value:
ok
;;; L-Eval input:
(define (map proc items)
  (if (null? items) '() (cons (proc (car items)) (map proc (cdr items)))))
;;; L-Eval value:
ok
;;; L-Eval input:
(define (scale-list items factor) (map (lambda (x) (* x factor)) items))
;;; L-Eval value:
ok
;;; L-Eval input:
(define (add-lists list1 list2)
  (cond ((null? list1) list2)
        ((null? list2) list1)
        (else
         (cons (+ (car list1) (car list2))
               (add-lists (cdr list1) (cdr list2))))))
;;; L-Eval value:
ok
;;; L-Eval input:
(define ones (cons 1 ones))
;;; L-Eval value:
ok
;;; L-Eval input:
(define integers (cons 1 (add-lists ones integers)))
;;; L-Eval value:
ok
;;; L-Eval input:
(list-ref integers 17)
;;; L-Eval value:
18
;;; L-Eval input:
(define (integral integrand initial-value dt)
  (define int (cons initial-value (add-lists (scale-list integrand dt) int)))
  int)
;;; L-Eval value:
ok
;;; L-Eval input:
(define (solve f y0 dt)
  (define y (integral dy y0 dt))
  (define dy (map f y))
  y)
;;; L-Eval value:
ok
;;; L-Eval input:
(list-ref (solve (lambda (x) x) 1 0.001) 1000)
;;; L-Eval value:
2.716923932235896
;;; L-Eval input:
(exit)
#+end_src

Seems to work.

***** DONE Exercise 4.32 streams versus lazy lists
      CLOSED: [2020-02-16 Sun 11:49]

#+name: s-lazy-input-streams-trees
#+begin_example
  (define (cons x y) (lambda (m) (m x y)))
  (define (car z) (z (lambda (p q) p)))
  (define (cdr z) (z (lambda (p q) q)))
  (define (list-ref items n)
    (if (= n 0)
	(car items)
	(list-ref (cdr items) (- n 1))))
  (define (map proc items)
    (if (null? items)
	'()
	(cons (proc (car items)) (map proc (cdr items)))))
  (define (scale-list items factor)
    (map (lambda (x) (* x factor)) items))
  (define (add-lists list1 list2)
    (cond ((null? list1) list2)
	  ((null? list2) list1)
	  (else (cons (+ (car list1) (car list2))
		      (add-lists (cdr list1) (cdr list2))))))
  (define ones (cons 1 ones))
  (define integers (cons 1 (add-lists ones integers)))

  (define node (cons 1 p))
  (define p (cons 1 (cons p p)))

  (define (print-tree tree depth rightmost)
    (if (= depth 0)
        'ok
        (begin
          (display (car tree))

          (print-tree (car (cdr tree)) (- depth 1) #f)
          (if rightmost (newline))
          (print-tree (cdr (cdr tree)) (- depth 1) (if rightmost #t #f))

          ))
    'ok)
(begin (newline) (print-tree p 5 #t))
(exit)
#+end_example

#+header: :stdin s-lazy-input-streams-trees
#+begin_src shell :shebang "#! /usr/bin/chibi-scheme" :results output scalar code :exports both
<<s-glue1>>
<<put-and-get>>
<<s-lazy-eval-implementation>>
<<s-lazy-eval-installation>>
<<s-lazy-apply>>
<<s-lazy-actual-value>>
<<s-lazy-if>>
<<s-sequences>>
<<s-assignment>>
<<s-define>>
<<s-syntax>>
<<s-application>>
<<s-cond-with-arrow>>
<<s-truefalse>>
<<s-compound-procedures>>
<<s-environments>>
<<s-primitive-procedures>>
<<s-lazy-thunks>>
<<s-lazy-force-it-memoizing>>
<<s-lazy-driver-loop>>
<<s-glue2>>

(driver-loop)

#+end_src

#+RESULTS[4c9c2467ec754a16147936722852e7be589a0640]:
#+begin_src shell
;;; L-Eval input:
(define (cons x y) (lambda (m) (m x y)))
;;; L-Eval value:
ok
;;; L-Eval input:
(define (car z) (z (lambda (p q) p)))
;;; L-Eval value:
ok
;;; L-Eval input:
(define (cdr z) (z (lambda (p q) q)))
;;; L-Eval value:
ok
;;; L-Eval input:
(define (list-ref items n)
  (if (= n 0) (car items) (list-ref (cdr items) (- n 1))))
;;; L-Eval value:
ok
;;; L-Eval input:
(define (map proc items)
  (if (null? items) '() (cons (proc (car items)) (map proc (cdr items)))))
;;; L-Eval value:
ok
;;; L-Eval input:
(define (scale-list items factor) (map (lambda (x) (* x factor)) items))
;;; L-Eval value:
ok
;;; L-Eval input:
(define (add-lists list1 list2)
  (cond ((null? list1) list2)
        ((null? list2) list1)
        (else
         (cons (+ (car list1) (car list2))
               (add-lists (cdr list1) (cdr list2))))))
;;; L-Eval value:
ok
;;; L-Eval input:
(define ones (cons 1 ones))
;;; L-Eval value:
ok
;;; L-Eval input:
(define integers (cons 1 (add-lists ones integers)))
;;; L-Eval value:
ok
;;; L-Eval input:
(define node (cons 1 p))
;;; L-Eval value:
ok
;;; L-Eval input:
(define p (cons 1 (cons p p)))
;;; L-Eval value:
ok
;;; L-Eval input:
(define (print-tree tree depth rightmost)
  (if (= depth 0)
      'ok
      (begin (display (car tree))
             (print-tree (car (cdr tree)) (- depth 1) #f)
             (if rightmost (newline))
             (print-tree (cdr (cdr tree)) (- depth 1) (if rightmost #t #f))))
  'ok)
;;; L-Eval value:
ok
;;; L-Eval input:
(begin (newline) (print-tree p 5 #t))

1111111111111111
11111111
1111
11
1
;;; L-Eval value:
ok
;;; L-Eval input:
(exit)
#+end_src

Yay, a tree. You can't do it with simple "streams".

***** DONE Exercise 4.33 quoted lazy lists
      CLOSED: [2020-02-16 Sun 14:09]

#+name: s-lazy-quote-to-lazy-list
#+begin_src scheme :exports code :results none
  #;(put 'eval 'quote (lambda (exp env) (text-of-quotation exp)))
  (put 'eval 'quote (lambda (exp env)
		      (let ((text (text-of-quotation exp)))
			(if (or (null? text) (not (list? text)))
			    text
			    (eval (list 'cons  (list 'quote (car text))
					(list 'quote (cdr text)))  env)))))

#+end_src

#+name: s-lazy-input-lazy-quote
#+begin_example
(define test1 (quote (test input1 input2)))
(quote (test input1 input2))

  (define (cons x y) (lambda (m) (m x y)))
  (define (car z) (z (lambda (p q) p)))
  (define (cdr z) (z (lambda (p q) q)))
  (define (list-ref items n)
    (if (= n 0)
	(car items)
	(list-ref (cdr items) (- n 1))))
  (define (map proc items)
    (if (null? items)
	'()
	(cons (proc (car items)) (map proc (cdr items)))))
  (define (scale-list items factor)
    (map (lambda (x) (* x factor)) items))
  (define (add-lists list1 list2)
    (cond ((null? list1) list2)
	  ((null? list2) list1)
	  (else (cons (+ (car list1) (car list2))
		      (add-lists (cdr list1) (cdr list2))))))
  (define ones (cons 1 ones))
  (define integers (cons 1 (add-lists ones integers)))
"Testing Ben's work"
(car '(a b c))
(quote '(a b c))
(exit)
#+end_example


#+header: :stdin s-lazy-input-lazy-quote
#+begin_src shell :shebang "#! /usr/bin/chibi-scheme" :results output scalar code :exports both
<<s-glue1>>
<<put-and-get>>
<<s-lazy-eval-implementation>>
<<s-lazy-eval-installation>>
<<s-lazy-quote-to-lazy-list>>
<<s-lazy-apply>>
<<s-lazy-actual-value>>
<<s-lazy-if>>
<<s-sequences>>
<<s-assignment>>
<<s-define>>
<<s-syntax>>
<<s-application>>
<<s-cond-with-arrow>>
<<s-truefalse>>
<<s-compound-procedures>>
<<s-environments>>
<<s-primitive-procedures>>
<<s-lazy-thunks>>
<<s-lazy-force-it-memoizing>>
<<s-lazy-driver-loop>>
<<s-glue2>>

(driver-loop)

#+end_src

#+RESULTS[755fb7dac9701068cfaa8a28e8d139a23658496d]:
#+begin_src shell
;;; L-Eval input:
(define test1 '(test input1 input2))
;;; L-Eval value:
ok
;;; L-Eval input:
'(test input1 input2)
;;; L-Eval value:
(test input1 input2)
;;; L-Eval input:
(define (cons x y) (lambda (m) (m x y)))
;;; L-Eval value:
ok
;;; L-Eval input:
(define (car z) (z (lambda (p q) p)))
;;; L-Eval value:
ok
;;; L-Eval input:
(define (cdr z) (z (lambda (p q) q)))
;;; L-Eval value:
ok
;;; L-Eval input:
(define (list-ref items n)
  (if (= n 0) (car items) (list-ref (cdr items) (- n 1))))
;;; L-Eval value:
ok
;;; L-Eval input:
(define (map proc items)
  (if (null? items) '() (cons (proc (car items)) (map proc (cdr items)))))
;;; L-Eval value:
ok
;;; L-Eval input:
(define (scale-list items factor) (map (lambda (x) (* x factor)) items))
;;; L-Eval value:
ok
;;; L-Eval input:
(define (add-lists list1 list2)
  (cond ((null? list1) list2)
        ((null? list2) list1)
        (else
         (cons (+ (car list1) (car list2))
               (add-lists (cdr list1) (cdr list2))))))
;;; L-Eval value:
ok
;;; L-Eval input:
(define ones (cons 1 ones))
;;; L-Eval value:
ok
;;; L-Eval input:
(define integers (cons 1 (add-lists ones integers)))
;;; L-Eval value:
ok
;;; L-Eval input:
"Testing Ben's work"
;;; L-Eval value:
"Testing Ben's work"
;;; L-Eval input:
(car '(a b c))
;;; L-Eval value:
a
;;; L-Eval input:
''(a b c)
;;; L-Eval value:
(compound-procedure (m) ((m x y)) <procedure-env>)
;;; L-Eval input:
(exit)
#+end_src

I kind of like this solution, because it allows you to redefine
~cons~, ~car~ and ~cdr~, and you are automatically getting the quote
redefined the way you want.

***** DONE Exercise 4.34 printing lazy lists
      CLOSED: [2020-02-16 Sun 19:25]

I will set the default depth of printing to 10 just because it seems reasonable.

#+name: s-lazy-driver-loop-with-lazy-pairs
#+begin_src scheme :exports code :results none
  (define input-prompt ";;; L-Eval input:")
  (define output-prompt ";;; L-Eval value:")
  (define (driver-loop)
    (prompt-for-input input-prompt)
    (let ((input (read)))
      (user-print input)
      (let ((output (actual-value
                       input the-global-environment)))
	(announce-output output-prompt)
	(user-print output)))
    (driver-loop))
  (define (prompt-for-input string)
    (newline) (newline) (display string) (newline))
  (define (announce-output string)
    (newline) (display string) (newline))
  (define (lazy-pair? o) (tagged-list? o 'lazy-pair))
  (define (user-print object)
    (cond ((compound-procedure? object)
	     (show #t (pretty  (list 'compound-procedure
		       (procedure-parameters object)
		       (procedure-body object)
		       '<procedure-env>))))
          ((lazy-pair? object ) (apply (cdr object) (list "bla" 0)
                                      (procedure-environment (cdr object))))
	  (else (show #t (pretty object)))))
#+end_src


#+name: s-lazy-input-lazy-list-print
#+begin_example

(define test1 (quote (test input1 input2)))
(quote (test input1 input2))
(define kons cons)
(define kar car)
(define kdr cdr)
(define (tagged-list? exp tag)
            (if (pair? exp)
                (eq? (kar exp) tag)
                #f))
(define (lazy-pair? x) (tagged-list? x 'lazy-pair))
  (define (cons x y)
     (let ((already-printed #f))
        (define (print depth)
           (if already-printed
               (begin (display "#=")
                      (display already-printed))
               (begin (set! already-printed depth)
                      (display "[")
                      (display already-printed)
                      (display "]")
                      (display "(")
                      (if (lazy-pair? x)
                         (if (< depth 30)
                           ((kdr x) "print" (+ depth 1))
                           (display "..."))
                         (display x))
                      (display ",")
                      (if (lazy-pair? y)
                         (if (< depth 30)
                           ((kdr y) "print" (+ depth 1))
                           (display "..."))
                         (display y))
                      (display ")")
                      (set! already-printed #f))))
        (kons 'lazy-pair
           (lambda (m d)
               (if (null? d)
                     (m x y)
                 (print d))))))
  (define (car z) ((kdr z) (lambda (p q) p) (list)))
  (define (cdr z) ((kdr z) (lambda (p q) q) (list)))

  (define (list-ref items n)
    (if (= n 0)
	(car items)
	(list-ref (cdr items) (- n 1))))
  (define (map proc items)
    (if (null? items)
	'()
	(cons (proc (car items)) (map proc (cdr items)))))
  (define (scale-list items factor)
    (map (lambda (x) (* x factor)) items))
  (define (add-lists list1 list2)
    (cond ((null? list1) list2)
	  ((null? list2) list1)
	  (else (cons (+ (car list1) (car list2))
		      (add-lists (cdr list1) (cdr list2))))))
  (define ones (cons 1 ones))
  (define integers (cons 1 (add-lists ones integers)))
"Testing Ben's work"
(car '(a b c))
'(a b c d e f)
(exit)
#+end_example


#+header: :stdin s-lazy-input-lazy-list-print
#+begin_src shell :shebang "#! /usr/bin/chibi-scheme" :results output scalar code :exports both

<<s-glue1>>
<<put-and-get>>
<<s-lazy-eval-implementation>>
<<s-lazy-eval-installation>>
<<s-lazy-quote-to-lazy-list>>
<<s-lazy-apply>>
<<s-lazy-actual-value>>
<<s-lazy-if>>
<<s-sequences-lazy-eager>>
<<s-assignment>>
<<s-define>>
<<s-syntax>>
<<s-application>>
<<s-cond-with-arrow>>
<<s-let>>
<<s-truefalse>>
<<s-compound-procedures>>
<<s-environments>>
<<s-primitive-procedures>>
<<s-lazy-thunks>>
<<s-lazy-force-it-memoizing>>
<<s-lazy-driver-loop-with-lazy-pairs>>
<<s-glue2>>

(driver-loop)

#+end_src

#+RESULTS[09a02f6ed6e773e7a5a5155d16ed8849fa53ce70]:
#+begin_src shell


;;; L-Eval input:
(define test1 '(test input1 input2))

;;; L-Eval value:
ok


;;; L-Eval input:
'(test input1 input2)

;;; L-Eval value:
(test input1 input2)


;;; L-Eval input:
(define kons cons)

;;; L-Eval value:
ok


;;; L-Eval input:
(define kar car)

;;; L-Eval value:
ok


;;; L-Eval input:
(define kdr cdr)

;;; L-Eval value:
ok


;;; L-Eval input:
(define (tagged-list? exp tag) (if (pair? exp) (eq? (kar exp) tag) #f))

;;; L-Eval value:
ok


;;; L-Eval input:
(define (lazy-pair? x) (tagged-list? x 'lazy-pair))

;;; L-Eval value:
ok


;;; L-Eval input:
(define (cons x y)
  (let ((already-printed #f))
    (define (print depth)
      (if already-printed
          (begin (display "#=") (display already-printed))
          (begin (set! already-printed depth)
                 (display "[")
                 (display already-printed)
                 (display "]")
                 (display "(")
                 (if (lazy-pair? x)
                     (if (< depth 30)
                         ((kdr x) "print" (+ depth 1))
                         (display "..."))
                     (display x))
                 (display ",")
                 (if (lazy-pair? y)
                     (if (< depth 30)
                         ((kdr y) "print" (+ depth 1))
                         (display "..."))
                     (display y))
                 (display ")")
                 (set! already-printed #f))))
    (kons 'lazy-pair (lambda (m d) (if (null? d) (m x y) (print d))))))

;;; L-Eval value:
ok


;;; L-Eval input:
(define (car z) ((kdr z) (lambda (p q) p) (list)))

;;; L-Eval value:
ok


;;; L-Eval input:
(define (cdr z) ((kdr z) (lambda (p q) q) (list)))

;;; L-Eval value:
ok


;;; L-Eval input:
(define (list-ref items n)
  (if (= n 0) (car items) (list-ref (cdr items) (- n 1))))

;;; L-Eval value:
ok


;;; L-Eval input:
(define (map proc items)
  (if (null? items) '() (cons (proc (car items)) (map proc (cdr items)))))

;;; L-Eval value:
ok


;;; L-Eval input:
(define (scale-list items factor) (map (lambda (x) (* x factor)) items))

;;; L-Eval value:
ok


;;; L-Eval input:
(define (add-lists list1 list2)
  (cond ((null? list1) list2)
        ((null? list2) list1)
        (else
         (cons (+ (car list1) (car list2))
               (add-lists (cdr list1) (cdr list2))))))

;;; L-Eval value:
ok


;;; L-Eval input:
(define ones (cons 1 ones))

;;; L-Eval value:
ok


;;; L-Eval input:
(define integers (cons 1 (add-lists ones integers)))

;;; L-Eval value:
ok


;;; L-Eval input:
"Testing Ben's work"

;;; L-Eval value:
"Testing Ben's work"


;;; L-Eval input:
(car '(a b c))

;;; L-Eval value:
a


;;; L-Eval input:
'(a b c d e f)

;;; L-Eval value:
[0](a,[1](b,[2](c,[3](d,[4](e,[5](f,()))))))

;;; L-Eval input:
(exit)
#+end_src

Well, this may be not the best, but still a meaningful solution. It
avoids infinite lists, is rather careful at printing cycles, prints
eager lists correctly, and it's only drawback is not being able to
distinguish between finite lazy lists and infinite ones.

**** IMPROV Needs exercises on (scheme lazy) library               :edition3:

*** 4.3 Variations on Scheme − Nondeterministic Computing [20/20]

Note. Very typical of this book, the first two subsections of this
section are impossible to pass without using the third one. So it is
advised that the third subsection is consulted first.

**** 4.3.1 Amb and Search [3/3]
Before solving anything in this section, ~amb~ must be
implemented. Therefore, it is recommended to study the section [[4.3.3
Implementing the ~amb~ Evaluator]], before doing this exercises.

***** Common code

The code below tests the interpreter with the examples from the book.

#+name: s-amb-input-require
#+begin_src scheme :exports code :results none
  (define (require p) (if (not p) (amb)))
#+end_src

#+name: s-amb-input-an-element-of
#+begin_src scheme :exports code :results none
  (define (an-element-of items)
    (require (not (null? items)))
    (amb (car items) (an-element-of (cdr items))))
  (define (an-integer-starting-from n)
    (amb n (an-integer-starting-from (+ n 1))))
#+end_src

#+name: s-amb-input-prime-sum-pair
#+begin_src scheme :exports code :results none
  (define (prime-sum-pair list1 list2)
    (let ((a (an-element-of list1))
	  (b (an-element-of list2)))
      (require (prime? (+ a b)))
      (list a b)))
#+end_src

#+name: s-input-prime-sum-pair-test
#+begin_src shell :exports code :results output
cat << EOF
<<expmod>>
<<fermat-primetest>>
<<fast-prime>>
(prime? 7)

<<s-amb-input-require>>
<<s-amb-input-an-element-of>>
<<s-amb-input-prime-sum-pair>>

(prime-sum-pair '(1 3 5 8) '(20 35 110))
try-again
try-again
try-again
(exit)
EOF
#+end_src

#+header: :stdin s-input-prime-sum-pair-test
#+begin_src shell :shebang "#! /usr/bin/chibi-scheme" :results output scalar code :exports both
<<s-glue1>>
<<s-amb-amb-implementation>>
<<s-amb-analyze-eval-with-let-amb-ramb>>
<<s-let-implementation>>
<<s-amb-simple-expressions>>
<<s-amb-analyze-if>>
<<s-amb-analyze-sequence>>
<<s-amb-analyze-definition>>
<<s-amb-analyze-assignment>>
<<s-amb-analyze-application>>
<<s-amb-get-args>>
<<s-amb-execute-application>>
<<s-amb-analyze-amb>>
<<s-amb-ramb>>
<<s-syntax>>
<<s-application>>
<<s-cond-with-arrow>>
<<s-truefalse>>
<<s-compound-procedures>>
<<s-environments-list-of-bindings-better-abstractions>>
<<s-primitive-procedures>>
<<s-amb-driver-loop>>
<<s-user-prompt-print>>
<<s-glue2>>

(driver-loop)

#+end_src

#+RESULTS[a76961703744621453b6cbb18caf81fa1f6683ca]:
#+begin_src shell

;;; Amb-Eval input:
(define (expmod base exp m) (cond ((= exp 0) 1) ((even? exp) (remainder (square (expmod base (/ exp 2) m)) m)) (else (remainder (* base (expmod base (- exp 1) m)) m))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (random x) (random-integer x))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (fermat-test n) (define (try-it a) (= (expmod a n n) a)) (try-it (+ 1 (random (- n 1)))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define prime-test fermat-test)
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (fast-prime? n times) (cond ((= times 0) true) ((prime-test n) (fast-prime? n (- times 1))) (else false)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define true #t)
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define false #f)
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (prime? x) (fast-prime? x 10))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(prime? 7)
;;; Starting a new problem 
;;; Amb-Eval value:
#t
;;; Amb-Eval input:
(define (require p) (if (not p) (amb)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (an-element-of items) (require (not (null? items))) (amb (car items) (an-element-of (cdr items))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (an-integer-starting-from n) (amb n (an-integer-starting-from (+ n 1))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (prime-sum-pair list1 list2) (let ((a (an-element-of list1)) (b (an-element-of list2))) (require (prime? (+ a b))) (list a b)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(prime-sum-pair (quote (1 3 5 8)) (quote (20 35 110)))
;;; Starting a new problem 
;;; Amb-Eval value:
(3 20)
;;; Amb-Eval input:
try-again
;;; Amb-Eval value:
(3 110)
;;; Amb-Eval input:
try-again
;;; Amb-Eval value:
(8 35)
;;; Amb-Eval input:
try-again
;;; There are no more values of

(prime-sum-pair (quote (1 3 5 8)) (quote (20 35 110)))
;;; Amb-Eval input:
(exit)
;;; Starting a new problem 
#+end_src


***** DONE Exercise 4.35 ~an-integer-between~ and Pythagorean triples
      CLOSED: [2020-02-17 Mon 17:25]

The next thing is better than just pack a list into an ~amb~, because
it doesn't require maintaining the full list in memory.

#+name: s-amb-input-an-integer-between
#+begin_src scheme :exports code
  (define (an-integer-between n k)
    (require (< n k))
    (amb n (an-integer-between (+ n 1) k)))
#+end_src

#+name: s-amb-input-a-pythagorean-triple
#+begin_src scheme :exports code
  (define (a-pythagorean-triple-between low high)
    (let ((i (an-integer-between low high)))
      (let ((j (an-integer-between i high)))
	(let ((k (an-integer-between j high)))
	  (require (= (+ (* i i) (* j j)) (* k k)))
	  (list i j k)))))
#+end_src

#+name: s-amb-input-pythagorean-triples
#+begin_src shell :results output :exports code
cat << EOF
<<expmod>>
<<fermat-primetest>>
<<fast-prime>>
(prime? 7)
<<s-amb-input-require>>
<<s-amb-input-an-element-of>>
<<s-amb-input-prime-sum-pair>>
(prime-sum-pair '(1 3 5 8) '(20 35 110))
try-again
try-again
try-again
"New problem"
<<s-amb-input-an-integer-between>>
<<s-amb-input-a-pythagorean-triple>>
(a-pythagorean-triple-between 0 10)
try-again
try-again
(exit)
EOF
#+end_src


#+header: :stdin s-amb-input-pythagorean-triples
#+begin_src shell :shebang "#! /usr/bin/chibi-scheme" :results output scalar code :exports both
<<s-glue1>>
<<s-amb-amb-implementation>>
<<s-amb-analyze-eval-with-let-amb-ramb>>
<<s-let-implementation>>
<<s-amb-simple-expressions>>
<<s-amb-analyze-if>>
<<s-amb-analyze-sequence>>
<<s-amb-analyze-definition>>
<<s-amb-analyze-assignment>>
<<s-amb-analyze-application>>
<<s-amb-get-args>>
<<s-amb-execute-application>>
<<s-amb-analyze-amb>>
<<s-amb-ramb>>
<<s-syntax>>
<<s-application>>
<<s-cond-with-arrow>>
<<s-truefalse>>
<<s-compound-procedures>>
<<s-environments-list-of-bindings-better-abstractions>>
<<s-primitive-procedures>>
<<s-amb-driver-loop>>
<<s-user-prompt-print>>
<<s-glue2>>

(driver-loop)

#+end_src

#+RESULTS[8e68db6ed838abbe78c5d26c198b0b87c624cd52]:
#+begin_src shell

;;; Amb-Eval input:
(define (expmod base exp m) (cond ((= exp 0) 1) ((even? exp) (remainder (square (expmod base (/ exp 2) m)) m)) (else (remainder (* base (expmod base (- exp 1) m)) m))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (random x) (random-integer x))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (fermat-test n) (define (try-it a) (= (expmod a n n) a)) (try-it (+ 1 (random (- n 1)))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define prime-test fermat-test)
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (fast-prime? n times) (cond ((= times 0) true) ((prime-test n) (fast-prime? n (- times 1))) (else false)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define true #t)
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define false #f)
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (prime? x) (fast-prime? x 10))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(prime? 7)
;;; Starting a new problem 
;;; Amb-Eval value:
#t
;;; Amb-Eval input:
(define (require p) (if (not p) (amb)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (an-element-of items) (require (not (null? items))) (amb (car items) (an-element-of (cdr items))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (an-integer-starting-from n) (amb n (an-integer-starting-from (+ n 1))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (prime-sum-pair list1 list2) (let ((a (an-element-of list1)) (b (an-element-of list2))) (require (prime? (+ a b))) (list a b)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(prime-sum-pair (quote (1 3 5 8)) (quote (20 35 110)))
;;; Starting a new problem 
;;; Amb-Eval value:
(3 20)
;;; Amb-Eval input:
try-again
;;; Amb-Eval value:
(3 110)
;;; Amb-Eval input:
try-again
;;; Amb-Eval value:
(8 35)
;;; Amb-Eval input:
try-again
;;; There are no more values of

(prime-sum-pair (quote (1 3 5 8)) (quote (20 35 110)))
;;; Amb-Eval input:
"New problem"
;;; Starting a new problem 
;;; Amb-Eval value:
"New problem"
;;; Amb-Eval input:
(define (an-integer-between n k) (require (< n k)) (amb n (an-integer-between (+ n 1) k)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (a-pythagorean-triple-between low high) (let ((i (an-integer-between low high))) (let ((j (an-integer-between i high))) (let ((k (an-integer-between j high))) (require (= (+ (* i i) (* j j)) (* k k))) (list i j k)))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(a-pythagorean-triple-between 0 10)
;;; Starting a new problem 
;;; Amb-Eval value:
(0 0 0)
;;; Amb-Eval input:
try-again
;;; Amb-Eval value:
(0 1 1)
;;; Amb-Eval input:
try-again
;;; Amb-Eval value:
(0 2 2)
;;; Amb-Eval input:
(exit)
;;; Starting a new problem 
#+end_src

***** DONE Exercise 4.36 infinite search for Pythagorean triples
      CLOSED: [2020-02-17 Mon 20:26]

The problem with the previous solution is that it searches the whole
range of ~k~ before failing on ~j~.

#+name: s-amb-input-infinite-triples-test
#+begin_src scheme :exports code :results none
  (define (a-pythagorean-triple-from start)
   (let ((k (an-integer-starting-from start)))
    (let ((j (an-integer-between 0 k)))
      (let ((i (an-integer-between 0 j)))
	  (require (= (+ (* i i) (* j j)) (* k k)))
	  (list i j k)))))
#+end_src

#+name: s-amb-input-pythagorean-triples-infinite
#+begin_src shell :exports code :results output scalar code
cat << EOF
<<expmod>>
<<fermat-primetest>>
<<fast-prime>>
(prime? 7)
<<s-amb-input-require>>
<<s-amb-input-an-element-of>>
<<s-amb-input-prime-sum-pair>>
(prime-sum-pair '(1 3 5 8) '(20 35 110))
try-again
try-again
try-again
"New problem"
<<s-amb-input-an-integer-between>>
<<s-amb-input-a-pythagorean-triple>>
<<s-amb-input-infinite-triples-test>>
(a-pythagorean-triple-from 0)
try-again
try-again
try-again
try-again

(exit)
EOF
#+end_src


#+header: :stdin s-amb-input-pythagorean-triples-infinite
#+begin_src shell :shebang "#! /usr/bin/chibi-scheme" :results output scalar code :exports both
<<s-glue1>>
<<s-amb-amb-implementation>>
<<s-amb-analyze-eval-with-let-amb-ramb>>
<<s-let-implementation>>
<<s-amb-simple-expressions>>
<<s-amb-analyze-if>>
<<s-amb-analyze-sequence>>
<<s-amb-analyze-definition>>
<<s-amb-analyze-assignment>>
<<s-amb-analyze-application>>
<<s-amb-get-args>>
<<s-amb-execute-application>>
<<s-amb-analyze-amb>>
<<s-amb-ramb>>
<<s-syntax>>
<<s-application>>
<<s-cond-with-arrow>>
<<s-truefalse>>
<<s-compound-procedures>>
<<s-environments-list-of-bindings-better-abstractions>>
<<s-primitive-procedures>>
<<s-amb-driver-loop>>
<<s-user-prompt-print>>
<<s-glue2>>

(driver-loop)

#+end_src

#+RESULTS[28c4661b6aac1cc6ef0f1cdeeaeb01d7345dc254]:
#+begin_src shell

;;; Amb-Eval input:
(define (expmod base exp m) (cond ((= exp 0) 1) ((even? exp) (remainder (square (expmod base (/ exp 2) m)) m)) (else (remainder (* base (expmod base (- exp 1) m)) m))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (random x) (random-integer x))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (fermat-test n) (define (try-it a) (= (expmod a n n) a)) (try-it (+ 1 (random (- n 1)))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define prime-test fermat-test)
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (fast-prime? n times) (cond ((= times 0) true) ((prime-test n) (fast-prime? n (- times 1))) (else false)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define true #t)
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define false #f)
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (prime? x) (fast-prime? x 10))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(prime? 7)
;;; Starting a new problem 
;;; Amb-Eval value:
#t
;;; Amb-Eval input:
(define (require p) (if (not p) (amb)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (an-element-of items) (require (not (null? items))) (amb (car items) (an-element-of (cdr items))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (an-integer-starting-from n) (amb n (an-integer-starting-from (+ n 1))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (prime-sum-pair list1 list2) (let ((a (an-element-of list1)) (b (an-element-of list2))) (require (prime? (+ a b))) (list a b)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(prime-sum-pair (quote (1 3 5 8)) (quote (20 35 110)))
;;; Starting a new problem 
;;; Amb-Eval value:
(3 20)
;;; Amb-Eval input:
try-again
;;; Amb-Eval value:
(3 110)
;;; Amb-Eval input:
try-again
;;; Amb-Eval value:
(8 35)
;;; Amb-Eval input:
try-again
;;; There are no more values of

(prime-sum-pair (quote (1 3 5 8)) (quote (20 35 110)))
;;; Amb-Eval input:
"New problem"
;;; Starting a new problem 
;;; Amb-Eval value:
"New problem"
;;; Amb-Eval input:
(define (an-integer-between n k) (require (< n k)) (amb n (an-integer-between (+ n 1) k)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (a-pythagorean-triple-between low high) (let ((i (an-integer-between low high))) (let ((j (an-integer-between i high))) (let ((k (an-integer-between j high))) (require (= (+ (* i i) (* j j)) (* k k))) (list i j k)))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (a-pythagorean-triple-from start) (let ((k (an-integer-starting-from start))) (let ((j (an-integer-between 0 k))) (let ((i (an-integer-between 0 j))) (require (= (+ (* i i) (* j j)) (* k k))) (list i j k)))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(a-pythagorean-triple-from 0)
;;; Starting a new problem 
;;; Amb-Eval value:
(3 4 5)
;;; Amb-Eval input:
try-again
;;; Amb-Eval value:
(6 8 10)
;;; Amb-Eval input:
try-again
;;; Amb-Eval value:
(5 12 13)
;;; Amb-Eval input:
try-again
;;; Amb-Eval value:
(9 12 15)
;;; Amb-Eval input:
try-again
;;; Amb-Eval value:
(8 15 17)
;;; Amb-Eval input:
(exit)
;;; Starting a new problem 
#+end_src

Works like charm.

***** DONE Exercise 4.37 another method for triples
      CLOSED: [2020-02-17 Mon 21:17]

The original method requires \(O(n(n-1)(n-2))\) operations. Ben's
method requires \(O(n(n-1)s(n^{2}))\) operations, where s is the number
of operations needed to implement ~sqrt~, and if the algorithm we use
to implement ~sqrt~ is exact or inexact.

**** 4.3.2 Examples of Nondeterministic Programming [12/12]
***** Common code

#+name: s-amb-distinct
#+begin_src scheme :exports code :results none
  (define (distinct? items)
    (cond ((null? items) true)
	  ((null? (cdr items)) true)
	  ((member (car items) (cdr items)) false)
	  (else (distinct? (cdr items)))))
#+end_src

#+name: s-amb-multiple-dwelling-example
#+begin_src scheme :exports code :results none
  (define (multiple-dwelling)
    (let ((baker
	   (amb 1 2 3 4 5)) (cooper (amb 1 2 3 4 5))
	   (fletcher (amb 1 2 3 4 5)) (miller (amb 1 2 3 4 5))
	   (smith
	    (amb 1 2 3 4 5)))
      (require
       (distinct? (list baker cooper fletcher miller smith)))
      (require (not (= baker 5)))
      (require (not (= cooper 1)))
      (require (not (= fletcher 5)))
      (require (not (= fletcher 1)))
      (require (> miller cooper))
      (require (not (= (abs (- smith fletcher)) 1)))
      (require (not (= (abs (- fletcher cooper)) 1)))
      (list (list 'baker baker)
	    (list 'cooper cooper)
	    (list 'fletcher fletcher) (list 'miller miller)
	    (list 'smith smith))))
#+end_src

#+name: s-amb-input-multiple-dwelling-example
#+begin_src shell :exports code :results output scalar code
cat << EOF
<<s-amb-input-require>>
<<s-amb-input-an-element-of>>
<<s-amb-input-prime-sum-pair>>
<<s-amb-input-an-integer-between>>
<<s-amb-input-a-pythagorean-triple>>
<<s-amb-input-infinite-triples-test>>
<<s-amb-distinct>>
<<s-amb-multiple-dwelling-example>>
(multiple-dwelling)
try-again
(exit)
EOF
#+end_src


#+header: :stdin s-amb-input-multiple-dwelling-example
#+begin_src shell :shebang "#! /usr/bin/chibi-scheme" :results output scalar code :exports both
<<s-glue1>>
<<s-amb-amb-implementation>>
<<s-amb-analyze-eval-with-let-amb-ramb>>
<<s-let-implementation>>
<<s-amb-simple-expressions>>
<<s-amb-analyze-if>>
<<s-amb-analyze-sequence>>
<<s-amb-analyze-definition>>
<<s-amb-analyze-assignment>>
<<s-amb-analyze-application>>
<<s-amb-get-args>>
<<s-amb-execute-application>>
<<s-amb-analyze-amb>>
<<s-amb-ramb>>
<<s-syntax>>
<<s-application>>
<<s-cond-with-arrow>>
<<s-truefalse>>
<<s-compound-procedures>>
<<s-environments-list-of-bindings-better-abstractions>>
<<s-primitive-procedures>>
<<s-amb-driver-loop>>
<<s-user-prompt-print>>
<<s-glue2>>

(driver-loop)

#+end_src

#+RESULTS[3a56eb61e7b8117f479495eb4f9f0522adfe38fa]:
#+begin_src shell

;;; Amb-Eval input:
(define (require p) (if (not p) (amb)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (an-element-of items) (require (not (null? items))) (amb (car items) (an-element-of (cdr items))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (an-integer-starting-from n) (amb n (an-integer-starting-from (+ n 1))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (prime-sum-pair list1 list2) (let ((a (an-element-of list1)) (b (an-element-of list2))) (require (prime? (+ a b))) (list a b)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (an-integer-between n k) (require (< n k)) (amb n (an-integer-between (+ n 1) k)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (a-pythagorean-triple-between low high) (let ((i (an-integer-between low high))) (let ((j (an-integer-between i high))) (let ((k (an-integer-between j high))) (require (= (+ (* i i) (* j j)) (* k k))) (list i j k)))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (a-pythagorean-triple-from start) (let ((k (an-integer-starting-from start))) (let ((j (an-integer-between 0 k))) (let ((i (an-integer-between 0 j))) (require (= (+ (* i i) (* j j)) (* k k))) (list i j k)))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (distinct? items) (cond ((null? items) true) ((null? (cdr items)) true) ((member (car items) (cdr items)) false) (else (distinct? (cdr items)))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (multiple-dwelling) (let ((baker (amb 1 2 3 4 5)) (cooper (amb 1 2 3 4 5)) (fletcher (amb 1 2 3 4 5)) (miller (amb 1 2 3 4 5)) (smith (amb 1 2 3 4 5))) (require (distinct? (list baker cooper fletcher miller smith))) (require (not (= baker 5))) (require (not (= cooper 1))) (require (not (= fletcher 5))) (require (not (= fletcher 1))) (require (> miller cooper)) (require (not (= (abs (- smith fletcher)) 1))) (require (not (= (abs (- fletcher cooper)) 1))) (list (list (quote baker) baker) (list (quote cooper) cooper) (list (quote fletcher) fletcher) (list (quote miller) miller) (list (quote smith) smith))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(multiple-dwelling)
;;; Starting a new problem 
;;; Amb-Eval value:
((baker 3) (cooper 2) (fletcher 4) (miller 5) (smith 1))
;;; Amb-Eval input:
try-again
;;; There are no more values of

(multiple-dwelling)
;;; Amb-Eval input:
(exit)
;;; Starting a new problem 
#+end_src

***** DONE Exercise 4.38 Logical puzzle - Not same floor
      CLOSED: [2020-02-17 Mon 21:56]

#+name: s-amb-input-multiple-dwelling-not-same-floor
#+begin_src shell :exports code :results output :exports code
cat << EOF
<<s-amb-input-require>>
<<s-amb-input-an-element-of>>
<<s-amb-input-prime-sum-pair>>
<<s-amb-input-an-integer-between>>
<<s-amb-input-a-pythagorean-triple>>
<<s-amb-input-infinite-triples-test>>
<<s-amb-distinct>>
  (define (multiple-dwelling)
    (let ((baker
	   (amb 1 2 3 4 5)) (cooper (amb 1 2 3 4 5))
	   (fletcher (amb 1 2 3 4 5)) (miller (amb 1 2 3 4 5))
	   (smith
	    (amb 1 2 3 4 5)))
      (require
       (distinct? (list baker cooper fletcher miller smith)))
      (require (not (= baker 5)))
      (require (not (= cooper 1)))
      (require (not (= fletcher 5)))
      (require (not (= fletcher 1)))
      (require (> miller cooper))

      (require (not (= (abs (- fletcher cooper)) 1)))
      (list (list 'baker baker)
	    (list 'cooper cooper)
	    (list 'fletcher fletcher) (list 'miller miller)
	    (list 'smith smith))))

(multiple-dwelling)
try-again
try-again
try-again
try-again
try-again
(exit)
EOF
#+end_src


#+header: :stdin s-amb-input-multiple-dwelling-not-same-floor
#+begin_src shell :shebang "#! /usr/bin/chibi-scheme" :results output scalar code :exports both
<<s-glue1>>
<<s-amb-amb-implementation>>
<<s-amb-analyze-eval-with-let-amb-ramb>>
<<s-let-implementation>>
<<s-amb-simple-expressions>>
<<s-amb-analyze-if>>
<<s-amb-analyze-sequence>>
<<s-amb-analyze-definition>>
<<s-amb-analyze-assignment>>
<<s-amb-analyze-application>>
<<s-amb-get-args>>
<<s-amb-execute-application>>
<<s-amb-analyze-amb>>
<<s-amb-ramb>>
<<s-syntax>>
<<s-application>>
<<s-cond-with-arrow>>
<<s-truefalse>>
<<s-compound-procedures>>
<<s-environments-list-of-bindings-better-abstractions>>
<<s-primitive-procedures>>
<<s-amb-driver-loop>>
<<s-user-prompt-print>>
<<s-glue2>>

(driver-loop)

#+end_src

#+RESULTS[78e842e7c412ebb238c653b0e46cd257a253f473]:
#+begin_src shell

;;; Amb-Eval input:
(define (require p) (if (not p) (amb)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (an-element-of items) (require (not (null? items))) (amb (car items) (an-element-of (cdr items))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (an-integer-starting-from n) (amb n (an-integer-starting-from (+ n 1))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (prime-sum-pair list1 list2) (let ((a (an-element-of list1)) (b (an-element-of list2))) (require (prime? (+ a b))) (list a b)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (an-integer-between n k) (require (< n k)) (amb n (an-integer-between (+ n 1) k)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (a-pythagorean-triple-between low high) (let ((i (an-integer-between low high))) (let ((j (an-integer-between i high))) (let ((k (an-integer-between j high))) (require (= (+ (* i i) (* j j)) (* k k))) (list i j k)))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (a-pythagorean-triple-from start) (let ((k (an-integer-starting-from start))) (let ((j (an-integer-between 0 k))) (let ((i (an-integer-between 0 j))) (require (= (+ (* i i) (* j j)) (* k k))) (list i j k)))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (distinct? items) (cond ((null? items) true) ((null? (cdr items)) true) ((member (car items) (cdr items)) false) (else (distinct? (cdr items)))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (multiple-dwelling) (let ((baker (amb 1 2 3 4 5)) (cooper (amb 1 2 3 4 5)) (fletcher (amb 1 2 3 4 5)) (miller (amb 1 2 3 4 5)) (smith (amb 1 2 3 4 5))) (require (distinct? (list baker cooper fletcher miller smith))) (require (not (= baker 5))) (require (not (= cooper 1))) (require (not (= fletcher 5))) (require (not (= fletcher 1))) (require (> miller cooper)) (require (not (= (abs (- fletcher cooper)) 1))) (list (list (quote baker) baker) (list (quote cooper) cooper) (list (quote fletcher) fletcher) (list (quote miller) miller) (list (quote smith) smith))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(multiple-dwelling)
;;; Starting a new problem 
;;; Amb-Eval value:
((baker 1) (cooper 2) (fletcher 4) (miller 3) (smith 5))
;;; Amb-Eval input:
try-again
;;; Amb-Eval value:
((baker 1) (cooper 2) (fletcher 4) (miller 5) (smith 3))
;;; Amb-Eval input:
try-again
;;; Amb-Eval value:
((baker 1) (cooper 4) (fletcher 2) (miller 5) (smith 3))
;;; Amb-Eval input:
try-again
;;; Amb-Eval value:
((baker 3) (cooper 2) (fletcher 4) (miller 5) (smith 1))
;;; Amb-Eval input:
try-again
;;; Amb-Eval value:
((baker 3) (cooper 4) (fletcher 2) (miller 5) (smith 1))
;;; Amb-Eval input:
try-again
;;; There are no more values of

(multiple-dwelling)
;;; Amb-Eval input:
(exit)
;;; Starting a new problem 
#+end_src

Apparently, there are 5 solutions.

***** DONE Exercise 4.39 Order of restrictions
      CLOSED: [2020-02-17 Mon 22:01]
The order of restrictions affects the time required to find the answer.
This can be easily shown by adding a plain ~(amb)~ at the end of the
problem. This would make any problem have no solutions, but the last
~(amb)~ would require searching through the whole parameter set.
Speaking of the actual solution, I don't think so, since the whole
parameter set is searched exhaustively any way.

***** DONE Exercise 4.40 People to floor assignment
      CLOSED: [2020-02-17 Mon 22:29]
The amount of assignments without distinct floors is \(n^m\), where n
is the number of floors and m is the number of people. With distinct
floors it is \[\prod_i^m(n-i)\].

#+name: s-amb-input-multiple-dwelling-more-efficient
#+begin_src shell :exports code :results output scalar code
  cat << EOF
  <<s-amb-input-require>>
  <<s-amb-input-an-element-of>>
  <<s-amb-input-prime-sum-pair>>
  <<s-amb-input-an-integer-between>>
  <<s-amb-input-a-pythagorean-triple>>
  <<s-amb-input-infinite-triples-test>>
  <<s-amb-distinct>>
  (define (multiple-dwelling)
    (let ((baker (amb 1 2 3 4 5)))
      (require (not (= baker 5)))
      (let ((cooper (amb 1 2 3 4 5)))
	(require (not (= cooper 1)))
	(let ((miller (amb 1 2 3 4 5)))
	  (require (> miller cooper))
	  (let ((fletcher (amb 1 2 3 4 5)))
	    (require (not (= fletcher 5)))
	    (require (not (= fletcher 1)))
	    (require (not (= (abs (- fletcher cooper)) 1)))
	    (let ((smith(amb 1 2 3 4 5)))
	      (require (not (= (abs (- smith fletcher)) 1)))
	      (require (distinct? (list baker cooper fletcher miller smith)))
	      (list (list 'baker baker)
		    (list 'cooper cooper)
		    (list 'fletcher fletcher) (list 'miller miller)
		    (list 'smith smith))))))))

  (multiple-dwelling)
  try-again
  try-again
  try-again
  try-again
  try-again
  (exit)
  EOF
#+end_src


#+header: :stdin s-amb-input-multiple-dwelling-more-efficient
#+begin_src shell :shebang "#! /usr/bin/chibi-scheme" :results output scalar code :exports both
<<s-glue1>>
<<s-amb-amb-implementation>>
<<s-amb-analyze-eval-with-let-amb-ramb>>
<<s-let-implementation>>
<<s-amb-simple-expressions>>
<<s-amb-analyze-if>>
<<s-amb-analyze-sequence>>
<<s-amb-analyze-definition>>
<<s-amb-analyze-assignment>>
<<s-amb-analyze-application>>
<<s-amb-get-args>>
<<s-amb-execute-application>>
<<s-amb-analyze-amb>>
<<s-amb-ramb>>
<<s-syntax>>
<<s-application>>
<<s-cond-with-arrow>>
<<s-truefalse>>
<<s-compound-procedures>>
<<s-environments-list-of-bindings-better-abstractions>>
<<s-primitive-procedures>>
<<s-amb-driver-loop>>
<<s-user-prompt-print>>
<<s-glue2>>

(driver-loop)

#+end_src

#+RESULTS[9acc52fa8447d993dba16171372d8a68a25966e4]:
#+begin_src shell

;;; Amb-Eval input:
(define (require p) (if (not p) (amb)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (an-element-of items) (require (not (null? items))) (amb (car items) (an-element-of (cdr items))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (an-integer-starting-from n) (amb n (an-integer-starting-from (+ n 1))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (prime-sum-pair list1 list2) (let ((a (an-element-of list1)) (b (an-element-of list2))) (require (prime? (+ a b))) (list a b)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (an-integer-between n k) (require (< n k)) (amb n (an-integer-between (+ n 1) k)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (a-pythagorean-triple-between low high) (let ((i (an-integer-between low high))) (let ((j (an-integer-between i high))) (let ((k (an-integer-between j high))) (require (= (+ (* i i) (* j j)) (* k k))) (list i j k)))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (a-pythagorean-triple-from start) (let ((k (an-integer-starting-from start))) (let ((j (an-integer-between 0 k))) (let ((i (an-integer-between 0 j))) (require (= (+ (* i i) (* j j)) (* k k))) (list i j k)))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (distinct? items) (cond ((null? items) true) ((null? (cdr items)) true) ((member (car items) (cdr items)) false) (else (distinct? (cdr items)))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (multiple-dwelling) (let ((baker (amb 1 2 3 4 5))) (require (not (= baker 5))) (let ((cooper (amb 1 2 3 4 5))) (require (not (= cooper 1))) (let ((miller (amb 1 2 3 4 5))) (require (> miller cooper)) (let ((fletcher (amb 1 2 3 4 5))) (require (not (= fletcher 5))) (require (not (= fletcher 1))) (require (not (= (abs (- fletcher cooper)) 1))) (let ((smith (amb 1 2 3 4 5))) (require (not (= (abs (- smith fletcher)) 1))) (require (distinct? (list baker cooper fletcher miller smith))) (list (list (quote baker) baker) (list (quote cooper) cooper) (list (quote fletcher) fletcher) (list (quote miller) miller) (list (quote smith) smith))))))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(multiple-dwelling)
;;; Starting a new problem 
;;; Amb-Eval value:
((baker 3) (cooper 2) (fletcher 4) (miller 5) (smith 1))
;;; Amb-Eval input:
try-again
;;; There are no more values of

(multiple-dwelling)
;;; Amb-Eval input:
try-again
;;; There is no current problem
;;; Amb-Eval input:
try-again
;;; There is no current problem
;;; Amb-Eval input:
try-again
;;; There is no current problem
;;; Amb-Eval input:
try-again
;;; There is no current problem
;;; Amb-Eval input:
(exit)
;;; Starting a new problem 
#+end_src

Turned out to be easy.

***** DONE Exercise 4.41 Ordinary scheme to solve the problem
      CLOSED: [2020-02-18 Tue 00:12]

A long and painful exercise.

#+begin_src scheme :exports both :results output scalar code :exports both
  (define false #f)
  (define true #t)
  <<s-amb-distinct>>

  (display
   (let loop1
       ((baker '(1 2 3 4 5)))
     (let ((retval
	    (let loop2
		((cooper '(1 2 3 4 5)))
	      (let
		  ((retval
		    (let loop3
			((fletcher '(1 2 3 4 5)))
		      (let ((retval
			     (let loop4 ((miller '(1 2 3 4 5)))
			       (let ((retval
				      (let loop5 ((smith '(1 2 3 4 5)))
					(if (and (not (= (car    baker) 5))
						 (not (= (car   cooper) 5))
						 (not (= (car fletcher) 5))
						 (not (= (car fletcher) 1))
						 (not (< (car miller) (car cooper)))
						 (not (= (abs (- (car smith)
								 (car fletcher))) 1))
						 (not (= (abs (- (car fletcher)
								 (car cooper))) 1))
						 (distinct? (list (car baker)
								  (car cooper)
								  (car fletcher)
								  (car miller)
								  (car smith))))
					    (list (car baker) (car cooper)
						  (car fletcher) (car miller)
						  (car smith))
					    (if (null? (cdr smith))
						#f
						(loop5 (cdr smith)))))))
				 (if retval
				     retval
				     (if (null? (cdr miller))
					 #f
					 (loop4 (cdr miller))))))))
			(if retval
			    retval
			    (if (null? (cdr fletcher)) #f (loop3 (cdr fletcher))))))))
		(if retval
		    retval
		    (if (null? (cdr cooper)) #f (loop2 (cdr cooper))))))))
       (if retval
	   retval
	   (if (null? (cdr baker)) #f (loop1 (cdr baker)))))))
#+end_src

#+RESULTS[3f755fbe5dbcd4c6e4036e5602502074f64ac53e]:
#+begin_src scheme
(2 1 3 4 5)
#+end_src

***** DONE Exercise 4.42 The liars puzzle
      CLOSED: [2020-02-18 Tue 12:16]

The analyzing interpreter didn't include the ~and~ and ~or~
operations. Implementing them as functions is not really correct, but
will do for our purposes.

The idea of the ~xor~ function is from
http://community.schemewiki.org/?sicp-ex-4.42,
otherwise the solution is mine.

~xor~ can be a function because it always considers both arguments, so
this is even as efficient as a naive implementation can be.

#+name: s-amb-input-liars
#+begin_src shell :exports code :results output scalar code
  cat << EOF
  <<s-amb-input-require>>
  <<s-amb-input-an-element-of>>
  <<s-amb-input-prime-sum-pair>>
  <<s-amb-input-an-integer-between>>
  <<s-amb-input-a-pythagorean-triple>>
  <<s-amb-input-infinite-triples-test>>
  <<s-amb-distinct>>

(define (xor p q) (if p (not q) q))
  (define (liars)
    (let ((betty (amb 1 2 3 4 5)) (ethel (amb 1 2 3 4 5))
	   (joan (amb 1 2 3 4 5)) (kitty (amb 1 2 3 4 5))
	   (mary (amb 1 2 3 4 5)))
      (require (distinct? (list betty ethel joan kitty mary)))
      (require (xor (= kitty 2) (= betty 3)))
      (require (xor (= ethel 1) (= joan 2)))
      (require (xor (= joan 3) (= ethel 5)))
      (require (xor (= kitty 2) (= mary 4)))
      (require (xor (= mary 4)  (= betty 1)))

      (list (list 'betty betty)
	    (list 'ethel ethel)
	    (list 'joan joan)
            (list 'kitty kitty)
	    (list 'mary mary))))
  (liars)
  try-again
  (exit)
  EOF
#+end_src


#+header: :stdin s-amb-input-liars
#+begin_src shell :shebang "#! /usr/bin/chibi-scheme" :results output scalar code :exports both
<<s-glue1>>
<<s-amb-amb-implementation>>
<<s-amb-analyze-eval-with-let-amb-ramb>>
<<s-let-implementation>>
<<s-amb-simple-expressions>>
<<s-amb-analyze-if>>
<<s-amb-analyze-sequence>>
<<s-amb-analyze-definition>>
<<s-amb-analyze-assignment>>
<<s-amb-analyze-application>>
<<s-amb-get-args>>
<<s-amb-execute-application>>
<<s-amb-analyze-amb>>
<<s-amb-ramb>>
<<s-syntax>>
<<s-application>>
<<s-cond-with-arrow>>
<<s-truefalse>>
<<s-compound-procedures>>
<<s-environments-list-of-bindings-better-abstractions>>
<<s-primitive-procedures>>
<<s-amb-driver-loop>>
<<s-user-prompt-print>>
<<s-glue2>>

(driver-loop)

#+end_src

#+RESULTS[a080c969057b89348766fa4d2e75a3f3c44f54d5]:
#+begin_src shell

;;; Amb-Eval input:
(define (require p) (if (not p) (amb)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (an-element-of items) (require (not (null? items))) (amb (car items) (an-element-of (cdr items))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (an-integer-starting-from n) (amb n (an-integer-starting-from (+ n 1))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (prime-sum-pair list1 list2) (let ((a (an-element-of list1)) (b (an-element-of list2))) (require (prime? (+ a b))) (list a b)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (an-integer-between n k) (require (< n k)) (amb n (an-integer-between (+ n 1) k)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (a-pythagorean-triple-between low high) (let ((i (an-integer-between low high))) (let ((j (an-integer-between i high))) (let ((k (an-integer-between j high))) (require (= (+ (* i i) (* j j)) (* k k))) (list i j k)))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (a-pythagorean-triple-from start) (let ((k (an-integer-starting-from start))) (let ((j (an-integer-between 0 k))) (let ((i (an-integer-between 0 j))) (require (= (+ (* i i) (* j j)) (* k k))) (list i j k)))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (distinct? items) (cond ((null? items) true) ((null? (cdr items)) true) ((member (car items) (cdr items)) false) (else (distinct? (cdr items)))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (xor p q) (if p (not q) q))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (liars) (let ((betty (amb 1 2 3 4 5)) (ethel (amb 1 2 3 4 5)) (joan (amb 1 2 3 4 5)) (kitty (amb 1 2 3 4 5)) (mary (amb 1 2 3 4 5))) (require (distinct? (list betty ethel joan kitty mary))) (require (xor (= kitty 2) (= betty 3))) (require (xor (= ethel 1) (= joan 2))) (require (xor (= joan 3) (= ethel 5))) (require (xor (= kitty 2) (= mary 4))) (require (xor (= mary 4) (= betty 1))) (list (list (quote betty) betty) (list (quote ethel) ethel) (list (quote joan) joan) (list (quote kitty) kitty) (list (quote mary) mary))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(liars)
;;; Starting a new problem 
;;; Amb-Eval value:
((betty 3) (ethel 5) (joan 2) (kitty 1) (mary 4))
;;; Amb-Eval input:
try-again
;;; There are no more values of

(liars)
;;; Amb-Eval input:
(exit)
;;; Starting a new problem 
#+end_src

***** DONE Exercise 4.43 Problematical Recreations
      CLOSED: [2020-02-18 Tue 13:31]

#+name: s-amb-input-problematic-recreations
#+begin_src shell :exports code :results output scalar code
  cat << EOF
  <<s-amb-input-require>>
  <<s-amb-input-an-element-of>>
  <<s-amb-input-prime-sum-pair>>
  <<s-amb-input-an-integer-between>>
  <<s-amb-input-a-pythagorean-triple>>
  <<s-amb-input-infinite-triples-test>>
  <<s-amb-distinct>>

  (define (xor p q) (if p (not q) q))
  (define (problematic-recreations)
    (let ((moore   (list (amb 'maryann 'gabrielle 'lorna 'rosalind 'melissa)
			 (amb 'maryann 'gabrielle 'lorna 'rosalind 'melissa))))
      (require (distinct? moore))
      (require (eq? (car moore) 'maryann))
      (require (eq? (cadr moore) 'lorna))
      (let ((downing (list (amb 'maryann 'gabrielle 'lorna 'rosalind 'melissa)
			   (amb 'maryann 'gabrielle 'lorna 'rosalind 'melissa))))
	(require (distinct? downing))
	(require (eq? (cadr downing) 'melissa))
	(let ((hall    (list (amb 'maryann 'gabrielle 'lorna 'rosalind 'melissa)
			     (amb 'maryann 'gabrielle 'lorna 'rosalind 'melissa))))
	  (require (distinct? hall))
	  (require (eq? (cadr hall) 'rosalind))
	  (let ((hood    (list (amb 'maryann 'gabrielle 'lorna 'rosalind 'melissa)
			       (amb 'maryann 'gabrielle 'lorna 'rosalind 'melissa))))
	    (require (distinct? hood))
	    (require (eq? (cadr hood) 'gabrielle))
	    (require (eq? (car hood) 'melissa))
	    (let ((parker (list (amb 'maryann 'gabrielle 'lorna 'rosalind 'melissa)
				(amb 'maryann 'gabrielle 'lorna 'rosalind 'melissa))))
	      (require (distinct? parker))
	      (require (distinct? (list (car moore) (car downing) (car hall) (car hood) (car parker))))
	      (require (distinct? (list (cadr moore) (cadr downing) (cadr hall) (cadr hood) (cadr parker))))

	      (require (xor (not (eq? (car moore) 'gabrielle)) (eq? (cadr moore) (car parker))))
	      (require (xor (not (eq? (car downing) 'gabrielle)) (eq? (cadr downing) (car parker))))
	      (require (xor (not (eq? (car hall) 'gabrielle)) (eq? (cadr hall) (car parker))))
	      (require (xor (not (eq? (car hood) 'gabrielle)) (eq? (cadr hood) (car parker))))

	      (list (list 'moore moore)
		    (list 'downing downing)
		    (list 'hall hall)
		    (list 'hood hood)
		    (list 'parker parker))))))))
  (problematic-recreations)
  try-again
  (exit)
  EOF
#+end_src


#+header: :stdin s-amb-input-problematic-recreations
#+begin_src shell :shebang "#! /usr/bin/chibi-scheme" :results output scalar code :exports both
<<s-glue1>>
<<s-amb-amb-implementation>>
<<s-amb-analyze-eval-with-let-amb-ramb>>
<<s-let-implementation>>
<<s-amb-simple-expressions>>
<<s-amb-analyze-if>>
<<s-amb-analyze-sequence>>
<<s-amb-analyze-definition>>
<<s-amb-analyze-assignment>>
<<s-amb-analyze-application>>
<<s-amb-get-args>>
<<s-amb-execute-application>>
<<s-amb-analyze-amb>>
<<s-amb-ramb>>
<<s-syntax>>
<<s-application>>
<<s-cond-with-arrow>>
<<s-truefalse>>
<<s-compound-procedures>>
<<s-environments-list-of-bindings-better-abstractions>>
<<s-primitive-procedures>>
<<s-amb-driver-loop>>
<<s-user-prompt-print>>
<<s-glue2>>

(driver-loop)

#+end_src

#+RESULTS[88d1f6c78534f515db01de49f8e335f5fc69a301]:
#+begin_src shell

;;; Amb-Eval input:
(define (require p) (if (not p) (amb)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (an-element-of items) (require (not (null? items))) (amb (car items) (an-element-of (cdr items))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (an-integer-starting-from n) (amb n (an-integer-starting-from (+ n 1))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (prime-sum-pair list1 list2) (let ((a (an-element-of list1)) (b (an-element-of list2))) (require (prime? (+ a b))) (list a b)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (an-integer-between n k) (require (< n k)) (amb n (an-integer-between (+ n 1) k)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (a-pythagorean-triple-between low high) (let ((i (an-integer-between low high))) (let ((j (an-integer-between i high))) (let ((k (an-integer-between j high))) (require (= (+ (* i i) (* j j)) (* k k))) (list i j k)))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (a-pythagorean-triple-from start) (let ((k (an-integer-starting-from start))) (let ((j (an-integer-between 0 k))) (let ((i (an-integer-between 0 j))) (require (= (+ (* i i) (* j j)) (* k k))) (list i j k)))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (distinct? items) (cond ((null? items) true) ((null? (cdr items)) true) ((member (car items) (cdr items)) false) (else (distinct? (cdr items)))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (xor p q) (if p (not q) q))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (problematic-recreations) (let ((moore (list (amb (quote maryann) (quote gabrielle) (quote lorna) (quote rosalind) (quote melissa)) (amb (quote maryann) (quote gabrielle) (quote lorna) (quote rosalind) (quote melissa))))) (require (distinct? moore)) (require (eq? (car moore) (quote maryann))) (require (eq? (cadr moore) (quote lorna))) (let ((downing (list (amb (quote maryann) (quote gabrielle) (quote lorna) (quote rosalind) (quote melissa)) (amb (quote maryann) (quote gabrielle) (quote lorna) (quote rosalind) (quote melissa))))) (require (distinct? downing)) (require (eq? (cadr downing) (quote melissa))) (let ((hall (list (amb (quote maryann) (quote gabrielle) (quote lorna) (quote rosalind) (quote melissa)) (amb (quote maryann) (quote gabrielle) (quote lorna) (quote rosalind) (quote melissa))))) (require (distinct? hall)) (require (eq? (cadr hall) (quote rosalind))) (let ((hood (list (amb (quote maryann) (quote gabrielle) (quote lorna) (quote rosalind) (quote melissa)) (amb (quote maryann) (quote gabrielle) (quote lorna) (quote rosalind) (quote melissa))))) (require (distinct? hood)) (require (eq? (cadr hood) (quote gabrielle))) (require (eq? (car hood) (quote melissa))) (let ((parker (list (amb (quote maryann) (quote gabrielle) (quote lorna) (quote rosalind) (quote melissa)) (amb (quote maryann) (quote gabrielle) (quote lorna) (quote rosalind) (quote melissa))))) (require (distinct? parker)) (require (distinct? (list (car moore) (car downing) (car hall) (car hood) (car parker)))) (require (distinct? (list (cadr moore) (cadr downing) (cadr hall) (cadr hood) (cadr parker)))) (require (xor (not (eq? (car moore) (quote gabrielle))) (eq? (cadr moore) (car parker)))) (require (xor (not (eq? (car downing) (quote gabrielle))) (eq? (cadr downing) (car parker)))) (require (xor (not (eq? (car hall) (quote gabrielle))) (eq? (cadr hall) (car parker)))) (require (xor (not (eq? (car hood) (quote gabrielle))) (eq? (cadr hood) (car parker)))) (list (list (quote moore) moore) (list (quote downing) downing) (list (quote hall) hall) (list (quote hood) hood) (list (quote parker) parker))))))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(problematic-recreations)
;;; Starting a new problem 
;;; Amb-Eval value:
((moore (maryann lorna)) (downing (lorna melissa)) (hall (gabrielle rosalind)) (hood (melissa gabrielle)) (parker (rosalind maryann)))
;;; Amb-Eval input:
try-again
;;; There are no more values of

(problematic-recreations)
;;; Amb-Eval input:
(exit)
;;; Starting a new problem 
#+end_src

Turned out to be quite easy, although I think it could be made even
easier if I understood how to loop over the fathers' names.

The speed matters. Spreading ~require~'s over the nested loops helps a
lot. My first version with just one ~let~ couldn't finish in
reasonable time.

***** DONE Exercise 4.44 Nondeterministic eight queens
      CLOSED: [2020-02-18 Tue 15:17]

In this exercise be extra careful about adding a ~require~ _before_
calling the next recursion level, not after. This is the same speed
issue we had seen with all the ~amb~ exercises, and also i the
Exercise 4.43, the Louis's version of the eight queens.

#+name: s-amb-input-queens
#+begin_src shell :exports code :results output scalar code
  cat << EOF
  <<s-amb-input-require>>
  <<s-amb-input-an-element-of>>
  <<s-amb-input-prime-sum-pair>>
  <<s-amb-input-an-integer-between>>
  <<s-amb-input-a-pythagorean-triple>>
  <<s-amb-input-infinite-triples-test>>
  <<s-amb-distinct>>
  <<empty-board-adjoin-position-safe>>
  (define (xor p q) (if p (not q) q))

  (define (queens board-size)
     (define (queen-cols rest-of-queens k)
        (if (> k board-size)
          rest-of-queens
          (let ((new-row (an-integer-between 1 (+ 1 board-size))))
            (let ((retval (adjoin-position new-row k rest-of-queens)))
                (require (safe? k retval))
                (queen-cols retval (+ k 1))))))
   (queen-cols empty-board 1))
  (queens 8)
  try-again
  (exit)
  EOF
#+end_src


#+header: :stdin s-amb-input-queens
#+begin_src shell :shebang "#! /usr/bin/chibi-scheme" :results output scalar code :exports both
<<s-glue1>>
<<s-amb-amb-implementation>>
<<s-amb-analyze-eval-with-let-amb-ramb>>
<<s-let-implementation>>
<<s-amb-simple-expressions>>
<<s-amb-analyze-if>>
<<s-amb-analyze-sequence>>
<<s-amb-analyze-definition>>
<<s-amb-analyze-assignment>>
<<s-amb-analyze-application>>
<<s-amb-get-args>>
<<s-amb-execute-application>>
<<s-amb-analyze-amb>>
<<s-amb-ramb>>
<<s-syntax>>
<<s-application>>
<<s-cond-with-arrow>>
<<s-truefalse>>
<<s-compound-procedures>>
<<s-environments-list-of-bindings-better-abstractions>>
<<s-primitive-procedures>>
<<s-amb-driver-loop>>
<<s-user-prompt-print>>
<<s-glue2>>

(driver-loop)

#+end_src

#+RESULTS[1f404e5d83a731a2f5919c340ffae5f56e872bf5]:
#+begin_src shell

;;; Amb-Eval input:
(define (require p) (if (not p) (amb)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (an-element-of items) (require (not (null? items))) (amb (car items) (an-element-of (cdr items))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (an-integer-starting-from n) (amb n (an-integer-starting-from (+ n 1))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (prime-sum-pair list1 list2) (let ((a (an-element-of list1)) (b (an-element-of list2))) (require (prime? (+ a b))) (list a b)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (an-integer-between n k) (require (< n k)) (amb n (an-integer-between (+ n 1) k)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (a-pythagorean-triple-between low high) (let ((i (an-integer-between low high))) (let ((j (an-integer-between i high))) (let ((k (an-integer-between j high))) (require (= (+ (* i i) (* j j)) (* k k))) (list i j k)))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (a-pythagorean-triple-from start) (let ((k (an-integer-starting-from start))) (let ((j (an-integer-between 0 k))) (let ((i (an-integer-between 0 j))) (require (= (+ (* i i) (* j j)) (* k k))) (list i j k)))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (distinct? items) (cond ((null? items) true) ((null? (cdr items)) true) ((member (car items) (cdr items)) false) (else (distinct? (cdr items)))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define empty-board (quote ()))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (adjoin-position new-row k rest-of-queens) (cons (cons k new-row) rest-of-queens))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (safe? k positions) (cond ((null? (cdr positions)) #t) ((= k 1) #t) ((= (cdar positions) (cdadr positions)) #f) ((= (abs (- (cdar positions) (cdadr positions))) (abs (- (caar positions) (caadr positions)))) #f) (else (safe? k (cons (car positions) (cddr positions))))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (xor p q) (if p (not q) q))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (queens board-size) (define (queen-cols rest-of-queens k) (if (> k board-size) rest-of-queens (let ((new-row (an-integer-between 1 (+ 1 board-size)))) (let ((retval (adjoin-position new-row k rest-of-queens))) (require (safe? k retval)) (queen-cols retval (+ k 1)))))) (queen-cols empty-board 1))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(queens 8)
;;; Starting a new problem 
;;; Amb-Eval value:
((8 . 4) (7 . 2) (6 . 7) (5 . 3) (4 . 6) (3 . 8) (2 . 5) (1 . 1))
;;; Amb-Eval input:
try-again
;;; Amb-Eval value:
((8 . 5) (7 . 2) (6 . 4) (5 . 7) (4 . 3) (3 . 8) (2 . 6) (1 . 1))
;;; Amb-Eval input:
(exit)
;;; Starting a new problem 
#+end_src

***** Common code

#+name: natural-language-words
#+begin_src scheme :exports code :results none
  (define nouns '(noun student professor cat class))
  (define verbs '(verb studies lectures eats sleeps))
  (define articles '(article the a))
#+end_src

#+name: parse-sentence-1
#+begin_src scheme :exports code :results none
  (define (parse-sentence)
    (list 'sentence
	  (parse-noun-phrase)
	  (parse-word verbs)))
#+end_src

#+name: parse-noun-phrase-1
#+begin_src scheme :exports code :results none
  (define (parse-noun-phrase)
    (list 'noun-phrase
	  (parse-word articles)
	  (parse-word nouns)))
#+end_src

#+name: parse-word
#+begin_src scheme :exports code :results none
  (define (parse-word word-list)
    (require (not (null? *unparsed*)))
    (require (memq (car *unparsed*) (cdr word-list)))
    (let ((found-word (car *unparsed*)))
      (set! *unparsed* (cdr *unparsed*))
      (list (car word-list) found-word)))
#+end_src

#+name: parse-input
#+begin_src scheme :exports code :results none
  (define *unparsed* '())
  (define (parse input)
    (set! *unparsed* input)
    (let ((sent (parse-sentence)))
      (require (null? *unparsed*)) sent))
#+end_src

#+name: s-amb-input-parser-test-simple
#+begin_src shell :exports code :results output scalar code 
  cat << EOF
  <<s-amb-input-require>>
  <<s-amb-input-an-element-of>>
  <<s-amb-input-prime-sum-pair>>
  <<s-amb-input-an-integer-between>>
  <<s-amb-input-a-pythagorean-triple>>
  <<s-amb-input-infinite-triples-test>>
  <<s-amb-distinct>>
  <<empty-board-adjoin-position-safe>>
  <<natural-language-words>>
  <<parse-sentence-1>>
  <<parse-noun-phrase-1>>
  <<parse-word>>
  <<parse-input>>
  (parse '(the cat eats))
  try-again
  (exit)
  EOF
#+end_src



#+header: :stdin s-amb-input-parser-test-simple
#+begin_src shell :shebang "#! /usr/bin/chibi-scheme" :results output scalar code :exports both
<<s-glue1>>
<<s-amb-amb-implementation>>
<<s-amb-analyze-eval-with-let-amb-ramb>>
<<s-let-implementation>>
<<s-amb-simple-expressions>>
<<s-amb-analyze-if>>
<<s-amb-analyze-sequence>>
<<s-amb-analyze-definition>>
<<s-amb-analyze-assignment>>
<<s-amb-analyze-application>>
<<s-amb-get-args>>
<<s-amb-execute-application>>
<<s-amb-analyze-amb>>
<<s-amb-ramb>>
<<s-syntax>>
<<s-application>>
<<s-cond-with-arrow>>
<<s-truefalse>>
<<s-compound-procedures>>
<<s-environments-list-of-bindings-better-abstractions>>
<<s-primitive-procedures>>
<<s-amb-driver-loop>>
<<s-user-prompt-print>>
<<s-glue2>>

(driver-loop)

#+end_src

#+RESULTS[187453733b78b8e88882f2710f146325bdaa6421]:
#+begin_src shell

;;; Amb-Eval input:
(define (require p) (if (not p) (amb)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (an-element-of items) (require (not (null? items))) (amb (car items) (an-element-of (cdr items))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (an-integer-starting-from n) (amb n (an-integer-starting-from (+ n 1))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (prime-sum-pair list1 list2) (let ((a (an-element-of list1)) (b (an-element-of list2))) (require (prime? (+ a b))) (list a b)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (an-integer-between n k) (require (< n k)) (amb n (an-integer-between (+ n 1) k)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (a-pythagorean-triple-between low high) (let ((i (an-integer-between low high))) (let ((j (an-integer-between i high))) (let ((k (an-integer-between j high))) (require (= (+ (* i i) (* j j)) (* k k))) (list i j k)))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (a-pythagorean-triple-from start) (let ((k (an-integer-starting-from start))) (let ((j (an-integer-between 0 k))) (let ((i (an-integer-between 0 j))) (require (= (+ (* i i) (* j j)) (* k k))) (list i j k)))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (distinct? items) (cond ((null? items) true) ((null? (cdr items)) true) ((member (car items) (cdr items)) false) (else (distinct? (cdr items)))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define empty-board (quote ()))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (adjoin-position new-row k rest-of-queens) (cons (cons k new-row) rest-of-queens))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (safe? k positions) (cond ((null? (cdr positions)) #t) ((= k 1) #t) ((= (cdar positions) (cdadr positions)) #f) ((= (abs (- (cdar positions) (cdadr positions))) (abs (- (caar positions) (caadr positions)))) #f) (else (safe? k (cons (car positions) (cddr positions))))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define nouns (quote (noun student professor cat class)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define verbs (quote (verb studies lectures eats sleeps)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define articles (quote (article the a)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (parse-sentence) (list (quote sentence) (parse-noun-phrase) (parse-word verbs)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (parse-noun-phrase) (list (quote noun-phrase) (parse-word articles) (parse-word nouns)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (parse-word word-list) (require (not (null? *unparsed*))) (require (memq (car *unparsed*) (cdr word-list))) (let ((found-word (car *unparsed*))) (set! *unparsed* (cdr *unparsed*)) (list (car word-list) found-word)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define *unparsed* (quote ()))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (parse input) (set! *unparsed* input) (let ((sent (parse-sentence))) (require (null? *unparsed*)) sent))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(parse (quote (the cat eats)))
;;; Starting a new problem 
;;; Amb-Eval value:
(sentence (noun-phrase (article the) (noun cat)) (verb eats))
;;; Amb-Eval input:
try-again
;;; There are no more values of

(parse (quote (the cat eats)))
;;; Amb-Eval input:
(exit)
;;; Starting a new problem 
#+end_src

#+name: natural-language-prepositions
#+begin_src scheme :exports code :results none
  (define prepositions '(prep for to in by with))
#+end_src

#+name: parse-prepositional-phrase
#+begin_src scheme :exports code :results none
  (define (parse-prepositional-phrase)
    (list 'prep-phrase
	  (parse-word prepositions)
	  (parse-noun-phrase)))
#+end_src

#+name: parse-sentence-2
#+begin_src scheme :exports code :results none
  (define (parse-sentence)
    (list 'sentence (parse-noun-phrase) (parse-verb-phrase)))
#+end_src

#+name: parse-verb-phrase
#+begin_src scheme :exports code :results none
  (define (parse-verb-phrase)
    (define (maybe-extend verb-phrase)
      (amb verb-phrase
	   (maybe-extend
	    (list 'verb-phrase
		  verb-phrase
		  (parse-prepositional-phrase)))))
    (maybe-extend (parse-word verbs)))
#+end_src

#+name: parse-noun-phrase-2
#+begin_src scheme :exports code :results none
  (define (parse-simple-noun-phrase)
    (list 'simple-noun-phrase
	  (parse-word articles)
	  (parse-word nouns)))
  (define (parse-noun-phrase)
    (define (maybe-extend noun-phrase)
      (amb noun-phrase
	   (maybe-extend
	    (list 'noun-phrase
		  noun-phrase
		  (parse-prepositional-phrase)))))
    (maybe-extend (parse-simple-noun-phrase)))
#+end_src

#+name: s-amb-input-parser-test-better
#+begin_src shell :exports code :results output scalar code
  cat << EOF
  <<s-amb-input-require>>
  <<s-amb-input-an-element-of>>
  <<s-amb-input-prime-sum-pair>>
  <<s-amb-input-an-integer-between>>
  <<s-amb-input-a-pythagorean-triple>>
  <<s-amb-input-infinite-triples-test>>
  <<s-amb-distinct>>
  <<empty-board-adjoin-position-safe>>
  <<natural-language-words>>
  <<natural-language-prepositions>>
  <<parse-prepositional-phrase>>
  <<parse-sentence-2>>
  <<parse-verb-phrase>>
  <<parse-noun-phrase-2>>
  <<parse-word>>
  <<parse-input>>
  (parse '(the student with the cat sleeps in the class))
  try-again
  (parse '(the professor lectures to the student with the cat))
  try-again
  try-again
  (exit)
  EOF
#+end_src


#+header: :stdin s-amb-input-parser-test-better
#+begin_src shell :shebang "#! /usr/bin/chibi-scheme" :results output scalar code :exports both
<<s-glue1>>
<<s-amb-amb-implementation>>
<<s-amb-analyze-eval-with-let-amb-ramb>>
<<s-let-implementation>>
<<s-amb-simple-expressions>>
<<s-amb-analyze-if>>
<<s-amb-analyze-sequence>>
<<s-amb-analyze-definition>>
<<s-amb-analyze-assignment>>
<<s-amb-analyze-application>>
<<s-amb-get-args>>
<<s-amb-execute-application>>
<<s-amb-analyze-amb>>
<<s-amb-ramb>>
<<s-syntax>>
<<s-application>>
<<s-cond-with-arrow>>
<<s-truefalse>>
<<s-compound-procedures>>
<<s-environments-list-of-bindings-better-abstractions>>
<<s-primitive-procedures>>
<<s-amb-driver-loop>>
<<s-user-prompt-print>>
<<s-glue2>>

(driver-loop)

#+end_src

#+RESULTS[b76578a792ad0d34af8fd902458e2c516003db90]:
#+begin_src shell

;;; Amb-Eval input:
(define (require p) (if (not p) (amb)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (an-element-of items) (require (not (null? items))) (amb (car items) (an-element-of (cdr items))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (an-integer-starting-from n) (amb n (an-integer-starting-from (+ n 1))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (prime-sum-pair list1 list2) (let ((a (an-element-of list1)) (b (an-element-of list2))) (require (prime? (+ a b))) (list a b)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (an-integer-between n k) (require (< n k)) (amb n (an-integer-between (+ n 1) k)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (a-pythagorean-triple-between low high) (let ((i (an-integer-between low high))) (let ((j (an-integer-between i high))) (let ((k (an-integer-between j high))) (require (= (+ (* i i) (* j j)) (* k k))) (list i j k)))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (a-pythagorean-triple-from start) (let ((k (an-integer-starting-from start))) (let ((j (an-integer-between 0 k))) (let ((i (an-integer-between 0 j))) (require (= (+ (* i i) (* j j)) (* k k))) (list i j k)))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (distinct? items) (cond ((null? items) true) ((null? (cdr items)) true) ((member (car items) (cdr items)) false) (else (distinct? (cdr items)))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define empty-board (quote ()))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (adjoin-position new-row k rest-of-queens) (cons (cons k new-row) rest-of-queens))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (safe? k positions) (cond ((null? (cdr positions)) #t) ((= k 1) #t) ((= (cdar positions) (cdadr positions)) #f) ((= (abs (- (cdar positions) (cdadr positions))) (abs (- (caar positions) (caadr positions)))) #f) (else (safe? k (cons (car positions) (cddr positions))))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define nouns (quote (noun student professor cat class)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define verbs (quote (verb studies lectures eats sleeps)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define articles (quote (article the a)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define prepositions (quote (prep for to in by with)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (parse-prepositional-phrase) (list (quote prep-phrase) (parse-word prepositions) (parse-noun-phrase)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (parse-sentence) (list (quote sentence) (parse-noun-phrase) (parse-verb-phrase)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (parse-verb-phrase) (define (maybe-extend verb-phrase) (amb verb-phrase (maybe-extend (list (quote verb-phrase) verb-phrase (parse-prepositional-phrase))))) (maybe-extend (parse-word verbs)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (parse-simple-noun-phrase) (list (quote simple-noun-phrase) (parse-word articles) (parse-word nouns)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (parse-noun-phrase) (define (maybe-extend noun-phrase) (amb noun-phrase (maybe-extend (list (quote noun-phrase) noun-phrase (parse-prepositional-phrase))))) (maybe-extend (parse-simple-noun-phrase)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (parse-word word-list) (require (not (null? *unparsed*))) (require (memq (car *unparsed*) (cdr word-list))) (let ((found-word (car *unparsed*))) (set! *unparsed* (cdr *unparsed*)) (list (car word-list) found-word)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define *unparsed* (quote ()))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (parse input) (set! *unparsed* input) (let ((sent (parse-sentence))) (require (null? *unparsed*)) sent))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(parse (quote (the student with the cat sleeps in the class)))
;;; Starting a new problem 
;;; Amb-Eval value:
(sentence (noun-phrase (simple-noun-phrase (article the) (noun student)) (prep-phrase (prep with) (simple-noun-phrase (article the) (noun cat)))) (verb-phrase (verb sleeps) (prep-phrase (prep in) (simple-noun-phrase (article the) (noun class)))))
;;; Amb-Eval input:
try-again
;;; There are no more values of

(parse (quote (the student with the cat sleeps in the class)))
;;; Amb-Eval input:
(parse (quote (the professor lectures to the student with the cat)))
;;; Starting a new problem 
;;; Amb-Eval value:
(sentence (simple-noun-phrase (article the) (noun professor)) (verb-phrase (verb-phrase (verb lectures) (prep-phrase (prep to) (simple-noun-phrase (article the) (noun student)))) (prep-phrase (prep with) (simple-noun-phrase (article the) (noun cat)))))
;;; Amb-Eval input:
try-again
;;; Amb-Eval value:
(sentence (simple-noun-phrase (article the) (noun professor)) (verb-phrase (verb lectures) (prep-phrase (prep to) (noun-phrase (simple-noun-phrase (article the) (noun student)) (prep-phrase (prep with) (simple-noun-phrase (article the) (noun cat)))))))
;;; Amb-Eval input:
try-again
;;; There are no more values of

(parse (quote (the professor lectures to the student with the cat)))
;;; Amb-Eval input:
(exit)
;;; Starting a new problem 
#+end_src

***** DONE Exercise 4.45 Five parses
      CLOSED: [2020-02-18 Tue 19:45]

#+name: s-amb-input-parser-five-parses
#+begin_src shell :exports code :results output scalar code
  cat << EOF
  <<s-amb-input-require>>
  <<s-amb-input-an-element-of>>
  <<s-amb-input-prime-sum-pair>>
  <<s-amb-input-an-integer-between>>
  <<s-amb-input-a-pythagorean-triple>>
  <<s-amb-input-infinite-triples-test>>
  <<s-amb-distinct>>
  <<natural-language-words>>
  <<natural-language-prepositions>>
  <<parse-prepositional-phrase>>
  <<parse-sentence-2>>
  <<parse-verb-phrase>>
  <<parse-noun-phrase-2>>
  <<parse-word>>
  <<parse-input>>

  (parse '(the professor lectures to the student in the class with the cat))
  try-again
  try-again
  try-again
  try-again
  try-again
  (exit)
  EOF
#+end_src


#+header: :stdin s-amb-input-parser-five-parses
#+begin_src shell :shebang "#! /usr/bin/chibi-scheme" :results output scalar code :exports both
<<s-glue1>>
<<s-amb-amb-implementation>>
<<s-amb-analyze-eval-with-let-amb-ramb>>
<<s-let-implementation>>
<<s-amb-simple-expressions>>
<<s-amb-analyze-if>>
<<s-amb-analyze-sequence>>
<<s-amb-analyze-definition>>
<<s-amb-analyze-assignment>>
<<s-amb-analyze-application>>
<<s-amb-get-args>>
<<s-amb-execute-application>>
<<s-amb-analyze-amb>>
<<s-amb-ramb>>
<<s-syntax>>
<<s-application>>
<<s-cond-with-arrow>>
<<s-truefalse>>
<<s-compound-procedures>>
<<s-environments-list-of-bindings-better-abstractions>>
<<s-primitive-procedures>>
<<s-amb-driver-loop>>
<<s-user-prompt-print>>
<<s-glue2>>

(driver-loop)

#+end_src

#+RESULTS[dd26b718b562fda8b1e4004d480fe3a020e1e330]:
#+begin_src shell

;;; Amb-Eval input:
(define (require p) (if (not p) (amb)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (an-element-of items) (require (not (null? items))) (amb (car items) (an-element-of (cdr items))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (an-integer-starting-from n) (amb n (an-integer-starting-from (+ n 1))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (prime-sum-pair list1 list2) (let ((a (an-element-of list1)) (b (an-element-of list2))) (require (prime? (+ a b))) (list a b)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (an-integer-between n k) (require (< n k)) (amb n (an-integer-between (+ n 1) k)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (a-pythagorean-triple-between low high) (let ((i (an-integer-between low high))) (let ((j (an-integer-between i high))) (let ((k (an-integer-between j high))) (require (= (+ (* i i) (* j j)) (* k k))) (list i j k)))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (a-pythagorean-triple-from start) (let ((k (an-integer-starting-from start))) (let ((j (an-integer-between 0 k))) (let ((i (an-integer-between 0 j))) (require (= (+ (* i i) (* j j)) (* k k))) (list i j k)))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (distinct? items) (cond ((null? items) true) ((null? (cdr items)) true) ((member (car items) (cdr items)) false) (else (distinct? (cdr items)))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define nouns (quote (noun student professor cat class)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define verbs (quote (verb studies lectures eats sleeps)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define articles (quote (article the a)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define prepositions (quote (prep for to in by with)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (parse-prepositional-phrase) (list (quote prep-phrase) (parse-word prepositions) (parse-noun-phrase)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (parse-sentence) (list (quote sentence) (parse-noun-phrase) (parse-verb-phrase)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (parse-verb-phrase) (define (maybe-extend verb-phrase) (amb verb-phrase (maybe-extend (list (quote verb-phrase) verb-phrase (parse-prepositional-phrase))))) (maybe-extend (parse-word verbs)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (parse-simple-noun-phrase) (list (quote simple-noun-phrase) (parse-word articles) (parse-word nouns)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (parse-noun-phrase) (define (maybe-extend noun-phrase) (amb noun-phrase (maybe-extend (list (quote noun-phrase) noun-phrase (parse-prepositional-phrase))))) (maybe-extend (parse-simple-noun-phrase)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (parse-word word-list) (require (not (null? *unparsed*))) (require (memq (car *unparsed*) (cdr word-list))) (let ((found-word (car *unparsed*))) (set! *unparsed* (cdr *unparsed*)) (list (car word-list) found-word)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define *unparsed* (quote ()))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (parse input) (set! *unparsed* input) (let ((sent (parse-sentence))) (require (null? *unparsed*)) sent))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(parse (quote (the professor lectures to the student in the class with the cat)))
;;; Starting a new problem 
;;; Amb-Eval value:
(sentence (simple-noun-phrase (article the) (noun professor)) (verb-phrase (verb-phrase (verb-phrase (verb lectures) (prep-phrase (prep to) (simple-noun-phrase (article the) (noun student)))) (prep-phrase (prep in) (simple-noun-phrase (article the) (noun class)))) (prep-phrase (prep with) (simple-noun-phrase (article the) (noun cat)))))
;;; Amb-Eval input:
try-again
;;; Amb-Eval value:
(sentence (simple-noun-phrase (article the) (noun professor)) (verb-phrase (verb-phrase (verb lectures) (prep-phrase (prep to) (simple-noun-phrase (article the) (noun student)))) (prep-phrase (prep in) (noun-phrase (simple-noun-phrase (article the) (noun class)) (prep-phrase (prep with) (simple-noun-phrase (article the) (noun cat)))))))
;;; Amb-Eval input:
try-again
;;; Amb-Eval value:
(sentence (simple-noun-phrase (article the) (noun professor)) (verb-phrase (verb-phrase (verb lectures) (prep-phrase (prep to) (noun-phrase (simple-noun-phrase (article the) (noun student)) (prep-phrase (prep in) (simple-noun-phrase (article the) (noun class)))))) (prep-phrase (prep with) (simple-noun-phrase (article the) (noun cat)))))
;;; Amb-Eval input:
try-again
;;; Amb-Eval value:
(sentence (simple-noun-phrase (article the) (noun professor)) (verb-phrase (verb lectures) (prep-phrase (prep to) (noun-phrase (noun-phrase (simple-noun-phrase (article the) (noun student)) (prep-phrase (prep in) (simple-noun-phrase (article the) (noun class)))) (prep-phrase (prep with) (simple-noun-phrase (article the) (noun cat)))))))
;;; Amb-Eval input:
try-again
;;; Amb-Eval value:
(sentence (simple-noun-phrase (article the) (noun professor)) (verb-phrase (verb lectures) (prep-phrase (prep to) (noun-phrase (simple-noun-phrase (article the) (noun student)) (prep-phrase (prep in) (noun-phrase (simple-noun-phrase (article the) (noun class)) (prep-phrase (prep with) (simple-noun-phrase (article the) (noun cat)))))))))
;;; Amb-Eval input:
try-again
;;; There are no more values of

(parse (quote (the professor lectures to the student in the class with the cat)))
;;; Amb-Eval input:
(exit)
;;; Starting a new problem 
#+end_src

We have obtained the parses with our nondeterministic interpreter. Now
let us explain them.

I will do some manual post-processing for clarity.

#+begin_src scheme :exports code :results none
  (sentence
   (simple-noun-phrase
    (article the)
    (noun professor))
   (verb-phrase
    (verb-phrase
     (verb-phrase
      (verb lectures)
      (prep-phrase
       (prep to)
       (simple-noun-phrase
	(article the)
	(noun student))))
     (prep-phrase
      (prep in)
      (simple-noun-phrase
       (article the)
       (noun class))))
    (prep-phrase
     (prep with)
     (simple-noun-phrase
      (article the)
      (noun cat)))))
#+end_src

#+begin_src scheme :exports code :results none
  (professor (((lectures (to student)) (in class)) (with cat)))
#+end_src
The professor has a cat with him. The professor is in a class. The
professor lectures. The lecture influences the student.


#+begin_src scheme :exports code :results none
  (professor ((lectures (to student)) (in (class (with cat)))))
#+end_src
There is a cat in the class. The professor does something in this
class. What he does is lecturing. He is lecturing to the student.

#+begin_src scheme :exports code :results none
  (professor ((lectures (to (student (in class)))) (with cat)))
#+end_src

Another case when a professor has a cat with him. He lectures to
student. This student is in a class. (The professor may not be in
class, he may be lecturing by a video call.)

It is a bit weird that our grammar allows phrases like "lectures with
cat". I'm not a native speaker, so I can't understand how a verb phrase may
be applied to a preposition phrase.

#+begin_src scheme :exports code :results none
  (professor (lectures (to ((student (in class)) (with cat)))))
#+end_src

The student is in a class. This student has a cat. The professor
lectures to them.

#+begin_src scheme :exports code :results none
  (professor (lectures (to (student (in (class (with cat)))))))

#+end_src

There is a cat in a class. The student is in this class. The lectures
influences the student. The professor does the lecture.

This is the most natural way to parse this sentence to me. The general
logic goes by increasing precision.

***** DONE Exercise 4.46 Order of parsing
      CLOSED: [2020-02-18 Tue 19:55]

The order of evaluation determines the expected order of clauses in a
sentence. That is, all our functions have access to a single mutable
state (already not a very good sign!), and each successful evaluation
of a parser function mutates this state. Our grammar expects noun
phrases to be before verb phrases. Trying to parse a verb phrase first
would result in the verb parser "expiring". The noun phrase parser
then would parse the noun phrase correctly, but there will be some
text unparsed left.

This can in principle be fixed by writing a better grammar,
but... parsing algorithms are quite peculiar themselves, so it is
probably a good idea to do some basic studying of parsers and lexers.

***** DONE Exercise 4.47 Parse verb phrase by Louis
      CLOSED: [2020-02-18 Tue 20:13]

Let's try!

#+name: parse-verb-phrase-louis
#+begin_src scheme :exports code :results none
  (define (parse-verb-phrase)
    (amb (parse-word verbs)
	 (list 'verb-phrase
	       (parse-verb-phrase)
	       (parse-prepositional-phrase))))
#+end_src

#+name: s-amb-parse-verb-phrase-louis
#+begin_src shell :exports code :results output scalar code
  cat << EOF
  <<s-amb-input-require>>
  <<s-amb-input-an-element-of>>
  <<s-amb-input-prime-sum-pair>>
  <<s-amb-input-an-integer-between>>
  <<s-amb-input-a-pythagorean-triple>>
  <<s-amb-input-infinite-triples-test>>
  <<s-amb-distinct>>
  <<natural-language-words>>
  <<natural-language-prepositions>>
  <<parse-prepositional-phrase>>
  <<parse-sentence-2>>
  <<parse-verb-phrase-louis>>
  <<parse-noun-phrase-2>>
  <<parse-word>>
  <<parse-input>>

  (parse '(the professor lectures to the student in the class with the cat))
  try-again
  try-again
  try-again
  try-again
  try-again
  (exit)
  EOF
#+end_src


#+header: :stdin s-amb-parse-verb-phrase-louis
#+begin_src shell :shebang "#! /usr/bin/chibi-scheme" :exports code :results none
<<s-glue1>>
<<s-amb-amb-implementation>>
<<s-amb-analyze-eval-with-let-amb-ramb>>
<<s-let-implementation>>
<<s-amb-simple-expressions>>
<<s-amb-analyze-if>>
<<s-amb-analyze-sequence>>
<<s-amb-analyze-definition>>
<<s-amb-analyze-assignment>>
<<s-amb-analyze-application>>
<<s-amb-get-args>>
<<s-amb-execute-application>>
<<s-amb-analyze-amb>>
<<s-amb-ramb>>
<<s-syntax>>
<<s-application>>
<<s-cond-with-arrow>>
<<s-truefalse>>
<<s-compound-procedures>>
<<s-environments-list-of-bindings-better-abstractions>>
<<s-primitive-procedures>>
<<s-amb-driver-loop>>
<<s-user-prompt-print>>
<<s-glue2>>

(driver-loop)

#+end_src

Suppose that (parse-word) fails. Then we fall into the second branch
of the ~amb~. It makes a list and runs (parse-word) again.. which will
fail again for the same reason it failed the first time. Therefore the
interpreter will run indefinitely.

***** DONE Exercise 4.48 Extending the grammar
      CLOSED: [2020-02-18 Tue 21:06]

Let's not dig too much into the matter. Let's just add compound
sentences to the parsing system.

#+name: compound-sentences
#+begin_src scheme :exports code :results none
  (define conjunctions '(conjunction and therefore however but))

  (define (parse-compound-sentence)
    (define (maybe-extend my-sent)
       (amb my-sent (maybe-extend (list 'compound-sentence my-sent (parse-word conjunctions) (parse-compound-sentence)))))
   (maybe-extend (parse-sentence)))

#+end_src

#+name: parse-input-compound
#+begin_src scheme :exports code :results none
  (define *unparsed* '())
  (define (parse input)
    (set! *unparsed* input)
    (let ((sent (parse-compound-sentence)))
      (require (null? *unparsed*)) sent))
#+end_src


#+name: s-amb-input-parser-extending-grammar
#+begin_src shell :exports code :results output scalar code
  cat << EOF
  <<s-amb-input-require>>
  <<s-amb-input-an-element-of>>
  <<s-amb-input-prime-sum-pair>>
  <<s-amb-input-an-integer-between>>
  <<s-amb-input-a-pythagorean-triple>>
  <<s-amb-input-infinite-triples-test>>
  <<s-amb-distinct>>
  <<empty-board-adjoin-position-safe>>
  <<natural-language-words>>
  <<natural-language-prepositions>>
  <<parse-prepositional-phrase>>
  <<parse-sentence-2>>
  <<parse-verb-phrase>>
  <<parse-noun-phrase-2>>
  <<parse-word>>
  <<compound-sentences>>
  <<parse-input-compound>>
  (parse '(the student with the cat sleeps in the class))
  try-again
  (parse '(the professor lectures to the student with the cat))
  try-again
  (parse '(the professor lectures but the cat sleeps))
  (exit)
  EOF
#+end_src


#+header: :stdin s-amb-input-parser-extending-grammar
#+begin_src shell :shebang "#! /usr/bin/chibi-scheme" :results output scalar code :exports both
<<s-glue1>>
<<s-amb-amb-implementation>>
<<s-amb-analyze-eval-with-let-amb-ramb>>
<<s-let-implementation>>
<<s-amb-simple-expressions>>
<<s-amb-analyze-if>>
<<s-amb-analyze-sequence>>
<<s-amb-analyze-definition>>
<<s-amb-analyze-assignment>>
<<s-amb-analyze-application>>
<<s-amb-get-args>>
<<s-amb-execute-application>>
<<s-amb-analyze-amb>>
<<s-amb-ramb>>
<<s-syntax>>
<<s-application>>
<<s-cond-with-arrow>>
<<s-truefalse>>
<<s-compound-procedures>>
<<s-environments-list-of-bindings-better-abstractions>>
<<s-primitive-procedures>>
<<s-amb-driver-loop>>
<<s-user-prompt-print>>
<<s-glue2>>

(driver-loop)

#+end_src

#+RESULTS[83493052444190ebb075aea4b6cc9dd247528814]:
#+begin_src shell

;;; Amb-Eval input:
(define (require p) (if (not p) (amb)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (an-element-of items) (require (not (null? items))) (amb (car items) (an-element-of (cdr items))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (an-integer-starting-from n) (amb n (an-integer-starting-from (+ n 1))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (prime-sum-pair list1 list2) (let ((a (an-element-of list1)) (b (an-element-of list2))) (require (prime? (+ a b))) (list a b)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (an-integer-between n k) (require (< n k)) (amb n (an-integer-between (+ n 1) k)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (a-pythagorean-triple-between low high) (let ((i (an-integer-between low high))) (let ((j (an-integer-between i high))) (let ((k (an-integer-between j high))) (require (= (+ (* i i) (* j j)) (* k k))) (list i j k)))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (a-pythagorean-triple-from start) (let ((k (an-integer-starting-from start))) (let ((j (an-integer-between 0 k))) (let ((i (an-integer-between 0 j))) (require (= (+ (* i i) (* j j)) (* k k))) (list i j k)))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (distinct? items) (cond ((null? items) true) ((null? (cdr items)) true) ((member (car items) (cdr items)) false) (else (distinct? (cdr items)))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define empty-board (quote ()))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (adjoin-position new-row k rest-of-queens) (cons (cons k new-row) rest-of-queens))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (safe? k positions) (cond ((null? (cdr positions)) #t) ((= k 1) #t) ((= (cdar positions) (cdadr positions)) #f) ((= (abs (- (cdar positions) (cdadr positions))) (abs (- (caar positions) (caadr positions)))) #f) (else (safe? k (cons (car positions) (cddr positions))))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define nouns (quote (noun student professor cat class)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define verbs (quote (verb studies lectures eats sleeps)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define articles (quote (article the a)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define prepositions (quote (prep for to in by with)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (parse-prepositional-phrase) (list (quote prep-phrase) (parse-word prepositions) (parse-noun-phrase)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (parse-sentence) (list (quote sentence) (parse-noun-phrase) (parse-verb-phrase)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (parse-verb-phrase) (define (maybe-extend verb-phrase) (amb verb-phrase (maybe-extend (list (quote verb-phrase) verb-phrase (parse-prepositional-phrase))))) (maybe-extend (parse-word verbs)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (parse-simple-noun-phrase) (list (quote simple-noun-phrase) (parse-word articles) (parse-word nouns)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (parse-noun-phrase) (define (maybe-extend noun-phrase) (amb noun-phrase (maybe-extend (list (quote noun-phrase) noun-phrase (parse-prepositional-phrase))))) (maybe-extend (parse-simple-noun-phrase)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (parse-word word-list) (require (not (null? *unparsed*))) (require (memq (car *unparsed*) (cdr word-list))) (let ((found-word (car *unparsed*))) (set! *unparsed* (cdr *unparsed*)) (list (car word-list) found-word)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define conjunctions (quote (conjunction and therefore however but)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (parse-compound-sentence) (define (maybe-extend my-sent) (amb my-sent (maybe-extend (list (quote compound-sentence) my-sent (parse-word conjunctions) (parse-compound-sentence))))) (maybe-extend (parse-sentence)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define *unparsed* (quote ()))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (parse input) (set! *unparsed* input) (let ((sent (parse-compound-sentence))) (require (null? *unparsed*)) sent))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(parse (quote (the student with the cat sleeps in the class)))
;;; Starting a new problem 
;;; Amb-Eval value:
(sentence (noun-phrase (simple-noun-phrase (article the) (noun student)) (prep-phrase (prep with) (simple-noun-phrase (article the) (noun cat)))) (verb-phrase (verb sleeps) (prep-phrase (prep in) (simple-noun-phrase (article the) (noun class)))))
;;; Amb-Eval input:
try-again
;;; There are no more values of

(parse (quote (the student with the cat sleeps in the class)))
;;; Amb-Eval input:
(parse (quote (the professor lectures to the student with the cat)))
;;; Starting a new problem 
;;; Amb-Eval value:
(sentence (simple-noun-phrase (article the) (noun professor)) (verb-phrase (verb-phrase (verb lectures) (prep-phrase (prep to) (simple-noun-phrase (article the) (noun student)))) (prep-phrase (prep with) (simple-noun-phrase (article the) (noun cat)))))
;;; Amb-Eval input:
try-again
;;; Amb-Eval value:
(sentence (simple-noun-phrase (article the) (noun professor)) (verb-phrase (verb lectures) (prep-phrase (prep to) (noun-phrase (simple-noun-phrase (article the) (noun student)) (prep-phrase (prep with) (simple-noun-phrase (article the) (noun cat)))))))
;;; Amb-Eval input:
(parse (quote (the professor lectures but the cat sleeps)))
;;; Starting a new problem 
;;; Amb-Eval value:
(compound-sentence (sentence (simple-noun-phrase (article the) (noun professor)) (verb lectures)) (conjunction but) (sentence (simple-noun-phrase (article the) (noun cat)) (verb sleeps)))
;;; Amb-Eval input:
(exit)
;;; Starting a new problem 
#+end_src

***** DONE Exercise 4.49 Alyssa's generator
      CLOSED: [2020-02-18 Tue 21:51]

#+name: parser-parse-word-generate
#+begin_src scheme :exports code :results none
(define (a-random-of l)
   (require (not (null? l)))
   (ramb (a-random-of (cdr l)) (car l) (ramb)))

  (define (parse-word word-list)
    (require (not (null? *unparsed*)))
    #;(require (memq (car *unparsed*) (cdr word-list)))
    (let ((found-word (a-random-of (cdr word-list))))
      (set! *unparsed* (cdr *unparsed*))
      (list (car word-list) found-word)))
#+end_src

#+name: phrase-generator
#+begin_src shell :exports code :results output scalar code
  cat << EOF
  <<s-amb-input-require>>
  <<s-amb-input-an-element-of>>
  <<s-amb-input-prime-sum-pair>>
  <<s-amb-input-an-integer-between>>
  <<s-amb-input-a-pythagorean-triple>>
  <<s-amb-input-infinite-triples-test>>
  <<s-amb-distinct>>
  <<empty-board-adjoin-position-safe>>
  <<natural-language-words>>
  <<natural-language-prepositions>>
  <<parse-prepositional-phrase>>
  <<parse-sentence-2>>
  <<parse-verb-phrase>>
  <<parse-noun-phrase-2>>
  <<parser-parse-word-generate>>
  <<parse-input>>
  (parse '(the student with the cat sleeps in the class))
  try-again
  try-again
  try-again
  try-again
  try-again
  try-again
  (parse '(the professor lectures to the student with the cat))
  try-again
  try-again
  (exit)
  EOF
#+end_src


#+header: :stdin phrase-generator
#+begin_src shell :shebang "#! /usr/bin/chibi-scheme" :results output scalar code :exports both
<<s-glue1>>
<<s-amb-amb-implementation>>
<<s-amb-analyze-eval-with-let-amb-ramb>>
<<s-let-implementation>>
<<s-amb-simple-expressions>>
<<s-amb-analyze-if>>
<<s-amb-analyze-sequence>>
<<s-amb-analyze-definition>>
<<s-amb-analyze-assignment>>
<<s-amb-analyze-application>>
<<s-amb-get-args>>
<<s-amb-execute-application>>
<<s-amb-analyze-amb>>
<<s-amb-ramb>>
<<s-syntax>>
<<s-application>>
<<s-cond-with-arrow>>
<<s-truefalse>>
<<s-compound-procedures>>
<<s-environments-list-of-bindings-better-abstractions>>
<<s-primitive-procedures>>
<<s-amb-driver-loop>>
<<s-user-prompt-print>>
<<s-glue2>>

(driver-loop)

#+end_src

#+RESULTS[c50712bae9cde0734e0464faa2fc6ac0df657bcc]:
#+begin_src shell

;;; Amb-Eval input:
(define (require p) (if (not p) (amb)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (an-element-of items) (require (not (null? items))) (amb (car items) (an-element-of (cdr items))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (an-integer-starting-from n) (amb n (an-integer-starting-from (+ n 1))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (prime-sum-pair list1 list2) (let ((a (an-element-of list1)) (b (an-element-of list2))) (require (prime? (+ a b))) (list a b)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (an-integer-between n k) (require (< n k)) (amb n (an-integer-between (+ n 1) k)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (a-pythagorean-triple-between low high) (let ((i (an-integer-between low high))) (let ((j (an-integer-between i high))) (let ((k (an-integer-between j high))) (require (= (+ (* i i) (* j j)) (* k k))) (list i j k)))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (a-pythagorean-triple-from start) (let ((k (an-integer-starting-from start))) (let ((j (an-integer-between 0 k))) (let ((i (an-integer-between 0 j))) (require (= (+ (* i i) (* j j)) (* k k))) (list i j k)))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (distinct? items) (cond ((null? items) true) ((null? (cdr items)) true) ((member (car items) (cdr items)) false) (else (distinct? (cdr items)))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define empty-board (quote ()))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (adjoin-position new-row k rest-of-queens) (cons (cons k new-row) rest-of-queens))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (safe? k positions) (cond ((null? (cdr positions)) #t) ((= k 1) #t) ((= (cdar positions) (cdadr positions)) #f) ((= (abs (- (cdar positions) (cdadr positions))) (abs (- (caar positions) (caadr positions)))) #f) (else (safe? k (cons (car positions) (cddr positions))))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define nouns (quote (noun student professor cat class)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define verbs (quote (verb studies lectures eats sleeps)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define articles (quote (article the a)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define prepositions (quote (prep for to in by with)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (parse-prepositional-phrase) (list (quote prep-phrase) (parse-word prepositions) (parse-noun-phrase)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (parse-sentence) (list (quote sentence) (parse-noun-phrase) (parse-verb-phrase)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (parse-verb-phrase) (define (maybe-extend verb-phrase) (amb verb-phrase (maybe-extend (list (quote verb-phrase) verb-phrase (parse-prepositional-phrase))))) (maybe-extend (parse-word verbs)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (parse-simple-noun-phrase) (list (quote simple-noun-phrase) (parse-word articles) (parse-word nouns)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (parse-noun-phrase) (define (maybe-extend noun-phrase) (amb noun-phrase (maybe-extend (list (quote noun-phrase) noun-phrase (parse-prepositional-phrase))))) (maybe-extend (parse-simple-noun-phrase)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (a-random-of l) (require (not (null? l))) (ramb (a-random-of (cdr l)) (car l) (ramb)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (parse-word word-list) (require (not (null? *unparsed*))) (let ((found-word (a-random-of (cdr word-list)))) (set! *unparsed* (cdr *unparsed*)) (list (car word-list) found-word)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define *unparsed* (quote ()))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (parse input) (set! *unparsed* input) (let ((sent (parse-sentence))) (require (null? *unparsed*)) sent))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(parse (quote (the student with the cat sleeps in the class)))
;;; Starting a new problem 
;;; Amb-Eval value:
(sentence (simple-noun-phrase (article the) (noun professor)) (verb-phrase (verb-phrase (verb lectures) (prep-phrase (prep to) (simple-noun-phrase (article the) (noun student)))) (prep-phrase (prep for) (simple-noun-phrase (article a) (noun professor)))))
;;; Amb-Eval input:
try-again
;;; Amb-Eval value:
(sentence (simple-noun-phrase (article the) (noun professor)) (verb-phrase (verb-phrase (verb lectures) (prep-phrase (prep to) (simple-noun-phrase (article the) (noun student)))) (prep-phrase (prep for) (simple-noun-phrase (article a) (noun professor)))))
;;; Amb-Eval input:
try-again
;;; Amb-Eval value:
(sentence (simple-noun-phrase (article the) (noun professor)) (verb-phrase (verb lectures) (prep-phrase (prep to) (noun-phrase (simple-noun-phrase (article the) (noun student)) (prep-phrase (prep for) (simple-noun-phrase (article a) (noun professor)))))))
;;; Amb-Eval input:
try-again
;;; Amb-Eval value:
(sentence (simple-noun-phrase (article the) (noun professor)) (verb-phrase (verb lectures) (prep-phrase (prep to) (noun-phrase (simple-noun-phrase (article the) (noun student)) (prep-phrase (prep for) (simple-noun-phrase (article a) (noun professor)))))))
;;; Amb-Eval input:
try-again
;;; Amb-Eval value:
(sentence (simple-noun-phrase (article the) (noun professor)) (verb-phrase (verb-phrase (verb lectures) (prep-phrase (prep to) (simple-noun-phrase (article the) (noun student)))) (prep-phrase (prep for) (simple-noun-phrase (article a) (noun student)))))
;;; Amb-Eval input:
try-again
;;; Amb-Eval value:
(sentence (simple-noun-phrase (article the) (noun professor)) (verb-phrase (verb-phrase (verb lectures) (prep-phrase (prep to) (simple-noun-phrase (article the) (noun student)))) (prep-phrase (prep for) (simple-noun-phrase (article a) (noun student)))))
;;; Amb-Eval input:
try-again
;;; Amb-Eval value:
(sentence (simple-noun-phrase (article the) (noun professor)) (verb-phrase (verb-phrase (verb lectures) (prep-phrase (prep to) (simple-noun-phrase (article the) (noun student)))) (prep-phrase (prep for) (simple-noun-phrase (article the) (noun student)))))
;;; Amb-Eval input:
(parse (quote (the professor lectures to the student with the cat)))
;;; Starting a new problem 
;;; Amb-Eval value:
(sentence (noun-phrase (simple-noun-phrase (article a) (noun student)) (prep-phrase (prep to) (simple-noun-phrase (article the) (noun professor)))) (verb-phrase (verb studies) (prep-phrase (prep for) (simple-noun-phrase (article a) (noun student)))))
;;; Amb-Eval input:
try-again
;;; Amb-Eval value:
(sentence (noun-phrase (noun-phrase (simple-noun-phrase (article a) (noun student)) (prep-phrase (prep to) (simple-noun-phrase (article the) (noun professor)))) (prep-phrase (prep for) (simple-noun-phrase (article the) (noun professor)))) (verb lectures))
;;; Amb-Eval input:
try-again
;;; Amb-Eval value:
(sentence (noun-phrase (noun-phrase (simple-noun-phrase (article a) (noun student)) (prep-phrase (prep to) (simple-noun-phrase (article the) (noun professor)))) (prep-phrase (prep for) (simple-noun-phrase (article the) (noun professor)))) (verb studies))
;;; Amb-Eval input:
(exit)
;;; Starting a new problem 
#+end_src


Works... sorta.

**** 4.3.3 Implementing the ~amb~ Evaluator [5/5]
***** Common code

#+name: s-amb-amb-implementation
#+begin_src scheme :exports code :results none
  (define (amb? exp) (tagged-list? exp 'amb))
  (define (amb-choices exp) (cdr exp))
#+end_src

#+name: s-amb-analyze-eval-with-let-and-amb
#+begin_src scheme :exports code :results none
  (define (ambeval exp env succeed fail)
     ((analyze exp) env succeed fail))
  (define (analyze exp)
    (cond ((self-evaluating? exp) (analyze-self-evaluating exp))
	  ((quoted? exp) (analyze-quoted exp))
	  ((variable? exp) (analyze-variable exp))
	  ((assignment? exp) (analyze-assignment exp))
	  ((definition? exp) (analyze-definition exp))
	  ((if? exp) (analyze-if exp))
	  ((lambda? exp) (analyze-lambda exp))
	  ((begin? exp) (analyze-sequence (begin-actions exp)))
	  ((cond? exp) (analyze (cond->if exp)))
          ((let? exp) (analyze (let->combination exp)))
          ((amb? exp) (analyze-amb exp))
	  ((application? exp) (analyze-application exp))
	  (else (error "Unknown expression type: ANALYZE" exp))))

#+end_src

#+name: s-amb-simple-expressions
#+begin_src scheme :exports code :results none
  (define (analyze-self-evaluating exp)
    (lambda (env succeed fail)
      (succeed exp fail)))
  (define (analyze-quoted exp)
    (let ((qval (text-of-quotation exp)))
      (lambda (env succeed fail)
	(succeed qval fail))))
  (define (analyze-variable exp)
    (lambda (env succeed fail)
      (succeed (lookup-variable-value exp env) fail)))
  (define (analyze-lambda exp)
    (let ((vars (lambda-parameters exp))
	  (bproc (analyze-sequence (lambda-body exp))))
      (lambda (env succeed fail)
	(succeed (make-procedure vars bproc env) fail))))
#+end_src

#+name: s-amb-analyze-if
#+begin_src scheme :exports code :results none
  (define (analyze-if exp)
    (let ((pproc (analyze (if-predicate exp)))
	  (cproc (analyze (if-consequent exp)))
	  (aproc (analyze (if-alternative exp))))
      (lambda (env succeed fail)
	(pproc env
	       ;; success continuation for evaluating the predicate
	       ;; to obtain pred-value
	       (lambda (pred-value fail2)
		 (if (true? pred-value)
		     (cproc env succeed fail2)
		     (aproc env succeed fail2)))
	       ;; failure continuation for evaluating the predicate
	       fail))))
#+end_src

#+name: s-amb-analyze-sequence
#+begin_src scheme :exports code :results none
  (define (analyze-sequence exps)
    (define (sequentially a b)
      (lambda (env succeed fail)
	(a env
	   ;; success continuation for calling a
	   (lambda (a-value fail2)
	     (b env succeed fail2))
	   ;; failure continuation for calling a
	   fail)))
    (define (loop first-proc rest-procs)
      (if (null? rest-procs)
	  first-proc
	  (loop (sequentially first-proc
			      (car rest-procs))
		(cdr rest-procs))))
    (let ((procs (map analyze exps)))
      (if (null? procs)
	  (error "Empty sequence: ANALYZE"))
      (loop (car procs) (cdr procs))))
#+end_src

#+name: s-amb-analyze-definition
#+begin_src scheme :exports code :results none
  (define (analyze-definition exp)
    (let ((var (definition-variable exp))
	  (vproc (analyze (definition-value exp))))
      (lambda (env succeed fail)
	(vproc env
	       (lambda (val fail2)
		 (define-variable! var val env)
		 (succeed 'ok fail2))
	       fail))))
#+end_src

#+name: s-amb-analyze-assignment
#+begin_src scheme :exports code :results none
  (define (analyze-assignment exp)
    (let ((var (assignment-variable exp))
	  (vproc (analyze (assignment-value exp))))
      (lambda (env succeed fail)
	(vproc env
	       (lambda (val fail2)
					  ; *1*
		 (let ((old-value
			(lookup-variable-value var env)))
		   (set-variable-value! var val env)
		   (succeed 'ok
			    (lambda ()
					  ; *2*
			      (set-variable-value!
			       var old-value env)
			      (fail2)))))
	       fail))))
#+end_src

#+name: s-amb-analyze-application
#+begin_src scheme :exports code :results none
  (define (analyze-application exp)
    (let ((fproc (analyze (operator exp)))
	  (aprocs (map analyze (operands exp))))
      (lambda (env succeed fail)
	(fproc env
	       (lambda (proc fail2)
		 (get-args aprocs
			   env
			   (lambda (args fail3)
			     (execute-application
			      proc args succeed fail3))
			   fail2))
	       fail))))
#+end_src

#+name: s-amb-get-args
#+begin_src scheme :exports code :results none
  (define (get-args aprocs env succeed fail)
    (if (null? aprocs)
	(succeed '() fail)
	((car aprocs)
	 env
	 ;; success continuation for this aproc
	 (lambda (arg fail2)
	   (get-args
	    (cdr aprocs)
	    env
	    ;; success continuation for
	    ;; recursive call to get-args
	    (lambda (args fail3)
	      (succeed (cons arg args) fail3))
	    fail2))
	 fail)))
#+end_src

#+name: s-amb-execute-application
#+begin_src scheme :exports code :results none
  (define (execute-application proc args succeed fail)
    (cond ((primitive-procedure? proc)
	   (succeed (apply-primitive-procedure proc args)
		    fail))
	  ((compound-procedure? proc)
	   ((procedure-body proc)
	    (extend-environment
	     (procedure-parameters proc)
	     args
	     (procedure-environment proc))
	    succeed
	    fail))
	  (else
	   (error "Unknown procedure type: EXECUTE-APPLICATION"
		  proc))))
#+end_src

#+name: s-amb-analyze-amb
#+begin_src scheme :exports code :results none
  (define (analyze-amb exp)
    (let ((cprocs (map analyze (amb-choices exp))))
      (lambda (env succeed fail)
	(define (try-next choices)
	  (if (null? choices)
	      (fail)
	      ((car choices)
	       env
	       succeed
	       (lambda () (try-next (cdr choices))))))
	(try-next cprocs))))
#+end_src

Important! Because I am writing this code in a literate style, I had
to add ~(user-print (input))~ to the ~let~ body, so that the output
also contains the input. I did the same thing with the metacircular
evaluator's ~driver-loop~.

#+name: s-amb-driver-loop
#+begin_src scheme :exports code :results node
  (define input-prompt ";;; Amb-Eval input:")
  (define output-prompt ";;; Amb-Eval value:")
  (define (driver-loop)
    (define (internal-loop try-again)
      (prompt-for-input input-prompt)
      (let ((input (read)))
        (user-print input)

	(if (eq? input 'try-again)
	    (try-again)
	    (begin
	      (newline) (display ";;; Starting a new problem ")
	      (ambeval
	       input
	       the-global-environment
	       ;; ambeval success
	       (lambda (val next-alternative)
		 (announce-output output-prompt)
		 (user-print val)
		 (internal-loop next-alternative))
	       ;; ambeval failure
	       (lambda ()
		 (announce-output
		  ";;; There are no more values of\n")
		 (user-print input)
		 (driver-loop)))))))
    (internal-loop
     (lambda ()
       (newline) (display ";;; There is no current problem")
       (driver-loop))))
#+end_src

#+name: s-amb-first-test
#+begin_example
"Starting test"
try-again
(amb 1 2 3)
try-again
try-again
try-again
(exit)
#+end_example

#+header: :stdin s-amb-first-test
#+begin_src shell :shebang "#! /usr/bin/chibi-scheme" :results output scalar code :exports both
<<s-glue1>>

<<s-amb-amb-implementation>>
<<s-amb-analyze-eval-with-let-and-amb>>
<<s-let-implementation>>
<<s-amb-simple-expressions>>
<<s-amb-analyze-if>>
<<s-amb-analyze-sequence>>
<<s-amb-analyze-definition>>
<<s-amb-analyze-assignment>>
<<s-amb-analyze-application>>
<<s-amb-get-args>>
<<s-amb-execute-application>>
<<s-amb-analyze-amb>>

<<s-syntax>>
<<s-application>>
<<s-cond-with-arrow>>
<<s-truefalse>>
<<s-compound-procedures>>
<<s-environments-list-of-bindings-better-abstractions>>
<<s-primitive-procedures>>
<<s-amb-driver-loop>>
<<s-user-prompt-print>>
<<s-glue2>>

(driver-loop)

#+end_src

#+RESULTS[56944cf13c15e420addd7bafb1e3928433bdbdfc]:
#+begin_src shell

;;; Amb-Eval input:
"Starting test"
;;; Starting a new problem 
;;; Amb-Eval value:
"Starting test"
;;; Amb-Eval input:
try-again
;;; There are no more values of

"Starting test"
;;; Amb-Eval input:
(amb 1 2 3)
;;; Starting a new problem 
;;; Amb-Eval value:
1
;;; Amb-Eval input:
try-again
;;; Amb-Eval value:
2
;;; Amb-Eval input:
try-again
;;; Amb-Eval value:
3
;;; Amb-Eval input:
try-again
;;; There are no more values of

(amb 1 2 3)
;;; Amb-Eval input:
(exit)
;;; Starting a new problem 
#+end_src

Seems to be working, huh.

***** DONE Exercise 4.50 The ~ramb~ operator
      CLOSED: [2020-02-17 Mon 14:56]

#+name: s-amb-ramb
#+begin_src scheme :exports code :results none
    (define (random-permutation l)
       (set! l (list->vector l))
       (define retval '())
       (let loop ((maxindex (vector-length l)))
	 (if (> maxindex 0)
	   (let ((index (random-integer maxindex)))
	    (set! retval (cons (vector-ref l index) retval))
	    (vector-set! l index (vector-ref l (- maxindex 1)))
	    (loop (- maxindex 1)))
          retval)))
    (define (ramb? exp) (tagged-list? exp 'ramb))

  (define (analyze-ramb exp)
    (let ((cprocs (map analyze (amb-choices exp))))
      (lambda (env succeed fail)
	(define (try-next choices)
	  (if (null? choices)
	      (fail)
	      ((car (random-permutation choices))
	       env
	       succeed
	       (lambda () (try-next (cdr choices))))))
	(try-next cprocs))))

#+end_src


#+name: s-amb-analyze-eval-with-let-amb-ramb
#+begin_src scheme :exports code :results none
  (define (ambeval exp env succeed fail)
     ((analyze exp) env succeed fail))
  (define (analyze exp)
    (cond ((self-evaluating? exp) (analyze-self-evaluating exp))
	  ((quoted? exp) (analyze-quoted exp))
	  ((variable? exp) (analyze-variable exp))
	  ((assignment? exp) (analyze-assignment exp))
	  ((definition? exp) (analyze-definition exp))
	  ((if? exp) (analyze-if exp))
	  ((lambda? exp) (analyze-lambda exp))
	  ((begin? exp) (analyze-sequence (begin-actions exp)))
	  ((cond? exp) (analyze (cond->if exp)))
          ((let? exp) (analyze (let->combination exp)))
          ((amb? exp) (analyze-amb exp))
          ((ramb? exp) (analyze-ramb exp))
	  ((application? exp) (analyze-application exp))
	  (else (error "Unknown expression type: ANALYZE" exp))))

#+end_src

#+name: s-amb-ramb-test
#+begin_example
"Testing amb"
try-again
(amb 1 2 3)
try-again
try-again
try-again
"Testing ramb"
(ramb 1 2 3)
try-again
try-again
try-again
(exit)
#+end_example

#+header: :stdin s-amb-ramb-test
#+begin_src shell :shebang "#! /usr/bin/chibi-scheme" :results output scalar code :exports both
<<s-glue1>>

<<s-amb-amb-implementation>>
<<s-amb-analyze-eval-with-let-amb-ramb>>
<<s-let-implementation>>
<<s-amb-simple-expressions>>
<<s-amb-analyze-if>>
<<s-amb-analyze-sequence>>
<<s-amb-analyze-definition>>
<<s-amb-analyze-assignment>>
<<s-amb-analyze-application>>
<<s-amb-get-args>>
<<s-amb-execute-application>>
<<s-amb-analyze-amb>>
<<s-amb-ramb>>

<<s-syntax>>
<<s-application>>
<<s-cond-with-arrow>>
<<s-truefalse>>
<<s-compound-procedures>>
<<s-environments-list-of-bindings-better-abstractions>>
<<s-primitive-procedures>>
<<s-amb-driver-loop>>
<<s-user-prompt-print>>
<<s-glue2>>

(driver-loop)

#+end_src

#+RESULTS[949eb6ad2510778b9854672d3f54ff81b9323bca]:
#+begin_src shell

;;; Amb-Eval input:
"Testing amb"
;;; Starting a new problem 
;;; Amb-Eval value:
"Testing amb"
;;; Amb-Eval input:
try-again
;;; There are no more values of

"Testing amb"
;;; Amb-Eval input:
(amb 1 2 3)
;;; Starting a new problem 
;;; Amb-Eval value:
1
;;; Amb-Eval input:
try-again
;;; Amb-Eval value:
2
;;; Amb-Eval input:
try-again
;;; Amb-Eval value:
3
;;; Amb-Eval input:
try-again
;;; There are no more values of

(amb 1 2 3)
;;; Amb-Eval input:
"Testing ramb"
;;; Starting a new problem 
;;; Amb-Eval value:
"Testing ramb"
;;; Amb-Eval input:
(ramb 1 2 3)
;;; Starting a new problem 
;;; Amb-Eval value:
3
;;; Amb-Eval input:
try-again
;;; Amb-Eval value:
3
;;; Amb-Eval input:
try-again
;;; Amb-Eval value:
3
;;; Amb-Eval input:
try-again
;;; There are no more values of

(ramb 1 2 3)
;;; Amb-Eval input:
(exit)
;;; Starting a new problem 
#+end_src

***** DONE Exercise 4.51 Implementing ~permanent-set!~
      CLOSED: [2020-02-18 Tue 22:34]

#+name: s-amb-analyze-eval-with-let-amb-ramb-pset
#+begin_src scheme :exports code :results none
  (define (ambeval exp env succeed fail)
     ((analyze exp) env succeed fail))
  (define (analyze exp)
    (cond ((self-evaluating? exp) (analyze-self-evaluating exp))
	  ((quoted? exp) (analyze-quoted exp))
	  ((variable? exp) (analyze-variable exp))
	  ((assignment? exp) (analyze-assignment exp))
          ((permanent-assignment? exp) (analyze-permanent-assignment exp))
	  ((definition? exp) (analyze-definition exp))
	  ((if? exp) (analyze-if exp))
	  ((lambda? exp) (analyze-lambda exp))
	  ((begin? exp) (analyze-sequence (begin-actions exp)))
	  ((cond? exp) (analyze (cond->if exp)))
          ((let? exp) (analyze (let->combination exp)))
          ((amb? exp) (analyze-amb exp))
          ((ramb? exp) (analyze-ramb exp))
	  ((application? exp) (analyze-application exp))
	  (else (error "Unknown expression type: ANALYZE" exp))))

#+end_src


#+name: s-amb-analyze-permanent-assignment
#+begin_src scheme :exports code :results none
  (define (permanent-assignment? exp) (tagged-list? exp 'permanent-set!))
  (define (analyze-permanent-assignment exp)
    (let ((var (assignment-variable exp))
	  (vproc (analyze (assignment-value exp))))
      (lambda (env succeed fail)
	(vproc env
	       (lambda (val fail2)
		  (set-variable-value! var val env)
		   (succeed 'ok fail2))
	       fail))))
#+end_src



#+name: s-amb-permanent-set-test
#+begin_src shell :exports code :results output scalar code
  cat << EOF
  <<s-amb-input-require>>
  <<s-amb-input-an-element-of>>
  <<s-amb-input-prime-sum-pair>>
  <<s-amb-input-an-integer-between>>
  <<s-amb-input-a-pythagorean-triple>>
  <<s-amb-input-infinite-triples-test>>
  <<s-amb-distinct>>
  (define count 0)
  (let ((x (an-element-of '(a b c)))
        (y (an-element-of '(a b c))))
    (permanent-set! count (+ count 1))
    (require (not (eq? x y)))
    (list x y count))
  try-again
  (exit)
  EOF
#+end_src


#+header: :stdin s-amb-permanent-set-test
#+begin_src shell :shebang "#! /usr/bin/chibi-scheme" :results output scalar code :exports both
<<s-glue1>>
<<s-amb-amb-implementation>>
<<s-amb-analyze-eval-with-let-amb-ramb-pset>>
<<s-amb-analyze-permanent-assignment>>
<<s-let-implementation>>
<<s-amb-simple-expressions>>
<<s-amb-analyze-if>>
<<s-amb-analyze-sequence>>
<<s-amb-analyze-definition>>
<<s-amb-analyze-assignment>>
<<s-amb-analyze-application>>
<<s-amb-get-args>>
<<s-amb-execute-application>>
<<s-amb-analyze-amb>>
<<s-amb-ramb>>
<<s-syntax>>
<<s-application>>
<<s-cond-with-arrow>>
<<s-truefalse>>
<<s-compound-procedures>>
<<s-environments-list-of-bindings-better-abstractions>>
<<s-primitive-procedures>>
<<s-amb-driver-loop>>
<<s-user-prompt-print>>
<<s-glue2>>

(driver-loop)

#+end_src

#+RESULTS[81ebb3799c22df89e7faca50f2a58038972c3e33]:
#+begin_src shell

;;; Amb-Eval input:
(define (require p) (if (not p) (amb)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (an-element-of items) (require (not (null? items))) (amb (car items) (an-element-of (cdr items))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (an-integer-starting-from n) (amb n (an-integer-starting-from (+ n 1))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (prime-sum-pair list1 list2) (let ((a (an-element-of list1)) (b (an-element-of list2))) (require (prime? (+ a b))) (list a b)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (an-integer-between n k) (require (< n k)) (amb n (an-integer-between (+ n 1) k)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (a-pythagorean-triple-between low high) (let ((i (an-integer-between low high))) (let ((j (an-integer-between i high))) (let ((k (an-integer-between j high))) (require (= (+ (* i i) (* j j)) (* k k))) (list i j k)))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (a-pythagorean-triple-from start) (let ((k (an-integer-starting-from start))) (let ((j (an-integer-between 0 k))) (let ((i (an-integer-between 0 j))) (require (= (+ (* i i) (* j j)) (* k k))) (list i j k)))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (distinct? items) (cond ((null? items) true) ((null? (cdr items)) true) ((member (car items) (cdr items)) false) (else (distinct? (cdr items)))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define count 0)
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(let ((x (an-element-of (quote (a b c)))) (y (an-element-of (quote (a b c))))) (permanent-set! count (+ count 1)) (require (not (eq? x y))) (list x y count))
;;; Starting a new problem 
;;; Amb-Eval value:
(a b 2)
;;; Amb-Eval input:
try-again
;;; Amb-Eval value:
(a c 3)
;;; Amb-Eval input:
(exit)
;;; Starting a new problem 
#+end_src

Works as expected.

#+name: s-amb-permanent-set-test-ordinary-set
#+begin_src shell :exports code :results output scalar code
  cat << EOF
  <<s-amb-input-require>>
  <<s-amb-input-an-element-of>>
  <<s-amb-input-prime-sum-pair>>
  <<s-amb-input-an-integer-between>>
  <<s-amb-input-a-pythagorean-triple>>
  <<s-amb-input-infinite-triples-test>>
  <<s-amb-distinct>>
  (define count 0)
  (let ((x (an-element-of '(a b c)))
        (y (an-element-of '(a b c))))
    (set! count (+ count 1))
    (require (not (eq? x y)))
    (list x y count))
  try-again
  (exit)
  EOF
#+end_src


#+header: :stdin s-amb-permanent-set-test-ordinary-set
#+begin_src shell :shebang "#! /usr/bin/chibi-scheme" :results output scalar code :exports both
<<s-glue1>>
<<s-amb-amb-implementation>>
<<s-amb-analyze-eval-with-let-amb-ramb-pset>>
<<s-amb-analyze-permanent-assignment>>
<<s-let-implementation>>
<<s-amb-simple-expressions>>
<<s-amb-analyze-if>>
<<s-amb-analyze-sequence>>
<<s-amb-analyze-definition>>
<<s-amb-analyze-assignment>>
<<s-amb-analyze-application>>
<<s-amb-get-args>>
<<s-amb-execute-application>>
<<s-amb-analyze-amb>>
<<s-amb-ramb>>
<<s-syntax>>
<<s-application>>
<<s-cond-with-arrow>>
<<s-truefalse>>
<<s-compound-procedures>>
<<s-environments-list-of-bindings-better-abstractions>>
<<s-primitive-procedures>>
<<s-amb-driver-loop>>
<<s-user-prompt-print>>
<<s-glue2>>

(driver-loop)

#+end_src

#+RESULTS[98b19e3efc4f0752f587e6415b9f0472c3a65508]:
#+begin_src shell

;;; Amb-Eval input:
(define (require p) (if (not p) (amb)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (an-element-of items) (require (not (null? items))) (amb (car items) (an-element-of (cdr items))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (an-integer-starting-from n) (amb n (an-integer-starting-from (+ n 1))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (prime-sum-pair list1 list2) (let ((a (an-element-of list1)) (b (an-element-of list2))) (require (prime? (+ a b))) (list a b)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (an-integer-between n k) (require (< n k)) (amb n (an-integer-between (+ n 1) k)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (a-pythagorean-triple-between low high) (let ((i (an-integer-between low high))) (let ((j (an-integer-between i high))) (let ((k (an-integer-between j high))) (require (= (+ (* i i) (* j j)) (* k k))) (list i j k)))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (a-pythagorean-triple-from start) (let ((k (an-integer-starting-from start))) (let ((j (an-integer-between 0 k))) (let ((i (an-integer-between 0 j))) (require (= (+ (* i i) (* j j)) (* k k))) (list i j k)))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (distinct? items) (cond ((null? items) true) ((null? (cdr items)) true) ((member (car items) (cdr items)) false) (else (distinct? (cdr items)))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define count 0)
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(let ((x (an-element-of (quote (a b c)))) (y (an-element-of (quote (a b c))))) (set! count (+ count 1)) (require (not (eq? x y))) (list x y count))
;;; Starting a new problem 
;;; Amb-Eval value:
(a b 1)
;;; Amb-Eval input:
try-again
;;; Amb-Eval value:
(a c 1)
;;; Amb-Eval input:
(exit)
;;; Starting a new problem 
#+end_src

This makes sense, the last element of the vector will always be 1,
because all unsuccessful attempts are unrolled, and all attempts
marked by "try-again" are also unrolled.

***** DONE Exercise 4.52 ~if-fail~
      CLOSED: [2020-02-19 Wed 00:05]

#+name: s-amb-analyze-eval-with-let-amb-ramb-pset-iffail
#+begin_src scheme :exports code :results none
  (define (ambeval exp env succeed fail)
     ((analyze exp) env succeed fail))
  (define (analyze exp)
    (cond ((self-evaluating? exp) (analyze-self-evaluating exp))
	  ((quoted? exp) (analyze-quoted exp))
	  ((variable? exp) (analyze-variable exp))
	  ((assignment? exp) (analyze-assignment exp))
          ((permanent-assignment? exp) (analyze-permanent-assignment exp))
	  ((definition? exp) (analyze-definition exp))
	  ((if? exp) (analyze-if exp))
	  ((lambda? exp) (analyze-lambda exp))
	  ((begin? exp) (analyze-sequence (begin-actions exp)))
	  ((cond? exp) (analyze (cond->if exp)))
          ((let? exp) (analyze (let->combination exp)))
          ((if-fail? exp) (analyze-if-fail exp))
          ((amb? exp) (analyze-amb exp))
          ((ramb? exp) (analyze-ramb exp))
	  ((application? exp) (analyze-application exp))
	  (else (error "Unknown expression type: ANALYZE" exp))))

#+end_src

#+name: s-amb-analyze-if-fail
#+begin_src scheme :exports code :results none
  (define (if-fail? exp) (tagged-list? exp 'if-fail))
  (define (if-fail-normal-case exp) (cadr exp))
  (define (if-fail-abnormal-case exp) (caddr exp))
  (define (analyze-if-fail exp)
    (let ((nproc (analyze (if-fail-normal-case exp)))
	  (eproc (analyze (if-fail-abnormal-case exp))))
      (lambda (env succeed fail)
           (nproc env succeed
               (lambda ()
                (eproc env succeed fail))))))
#+end_src

#+name: s-amb-iffail-test
#+begin_src shell :exports code :results output scalar code
  cat << EOF
  <<s-amb-input-require>>
  <<s-amb-input-an-element-of>>
  <<s-amb-input-an-integer-between>>
  <<s-amb-distinct>>

  (if-fail (let ((x (an-element-of '(1 3 5))))
             (require (even? x))
             x)
           'all-odd)
  (if-fail (let ((x (an-element-of '(1 3 5 8))))
              (require (even? x))
              x)
            'all-odd)
  (exit)
  EOF
#+end_src

#+RESULTS: s-amb-iffail-test

#+header: :stdin s-amb-iffail-test
#+begin_src shell :shebang "#! /usr/bin/chibi-scheme" :results output scalar code :exports both
<<s-glue1>>
<<s-amb-amb-implementation>>
<<s-amb-analyze-eval-with-let-amb-ramb-pset-iffail>>

<<s-amb-analyze-permanent-assignment>>
<<s-let-implementation>>
<<s-amb-simple-expressions>>
<<s-amb-analyze-if>>
<<s-amb-analyze-sequence>>
<<s-amb-analyze-definition>>
<<s-amb-analyze-assignment>>
<<s-amb-analyze-application>>
<<s-amb-get-args>>
<<s-amb-execute-application>>
<<s-amb-analyze-amb>>
<<s-amb-ramb>>
<<s-amb-analyze-if-fail>>
<<s-syntax>>
<<s-application>>
<<s-cond-with-arrow>>
<<s-truefalse>>
<<s-compound-procedures>>
<<s-environments-list-of-bindings-better-abstractions>>
<<s-primitive-procedures>>
<<s-amb-driver-loop>>
<<s-user-prompt-print>>
<<s-glue2>>

(driver-loop)

#+end_src

#+RESULTS[0da18810d198124035c244e1dbbf0097e077e9bc]:
#+begin_src shell

;;; Amb-Eval input:
(define (require p) (if (not p) (amb)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (an-element-of items) (require (not (null? items))) (amb (car items) (an-element-of (cdr items))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (an-integer-starting-from n) (amb n (an-integer-starting-from (+ n 1))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (an-integer-between n k) (require (< n k)) (amb n (an-integer-between (+ n 1) k)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (distinct? items) (cond ((null? items) true) ((null? (cdr items)) true) ((member (car items) (cdr items)) false) (else (distinct? (cdr items)))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(if-fail (let ((x (an-element-of (quote (1 3 5))))) (require (even? x)) x) (quote all-odd))
;;; Starting a new problem 
;;; Amb-Eval value:
all-odd
;;; Amb-Eval input:
(if-fail (let ((x (an-element-of (quote (1 3 5 8))))) (require (even? x)) x) (quote all-odd))
;;; Starting a new problem 
;;; Amb-Eval value:
8
;;; Amb-Eval input:
(exit)
;;; Starting a new problem 
#+end_src

Spent a lot of time on this because Chibi's error reporting is not
perfect. Alas.

***** DONE Exercise 4.53 test evaluation
      CLOSED: [2020-02-19 Wed 00:12]

Just test the code? Hm... too easy to be true.

#+name: s-amb-another-prime-sum-pair
#+begin_src shell :exports code :results output
  cat << EOF
<<expmod>>
<<fermat-primetest>>
<<fast-prime>>

  <<s-amb-input-require>>
  <<s-amb-input-an-element-of>>
  <<s-amb-input-prime-sum-pair>>
  <<s-amb-input-an-integer-between>>
  <<s-amb-input-a-pythagorean-triple>>
  <<s-amb-input-infinite-triples-test>>
  <<s-amb-distinct>>

  (let ((pairs '()))
    (if-fail
      (let ((p (prime-sum-pair '(1 3 5 8)
                               '(20 35 110))))
        (permanent-set! pairs (cons p pairs))
        (amb))
      pairs))
  try-again
  (exit)
  EOF
#+end_src

#+header: :stdin s-amb-another-prime-sum-pair
#+begin_src shell :shebang "#! /usr/bin/chibi-scheme" :results output scalar code :exports both
<<s-glue1>>
<<s-amb-amb-implementation>>
<<s-amb-analyze-eval-with-let-amb-ramb-pset-iffail>>

<<s-amb-analyze-permanent-assignment>>
<<s-let-implementation>>
<<s-amb-simple-expressions>>
<<s-amb-analyze-if>>
<<s-amb-analyze-sequence>>
<<s-amb-analyze-definition>>
<<s-amb-analyze-assignment>>
<<s-amb-analyze-application>>
<<s-amb-get-args>>
<<s-amb-execute-application>>
<<s-amb-analyze-amb>>
<<s-amb-ramb>>
<<s-amb-analyze-if-fail>>
<<s-syntax>>
<<s-application>>
<<s-cond-with-arrow>>
<<s-truefalse>>
<<s-compound-procedures>>
<<s-environments-list-of-bindings-better-abstractions>>
<<s-primitive-procedures>>
<<s-amb-driver-loop>>
<<s-user-prompt-print>>
<<s-glue2>>

(driver-loop)

#+end_src

#+RESULTS[4f5c80b21377414de480e1d406936fec43f8a43e]:
#+begin_src shell

;;; Amb-Eval input:
(define (expmod base exp m) (cond ((= exp 0) 1) ((even? exp) (remainder (square (expmod base (/ exp 2) m)) m)) (else (remainder (* base (expmod base (- exp 1) m)) m))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (random x) (random-integer x))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (fermat-test n) (define (try-it a) (= (expmod a n n) a)) (try-it (+ 1 (random (- n 1)))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define prime-test fermat-test)
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (fast-prime? n times) (cond ((= times 0) true) ((prime-test n) (fast-prime? n (- times 1))) (else false)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define true #t)
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define false #f)
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (prime? x) (fast-prime? x 10))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (require p) (if (not p) (amb)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (an-element-of items) (require (not (null? items))) (amb (car items) (an-element-of (cdr items))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (an-integer-starting-from n) (amb n (an-integer-starting-from (+ n 1))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (prime-sum-pair list1 list2) (let ((a (an-element-of list1)) (b (an-element-of list2))) (require (prime? (+ a b))) (list a b)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (an-integer-between n k) (require (< n k)) (amb n (an-integer-between (+ n 1) k)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (a-pythagorean-triple-between low high) (let ((i (an-integer-between low high))) (let ((j (an-integer-between i high))) (let ((k (an-integer-between j high))) (require (= (+ (* i i) (* j j)) (* k k))) (list i j k)))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (a-pythagorean-triple-from start) (let ((k (an-integer-starting-from start))) (let ((j (an-integer-between 0 k))) (let ((i (an-integer-between 0 j))) (require (= (+ (* i i) (* j j)) (* k k))) (list i j k)))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (distinct? items) (cond ((null? items) true) ((null? (cdr items)) true) ((member (car items) (cdr items)) false) (else (distinct? (cdr items)))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(let ((pairs (quote ()))) (if-fail (let ((p (prime-sum-pair (quote (1 3 5 8)) (quote (20 35 110))))) (permanent-set! pairs (cons p pairs)) (amb)) pairs))
;;; Starting a new problem 
;;; Amb-Eval value:
((8 35) (3 110) (3 20))
;;; Amb-Eval input:
try-again
;;; There are no more values of

(let ((pairs (quote ()))) (if-fail (let ((p (prime-sum-pair (quote (1 3 5 8)) (quote (20 35 110))))) (permanent-set! pairs (cons p pairs)) (amb)) pairs))
;;; Amb-Eval input:
(exit)
;;; Starting a new problem 
#+end_src

And that's it? A neat way to iterate over everything.

***** DONE Exercise 4.54 ~analyze-require~
      CLOSED: [2020-02-19 Wed 11:26]

#+name: s-amb-analyze-eval-with-let-amb-ramb-pset-iffail-require
#+begin_src scheme :exports code :results none
  (define (ambeval exp env succeed fail)
     ((analyze exp) env succeed fail))
  (define (analyze exp)
    (cond ((self-evaluating? exp) (analyze-self-evaluating exp))
	  ((quoted? exp) (analyze-quoted exp))
	  ((variable? exp) (analyze-variable exp))
	  ((assignment? exp) (analyze-assignment exp))
          ((permanent-assignment? exp) (analyze-permanent-assignment exp))
	  ((definition? exp) (analyze-definition exp))
	  ((if? exp) (analyze-if exp))
	  ((lambda? exp) (analyze-lambda exp))
	  ((begin? exp) (analyze-sequence (begin-actions exp)))
	  ((cond? exp) (analyze (cond->if exp)))
          ((let? exp) (analyze (let->combination exp)))
          ((if-fail? exp) (analyze-if-fail exp))
          ((require? exp) (analyze-require exp))
          ((amb? exp) (analyze-amb exp))
          ((ramb? exp) (analyze-ramb exp))
	  ((application? exp) (analyze-application exp))
	  (else (error "Unknown expression type: ANALYZE" exp))))

#+end_src

#+name: s-amb-analyze-require
#+begin_src scheme :exports code :results none
  (define (require? exp)
    (tagged-list? exp 'require))
  (define (require-predicate exp)
    (cadr exp))
  (define (analyze-require exp)
    (let ((pproc (analyze (require-predicate exp))))
      (lambda (env succeed fail)
	(pproc env
	       (lambda (pred-value fail2)
		 (if
		  (not pred-value)
		  (fail2)
		  (succeed 'ok fail2)))
	       fail))))
#+end_src

#+name: s-amb-require-test
#+begin_src shell :exports code :results output
  cat << EOF

  <<s-amb-input-an-element-of>>
  <<s-amb-input-an-integer-between>>
  <<s-amb-distinct>>

  (if-fail (let ((x (an-element-of '(1 3 5))))
             (require (even? x))
             x)
           'all-odd)
  (if-fail (let ((x (an-element-of '(1 3 5 8))))
              (require (even? x))
              x)
            'all-odd)
  (exit)
  EOF
#+end_src

#+RESULTS: s-amb-iffail-test

#+header: :stdin s-amb-require-test
#+begin_src shell :shebang "#! /usr/bin/chibi-scheme" :results output scalar code :exports both
<<s-glue1>>
<<s-amb-amb-implementation>>
<<s-amb-analyze-eval-with-let-amb-ramb-pset-iffail-require>>
<<s-amb-analyze-permanent-assignment>>
<<s-amb-analyze-require>>
<<s-let-implementation>>
<<s-amb-simple-expressions>>
<<s-amb-analyze-if>>
<<s-amb-analyze-sequence>>
<<s-amb-analyze-definition>>
<<s-amb-analyze-assignment>>
<<s-amb-analyze-application>>
<<s-amb-get-args>>
<<s-amb-execute-application>>
<<s-amb-analyze-amb>>
<<s-amb-ramb>>
<<s-amb-analyze-if-fail>>
<<s-syntax>>
<<s-application>>
<<s-cond-with-arrow>>
<<s-truefalse>>
<<s-compound-procedures>>
<<s-environments-list-of-bindings-better-abstractions>>
<<s-primitive-procedures>>
<<s-amb-driver-loop>>
<<s-user-prompt-print>>
<<s-glue2>>

(driver-loop)

#+end_src

#+RESULTS[437657788c53683209df5ef624fad6ed5732dafb]:
#+begin_src shell

;;; Amb-Eval input:
(define (an-element-of items) (require (not (null? items))) (amb (car items) (an-element-of (cdr items))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (an-integer-starting-from n) (amb n (an-integer-starting-from (+ n 1))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (an-integer-between n k) (require (< n k)) (amb n (an-integer-between (+ n 1) k)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (distinct? items) (cond ((null? items) true) ((null? (cdr items)) true) ((member (car items) (cdr items)) false) (else (distinct? (cdr items)))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(if-fail (let ((x (an-element-of (quote (1 3 5))))) (require (even? x)) x) (quote all-odd))
;;; Starting a new problem 
;;; Amb-Eval value:
all-odd
;;; Amb-Eval input:
(if-fail (let ((x (an-element-of (quote (1 3 5 8))))) (require (even? x)) x) (quote all-odd))
;;; Starting a new problem 
;;; Amb-Eval value:
8
;;; Amb-Eval input:
(exit)
;;; Starting a new problem 
#+end_src

Hmm... seems an easy task.
**** IMPROV Closing remarks                                        :edition3:

This is a nice section. I think that the new edition of the book could
add some exercises about the ~call/cc~ operation in the newer RNRS.
*** 4.4 Logic Programming [26/26]
**** Some examples

#+name: prolog-examples
#+begin_src scheme :exports code :results none
  (job ?x (computer programmer))
  (address ?x ?y)
  (supervisor ?x ?x)
  (job ?x (computer ?type))
  (job ?x (computer . ?type))
  (and (job ?person (computer programmer))
       (address ?person ?where))
  (or (supervisor ?x (Bitdiddle Ben))
      (supervisor ?x (Hacker Alyssa P)))
  (and (supervisor ?x (Bitdiddle Ben))
       (not (job ?x (computer programmer))))
  (and (salary ?person ?amount) (lisp-value > ?amount 30000))
  (assert! (rule (lives-near ?person-1 ?person-2)
		 (and (address ?person-1 (?town . ?rest-1))
		      (address ?person-2 (?town . ?rest-2))
		      (not (same ?person-1 ?person-2)))))
  (assert! (rule (same ?x ?x)))
  (assert! (rule (wheel ?person)
	    (and (supervisor ?middle-manager ?person)
	         (supervisor ?x ?middle-manager))))
  (lives-near ?x (Bitdiddle Ben))
  (and (job ?x (computer programmer))
       (lives-near ?x (Bitdiddle Ben)))
  (assert! (rule (outranked-by ?staff-person ?boss)
	            (or (supervisor ?staff-person ?boss)
	                (and (supervisor ?staff-person ?middle-manager)
		             (outranked-by ?middle-manager ?boss)))))
  (assert! (rule (append-to-form () ?y ?y)))
  (assert! (rule (append-to-form (?u . ?v) ?y (?u . ?z))
                 (append-to-form ?v ?y ?z)))
  (append-to-form (a b) (c d) ?z)
  (append-to-form (a b) ?y (a b c d))
  (append-to-form ?x ?y (a b c d))

#+end_src

#+name: prolog-input-canned-rules
#+begin_src scheme :exports code :results none
  (assert! (rule (lives-near ?person-1 ?person-2)
		 (and (address ?person-1 (?town . ?rest-1))
		      (address ?person-2 (?town . ?rest-2))
		      (not (same ?person-1 ?person-2)))))
  (assert! (rule (same ?x ?x)))
  (assert! (rule (wheel ?person)
	    (and (supervisor ?middle-manager ?person)
	         (supervisor ?x ?middle-manager))))
  (assert! (rule (outranked-by ?staff-person ?boss)
	            (or (supervisor ?staff-person ?boss)
	                (and (supervisor ?staff-person ?middle-manager)
		             (outranked-by ?middle-manager ?boss)))))
  (assert! (rule (append-to-form () ?y ?y)))
  (assert! (rule (append-to-form (?u . ?v) ?y (?u . ?z))
                 (append-to-form ?v ?y ?z)))

#+end_src

#+name: prolog-input-examples
#+begin_src shell :exports code :results output scalar code
  printf "%s" '
  <<prolog-input-sample-database>>
  <<prolog-examples>>
  exit'
#+end_src

#+header: :stdin prolog-input-examples
#+begin_src shell :shebang "#! /usr/bin/chibi-scheme" :exports both :results output scalar code :exports both
  <<prolog-glue>>
  <<put-and-get>>
  <<streams-common>>
  <<streams-2>>
  <<stream-append>>
  <<prolog-driver-loop>>
  <<prolog-instantiate>>
  <<prolog-qeval>>
  <<prolog-simple-queries>>
  <<prolog-conjoin>>
  <<prolog-conjoin-installation>>
  <<prolog-disjoin>>
  <<prolog-disjoin-installation>>
  <<prolog-negate>>
  <<prolog-negate-installation>>
  <<prolog-lisp-filter>>
  <<prolog-lisp-filter-installation>>
  <<prolog-always-true>>
  <<prolog-pattern-matching>>
  <<prolog-rules-and-unification>>
  <<prolog-database>>
  <<prolog-database-add-assertion-original>>
  <<prolog-database-store-assertion-in-index>>
  <<prolog-stream-operations>>
  <<prolog-stream-flatmap>>
  <<prolog-flatten-stream>>
  <<streams-singleton>>
  <<prolog-query>>
  <<prolog-frames-and-bindings>>
  (query-driver-loop)
#+end_src

#+RESULTS[79263948e4ea2423f3de1dbf248edcb26c641e5e]:
#+begin_src shell

;;; Query input:
(assert! (address (Bitdiddle Ben) (Slumerville (Ridge Road) 10)))
Assertion added to data base.
;;; Query input:
(assert! (job (Bitdiddle Ben) (computer wizard)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Bitdiddle Ben) 60000))
Assertion added to data base.
;;; Query input:
(assert! (address (Hacker Alyssa P) (Cambridge (Mass Ave) 78)))
Assertion added to data base.
;;; Query input:
(assert! (job (Hacker Alyssa P) (computer programmer)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Hacker Alyssa P) 40000))
Assertion added to data base.
;;; Query input:
(assert! (supervisor (Hacker Alyssa P) (Bitdiddle Ben)))
Assertion added to data base.
;;; Query input:
(assert! (address (Fect Cy D) (Cambridge (Ames Street) 3)))
Assertion added to data base.
;;; Query input:
(assert! (job (Fect Cy D) (computer programmer)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Fect Cy D) 35000))
Assertion added to data base.
;;; Query input:
(assert! (supervisor (Fect Cy D) (Bitdiddle Ben)))
Assertion added to data base.
;;; Query input:
(assert! (address (Tweakit Lem E) (Boston (Bay State Road) 22)))
Assertion added to data base.
;;; Query input:
(assert! (job (Tweakit Lem E) (computer technician)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Tweakit Lem E) 25000))
Assertion added to data base.
;;; Query input:
(assert! (supervisor (Tweakit Lem E) (Bitdiddle Ben)))
Assertion added to data base.
;;; Query input:
(assert! (address (Reasoner Louis) (Slumerville (Pine Tree Road) 80)))
Assertion added to data base.
;;; Query input:
(assert! (job (Reasoner Louis) (computer programmer trainee)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Reasoner Louis) 30000))
Assertion added to data base.
;;; Query input:
(assert! (supervisor (Reasoner Louis) (Hacker Alyssa P)))
Assertion added to data base.
;;; Query input:
(assert! (supervisor (Bitdiddle Ben) (Warbucks Oliver)))
Assertion added to data base.
;;; Query input:
(assert! (address (Warbucks Oliver) (Swellesley (Top Heap Road))))
Assertion added to data base.
;;; Query input:
(assert! (job (Warbucks Oliver) (administration big wheel)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Warbucks Oliver) 150000))
Assertion added to data base.
;;; Query input:
(assert! (address (Scrooge Eben) (Weston (Shady Lane) 10)))
Assertion added to data base.
;;; Query input:
(assert! (job (Scrooge Eben) (accounting chief accountant)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Scrooge Eben) 75000))
Assertion added to data base.
;;; Query input:
(assert! (supervisor (Scrooge Eben) (Warbucks Oliver)))
Assertion added to data base.
;;; Query input:
(assert! (address (Cratchet Robert) (Allston (N Harvard Street) 16)))
Assertion added to data base.
;;; Query input:
(assert! (job (Cratchet Robert) (accounting scrivener)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Cratchet Robert) 18000))
Assertion added to data base.
;;; Query input:
(assert! (supervisor (Cratchet Robert) (Scrooge Eben)))
Assertion added to data base.
;;; Query input:
(assert! (address (Aull DeWitt) (Slumerville (Onion Square) 5)))
Assertion added to data base.
;;; Query input:
(assert! (job (Aull DeWitt) (administration secretary)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Aull DeWitt) 25000))
Assertion added to data base.
;;; Query input:
(assert! (supervisor (Aull DeWitt) (Warbucks Oliver)))
Assertion added to data base.
;;; Query input:
(assert! (can-do-job (computer wizard) (computer programmer)))
Assertion added to data base.
;;; Query input:
(assert! (can-do-job (computer wizard) (computer technician)))
Assertion added to data base.
;;; Query input:
(assert! (can-do-job (computer programmer) (computer programmer trainee)))
Assertion added to data base.
;;; Query input:
(assert! (can-do-job (administration secretary) (administration big wheel)))
Assertion added to data base.
;;; Query input:
(job (? x) (computer programmer))
;;; Query results:

debug:simple-query
(job (Fect Cy D) (computer programmer))
(job (Hacker Alyssa P) (computer programmer))

;;; Query input:
(address (? x) (? y))
;;; Query results:

debug:simple-query
(address (Aull DeWitt) (Slumerville (Onion Square) 5))
(address (Cratchet Robert) (Allston (N Harvard Street) 16))
(address (Scrooge Eben) (Weston (Shady Lane) 10))
(address (Warbucks Oliver) (Swellesley (Top Heap Road)))
(address (Reasoner Louis) (Slumerville (Pine Tree Road) 80))
(address (Tweakit Lem E) (Boston (Bay State Road) 22))
(address (Fect Cy D) (Cambridge (Ames Street) 3))
(address (Hacker Alyssa P) (Cambridge (Mass Ave) 78))
(address (Bitdiddle Ben) (Slumerville (Ridge Road) 10))

;;; Query input:
(supervisor (? x) (? x))
;;; Query results:

debug:simple-query

;;; Query input:
(job (? x) (computer (? type)))
;;; Query results:

debug:simple-query
(job (Tweakit Lem E) (computer technician))
(job (Fect Cy D) (computer programmer))
(job (Hacker Alyssa P) (computer programmer))
(job (Bitdiddle Ben) (computer wizard))

;;; Query input:
(job (? x) (computer ? type))
;;; Query results:

debug:simple-query
(job (Reasoner Louis) (computer programmer trainee))
(job (Tweakit Lem E) (computer technician))
(job (Fect Cy D) (computer programmer))
(job (Hacker Alyssa P) (computer programmer))
(job (Bitdiddle Ben) (computer wizard))

;;; Query input:
(and (job (? person) (computer programmer)) (address (? person) (? where)))
;;; Query results:

debug:simple-query

debug:simple-query
(and (job (Fect Cy D) (computer programmer))
     (address (Fect Cy D) (Cambridge (Ames Street) 3)))
(and (job (Hacker Alyssa P) (computer programmer))
     (address (Hacker Alyssa P) (Cambridge (Mass Ave) 78)))

;;; Query input:
(or (supervisor (? x) (Bitdiddle Ben)) (supervisor (? x) (Hacker Alyssa P)))
;;; Query results:

debug:simple-query
(or (supervisor (Tweakit Lem E) (Bitdiddle Ben))
    (supervisor (Tweakit Lem E) (Hacker Alyssa P)))

debug:simple-query
(or (supervisor (Reasoner Louis) (Bitdiddle Ben))
    (supervisor (Reasoner Louis) (Hacker Alyssa P)))
(or (supervisor (Fect Cy D) (Bitdiddle Ben))
    (supervisor (Fect Cy D) (Hacker Alyssa P)))
(or (supervisor (Hacker Alyssa P) (Bitdiddle Ben))
    (supervisor (Hacker Alyssa P) (Hacker Alyssa P)))

;;; Query input:
(and (supervisor (? x) (Bitdiddle Ben))
     (not (job (? x) (computer programmer))))
;;; Query results:

debug:simple-query

debug:simple-query
(and (supervisor (Tweakit Lem E) (Bitdiddle Ben))
     (not (job (Tweakit Lem E) (computer programmer))))

debug:simple-query

debug:simple-query

;;; Query input:
(and (salary (? person) (? amount)) (lisp-value > (? amount) 30000))
;;; Query results:

debug:simple-query
(and (salary (Scrooge Eben) 75000) (lisp-value > 75000 30000))
(and (salary (Warbucks Oliver) 150000) (lisp-value > 150000 30000))
(and (salary (Fect Cy D) 35000) (lisp-value > 35000 30000))
(and (salary (Hacker Alyssa P) 40000) (lisp-value > 40000 30000))
(and (salary (Bitdiddle Ben) 60000) (lisp-value > 60000 30000))

;;; Query input:
(assert!
 (rule (lives-near (? person-1) (? person-2))
       (and (address (? person-1) ((? town) ? rest-1))
            (address (? person-2) ((? town) ? rest-2))
            (not (same (? person-1) (? person-2))))))
Assertion added to data base.
;;; Query input:
(assert! (rule (same (? x) (? x))))
Assertion added to data base.
;;; Query input:
(assert!
 (rule (wheel (? person))
       (and (supervisor (? middle-manager) (? person))
            (supervisor (? x) (? middle-manager)))))
Assertion added to data base.
;;; Query input:
(lives-near (? x) (Bitdiddle Ben))
;;; Query results:

debug:simple-query
apply-a-rule
rule=(rule (lives-near (? person-1) (? person-2))
           (and (address (? person-1) ((? town) ? rest-1))
                (address (? person-2) ((? town) ? rest-2))
                (not (same (? person-1) (? person-2)))))
pattern=(lives-near (? x) (Bitdiddle Ben))
frame=()

unify-result=(((? 1 person-2) Bitdiddle Ben) ((? x) ? 1 person-1))

debug:simple-query

debug:simple-query

debug:simple-query
apply-a-rule
rule=(rule (same (? x) (? x)))
pattern=(same (? 1 person-1) (? 1 person-2))
frame=(((? 1 rest-2) (Ridge Road) 10) ((? 1 rest-1) (Onion Square) 5)
                                      ((? 1 town) . Slumerville)
                                      ((? 1 person-1) Aull DeWitt)
                                      ((? 1 person-2) Bitdiddle Ben)
                                      ((? x) ? 1 person-1))

unify-result=failed
(lives-near (Aull DeWitt) (Bitdiddle Ben))

debug:simple-query
apply-a-rule
rule=(rule (same (? x) (? x)))
pattern=(same (? 1 person-1) (? 1 person-2))
frame=(((? 1 rest-2) (Ridge Road) 10) ((? 1 rest-1) (Pine Tree Road) 80)
                                      ((? 1 town) . Slumerville)
                                      ((? 1 person-1) Reasoner Louis)
                                      ((? 1 person-2) Bitdiddle Ben)
                                      ((? x) ? 1 person-1))

unify-result=failed
(lives-near (Reasoner Louis) (Bitdiddle Ben))

debug:simple-query
apply-a-rule
rule=(rule (same (? x) (? x)))
pattern=(same (? 1 person-1) (? 1 person-2))
frame=(((? 1 rest-2) (Ridge Road) 10) ((? 1 rest-1) (Ridge Road) 10)
                                      ((? 1 town) . Slumerville)
                                      ((? 1 person-1) Bitdiddle Ben)
                                      ((? 1 person-2) Bitdiddle Ben)
                                      ((? x) ? 1 person-1))

unify-result=(((? 4 x) Bitdiddle Ben) ((? 1 rest-2) (Ridge Road) 10)
                                      ((? 1 rest-1) (Ridge Road) 10)
                                      ((? 1 town) . Slumerville)
                                      ((? 1 person-1) Bitdiddle Ben)
                                      ((? 1 person-2) Bitdiddle Ben)
                                      ((? x) ? 1 person-1))

;;; Query input:
(and (job (? x) (computer programmer)) (lives-near (? x) (Bitdiddle Ben)))
;;; Query results:

debug:simple-query

debug:simple-query
apply-a-rule
rule=(rule (lives-near (? person-1) (? person-2))
           (and (address (? person-1) ((? town) ? rest-1))
                (address (? person-2) ((? town) ? rest-2))
                (not (same (? person-1) (? person-2)))))
pattern=(lives-near (? x) (Bitdiddle Ben))
frame=(((? x) Fect Cy D))

unify-result=(((? 5 person-2) Bitdiddle Ben) ((? 5 person-1) Fect Cy D)
                                             ((? x) Fect Cy D))

debug:simple-query

debug:simple-query
apply-a-rule
rule=(rule (lives-near (? person-1) (? person-2))
           (and (address (? person-1) ((? town) ? rest-1))
                (address (? person-2) ((? town) ? rest-2))
                (not (same (? person-1) (? person-2)))))
pattern=(lives-near (? x) (Bitdiddle Ben))
frame=(((? x) Hacker Alyssa P))

unify-result=(((? 6 person-2) Bitdiddle Ben) ((? 6 person-1) Hacker Alyssa P)
                                             ((? x) Hacker Alyssa P))

debug:simple-query

debug:simple-query

;;; Query input:
(assert!
 (rule (outranked-by (? staff-person) (? boss))
       (or (supervisor (? staff-person) (? boss))
           (and (supervisor (? staff-person) (? middle-manager))
                (outranked-by (? middle-manager) (? boss))))))
Assertion added to data base.
;;; Query input:
(assert! (rule (append-to-form () (? y) (? y))))
Assertion added to data base.
;;; Query input:
(assert!
 (rule (append-to-form ((? u) ? v) (? y) ((? u) ? z))
       (append-to-form (? v) (? y) (? z))))
Assertion added to data base.
;;; Query input:
(append-to-form (a b) (c d) (? z))
;;; Query results:

debug:simple-query
apply-a-rule
rule=(rule (append-to-form ((? u) ? v) (? y) ((? u) ? z))
           (append-to-form (? v) (? y) (? z)))
pattern=(append-to-form (a b) (c d) (? z))
frame=()

unify-result=(((? z) (? 7 u) ? 7 z) ((? 7 y) c d) ((? 7 v) b) ((? 7 u) . a))

debug:simple-query
apply-a-rule
rule=(rule (append-to-form ((? u) ? v) (? y) ((? u) ? z))
           (append-to-form (? v) (? y) (? z)))
pattern=(append-to-form (? 7 v) (? 7 y) (? 7 z))
frame=(((? z) (? 7 u) ? 7 z) ((? 7 y) c d) ((? 7 v) b) ((? 7 u) . a))

unify-result=(((? 7 z) (? 8 u) ? 8 z) ((? 8 y) c d)
                                      ((? 8 v))
                                      ((? 8 u) . b)
                                      ((? z) (? 7 u) ? 7 z)
                                      ((? 7 y) c d)
                                      ((? 7 v) b)
                                      ((? 7 u) . a))

debug:simple-query
apply-a-rule
rule=(rule (append-to-form ((? u) ? v) (? y) ((? u) ? z))
           (append-to-form (? v) (? y) (? z)))
pattern=(append-to-form (? 8 v) (? 8 y) (? 8 z))
frame=(((? 7 z) (? 8 u) ? 8 z) ((? 8 y) c d)
                               ((? 8 v))
                               ((? 8 u) . b)
                               ((? z) (? 7 u) ? 7 z)
                               ((? 7 y) c d)
                               ((? 7 v) b)
                               ((? 7 u) . a))

unify-result=failed
apply-a-rule
rule=(rule (append-to-form () (? y) (? y)))
pattern=(append-to-form (? 8 v) (? 8 y) (? 8 z))
frame=(((? 7 z) (? 8 u) ? 8 z) ((? 8 y) c d)
                               ((? 8 v))
                               ((? 8 u) . b)
                               ((? z) (? 7 u) ? 7 z)
                               ((? 7 y) c d)
                               ((? 7 v) b)
                               ((? 7 u) . a))

unify-result=(((? 8 z) c d) ((? 10 y) c d)
                            ((? 7 z) (? 8 u) ? 8 z)
                            ((? 8 y) c d)
                            ((? 8 v))
                            ((? 8 u) . b)
                            ((? z) (? 7 u) ? 7 z)
                            ((? 7 y) c d)
                            ((? 7 v) b)
                            ((? 7 u) . a))
(append-to-form (a b) (c d) (a b c d))
apply-a-rule
rule=(rule (append-to-form () (? y) (? y)))
pattern=(append-to-form (a b) (c d) (? z))
frame=()

unify-result=failed
apply-a-rule
rule=(rule (append-to-form () (? y) (? y)))
pattern=(append-to-form (? 7 v) (? 7 y) (? 7 z))
frame=(((? z) (? 7 u) ? 7 z) ((? 7 y) c d) ((? 7 v) b) ((? 7 u) . a))

unify-result=failed

;;; Query input:
(append-to-form (a b) (? y) (a b c d))
;;; Query results:

debug:simple-query
apply-a-rule
rule=(rule (append-to-form ((? u) ? v) (? y) ((? u) ? z))
           (append-to-form (? v) (? y) (? z)))
pattern=(append-to-form (a b) (? y) (a b c d))
frame=()

unify-result=(((? 13 z) b c d) ((? y) ? 13 y) ((? 13 v) b) ((? 13 u) . a))

debug:simple-query
apply-a-rule
rule=(rule (append-to-form ((? u) ? v) (? y) ((? u) ? z))
           (append-to-form (? v) (? y) (? z)))
pattern=(append-to-form (? 13 v) (? 13 y) (? 13 z))
frame=(((? 13 z) b c d) ((? y) ? 13 y) ((? 13 v) b) ((? 13 u) . a))

unify-result=(((? 14 z) c d) ((? 13 y) ? 14 y)
                             ((? 14 v))
                             ((? 14 u) . b)
                             ((? 13 z) b c d)
                             ((? y) ? 13 y)
                             ((? 13 v) b)
                             ((? 13 u) . a))

debug:simple-query
apply-a-rule
rule=(rule (append-to-form ((? u) ? v) (? y) ((? u) ? z))
           (append-to-form (? v) (? y) (? z)))
pattern=(append-to-form (? 14 v) (? 14 y) (? 14 z))
frame=(((? 14 z) c d) ((? 13 y) ? 14 y)
                      ((? 14 v))
                      ((? 14 u) . b)
                      ((? 13 z) b c d)
                      ((? y) ? 13 y)
                      ((? 13 v) b)
                      ((? 13 u) . a))

unify-result=failed
apply-a-rule
rule=(rule (append-to-form () (? y) (? y)))
pattern=(append-to-form (? 14 v) (? 14 y) (? 14 z))
frame=(((? 14 z) c d) ((? 13 y) ? 14 y)
                      ((? 14 v))
                      ((? 14 u) . b)
                      ((? 13 z) b c d)
                      ((? y) ? 13 y)
                      ((? 13 v) b)
                      ((? 13 u) . a))

unify-result=(((? 16 y) c d) ((? 14 y) ? 16 y)
                             ((? 14 z) c d)
                             ((? 13 y) ? 14 y)
                             ((? 14 v))
                             ((? 14 u) . b)
                             ((? 13 z) b c d)
                             ((? y) ? 13 y)
                             ((? 13 v) b)
                             ((? 13 u) . a))
(append-to-form (a b) (c d) (a b c d))
apply-a-rule
rule=(rule (append-to-form () (? y) (? y)))
pattern=(append-to-form (a b) (? y) (a b c d))
frame=()

unify-result=failed
apply-a-rule
rule=(rule (append-to-form () (? y) (? y)))
pattern=(append-to-form (? 13 v) (? 13 y) (? 13 z))
frame=(((? 13 z) b c d) ((? y) ? 13 y) ((? 13 v) b) ((? 13 u) . a))

unify-result=failed

;;; Query input:
(append-to-form (? x) (? y) (a b c d))
;;; Query results:

debug:simple-query
apply-a-rule
rule=(rule (append-to-form ((? u) ? v) (? y) ((? u) ? z))
           (append-to-form (? v) (? y) (? z)))
pattern=(append-to-form (? x) (? y) (a b c d))
frame=()

unify-result=(((? 19 z) b c d) ((? 19 u) . a)
                               ((? y) ? 19 y)
                               ((? x) (? 19 u) ? 19 v))

debug:simple-query
apply-a-rule
rule=(rule (append-to-form ((? u) ? v) (? y) ((? u) ? z))
           (append-to-form (? v) (? y) (? z)))
pattern=(append-to-form (? 19 v) (? 19 y) (? 19 z))
frame=(((? 19 z) b c d) ((? 19 u) . a) ((? y) ? 19 y) ((? x) (? 19 u) ? 19 v))

unify-result=(((? 20 z) c d) ((? 20 u) . b)
                             ((? 19 y) ? 20 y)
                             ((? 19 v) (? 20 u) ? 20 v)
                             ((? 19 z) b c d)
                             ((? 19 u) . a)
                             ((? y) ? 19 y)
                             ((? x) (? 19 u) ? 19 v))

debug:simple-query
apply-a-rule
rule=(rule (append-to-form ((? u) ? v) (? y) ((? u) ? z))
           (append-to-form (? v) (? y) (? z)))
pattern=(append-to-form (? 20 v) (? 20 y) (? 20 z))
frame=(((? 20 z) c d) ((? 20 u) . b)
                      ((? 19 y) ? 20 y)
                      ((? 19 v) (? 20 u) ? 20 v)
                      ((? 19 z) b c d)
                      ((? 19 u) . a)
                      ((? y) ? 19 y)
                      ((? x) (? 19 u) ? 19 v))

unify-result=(((? 21 z) d) ((? 21 u) . c)
                           ((? 20 y) ? 21 y)
                           ((? 20 v) (? 21 u) ? 21 v)
                           ((? 20 z) c d)
                           ((? 20 u) . b)
                           ((? 19 y) ? 20 y)
                           ((? 19 v) (? 20 u) ? 20 v)
                           ((? 19 z) b c d)
                           ((? 19 u) . a)
                           ((? y) ? 19 y)
                           ((? x) (? 19 u) ? 19 v))

debug:simple-query
apply-a-rule
rule=(rule (append-to-form ((? u) ? v) (? y) ((? u) ? z))
           (append-to-form (? v) (? y) (? z)))
pattern=(append-to-form (? 21 v) (? 21 y) (? 21 z))
frame=(((? 21 z) d) ((? 21 u) . c)
                    ((? 20 y) ? 21 y)
                    ((? 20 v) (? 21 u) ? 21 v)
                    ((? 20 z) c d)
                    ((? 20 u) . b)
                    ((? 19 y) ? 20 y)
                    ((? 19 v) (? 20 u) ? 20 v)
                    ((? 19 z) b c d)
                    ((? 19 u) . a)
                    ((? y) ? 19 y)
                    ((? x) (? 19 u) ? 19 v))

unify-result=(((? 22 z)) ((? 22 u) . d)
                         ((? 21 y) ? 22 y)
                         ((? 21 v) (? 22 u) ? 22 v)
                         ((? 21 z) d)
                         ((? 21 u) . c)
                         ((? 20 y) ? 21 y)
                         ((? 20 v) (? 21 u) ? 21 v)
                         ((? 20 z) c d)
                         ((? 20 u) . b)
                         ((? 19 y) ? 20 y)
                         ((? 19 v) (? 20 u) ? 20 v)
                         ((? 19 z) b c d)
                         ((? 19 u) . a)
                         ((? y) ? 19 y)
                         ((? x) (? 19 u) ? 19 v))

debug:simple-query
apply-a-rule
rule=(rule (append-to-form ((? u) ? v) (? y) ((? u) ? z))
           (append-to-form (? v) (? y) (? z)))
pattern=(append-to-form (? 22 v) (? 22 y) (? 22 z))
frame=(((? 22 z)) ((? 22 u) . d)
                  ((? 21 y) ? 22 y)
                  ((? 21 v) (? 22 u) ? 22 v)
                  ((? 21 z) d)
                  ((? 21 u) . c)
                  ((? 20 y) ? 21 y)
                  ((? 20 v) (? 21 u) ? 21 v)
                  ((? 20 z) c d)
                  ((? 20 u) . b)
                  ((? 19 y) ? 20 y)
                  ((? 19 v) (? 20 u) ? 20 v)
                  ((? 19 z) b c d)
                  ((? 19 u) . a)
                  ((? y) ? 19 y)
                  ((? x) (? 19 u) ? 19 v))

unify-result=failed
apply-a-rule
rule=(rule (append-to-form () (? y) (? y)))
pattern=(append-to-form (? 22 v) (? 22 y) (? 22 z))
frame=(((? 22 z)) ((? 22 u) . d)
                  ((? 21 y) ? 22 y)
                  ((? 21 v) (? 22 u) ? 22 v)
                  ((? 21 z) d)
                  ((? 21 u) . c)
                  ((? 20 y) ? 21 y)
                  ((? 20 v) (? 21 u) ? 21 v)
                  ((? 20 z) c d)
                  ((? 20 u) . b)
                  ((? 19 y) ? 20 y)
                  ((? 19 v) (? 20 u) ? 20 v)
                  ((? 19 z) b c d)
                  ((? 19 u) . a)
                  ((? y) ? 19 y)
                  ((? x) (? 19 u) ? 19 v))

unify-result=(((? 24 y)) ((? 22 y) ? 24 y)
                         ((? 22 v))
                         ((? 22 z))
                         ((? 22 u) . d)
                         ((? 21 y) ? 22 y)
                         ((? 21 v) (? 22 u) ? 22 v)
                         ((? 21 z) d)
                         ((? 21 u) . c)
                         ((? 20 y) ? 21 y)
                         ((? 20 v) (? 21 u) ? 21 v)
                         ((? 20 z) c d)
                         ((? 20 u) . b)
                         ((? 19 y) ? 20 y)
                         ((? 19 v) (? 20 u) ? 20 v)
                         ((? 19 z) b c d)
                         ((? 19 u) . a)
                         ((? y) ? 19 y)
                         ((? x) (? 19 u) ? 19 v))
(append-to-form (a b c d) () (a b c d))
apply-a-rule
rule=(rule (append-to-form () (? y) (? y)))
pattern=(append-to-form (? x) (? y) (a b c d))
frame=()

unify-result=(((? 25 y) a b c d) ((? y) ? 25 y) ((? x)))
(append-to-form () (a b c d) (a b c d))
apply-a-rule
rule=(rule (append-to-form () (? y) (? y)))
pattern=(append-to-form (? 19 v) (? 19 y) (? 19 z))
frame=(((? 19 z) b c d) ((? 19 u) . a) ((? y) ? 19 y) ((? x) (? 19 u) ? 19 v))

unify-result=(((? 26 y) b c d) ((? 19 y) ? 26 y)
                               ((? 19 v))
                               ((? 19 z) b c d)
                               ((? 19 u) . a)
                               ((? y) ? 19 y)
                               ((? x) (? 19 u) ? 19 v))
(append-to-form (a) (b c d) (a b c d))
apply-a-rule
rule=(rule (append-to-form () (? y) (? y)))
pattern=(append-to-form (? 20 v) (? 20 y) (? 20 z))
frame=(((? 20 z) c d) ((? 20 u) . b)
                      ((? 19 y) ? 20 y)
                      ((? 19 v) (? 20 u) ? 20 v)
                      ((? 19 z) b c d)
                      ((? 19 u) . a)
                      ((? y) ? 19 y)
                      ((? x) (? 19 u) ? 19 v))

unify-result=(((? 27 y) c d) ((? 20 y) ? 27 y)
                             ((? 20 v))
                             ((? 20 z) c d)
                             ((? 20 u) . b)
                             ((? 19 y) ? 20 y)
                             ((? 19 v) (? 20 u) ? 20 v)
                             ((? 19 z) b c d)
                             ((? 19 u) . a)
                             ((? y) ? 19 y)
                             ((? x) (? 19 u) ? 19 v))
(append-to-form (a b) (c d) (a b c d))
apply-a-rule
rule=(rule (append-to-form () (? y) (? y)))
pattern=(append-to-form (? 21 v) (? 21 y) (? 21 z))
frame=(((? 21 z) d) ((? 21 u) . c)
                    ((? 20 y) ? 21 y)
                    ((? 20 v) (? 21 u) ? 21 v)
                    ((? 20 z) c d)
                    ((? 20 u) . b)
                    ((? 19 y) ? 20 y)
                    ((? 19 v) (? 20 u) ? 20 v)
                    ((? 19 z) b c d)
                    ((? 19 u) . a)
                    ((? y) ? 19 y)
                    ((? x) (? 19 u) ? 19 v))

unify-result=(((? 28 y) d) ((? 21 y) ? 28 y)
                           ((? 21 v))
                           ((? 21 z) d)
                           ((? 21 u) . c)
                           ((? 20 y) ? 21 y)
                           ((? 20 v) (? 21 u) ? 21 v)
                           ((? 20 z) c d)
                           ((? 20 u) . b)
                           ((? 19 y) ? 20 y)
                           ((? 19 v) (? 20 u) ? 20 v)
                           ((? 19 z) b c d)
                           ((? 19 u) . a)
                           ((? y) ? 19 y)
                           ((? x) (? 19 u) ? 19 v))
(append-to-form (a b c) (d) (a b c d))

;;; Query input:
exit
#+end_src

**** 4.4.1 Deductive Information Retrieval [9/9]
***** DONE Exercise 4.55 Simple queries
      CLOSED: [2020-02-19 Wed 17:38]

#+name: prolog-input-simple-queries
#+begin_src shell :exports code :results verbatim output code
  printf "%s" '
  <<prolog-input-sample-database>>
  (supervisor ?x (Bitdiddle Ben))
  (job ?x (accounting . ?post))
  (address ?x (Slumerville . ?street))
  exit'
#+end_src

#+header: :stdin prolog-input-simple-queries
#+begin_src shell :shebang "#! /usr/bin/chibi-scheme" :exports both :results output scalar code :exports both
  <<prolog-glue>>
  <<put-and-get>>
  <<streams-common>>
  <<streams-2>>
  <<stream-append>>
  <<prolog-driver-loop>>
  <<prolog-instantiate>>
  <<prolog-qeval>>
  <<prolog-simple-queries>>
  <<prolog-conjoin>>
  <<prolog-conjoin-installation>>
  <<prolog-disjoin>>
  <<prolog-disjoin-installation>>
  <<prolog-negate>>
  <<prolog-negate-installation>>
  <<prolog-lisp-filter>>
  <<prolog-lisp-filter-installation>>
  <<prolog-always-true>>
  <<prolog-pattern-matching>>
  <<prolog-rules-and-unification>>
  <<prolog-database>>
  <<prolog-database-add-assertion-original>>
  <<prolog-database-store-assertion-in-index>>
  <<prolog-stream-operations>>
  <<prolog-stream-flatmap>>
  <<prolog-flatten-stream>>
  <<streams-singleton>>
  <<prolog-query>>
  <<prolog-frames-and-bindings>>
  (query-driver-loop)
#+end_src

#+RESULTS[db186e0b640f423c6f62ba76cb44ef25362d1de4]:
#+begin_src shell

;;; Query input:
(assert! (address (Bitdiddle Ben) (Slumerville (Ridge Road) 10)))
Assertion added to data base.
;;; Query input:
(assert! (job (Bitdiddle Ben) (computer wizard)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Bitdiddle Ben) 60000))
Assertion added to data base.
;;; Query input:
(assert! (address (Hacker Alyssa P) (Cambridge (Mass Ave) 78)))
Assertion added to data base.
;;; Query input:
(assert! (job (Hacker Alyssa P) (computer programmer)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Hacker Alyssa P) 40000))
Assertion added to data base.
;;; Query input:
(assert! (supervisor (Hacker Alyssa P) (Bitdiddle Ben)))
Assertion added to data base.
;;; Query input:
(assert! (address (Fect Cy D) (Cambridge (Ames Street) 3)))
Assertion added to data base.
;;; Query input:
(assert! (job (Fect Cy D) (computer programmer)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Fect Cy D) 35000))
Assertion added to data base.
;;; Query input:
(assert! (supervisor (Fect Cy D) (Bitdiddle Ben)))
Assertion added to data base.
;;; Query input:
(assert! (address (Tweakit Lem E) (Boston (Bay State Road) 22)))
Assertion added to data base.
;;; Query input:
(assert! (job (Tweakit Lem E) (computer technician)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Tweakit Lem E) 25000))
Assertion added to data base.
;;; Query input:
(assert! (supervisor (Tweakit Lem E) (Bitdiddle Ben)))
Assertion added to data base.
;;; Query input:
(assert! (address (Reasoner Louis) (Slumerville (Pine Tree Road) 80)))
Assertion added to data base.
;;; Query input:
(assert! (job (Reasoner Louis) (computer programmer trainee)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Reasoner Louis) 30000))
Assertion added to data base.
;;; Query input:
(assert! (supervisor (Reasoner Louis) (Hacker Alyssa P)))
Assertion added to data base.
;;; Query input:
(assert! (supervisor (Bitdiddle Ben) (Warbucks Oliver)))
Assertion added to data base.
;;; Query input:
(assert! (address (Warbucks Oliver) (Swellesley (Top Heap Road))))
Assertion added to data base.
;;; Query input:
(assert! (job (Warbucks Oliver) (administration big wheel)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Warbucks Oliver) 150000))
Assertion added to data base.
;;; Query input:
(assert! (address (Scrooge Eben) (Weston (Shady Lane) 10)))
Assertion added to data base.
;;; Query input:
(assert! (job (Scrooge Eben) (accounting chief accountant)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Scrooge Eben) 75000))
Assertion added to data base.
;;; Query input:
(assert! (supervisor (Scrooge Eben) (Warbucks Oliver)))
Assertion added to data base.
;;; Query input:
(assert! (address (Cratchet Robert) (Allston (N Harvard Street) 16)))
Assertion added to data base.
;;; Query input:
(assert! (job (Cratchet Robert) (accounting scrivener)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Cratchet Robert) 18000))
Assertion added to data base.
;;; Query input:
(assert! (supervisor (Cratchet Robert) (Scrooge Eben)))
Assertion added to data base.
;;; Query input:
(assert! (address (Aull DeWitt) (Slumerville (Onion Square) 5)))
Assertion added to data base.
;;; Query input:
(assert! (job (Aull DeWitt) (administration secretary)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Aull DeWitt) 25000))
Assertion added to data base.
;;; Query input:
(assert! (supervisor (Aull DeWitt) (Warbucks Oliver)))
Assertion added to data base.
;;; Query input:
(assert! (can-do-job (computer wizard) (computer programmer)))
Assertion added to data base.
;;; Query input:
(assert! (can-do-job (computer wizard) (computer technician)))
Assertion added to data base.
;;; Query input:
(assert! (can-do-job (computer programmer) (computer programmer trainee)))
Assertion added to data base.
;;; Query input:
(assert! (can-do-job (administration secretary) (administration big wheel)))
Assertion added to data base.
;;; Query input:
(supervisor (? x) (Bitdiddle Ben))
;;; Query results:

debug:simple-query
(supervisor (Tweakit Lem E) (Bitdiddle Ben))
(supervisor (Fect Cy D) (Bitdiddle Ben))
(supervisor (Hacker Alyssa P) (Bitdiddle Ben))

;;; Query input:
(job (? x) (accounting ? post))
;;; Query results:

debug:simple-query
(job (Cratchet Robert) (accounting scrivener))
(job (Scrooge Eben) (accounting chief accountant))

;;; Query input:
(address (? x) (Slumerville ? street))
;;; Query results:

debug:simple-query
(address (Aull DeWitt) (Slumerville (Onion Square) 5))
(address (Reasoner Louis) (Slumerville (Pine Tree Road) 80))
(address (Bitdiddle Ben) (Slumerville (Ridge Road) 10))

;;; Query input:
exit
#+end_src

***** DONE Exercise 4.56 Compound queries
      CLOSED: [2020-02-19 Wed 18:04]

No need to use ~or~, huh?

#+name: prolog-input-compound-queries
#+begin_src shell :exports code :results verbatim output scalar code
  printf "%s" '
  <<prolog-input-sample-database>>
  (and (supervisor ?person (Bitdiddle Ben))
       (address ?person ?street))
  (and (salary (Bitdiddle Ben) ?amount)
       (salary ?name ?salary)
       (lisp-value < ?salary ?amount))
  (and (supervisor ?person ?name) (not (job ?name (computer . ?post))) (job ?name . ?x))
  exit'
#+end_src

#+header: :stdin prolog-input-compound-queries
#+begin_src shell :shebang "#! /usr/bin/chibi-scheme" :exports both :results output scalar code :exports both
  <<prolog-glue>>
  <<put-and-get>>
  <<streams-common>>
  <<streams-2>>
  <<stream-append>>
  <<prolog-driver-loop>>
  <<prolog-instantiate>>
  <<prolog-qeval>>
  <<prolog-simple-queries>>
  <<prolog-conjoin>>
  <<prolog-conjoin-installation>>
  <<prolog-disjoin>>
  <<prolog-disjoin-installation>>
  <<prolog-negate>>
  <<prolog-negate-installation>>
  <<prolog-lisp-filter>>
  <<prolog-lisp-filter-installation>>
  <<prolog-always-true>>
  <<prolog-pattern-matching>>
  <<prolog-rules-and-unification>>
  <<prolog-database>>
  <<prolog-database-add-assertion-original>>
  <<prolog-database-store-assertion-in-index>>
  <<prolog-stream-operations>>
  <<prolog-stream-flatmap>>
  <<prolog-flatten-stream>>
  <<streams-singleton>>
  <<prolog-query>>
  <<prolog-frames-and-bindings>>
  (query-driver-loop)
#+end_src

#+RESULTS[e0df34cda735833ba7ff731fae2b4358277d6bf1]:
#+begin_src shell

;;; Query input:
(assert! (address (Bitdiddle Ben) (Slumerville (Ridge Road) 10)))
Assertion added to data base.
;;; Query input:
(assert! (job (Bitdiddle Ben) (computer wizard)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Bitdiddle Ben) 60000))
Assertion added to data base.
;;; Query input:
(assert! (address (Hacker Alyssa P) (Cambridge (Mass Ave) 78)))
Assertion added to data base.
;;; Query input:
(assert! (job (Hacker Alyssa P) (computer programmer)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Hacker Alyssa P) 40000))
Assertion added to data base.
;;; Query input:
(assert! (supervisor (Hacker Alyssa P) (Bitdiddle Ben)))
Assertion added to data base.
;;; Query input:
(assert! (address (Fect Cy D) (Cambridge (Ames Street) 3)))
Assertion added to data base.
;;; Query input:
(assert! (job (Fect Cy D) (computer programmer)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Fect Cy D) 35000))
Assertion added to data base.
;;; Query input:
(assert! (supervisor (Fect Cy D) (Bitdiddle Ben)))
Assertion added to data base.
;;; Query input:
(assert! (address (Tweakit Lem E) (Boston (Bay State Road) 22)))
Assertion added to data base.
;;; Query input:
(assert! (job (Tweakit Lem E) (computer technician)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Tweakit Lem E) 25000))
Assertion added to data base.
;;; Query input:
(assert! (supervisor (Tweakit Lem E) (Bitdiddle Ben)))
Assertion added to data base.
;;; Query input:
(assert! (address (Reasoner Louis) (Slumerville (Pine Tree Road) 80)))
Assertion added to data base.
;;; Query input:
(assert! (job (Reasoner Louis) (computer programmer trainee)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Reasoner Louis) 30000))
Assertion added to data base.
;;; Query input:
(assert! (supervisor (Reasoner Louis) (Hacker Alyssa P)))
Assertion added to data base.
;;; Query input:
(assert! (supervisor (Bitdiddle Ben) (Warbucks Oliver)))
Assertion added to data base.
;;; Query input:
(assert! (address (Warbucks Oliver) (Swellesley (Top Heap Road))))
Assertion added to data base.
;;; Query input:
(assert! (job (Warbucks Oliver) (administration big wheel)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Warbucks Oliver) 150000))
Assertion added to data base.
;;; Query input:
(assert! (address (Scrooge Eben) (Weston (Shady Lane) 10)))
Assertion added to data base.
;;; Query input:
(assert! (job (Scrooge Eben) (accounting chief accountant)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Scrooge Eben) 75000))
Assertion added to data base.
;;; Query input:
(assert! (supervisor (Scrooge Eben) (Warbucks Oliver)))
Assertion added to data base.
;;; Query input:
(assert! (address (Cratchet Robert) (Allston (N Harvard Street) 16)))
Assertion added to data base.
;;; Query input:
(assert! (job (Cratchet Robert) (accounting scrivener)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Cratchet Robert) 18000))
Assertion added to data base.
;;; Query input:
(assert! (supervisor (Cratchet Robert) (Scrooge Eben)))
Assertion added to data base.
;;; Query input:
(assert! (address (Aull DeWitt) (Slumerville (Onion Square) 5)))
Assertion added to data base.
;;; Query input:
(assert! (job (Aull DeWitt) (administration secretary)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Aull DeWitt) 25000))
Assertion added to data base.
;;; Query input:
(assert! (supervisor (Aull DeWitt) (Warbucks Oliver)))
Assertion added to data base.
;;; Query input:
(assert! (can-do-job (computer wizard) (computer programmer)))
Assertion added to data base.
;;; Query input:
(assert! (can-do-job (computer wizard) (computer technician)))
Assertion added to data base.
;;; Query input:
(assert! (can-do-job (computer programmer) (computer programmer trainee)))
Assertion added to data base.
;;; Query input:
(assert! (can-do-job (administration secretary) (administration big wheel)))
Assertion added to data base.
;;; Query input:
(and (supervisor (? person) (Bitdiddle Ben)) (address (? person) (? street)))
;;; Query results:

debug:simple-query

debug:simple-query
(and (supervisor (Tweakit Lem E) (Bitdiddle Ben))
     (address (Tweakit Lem E) (Boston (Bay State Road) 22)))
(and (supervisor (Fect Cy D) (Bitdiddle Ben))
     (address (Fect Cy D) (Cambridge (Ames Street) 3)))
(and (supervisor (Hacker Alyssa P) (Bitdiddle Ben))
     (address (Hacker Alyssa P) (Cambridge (Mass Ave) 78)))

;;; Query input:
(and (salary (Bitdiddle Ben) (? amount))
     (salary (? name) (? salary))
     (lisp-value < (? salary) (? amount)))
;;; Query results:

debug:simple-query

debug:simple-query
(and (salary (Bitdiddle Ben) 60000)
     (salary (Aull DeWitt) 25000)
     (lisp-value < 25000 60000))
(and (salary (Bitdiddle Ben) 60000)
     (salary (Cratchet Robert) 18000)
     (lisp-value < 18000 60000))
(and (salary (Bitdiddle Ben) 60000)
     (salary (Reasoner Louis) 30000)
     (lisp-value < 30000 60000))
(and (salary (Bitdiddle Ben) 60000)
     (salary (Tweakit Lem E) 25000)
     (lisp-value < 25000 60000))
(and (salary (Bitdiddle Ben) 60000)
     (salary (Fect Cy D) 35000)
     (lisp-value < 35000 60000))
(and (salary (Bitdiddle Ben) 60000)
     (salary (Hacker Alyssa P) 40000)
     (lisp-value < 40000 60000))

;;; Query input:
(and (supervisor (? person) (? name))
     (not (job (? name) (computer ? post)))
     (job (? name) ? x))
;;; Query results:

debug:simple-query

debug:simple-query

debug:simple-query
(and (supervisor (Aull DeWitt) (Warbucks Oliver))
     (not (job (Warbucks Oliver) (computer . ?post)))
     (job (Warbucks Oliver) (administration big wheel)))

debug:simple-query
(and (supervisor (Cratchet Robert) (Scrooge Eben))
     (not (job (Scrooge Eben) (computer . ?post)))
     (job (Scrooge Eben) (accounting chief accountant)))

debug:simple-query
(and (supervisor (Scrooge Eben) (Warbucks Oliver))
     (not (job (Warbucks Oliver) (computer . ?post)))
     (job (Warbucks Oliver) (administration big wheel)))

debug:simple-query
(and (supervisor (Bitdiddle Ben) (Warbucks Oliver))
     (not (job (Warbucks Oliver) (computer . ?post)))
     (job (Warbucks Oliver) (administration big wheel)))

debug:simple-query

debug:simple-query

debug:simple-query

debug:simple-query

;;; Query input:
exit
#+end_src

***** DONE Exercise 4.57 custom rules
      CLOSED: [2020-02-19 Wed 21:36]

A not too hard exercise.

#+name: prolog-input-own-rules
#+begin_src shell :exports code :results verbatim output scalar code
  printf "%s" '
  <<prolog-input-sample-database>>
  <<prolog-input-canned-rules>>
  (assert! (rule (same-job ?person1 ?person2)
               (and
                    (job ?person1 . ?j1)
                    (job ?person2 . ?j1)
                    (not (same ?person1 ?person2)))))
  (assert! (rule (can-do-job-person ?person1 ?person2)
                    (and (job ?person1 ?job1)
                         (job ?person2 ?job2)
                         (can-do-job ?job2 ?job1))))
  (can-do-job ?job1 ?job2)
  (same-job (Fect Cy D) ?who1)
  (can-do-job-person (Fect Cy D) ?who2)
  (assert! (rule (can-replace ?person2 ?person1)
                 (or (can-do-job-person ?person1 ?person2)
                     (same-job ?person1 ?person2))))
  (can-replace ?who (Fect Cy D))
  (assert! (rule (has-smaller-salary ?poor ?rich ?sa1 ?sa2)
                 (and (salary ?poor ?sa1) (salary ?rich ?sa2) (lisp-value < ?sa1 ?sa2))))
  (has-smaller-salary ?who (Bitdiddle Ben) ?sa1 ?sa2)
  (assert! (rule (underpaid ?underpaid ?overpaid ?salary1 ?salary2)
                 (and (can-replace ?underpaid ?overpaid)
                      (has-smaller-salary ?underpaid ?overpaid ?salary1 ?salary2))))
  (underpaid ?underpaid ?overpaid ?salary1 ?salary2)
  exit'
#+end_src


#+header: :stdin prolog-input-own-rules
#+begin_src shell :shebang "#! /usr/bin/chibi-scheme" :exports both :results output scalar code :exports both
  <<prolog-glue>>
  <<put-and-get>>
  <<streams-common>>
  <<streams-2>>
  <<stream-append>>
  <<prolog-driver-loop>>
  <<prolog-instantiate>>
  <<prolog-qeval>>
  <<prolog-simple-queries>>
  <<prolog-conjoin>>
  <<prolog-conjoin-installation>>
  <<prolog-disjoin>>
  <<prolog-disjoin-installation>>
  <<prolog-negate>>
  <<prolog-negate-installation>>
  <<prolog-lisp-filter>>
  <<prolog-lisp-filter-installation>>
  <<prolog-always-true>>
  <<prolog-pattern-matching>>
  <<prolog-rules-and-unification>>
  <<prolog-database>>
  <<prolog-database-add-assertion-original>>
  <<prolog-database-store-assertion-in-index>>
  <<prolog-stream-operations>>
  <<prolog-stream-flatmap>>
  <<prolog-flatten-stream>>
  <<streams-singleton>>
  <<prolog-query>>
  <<prolog-frames-and-bindings>>
  (query-driver-loop)
#+end_src

#+RESULTS[cf104f7a8b30f92c51fc24504c6e787e542e3b34]:
#+begin_src shell

;;; Query input:
(assert! (address (Bitdiddle Ben) (Slumerville (Ridge Road) 10)))
Assertion added to data base.
;;; Query input:
(assert! (job (Bitdiddle Ben) (computer wizard)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Bitdiddle Ben) 60000))
Assertion added to data base.
;;; Query input:
(assert! (address (Hacker Alyssa P) (Cambridge (Mass Ave) 78)))
Assertion added to data base.
;;; Query input:
(assert! (job (Hacker Alyssa P) (computer programmer)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Hacker Alyssa P) 40000))
Assertion added to data base.
;;; Query input:
(assert! (supervisor (Hacker Alyssa P) (Bitdiddle Ben)))
Assertion added to data base.
;;; Query input:
(assert! (address (Fect Cy D) (Cambridge (Ames Street) 3)))
Assertion added to data base.
;;; Query input:
(assert! (job (Fect Cy D) (computer programmer)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Fect Cy D) 35000))
Assertion added to data base.
;;; Query input:
(assert! (supervisor (Fect Cy D) (Bitdiddle Ben)))
Assertion added to data base.
;;; Query input:
(assert! (address (Tweakit Lem E) (Boston (Bay State Road) 22)))
Assertion added to data base.
;;; Query input:
(assert! (job (Tweakit Lem E) (computer technician)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Tweakit Lem E) 25000))
Assertion added to data base.
;;; Query input:
(assert! (supervisor (Tweakit Lem E) (Bitdiddle Ben)))
Assertion added to data base.
;;; Query input:
(assert! (address (Reasoner Louis) (Slumerville (Pine Tree Road) 80)))
Assertion added to data base.
;;; Query input:
(assert! (job (Reasoner Louis) (computer programmer trainee)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Reasoner Louis) 30000))
Assertion added to data base.
;;; Query input:
(assert! (supervisor (Reasoner Louis) (Hacker Alyssa P)))
Assertion added to data base.
;;; Query input:
(assert! (supervisor (Bitdiddle Ben) (Warbucks Oliver)))
Assertion added to data base.
;;; Query input:
(assert! (address (Warbucks Oliver) (Swellesley (Top Heap Road))))
Assertion added to data base.
;;; Query input:
(assert! (job (Warbucks Oliver) (administration big wheel)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Warbucks Oliver) 150000))
Assertion added to data base.
;;; Query input:
(assert! (address (Scrooge Eben) (Weston (Shady Lane) 10)))
Assertion added to data base.
;;; Query input:
(assert! (job (Scrooge Eben) (accounting chief accountant)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Scrooge Eben) 75000))
Assertion added to data base.
;;; Query input:
(assert! (supervisor (Scrooge Eben) (Warbucks Oliver)))
Assertion added to data base.
;;; Query input:
(assert! (address (Cratchet Robert) (Allston (N Harvard Street) 16)))
Assertion added to data base.
;;; Query input:
(assert! (job (Cratchet Robert) (accounting scrivener)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Cratchet Robert) 18000))
Assertion added to data base.
;;; Query input:
(assert! (supervisor (Cratchet Robert) (Scrooge Eben)))
Assertion added to data base.
;;; Query input:
(assert! (address (Aull DeWitt) (Slumerville (Onion Square) 5)))
Assertion added to data base.
;;; Query input:
(assert! (job (Aull DeWitt) (administration secretary)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Aull DeWitt) 25000))
Assertion added to data base.
;;; Query input:
(assert! (supervisor (Aull DeWitt) (Warbucks Oliver)))
Assertion added to data base.
;;; Query input:
(assert! (can-do-job (computer wizard) (computer programmer)))
Assertion added to data base.
;;; Query input:
(assert! (can-do-job (computer wizard) (computer technician)))
Assertion added to data base.
;;; Query input:
(assert! (can-do-job (computer programmer) (computer programmer trainee)))
Assertion added to data base.
;;; Query input:
(assert! (can-do-job (administration secretary) (administration big wheel)))
Assertion added to data base.
;;; Query input:
(assert!
 (rule (lives-near (? person-1) (? person-2))
       (and (address (? person-1) ((? town) ? rest-1))
            (address (? person-2) ((? town) ? rest-2))
            (not (same (? person-1) (? person-2))))))
Assertion added to data base.
;;; Query input:
(assert! (rule (same (? x) (? x))))
Assertion added to data base.
;;; Query input:
(assert!
 (rule (wheel (? person))
       (and (supervisor (? middle-manager) (? person))
            (supervisor (? x) (? middle-manager)))))
Assertion added to data base.
;;; Query input:
(assert!
 (rule (outranked-by (? staff-person) (? boss))
       (or (supervisor (? staff-person) (? boss))
           (and (supervisor (? staff-person) (? middle-manager))
                (outranked-by (? middle-manager) (? boss))))))
Assertion added to data base.
;;; Query input:
(assert! (rule (append-to-form () (? y) (? y))))
Assertion added to data base.
;;; Query input:
(assert!
 (rule (append-to-form ((? u) ? v) (? y) ((? u) ? z))
       (append-to-form (? v) (? y) (? z))))
Assertion added to data base.
;;; Query input:
(assert!
 (rule (same-job (? person1) (? person2))
       (and (job (? person1) ? j1)
            (job (? person2) ? j1)
            (not (same (? person1) (? person2))))))
Assertion added to data base.
;;; Query input:
(assert!
 (rule (can-do-job-person (? person1) (? person2))
       (and (job (? person1) (? job1))
            (job (? person2) (? job2))
            (can-do-job (? job2) (? job1)))))
Assertion added to data base.
;;; Query input:
(can-do-job (? job1) (? job2))
;;; Query results:

debug:simple-query
(can-do-job (administration secretary) (administration big wheel))
(can-do-job (computer programmer) (computer programmer trainee))
(can-do-job (computer wizard) (computer technician))
(can-do-job (computer wizard) (computer programmer))

;;; Query input:
(same-job (Fect Cy D) (? who1))
;;; Query results:

debug:simple-query
apply-a-rule
rule=(rule (same-job (? person1) (? person2))
           (and (job (? person1) ? j1)
                (job (? person2) ? j1)
                (not (same (? person1) (? person2)))))
pattern=(same-job (Fect Cy D) (? who1))
frame=()

unify-result=(((? who1) ? 1 person2) ((? 1 person1) Fect Cy D))

debug:simple-query

debug:simple-query

debug:simple-query
apply-a-rule
rule=(rule (same (? x) (? x)))
pattern=(same (? 1 person1) (? 1 person2))
frame=(((? 1 person2) Fect Cy D) ((? 1 j1) (computer programmer))
                                 ((? who1) ? 1 person2)
                                 ((? 1 person1) Fect Cy D))

unify-result=(((? 2 x) Fect Cy D) ((? 1 person2) Fect Cy D)
                                  ((? 1 j1) (computer programmer))
                                  ((? who1) ? 1 person2)
                                  ((? 1 person1) Fect Cy D))

debug:simple-query
apply-a-rule
rule=(rule (same (? x) (? x)))
pattern=(same (? 1 person1) (? 1 person2))
frame=(((? 1 person2) Hacker Alyssa P) ((? 1 j1) (computer programmer))
                                       ((? who1) ? 1 person2)
                                       ((? 1 person1) Fect Cy D))

unify-result=failed
(same-job (Fect Cy D) (Hacker Alyssa P))

;;; Query input:
(can-do-job-person (Fect Cy D) (? who2))
;;; Query results:

debug:simple-query
apply-a-rule
rule=(rule (can-do-job-person (? person1) (? person2))
           (and (job (? person1) (? job1))
                (job (? person2) (? job2))
                (can-do-job (? job2) (? job1))))
pattern=(can-do-job-person (Fect Cy D) (? who2))
frame=()

unify-result=(((? who2) ? 4 person2) ((? 4 person1) Fect Cy D))

debug:simple-query

debug:simple-query

debug:simple-query
(can-do-job-person (Fect Cy D) (Bitdiddle Ben))

;;; Query input:
(assert!
 (rule (can-replace (? person2) (? person1))
       (or (can-do-job-person (? person1) (? person2))
           (same-job (? person1) (? person2)))))
Assertion added to data base.
;;; Query input:
(can-replace (? who) (Fect Cy D))
;;; Query results:

debug:simple-query
apply-a-rule
rule=(rule (can-replace (? person2) (? person1))
           (or (can-do-job-person (? person1) (? person2))
               (same-job (? person1) (? person2))))
pattern=(can-replace (? who) (Fect Cy D))
frame=()

unify-result=(((? 5 person1) Fect Cy D) ((? who) ? 5 person2))

debug:simple-query
apply-a-rule
rule=(rule (can-do-job-person (? person1) (? person2))
           (and (job (? person1) (? job1))
                (job (? person2) (? job2))
                (can-do-job (? job2) (? job1))))
pattern=(can-do-job-person (? 5 person1) (? 5 person2))
frame=(((? 5 person1) Fect Cy D) ((? who) ? 5 person2))

unify-result=(((? 5 person2) ? 6 person2) ((? 6 person1) Fect Cy D)
                                          ((? 5 person1) Fect Cy D)
                                          ((? who) ? 5 person2))

debug:simple-query

debug:simple-query

debug:simple-query
(can-replace (Bitdiddle Ben) (Fect Cy D))

debug:simple-query
apply-a-rule
rule=(rule (same-job (? person1) (? person2))
           (and (job (? person1) ? j1)
                (job (? person2) ? j1)
                (not (same (? person1) (? person2)))))
pattern=(same-job (? 5 person1) (? 5 person2))
frame=(((? 5 person1) Fect Cy D) ((? who) ? 5 person2))

unify-result=(((? 5 person2) ? 7 person2) ((? 7 person1) Fect Cy D)
                                          ((? 5 person1) Fect Cy D)
                                          ((? who) ? 5 person2))

debug:simple-query

debug:simple-query

debug:simple-query
apply-a-rule
rule=(rule (same (? x) (? x)))
pattern=(same (? 7 person1) (? 7 person2))
frame=(((? 7 person2) Fect Cy D) ((? 7 j1) (computer programmer))
                                 ((? 5 person2) ? 7 person2)
                                 ((? 7 person1) Fect Cy D)
                                 ((? 5 person1) Fect Cy D)
                                 ((? who) ? 5 person2))

unify-result=(((? 8 x) Fect Cy D) ((? 7 person2) Fect Cy D)
                                  ((? 7 j1) (computer programmer))
                                  ((? 5 person2) ? 7 person2)
                                  ((? 7 person1) Fect Cy D)
                                  ((? 5 person1) Fect Cy D)
                                  ((? who) ? 5 person2))

debug:simple-query
apply-a-rule
rule=(rule (same (? x) (? x)))
pattern=(same (? 7 person1) (? 7 person2))
frame=(((? 7 person2) Hacker Alyssa P) ((? 7 j1) (computer programmer))
                                       ((? 5 person2) ? 7 person2)
                                       ((? 7 person1) Fect Cy D)
                                       ((? 5 person1) Fect Cy D)
                                       ((? who) ? 5 person2))

unify-result=failed
(can-replace (Hacker Alyssa P) (Fect Cy D))

;;; Query input:
(assert!
 (rule (has-smaller-salary (? poor) (? rich) (? sa1) (? sa2))
       (and (salary (? poor) (? sa1))
            (salary (? rich) (? sa2))
            (lisp-value < (? sa1) (? sa2)))))
Assertion added to data base.
;;; Query input:
(has-smaller-salary (? who) (Bitdiddle Ben) (? sa1) (? sa2))
;;; Query results:

debug:simple-query
apply-a-rule
rule=(rule (has-smaller-salary (? poor) (? rich) (? sa1) (? sa2))
           (and (salary (? poor) (? sa1))
                (salary (? rich) (? sa2))
                (lisp-value < (? sa1) (? sa2))))
pattern=(has-smaller-salary (? who) (Bitdiddle Ben) (? sa1) (? sa2))
frame=()

unify-result=(((? sa2) ? 10 sa2) ((? sa1) ? 10 sa1)
                                 ((? 10 rich) Bitdiddle Ben)
                                 ((? who) ? 10 poor))

debug:simple-query

debug:simple-query
(has-smaller-salary (Aull DeWitt) (Bitdiddle Ben) 25000 60000)
(has-smaller-salary (Cratchet Robert) (Bitdiddle Ben) 18000 60000)
(has-smaller-salary (Reasoner Louis) (Bitdiddle Ben) 30000 60000)
(has-smaller-salary (Tweakit Lem E) (Bitdiddle Ben) 25000 60000)
(has-smaller-salary (Fect Cy D) (Bitdiddle Ben) 35000 60000)
(has-smaller-salary (Hacker Alyssa P) (Bitdiddle Ben) 40000 60000)

;;; Query input:
(assert!
 (rule (underpaid (? underpaid) (? overpaid) (? salary1) (? salary2))
       (and (can-replace (? underpaid) (? overpaid))
            (has-smaller-salary (? underpaid)
                                (? overpaid)
                                (? salary1)
                                (? salary2)))))
Assertion added to data base.
;;; Query input:
(underpaid (? underpaid) (? overpaid) (? salary1) (? salary2))
;;; Query results:

debug:simple-query
apply-a-rule
rule=(rule (underpaid (? underpaid) (? overpaid) (? salary1) (? salary2))
           (and (can-replace (? underpaid) (? overpaid))
                (has-smaller-salary (? underpaid)
                                    (? overpaid)
                                    (? salary1)
                                    (? salary2))))
pattern=(underpaid (? underpaid) (? overpaid) (? salary1) (? salary2))
frame=()

unify-result=(((? salary2) ? 11 salary2) ((? salary1) ? 11 salary1)
                                         ((? overpaid) ? 11 overpaid)
                                         ((? underpaid) ? 11 underpaid))

debug:simple-query
apply-a-rule
rule=(rule (can-replace (? person2) (? person1))
           (or (can-do-job-person (? person1) (? person2))
               (same-job (? person1) (? person2))))
pattern=(can-replace (? 11 underpaid) (? 11 overpaid))
frame=(((? salary2) ? 11 salary2) ((? salary1) ? 11 salary1)
                                  ((? overpaid) ? 11 overpaid)
                                  ((? underpaid) ? 11 underpaid))

unify-result=(((? 11 overpaid) ? 12 person1) ((? 11 underpaid) ? 12 person2)
                                             ((? salary2) ? 11 salary2)
                                             ((? salary1) ? 11 salary1)
                                             ((? overpaid) ? 11 overpaid)
                                             ((? underpaid) ? 11 underpaid))

debug:simple-query
apply-a-rule
rule=(rule (can-do-job-person (? person1) (? person2))
           (and (job (? person1) (? job1))
                (job (? person2) (? job2))
                (can-do-job (? job2) (? job1))))
pattern=(can-do-job-person (? 12 person1) (? 12 person2))
frame=(((? 11 overpaid) ? 12 person1) ((? 11 underpaid) ? 12 person2)
                                      ((? salary2) ? 11 salary2)
                                      ((? salary1) ? 11 salary1)
                                      ((? overpaid) ? 11 overpaid)
                                      ((? underpaid) ? 11 underpaid))

unify-result=(((? 12 person2) ? 13 person2) ((? 12 person1) ? 13 person1)
                                            ((? 11 overpaid) ? 12 person1)
                                            ((? 11 underpaid) ? 12 person2)
                                            ((? salary2) ? 11 salary2)
                                            ((? salary1) ? 11 salary1)
                                            ((? overpaid) ? 11 overpaid)
                                            ((? underpaid) ? 11 underpaid))

debug:simple-query

debug:simple-query

debug:simple-query

debug:simple-query
apply-a-rule
rule=(rule (has-smaller-salary (? poor) (? rich) (? sa1) (? sa2))
           (and (salary (? poor) (? sa1))
                (salary (? rich) (? sa2))
                (lisp-value < (? sa1) (? sa2))))
pattern=(has-smaller-salary (? 11 underpaid)
                            (? 11 overpaid)
                            (? 11 salary1)
                            (? 11 salary2))
frame=(((? 13 job2) administration secretary) ((? 13 person2) Aull DeWitt)
                                              ((? 13 job1) administration
                                                           big
                                                           wheel)
                                              ((? 13 person1) Warbucks Oliver)
                                              ((? 12 person2) ? 13 person2)
                                              ((? 12 person1) ? 13 person1)
                                              ((? 11 overpaid) ? 12 person1)
                                              ((? 11 underpaid) ? 12 person2)
                                              ((? salary2) ? 11 salary2)
                                              ((? salary1) ? 11 salary1)
                                              ((? overpaid) ? 11 overpaid)
                                              ((? underpaid) ? 11 underpaid))

unify-result=(((? 11 salary2) ? 14 sa2) ((? 11 salary1) ? 14 sa1)
                                        ((? 14 rich) Warbucks Oliver)
                                        ((? 14 poor) Aull DeWitt)
                                        ((? 13 job2) administration secretary)
                                        ((? 13 person2) Aull DeWitt)
                                        ((? 13 job1) administration big wheel)
                                        ((? 13 person1) Warbucks Oliver)
                                        ((? 12 person2) ? 13 person2)
                                        ((? 12 person1) ? 13 person1)
                                        ((? 11 overpaid) ? 12 person1)
                                        ((? 11 underpaid) ? 12 person2)
                                        ((? salary2) ? 11 salary2)
                                        ((? salary1) ? 11 salary1)
                                        ((? overpaid) ? 11 overpaid)
                                        ((? underpaid) ? 11 underpaid))

debug:simple-query

debug:simple-query
(underpaid (Aull DeWitt) (Warbucks Oliver) 25000 150000)

debug:simple-query
apply-a-rule
rule=(rule (same-job (? person1) (? person2))
           (and (job (? person1) ? j1)
                (job (? person2) ? j1)
                (not (same (? person1) (? person2)))))
pattern=(same-job (? 12 person1) (? 12 person2))
frame=(((? 11 overpaid) ? 12 person1) ((? 11 underpaid) ? 12 person2)
                                      ((? salary2) ? 11 salary2)
                                      ((? salary1) ? 11 salary1)
                                      ((? overpaid) ? 11 overpaid)
                                      ((? underpaid) ? 11 underpaid))

unify-result=(((? 12 person2) ? 15 person2) ((? 12 person1) ? 15 person1)
                                            ((? 11 overpaid) ? 12 person1)
                                            ((? 11 underpaid) ? 12 person2)
                                            ((? salary2) ? 11 salary2)
                                            ((? salary1) ? 11 salary1)
                                            ((? overpaid) ? 11 overpaid)
                                            ((? underpaid) ? 11 underpaid))

debug:simple-query

debug:simple-query

debug:simple-query
apply-a-rule
rule=(rule (same (? x) (? x)))
pattern=(same (? 15 person1) (? 15 person2))
frame=(((? 15 person2) Aull DeWitt) ((? 15 j1) (administration secretary))
                                    ((? 15 person1) Aull DeWitt)
                                    ((? 12 person2) ? 15 person2)
                                    ((? 12 person1) ? 15 person1)
                                    ((? 11 overpaid) ? 12 person1)
                                    ((? 11 underpaid) ? 12 person2)
                                    ((? salary2) ? 11 salary2)
                                    ((? salary1) ? 11 salary1)
                                    ((? overpaid) ? 11 overpaid)
                                    ((? underpaid) ? 11 underpaid))

unify-result=(((? 16 x) Aull DeWitt) ((? 15 person2) Aull DeWitt)
                                     ((? 15 j1) (administration secretary))
                                     ((? 15 person1) Aull DeWitt)
                                     ((? 12 person2) ? 15 person2)
                                     ((? 12 person1) ? 15 person1)
                                     ((? 11 overpaid) ? 12 person1)
                                     ((? 11 underpaid) ? 12 person2)
                                     ((? salary2) ? 11 salary2)
                                     ((? salary1) ? 11 salary1)
                                     ((? overpaid) ? 11 overpaid)
                                     ((? underpaid) ? 11 underpaid))

debug:simple-query
apply-a-rule
rule=(rule (same (? x) (? x)))
pattern=(same (? 15 person1) (? 15 person2))
frame=(((? 15 person2) Cratchet Robert) ((? 15 j1) (accounting scrivener))
                                        ((? 15 person1) Cratchet Robert)
                                        ((? 12 person2) ? 15 person2)
                                        ((? 12 person1) ? 15 person1)
                                        ((? 11 overpaid) ? 12 person1)
                                        ((? 11 underpaid) ? 12 person2)
                                        ((? salary2) ? 11 salary2)
                                        ((? salary1) ? 11 salary1)
                                        ((? overpaid) ? 11 overpaid)
                                        ((? underpaid) ? 11 underpaid))

unify-result=(((? 17 x) Cratchet Robert) ((? 15 person2) Cratchet Robert)
                                         ((? 15 j1) (accounting scrivener))
                                         ((? 15 person1) Cratchet Robert)
                                         ((? 12 person2) ? 15 person2)
                                         ((? 12 person1) ? 15 person1)
                                         ((? 11 overpaid) ? 12 person1)
                                         ((? 11 underpaid) ? 12 person2)
                                         ((? salary2) ? 11 salary2)
                                         ((? salary1) ? 11 salary1)
                                         ((? overpaid) ? 11 overpaid)
                                         ((? underpaid) ? 11 underpaid))

debug:simple-query
apply-a-rule
rule=(rule (same (? x) (? x)))
pattern=(same (? 15 person1) (? 15 person2))
frame=(((? 15 person2) Scrooge Eben)
       ((? 15 j1) (accounting chief accountant))
       ((? 15 person1) Scrooge Eben)
       ((? 12 person2) ? 15 person2)
       ((? 12 person1) ? 15 person1)
       ((? 11 overpaid) ? 12 person1)
       ((? 11 underpaid) ? 12 person2)
       ((? salary2) ? 11 salary2)
       ((? salary1) ? 11 salary1)
       ((? overpaid) ? 11 overpaid)
       ((? underpaid) ? 11 underpaid))

unify-result=(((? 18 x) Scrooge Eben) ((? 15 person2) Scrooge Eben)
                                      ((? 15 j1)
                                       (accounting chief accountant))
                                      ((? 15 person1) Scrooge Eben)
                                      ((? 12 person2) ? 15 person2)
                                      ((? 12 person1) ? 15 person1)
                                      ((? 11 overpaid) ? 12 person1)
                                      ((? 11 underpaid) ? 12 person2)
                                      ((? salary2) ? 11 salary2)
                                      ((? salary1) ? 11 salary1)
                                      ((? overpaid) ? 11 overpaid)
                                      ((? underpaid) ? 11 underpaid))

debug:simple-query
apply-a-rule
rule=(rule (same (? x) (? x)))
pattern=(same (? 15 person1) (? 15 person2))
frame=(((? 15 person2) Warbucks Oliver)
       ((? 15 j1) (administration big wheel))
       ((? 15 person1) Warbucks Oliver)
       ((? 12 person2) ? 15 person2)
       ((? 12 person1) ? 15 person1)
       ((? 11 overpaid) ? 12 person1)
       ((? 11 underpaid) ? 12 person2)
       ((? salary2) ? 11 salary2)
       ((? salary1) ? 11 salary1)
       ((? overpaid) ? 11 overpaid)
       ((? underpaid) ? 11 underpaid))

unify-result=(((? 19 x) Warbucks Oliver) ((? 15 person2) Warbucks Oliver)
                                         ((? 15 j1)
                                          (administration big wheel))
                                         ((? 15 person1) Warbucks Oliver)
                                         ((? 12 person2) ? 15 person2)
                                         ((? 12 person1) ? 15 person1)
                                         ((? 11 overpaid) ? 12 person1)
                                         ((? 11 underpaid) ? 12 person2)
                                         ((? salary2) ? 11 salary2)
                                         ((? salary1) ? 11 salary1)
                                         ((? overpaid) ? 11 overpaid)
                                         ((? underpaid) ? 11 underpaid))

debug:simple-query
apply-a-rule
rule=(rule (same (? x) (? x)))
pattern=(same (? 15 person1) (? 15 person2))
frame=(((? 15 person2) Reasoner Louis)
       ((? 15 j1) (computer programmer trainee))
       ((? 15 person1) Reasoner Louis)
       ((? 12 person2) ? 15 person2)
       ((? 12 person1) ? 15 person1)
       ((? 11 overpaid) ? 12 person1)
       ((? 11 underpaid) ? 12 person2)
       ((? salary2) ? 11 salary2)
       ((? salary1) ? 11 salary1)
       ((? overpaid) ? 11 overpaid)
       ((? underpaid) ? 11 underpaid))

unify-result=(((? 20 x) Reasoner Louis) ((? 15 person2) Reasoner Louis)
                                        ((? 15 j1)
                                         (computer programmer trainee))
                                        ((? 15 person1) Reasoner Louis)
                                        ((? 12 person2) ? 15 person2)
                                        ((? 12 person1) ? 15 person1)
                                        ((? 11 overpaid) ? 12 person1)
                                        ((? 11 underpaid) ? 12 person2)
                                        ((? salary2) ? 11 salary2)
                                        ((? salary1) ? 11 salary1)
                                        ((? overpaid) ? 11 overpaid)
                                        ((? underpaid) ? 11 underpaid))

debug:simple-query
apply-a-rule
rule=(rule (same (? x) (? x)))
pattern=(same (? 15 person1) (? 15 person2))
frame=(((? 15 person2) Tweakit Lem E) ((? 15 j1) (computer technician))
                                      ((? 15 person1) Tweakit Lem E)
                                      ((? 12 person2) ? 15 person2)
                                      ((? 12 person1) ? 15 person1)
                                      ((? 11 overpaid) ? 12 person1)
                                      ((? 11 underpaid) ? 12 person2)
                                      ((? salary2) ? 11 salary2)
                                      ((? salary1) ? 11 salary1)
                                      ((? overpaid) ? 11 overpaid)
                                      ((? underpaid) ? 11 underpaid))

unify-result=(((? 21 x) Tweakit Lem E) ((? 15 person2) Tweakit Lem E)
                                       ((? 15 j1) (computer technician))
                                       ((? 15 person1) Tweakit Lem E)
                                       ((? 12 person2) ? 15 person2)
                                       ((? 12 person1) ? 15 person1)
                                       ((? 11 overpaid) ? 12 person1)
                                       ((? 11 underpaid) ? 12 person2)
                                       ((? salary2) ? 11 salary2)
                                       ((? salary1) ? 11 salary1)
                                       ((? overpaid) ? 11 overpaid)
                                       ((? underpaid) ? 11 underpaid))

debug:simple-query
apply-a-rule
rule=(rule (same (? x) (? x)))
pattern=(same (? 15 person1) (? 15 person2))
frame=(((? 15 person2) Fect Cy D) ((? 15 j1) (computer programmer))
                                  ((? 15 person1) Fect Cy D)
                                  ((? 12 person2) ? 15 person2)
                                  ((? 12 person1) ? 15 person1)
                                  ((? 11 overpaid) ? 12 person1)
                                  ((? 11 underpaid) ? 12 person2)
                                  ((? salary2) ? 11 salary2)
                                  ((? salary1) ? 11 salary1)
                                  ((? overpaid) ? 11 overpaid)
                                  ((? underpaid) ? 11 underpaid))

unify-result=(((? 22 x) Fect Cy D) ((? 15 person2) Fect Cy D)
                                   ((? 15 j1) (computer programmer))
                                   ((? 15 person1) Fect Cy D)
                                   ((? 12 person2) ? 15 person2)
                                   ((? 12 person1) ? 15 person1)
                                   ((? 11 overpaid) ? 12 person1)
                                   ((? 11 underpaid) ? 12 person2)
                                   ((? salary2) ? 11 salary2)
                                   ((? salary1) ? 11 salary1)
                                   ((? overpaid) ? 11 overpaid)
                                   ((? underpaid) ? 11 underpaid))

debug:simple-query
apply-a-rule
rule=(rule (same (? x) (? x)))
pattern=(same (? 15 person1) (? 15 person2))
frame=(((? 15 person2) Fect Cy D) ((? 15 j1) (computer programmer))
                                  ((? 15 person1) Hacker Alyssa P)
                                  ((? 12 person2) ? 15 person2)
                                  ((? 12 person1) ? 15 person1)
                                  ((? 11 overpaid) ? 12 person1)
                                  ((? 11 underpaid) ? 12 person2)
                                  ((? salary2) ? 11 salary2)
                                  ((? salary1) ? 11 salary1)
                                  ((? overpaid) ? 11 overpaid)
                                  ((? underpaid) ? 11 underpaid))

unify-result=failed
apply-a-rule
rule=(rule (has-smaller-salary (? poor) (? rich) (? sa1) (? sa2))
           (and (salary (? poor) (? sa1))
                (salary (? rich) (? sa2))
                (lisp-value < (? sa1) (? sa2))))
pattern=(has-smaller-salary (? 11 underpaid)
                            (? 11 overpaid)
                            (? 11 salary1)
                            (? 11 salary2))
frame=(((? 15 person2) Fect Cy D) ((? 15 j1) (computer programmer))
                                  ((? 15 person1) Hacker Alyssa P)
                                  ((? 12 person2) ? 15 person2)
                                  ((? 12 person1) ? 15 person1)
                                  ((? 11 overpaid) ? 12 person1)
                                  ((? 11 underpaid) ? 12 person2)
                                  ((? salary2) ? 11 salary2)
                                  ((? salary1) ? 11 salary1)
                                  ((? overpaid) ? 11 overpaid)
                                  ((? underpaid) ? 11 underpaid))

unify-result=(((? 11 salary2) ? 24 sa2) ((? 11 salary1) ? 24 sa1)
                                        ((? 24 rich) Hacker Alyssa P)
                                        ((? 24 poor) Fect Cy D)
                                        ((? 15 person2) Fect Cy D)
                                        ((? 15 j1) (computer programmer))
                                        ((? 15 person1) Hacker Alyssa P)
                                        ((? 12 person2) ? 15 person2)
                                        ((? 12 person1) ? 15 person1)
                                        ((? 11 overpaid) ? 12 person1)
                                        ((? 11 underpaid) ? 12 person2)
                                        ((? salary2) ? 11 salary2)
                                        ((? salary1) ? 11 salary1)
                                        ((? overpaid) ? 11 overpaid)
                                        ((? underpaid) ? 11 underpaid))

debug:simple-query

debug:simple-query
(underpaid (Fect Cy D) (Hacker Alyssa P) 35000 40000)
apply-a-rule
rule=(rule (has-smaller-salary (? poor) (? rich) (? sa1) (? sa2))
           (and (salary (? poor) (? sa1))
                (salary (? rich) (? sa2))
                (lisp-value < (? sa1) (? sa2))))
pattern=(has-smaller-salary (? 11 underpaid)
                            (? 11 overpaid)
                            (? 11 salary1)
                            (? 11 salary2))
frame=(((? 13 job2) computer programmer) ((? 13 person2) Fect Cy D)
                                         ((? 13 job1) computer
                                                      programmer
                                                      trainee)
                                         ((? 13 person1) Reasoner Louis)
                                         ((? 12 person2) ? 13 person2)
                                         ((? 12 person1) ? 13 person1)
                                         ((? 11 overpaid) ? 12 person1)
                                         ((? 11 underpaid) ? 12 person2)
                                         ((? salary2) ? 11 salary2)
                                         ((? salary1) ? 11 salary1)
                                         ((? overpaid) ? 11 overpaid)
                                         ((? underpaid) ? 11 underpaid))

unify-result=(((? 11 salary2) ? 25 sa2) ((? 11 salary1) ? 25 sa1)
                                        ((? 25 rich) Reasoner Louis)
                                        ((? 25 poor) Fect Cy D)
                                        ((? 13 job2) computer programmer)
                                        ((? 13 person2) Fect Cy D)
                                        ((? 13 job1) computer
                                                     programmer
                                                     trainee)
                                        ((? 13 person1) Reasoner Louis)
                                        ((? 12 person2) ? 13 person2)
                                        ((? 12 person1) ? 13 person1)
                                        ((? 11 overpaid) ? 12 person1)
                                        ((? 11 underpaid) ? 12 person2)
                                        ((? salary2) ? 11 salary2)
                                        ((? salary1) ? 11 salary1)
                                        ((? overpaid) ? 11 overpaid)
                                        ((? underpaid) ? 11 underpaid))

debug:simple-query

debug:simple-query

debug:simple-query
apply-a-rule
rule=(rule (same (? x) (? x)))
pattern=(same (? 15 person1) (? 15 person2))
frame=(((? 15 person2) Hacker Alyssa P) ((? 15 j1) (computer programmer))
                                        ((? 15 person1) Fect Cy D)
                                        ((? 12 person2) ? 15 person2)
                                        ((? 12 person1) ? 15 person1)
                                        ((? 11 overpaid) ? 12 person1)
                                        ((? 11 underpaid) ? 12 person2)
                                        ((? salary2) ? 11 salary2)
                                        ((? salary1) ? 11 salary1)
                                        ((? overpaid) ? 11 overpaid)
                                        ((? underpaid) ? 11 underpaid))

unify-result=failed
apply-a-rule
rule=(rule (has-smaller-salary (? poor) (? rich) (? sa1) (? sa2))
           (and (salary (? poor) (? sa1))
                (salary (? rich) (? sa2))
                (lisp-value < (? sa1) (? sa2))))
pattern=(has-smaller-salary (? 11 underpaid)
                            (? 11 overpaid)
                            (? 11 salary1)
                            (? 11 salary2))
frame=(((? 15 person2) Hacker Alyssa P) ((? 15 j1) (computer programmer))
                                        ((? 15 person1) Fect Cy D)
                                        ((? 12 person2) ? 15 person2)
                                        ((? 12 person1) ? 15 person1)
                                        ((? 11 overpaid) ? 12 person1)
                                        ((? 11 underpaid) ? 12 person2)
                                        ((? salary2) ? 11 salary2)
                                        ((? salary1) ? 11 salary1)
                                        ((? overpaid) ? 11 overpaid)
                                        ((? underpaid) ? 11 underpaid))

unify-result=(((? 11 salary2) ? 27 sa2) ((? 11 salary1) ? 27 sa1)
                                        ((? 27 rich) Fect Cy D)
                                        ((? 27 poor) Hacker Alyssa P)
                                        ((? 15 person2) Hacker Alyssa P)
                                        ((? 15 j1) (computer programmer))
                                        ((? 15 person1) Fect Cy D)
                                        ((? 12 person2) ? 15 person2)
                                        ((? 12 person1) ? 15 person1)
                                        ((? 11 overpaid) ? 12 person1)
                                        ((? 11 underpaid) ? 12 person2)
                                        ((? salary2) ? 11 salary2)
                                        ((? salary1) ? 11 salary1)
                                        ((? overpaid) ? 11 overpaid)
                                        ((? underpaid) ? 11 underpaid))

debug:simple-query

debug:simple-query
apply-a-rule
rule=(rule (has-smaller-salary (? poor) (? rich) (? sa1) (? sa2))
           (and (salary (? poor) (? sa1))
                (salary (? rich) (? sa2))
                (lisp-value < (? sa1) (? sa2))))
pattern=(has-smaller-salary (? 11 underpaid)
                            (? 11 overpaid)
                            (? 11 salary1)
                            (? 11 salary2))
frame=(((? 13 job2) computer programmer) ((? 13 person2) Hacker Alyssa P)
                                         ((? 13 job1) computer
                                                      programmer
                                                      trainee)
                                         ((? 13 person1) Reasoner Louis)
                                         ((? 12 person2) ? 13 person2)
                                         ((? 12 person1) ? 13 person1)
                                         ((? 11 overpaid) ? 12 person1)
                                         ((? 11 underpaid) ? 12 person2)
                                         ((? salary2) ? 11 salary2)
                                         ((? salary1) ? 11 salary1)
                                         ((? overpaid) ? 11 overpaid)
                                         ((? underpaid) ? 11 underpaid))

unify-result=(((? 11 salary2) ? 28 sa2) ((? 11 salary1) ? 28 sa1)
                                        ((? 28 rich) Reasoner Louis)
                                        ((? 28 poor) Hacker Alyssa P)
                                        ((? 13 job2) computer programmer)
                                        ((? 13 person2) Hacker Alyssa P)
                                        ((? 13 job1) computer
                                                     programmer
                                                     trainee)
                                        ((? 13 person1) Reasoner Louis)
                                        ((? 12 person2) ? 13 person2)
                                        ((? 12 person1) ? 13 person1)
                                        ((? 11 overpaid) ? 12 person1)
                                        ((? 11 underpaid) ? 12 person2)
                                        ((? salary2) ? 11 salary2)
                                        ((? salary1) ? 11 salary1)
                                        ((? overpaid) ? 11 overpaid)
                                        ((? underpaid) ? 11 underpaid))

debug:simple-query

debug:simple-query

debug:simple-query
apply-a-rule
rule=(rule (same (? x) (? x)))
pattern=(same (? 15 person1) (? 15 person2))
frame=(((? 15 person2) Bitdiddle Ben) ((? 15 j1) (computer wizard))
                                      ((? 15 person1) Bitdiddle Ben)
                                      ((? 12 person2) ? 15 person2)
                                      ((? 12 person1) ? 15 person1)
                                      ((? 11 overpaid) ? 12 person1)
                                      ((? 11 underpaid) ? 12 person2)
                                      ((? salary2) ? 11 salary2)
                                      ((? salary1) ? 11 salary1)
                                      ((? overpaid) ? 11 overpaid)
                                      ((? underpaid) ? 11 underpaid))

unify-result=(((? 29 x) Bitdiddle Ben) ((? 15 person2) Bitdiddle Ben)
                                       ((? 15 j1) (computer wizard))
                                       ((? 15 person1) Bitdiddle Ben)
                                       ((? 12 person2) ? 15 person2)
                                       ((? 12 person1) ? 15 person1)
                                       ((? 11 overpaid) ? 12 person1)
                                       ((? 11 underpaid) ? 12 person2)
                                       ((? salary2) ? 11 salary2)
                                       ((? salary1) ? 11 salary1)
                                       ((? overpaid) ? 11 overpaid)
                                       ((? underpaid) ? 11 underpaid))

debug:simple-query
apply-a-rule
rule=(rule (same (? x) (? x)))
pattern=(same (? 15 person1) (? 15 person2))
frame=(((? 15 person2) Hacker Alyssa P) ((? 15 j1) (computer programmer))
                                        ((? 15 person1) Hacker Alyssa P)
                                        ((? 12 person2) ? 15 person2)
                                        ((? 12 person1) ? 15 person1)
                                        ((? 11 overpaid) ? 12 person1)
                                        ((? 11 underpaid) ? 12 person2)
                                        ((? salary2) ? 11 salary2)
                                        ((? salary1) ? 11 salary1)
                                        ((? overpaid) ? 11 overpaid)
                                        ((? underpaid) ? 11 underpaid))

unify-result=(((? 30 x) Hacker Alyssa P) ((? 15 person2) Hacker Alyssa P)
                                         ((? 15 j1) (computer programmer))
                                         ((? 15 person1) Hacker Alyssa P)
                                         ((? 12 person2) ? 15 person2)
                                         ((? 12 person1) ? 15 person1)
                                         ((? 11 overpaid) ? 12 person1)
                                         ((? 11 underpaid) ? 12 person2)
                                         ((? salary2) ? 11 salary2)
                                         ((? salary1) ? 11 salary1)
                                         ((? overpaid) ? 11 overpaid)
                                         ((? underpaid) ? 11 underpaid))
apply-a-rule
rule=(rule (has-smaller-salary (? poor) (? rich) (? sa1) (? sa2))
           (and (salary (? poor) (? sa1))
                (salary (? rich) (? sa2))
                (lisp-value < (? sa1) (? sa2))))
pattern=(has-smaller-salary (? 11 underpaid)
                            (? 11 overpaid)
                            (? 11 salary1)
                            (? 11 salary2))
frame=(((? 13 job2) computer wizard) ((? 13 person2) Bitdiddle Ben)
                                     ((? 13 job1) computer technician)
                                     ((? 13 person1) Tweakit Lem E)
                                     ((? 12 person2) ? 13 person2)
                                     ((? 12 person1) ? 13 person1)
                                     ((? 11 overpaid) ? 12 person1)
                                     ((? 11 underpaid) ? 12 person2)
                                     ((? salary2) ? 11 salary2)
                                     ((? salary1) ? 11 salary1)
                                     ((? overpaid) ? 11 overpaid)
                                     ((? underpaid) ? 11 underpaid))

unify-result=(((? 11 salary2) ? 31 sa2) ((? 11 salary1) ? 31 sa1)
                                        ((? 31 rich) Tweakit Lem E)
                                        ((? 31 poor) Bitdiddle Ben)
                                        ((? 13 job2) computer wizard)
                                        ((? 13 person2) Bitdiddle Ben)
                                        ((? 13 job1) computer technician)
                                        ((? 13 person1) Tweakit Lem E)
                                        ((? 12 person2) ? 13 person2)
                                        ((? 12 person1) ? 13 person1)
                                        ((? 11 overpaid) ? 12 person1)
                                        ((? 11 underpaid) ? 12 person2)
                                        ((? salary2) ? 11 salary2)
                                        ((? salary1) ? 11 salary1)
                                        ((? overpaid) ? 11 overpaid)
                                        ((? underpaid) ? 11 underpaid))

debug:simple-query

debug:simple-query
apply-a-rule
rule=(rule (has-smaller-salary (? poor) (? rich) (? sa1) (? sa2))
           (and (salary (? poor) (? sa1))
                (salary (? rich) (? sa2))
                (lisp-value < (? sa1) (? sa2))))
pattern=(has-smaller-salary (? 11 underpaid)
                            (? 11 overpaid)
                            (? 11 salary1)
                            (? 11 salary2))
frame=(((? 13 job2) computer wizard) ((? 13 person2) Bitdiddle Ben)
                                     ((? 13 job1) computer programmer)
                                     ((? 13 person1) Fect Cy D)
                                     ((? 12 person2) ? 13 person2)
                                     ((? 12 person1) ? 13 person1)
                                     ((? 11 overpaid) ? 12 person1)
                                     ((? 11 underpaid) ? 12 person2)
                                     ((? salary2) ? 11 salary2)
                                     ((? salary1) ? 11 salary1)
                                     ((? overpaid) ? 11 overpaid)
                                     ((? underpaid) ? 11 underpaid))

unify-result=(((? 11 salary2) ? 32 sa2) ((? 11 salary1) ? 32 sa1)
                                        ((? 32 rich) Fect Cy D)
                                        ((? 32 poor) Bitdiddle Ben)
                                        ((? 13 job2) computer wizard)
                                        ((? 13 person2) Bitdiddle Ben)
                                        ((? 13 job1) computer programmer)
                                        ((? 13 person1) Fect Cy D)
                                        ((? 12 person2) ? 13 person2)
                                        ((? 12 person1) ? 13 person1)
                                        ((? 11 overpaid) ? 12 person1)
                                        ((? 11 underpaid) ? 12 person2)
                                        ((? salary2) ? 11 salary2)
                                        ((? salary1) ? 11 salary1)
                                        ((? overpaid) ? 11 overpaid)
                                        ((? underpaid) ? 11 underpaid))

debug:simple-query

debug:simple-query
apply-a-rule
rule=(rule (has-smaller-salary (? poor) (? rich) (? sa1) (? sa2))
           (and (salary (? poor) (? sa1))
                (salary (? rich) (? sa2))
                (lisp-value < (? sa1) (? sa2))))
pattern=(has-smaller-salary (? 11 underpaid)
                            (? 11 overpaid)
                            (? 11 salary1)
                            (? 11 salary2))
frame=(((? 13 job2) computer wizard) ((? 13 person2) Bitdiddle Ben)
                                     ((? 13 job1) computer programmer)
                                     ((? 13 person1) Hacker Alyssa P)
                                     ((? 12 person2) ? 13 person2)
                                     ((? 12 person1) ? 13 person1)
                                     ((? 11 overpaid) ? 12 person1)
                                     ((? 11 underpaid) ? 12 person2)
                                     ((? salary2) ? 11 salary2)
                                     ((? salary1) ? 11 salary1)
                                     ((? overpaid) ? 11 overpaid)
                                     ((? underpaid) ? 11 underpaid))

unify-result=(((? 11 salary2) ? 33 sa2) ((? 11 salary1) ? 33 sa1)
                                        ((? 33 rich) Hacker Alyssa P)
                                        ((? 33 poor) Bitdiddle Ben)
                                        ((? 13 job2) computer wizard)
                                        ((? 13 person2) Bitdiddle Ben)
                                        ((? 13 job1) computer programmer)
                                        ((? 13 person1) Hacker Alyssa P)
                                        ((? 12 person2) ? 13 person2)
                                        ((? 12 person1) ? 13 person1)
                                        ((? 11 overpaid) ? 12 person1)
                                        ((? 11 underpaid) ? 12 person2)
                                        ((? salary2) ? 11 salary2)
                                        ((? salary1) ? 11 salary1)
                                        ((? overpaid) ? 11 overpaid)
                                        ((? underpaid) ? 11 underpaid))

debug:simple-query

debug:simple-query

;;; Query input:
exit
#+end_src

***** DONE Exercise 4.58 big shot
      CLOSED: [2020-02-19 Wed 22:12]

#+name: prolog-input-bigshot
#+begin_src shell :exports code :results verbatim output scalar code
  printf "%s" '
  <<prolog-input-sample-database>>
  <<prolog-input-canned-rules>>
  (assert! (rule (big-shot ?person)
                 (and (job ?person (?division . ?rest1))
                      (or (and (supervisor ?person ?boss)
                               (not (job ?boss (?division . ?rest2))))
                          (not (supervisor ?person ?boss2))))))
  (big-shot ?who)
  exit'
#+end_src


#+header: :stdin prolog-input-bigshot
#+begin_src shell :shebang "#! /usr/bin/chibi-scheme" :exports both :results output scalar code :exports both
  <<prolog-glue>>
  <<put-and-get>>
  <<streams-common>>
  <<streams-2>>
  <<stream-append>>
  <<prolog-driver-loop>>
  <<prolog-instantiate>>
  <<prolog-qeval>>
  <<prolog-simple-queries>>
  <<prolog-conjoin>>
  <<prolog-conjoin-installation>>
  <<prolog-disjoin>>
  <<prolog-disjoin-installation>>
  <<prolog-negate>>
  <<prolog-negate-installation>>
  <<prolog-lisp-filter>>
  <<prolog-lisp-filter-installation>>
  <<prolog-always-true>>
  <<prolog-pattern-matching>>
  <<prolog-rules-and-unification>>
  <<prolog-database>>
  <<prolog-database-add-assertion-original>>
  <<prolog-database-store-assertion-in-index>>
  <<prolog-stream-operations>>
  <<prolog-stream-flatmap>>
  <<prolog-flatten-stream>>
  <<streams-singleton>>
  <<prolog-query>>
  <<prolog-frames-and-bindings>>
  (query-driver-loop)
#+end_src

#+RESULTS[89c96708076807b00b500f733cde0dfaa73cfa0d]:
#+begin_src shell

;;; Query input:
(assert! (address (Bitdiddle Ben) (Slumerville (Ridge Road) 10)))
Assertion added to data base.
;;; Query input:
(assert! (job (Bitdiddle Ben) (computer wizard)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Bitdiddle Ben) 60000))
Assertion added to data base.
;;; Query input:
(assert! (address (Hacker Alyssa P) (Cambridge (Mass Ave) 78)))
Assertion added to data base.
;;; Query input:
(assert! (job (Hacker Alyssa P) (computer programmer)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Hacker Alyssa P) 40000))
Assertion added to data base.
;;; Query input:
(assert! (supervisor (Hacker Alyssa P) (Bitdiddle Ben)))
Assertion added to data base.
;;; Query input:
(assert! (address (Fect Cy D) (Cambridge (Ames Street) 3)))
Assertion added to data base.
;;; Query input:
(assert! (job (Fect Cy D) (computer programmer)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Fect Cy D) 35000))
Assertion added to data base.
;;; Query input:
(assert! (supervisor (Fect Cy D) (Bitdiddle Ben)))
Assertion added to data base.
;;; Query input:
(assert! (address (Tweakit Lem E) (Boston (Bay State Road) 22)))
Assertion added to data base.
;;; Query input:
(assert! (job (Tweakit Lem E) (computer technician)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Tweakit Lem E) 25000))
Assertion added to data base.
;;; Query input:
(assert! (supervisor (Tweakit Lem E) (Bitdiddle Ben)))
Assertion added to data base.
;;; Query input:
(assert! (address (Reasoner Louis) (Slumerville (Pine Tree Road) 80)))
Assertion added to data base.
;;; Query input:
(assert! (job (Reasoner Louis) (computer programmer trainee)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Reasoner Louis) 30000))
Assertion added to data base.
;;; Query input:
(assert! (supervisor (Reasoner Louis) (Hacker Alyssa P)))
Assertion added to data base.
;;; Query input:
(assert! (supervisor (Bitdiddle Ben) (Warbucks Oliver)))
Assertion added to data base.
;;; Query input:
(assert! (address (Warbucks Oliver) (Swellesley (Top Heap Road))))
Assertion added to data base.
;;; Query input:
(assert! (job (Warbucks Oliver) (administration big wheel)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Warbucks Oliver) 150000))
Assertion added to data base.
;;; Query input:
(assert! (address (Scrooge Eben) (Weston (Shady Lane) 10)))
Assertion added to data base.
;;; Query input:
(assert! (job (Scrooge Eben) (accounting chief accountant)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Scrooge Eben) 75000))
Assertion added to data base.
;;; Query input:
(assert! (supervisor (Scrooge Eben) (Warbucks Oliver)))
Assertion added to data base.
;;; Query input:
(assert! (address (Cratchet Robert) (Allston (N Harvard Street) 16)))
Assertion added to data base.
;;; Query input:
(assert! (job (Cratchet Robert) (accounting scrivener)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Cratchet Robert) 18000))
Assertion added to data base.
;;; Query input:
(assert! (supervisor (Cratchet Robert) (Scrooge Eben)))
Assertion added to data base.
;;; Query input:
(assert! (address (Aull DeWitt) (Slumerville (Onion Square) 5)))
Assertion added to data base.
;;; Query input:
(assert! (job (Aull DeWitt) (administration secretary)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Aull DeWitt) 25000))
Assertion added to data base.
;;; Query input:
(assert! (supervisor (Aull DeWitt) (Warbucks Oliver)))
Assertion added to data base.
;;; Query input:
(assert! (can-do-job (computer wizard) (computer programmer)))
Assertion added to data base.
;;; Query input:
(assert! (can-do-job (computer wizard) (computer technician)))
Assertion added to data base.
;;; Query input:
(assert! (can-do-job (computer programmer) (computer programmer trainee)))
Assertion added to data base.
;;; Query input:
(assert! (can-do-job (administration secretary) (administration big wheel)))
Assertion added to data base.
;;; Query input:
(assert!
 (rule (lives-near (? person-1) (? person-2))
       (and (address (? person-1) ((? town) ? rest-1))
            (address (? person-2) ((? town) ? rest-2))
            (not (same (? person-1) (? person-2))))))
Assertion added to data base.
;;; Query input:
(assert! (rule (same (? x) (? x))))
Assertion added to data base.
;;; Query input:
(assert!
 (rule (wheel (? person))
       (and (supervisor (? middle-manager) (? person))
            (supervisor (? x) (? middle-manager)))))
Assertion added to data base.
;;; Query input:
(assert!
 (rule (outranked-by (? staff-person) (? boss))
       (or (supervisor (? staff-person) (? boss))
           (and (supervisor (? staff-person) (? middle-manager))
                (outranked-by (? middle-manager) (? boss))))))
Assertion added to data base.
;;; Query input:
(assert! (rule (append-to-form () (? y) (? y))))
Assertion added to data base.
;;; Query input:
(assert!
 (rule (append-to-form ((? u) ? v) (? y) ((? u) ? z))
       (append-to-form (? v) (? y) (? z))))
Assertion added to data base.
;;; Query input:
(assert!
 (rule (big-shot (? person))
       (and (job (? person) ((? division) ? rest1))
            (or
             (and (supervisor (? person) (? boss))
                  (not (job (? boss) ((? division) ? rest2))))
             (not (supervisor (? person) (? boss2)))))))
Assertion added to data base.
;;; Query input:
(big-shot (? who))
;;; Query results:

debug:simple-query
apply-a-rule
rule=(rule (big-shot (? person))
           (and (job (? person) ((? division) ? rest1))
                (or
                 (and (supervisor (? person) (? boss))
                      (not (job (? boss) ((? division) ? rest2))))
                 (not (supervisor (? person) (? boss2))))))
pattern=(big-shot (? who))
frame=()

unify-result=(((? who) ? 1 person))

debug:simple-query

debug:simple-query

debug:simple-query

debug:simple-query

debug:simple-query
(big-shot (Scrooge Eben))

debug:simple-query

debug:simple-query

debug:simple-query

debug:simple-query
(big-shot (Warbucks Oliver))

debug:simple-query

debug:simple-query

debug:simple-query

debug:simple-query

debug:simple-query
(big-shot (Bitdiddle Ben))

debug:simple-query

debug:simple-query

debug:simple-query

debug:simple-query

debug:simple-query

;;; Query input:
exit
#+end_src

This exercise is a little bit tricky, because Oliver Warbucks doesn't
have a supervisor at all, and this case should be catered for separately.

***** DONE Exercise 4.59 meetings
      CLOSED: [2020-02-19 Wed 22:57]

Important! The in following code I had to replace the times with
strings. It doesn't affect anything, since the values of time are
never used anywhere, but as it is a change to the original code, I am
declaring it here.

#+name: prolog-input-meetings
#+begin_src shell :exports code :results verbatim output scalar code
  printf "%s" '
  <<prolog-input-sample-database>>
  <<prolog-input-canned-rules>>
  (assert! (meeting accounting (Monday "9am")))
  (assert! (meeting administration (Monday "10am")))
  (assert! (meeting computer (Wednesday "3pm")))
  (assert! (meeting administration (Friday "1pm")))
  (assert! (meeting whole-company (Wednesday "4pm")))
  (meeting ?dept (Friday . ?rest))
  (job (Hacker Alyssa P) (?dept . ?rest))
  (assert! (rule (meeting-time ?person ?day-and-time)
               (or (and (job ?person (?dept . ?rest))
                        (meeting ?dept ?day-and-time))
                   (meeting whole-company ?day-and-time))))
  (meeting-time (Hacker Alyssa P) (Wednesday . ?time))
  exit'
#+end_src


#+header: :stdin prolog-input-meetings
#+begin_src shell :shebang "#! /usr/bin/chibi-scheme" :exports both :results output scalar code :exports both
  <<prolog-glue>>
  <<put-and-get>>
  <<streams-common>>
  <<streams-2>>
  <<stream-append>>
  <<prolog-driver-loop>>
  <<prolog-instantiate>>
  <<prolog-qeval>>
  <<prolog-simple-queries>>
  <<prolog-conjoin>>
  <<prolog-conjoin-installation>>
  <<prolog-disjoin>>
  <<prolog-disjoin-installation>>
  <<prolog-negate>>
  <<prolog-negate-installation>>
  <<prolog-lisp-filter>>
  <<prolog-lisp-filter-installation>>
  <<prolog-always-true>>
  <<prolog-pattern-matching>>
  <<prolog-rules-and-unification>>
  <<prolog-database>>
  <<prolog-database-add-assertion-original>>
  <<prolog-database-store-assertion-in-index>>
  <<prolog-stream-operations>>
  <<prolog-stream-flatmap>>
  <<prolog-flatten-stream>>
  <<streams-singleton>>
  <<prolog-query>>
  <<prolog-frames-and-bindings>>
  (query-driver-loop)
#+end_src

#+RESULTS[3fd4fd58081bf6d257f9f1d964e4c20a7dffb661]:
#+begin_src shell

;;; Query input:
(assert! (address (Bitdiddle Ben) (Slumerville (Ridge Road) 10)))
Assertion added to data base.
;;; Query input:
(assert! (job (Bitdiddle Ben) (computer wizard)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Bitdiddle Ben) 60000))
Assertion added to data base.
;;; Query input:
(assert! (address (Hacker Alyssa P) (Cambridge (Mass Ave) 78)))
Assertion added to data base.
;;; Query input:
(assert! (job (Hacker Alyssa P) (computer programmer)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Hacker Alyssa P) 40000))
Assertion added to data base.
;;; Query input:
(assert! (supervisor (Hacker Alyssa P) (Bitdiddle Ben)))
Assertion added to data base.
;;; Query input:
(assert! (address (Fect Cy D) (Cambridge (Ames Street) 3)))
Assertion added to data base.
;;; Query input:
(assert! (job (Fect Cy D) (computer programmer)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Fect Cy D) 35000))
Assertion added to data base.
;;; Query input:
(assert! (supervisor (Fect Cy D) (Bitdiddle Ben)))
Assertion added to data base.
;;; Query input:
(assert! (address (Tweakit Lem E) (Boston (Bay State Road) 22)))
Assertion added to data base.
;;; Query input:
(assert! (job (Tweakit Lem E) (computer technician)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Tweakit Lem E) 25000))
Assertion added to data base.
;;; Query input:
(assert! (supervisor (Tweakit Lem E) (Bitdiddle Ben)))
Assertion added to data base.
;;; Query input:
(assert! (address (Reasoner Louis) (Slumerville (Pine Tree Road) 80)))
Assertion added to data base.
;;; Query input:
(assert! (job (Reasoner Louis) (computer programmer trainee)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Reasoner Louis) 30000))
Assertion added to data base.
;;; Query input:
(assert! (supervisor (Reasoner Louis) (Hacker Alyssa P)))
Assertion added to data base.
;;; Query input:
(assert! (supervisor (Bitdiddle Ben) (Warbucks Oliver)))
Assertion added to data base.
;;; Query input:
(assert! (address (Warbucks Oliver) (Swellesley (Top Heap Road))))
Assertion added to data base.
;;; Query input:
(assert! (job (Warbucks Oliver) (administration big wheel)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Warbucks Oliver) 150000))
Assertion added to data base.
;;; Query input:
(assert! (address (Scrooge Eben) (Weston (Shady Lane) 10)))
Assertion added to data base.
;;; Query input:
(assert! (job (Scrooge Eben) (accounting chief accountant)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Scrooge Eben) 75000))
Assertion added to data base.
;;; Query input:
(assert! (supervisor (Scrooge Eben) (Warbucks Oliver)))
Assertion added to data base.
;;; Query input:
(assert! (address (Cratchet Robert) (Allston (N Harvard Street) 16)))
Assertion added to data base.
;;; Query input:
(assert! (job (Cratchet Robert) (accounting scrivener)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Cratchet Robert) 18000))
Assertion added to data base.
;;; Query input:
(assert! (supervisor (Cratchet Robert) (Scrooge Eben)))
Assertion added to data base.
;;; Query input:
(assert! (address (Aull DeWitt) (Slumerville (Onion Square) 5)))
Assertion added to data base.
;;; Query input:
(assert! (job (Aull DeWitt) (administration secretary)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Aull DeWitt) 25000))
Assertion added to data base.
;;; Query input:
(assert! (supervisor (Aull DeWitt) (Warbucks Oliver)))
Assertion added to data base.
;;; Query input:
(assert! (can-do-job (computer wizard) (computer programmer)))
Assertion added to data base.
;;; Query input:
(assert! (can-do-job (computer wizard) (computer technician)))
Assertion added to data base.
;;; Query input:
(assert! (can-do-job (computer programmer) (computer programmer trainee)))
Assertion added to data base.
;;; Query input:
(assert! (can-do-job (administration secretary) (administration big wheel)))
Assertion added to data base.
;;; Query input:
(assert!
 (rule (lives-near (? person-1) (? person-2))
       (and (address (? person-1) ((? town) ? rest-1))
            (address (? person-2) ((? town) ? rest-2))
            (not (same (? person-1) (? person-2))))))
Assertion added to data base.
;;; Query input:
(assert! (rule (same (? x) (? x))))
Assertion added to data base.
;;; Query input:
(assert!
 (rule (wheel (? person))
       (and (supervisor (? middle-manager) (? person))
            (supervisor (? x) (? middle-manager)))))
Assertion added to data base.
;;; Query input:
(assert!
 (rule (outranked-by (? staff-person) (? boss))
       (or (supervisor (? staff-person) (? boss))
           (and (supervisor (? staff-person) (? middle-manager))
                (outranked-by (? middle-manager) (? boss))))))
Assertion added to data base.
;;; Query input:
(assert! (rule (append-to-form () (? y) (? y))))
Assertion added to data base.
;;; Query input:
(assert!
 (rule (append-to-form ((? u) ? v) (? y) ((? u) ? z))
       (append-to-form (? v) (? y) (? z))))
Assertion added to data base.
;;; Query input:
(assert! (meeting accounting (Monday "9am")))
Assertion added to data base.
;;; Query input:
(assert! (meeting administration (Monday "10am")))
Assertion added to data base.
;;; Query input:
(assert! (meeting computer (Wednesday "3pm")))
Assertion added to data base.
;;; Query input:
(assert! (meeting administration (Friday "1pm")))
Assertion added to data base.
;;; Query input:
(assert! (meeting whole-company (Wednesday "4pm")))
Assertion added to data base.
;;; Query input:
(meeting (? dept) (Friday ? rest))
;;; Query results:

debug:simple-query
(meeting administration (Friday "1pm"))

;;; Query input:
(job (Hacker Alyssa P) ((? dept) ? rest))
;;; Query results:

debug:simple-query
(job (Hacker Alyssa P) (computer programmer))

;;; Query input:
(assert!
 (rule (meeting-time (? person) (? day-and-time))
       (or
        (and (job (? person) ((? dept) ? rest))
             (meeting (? dept) (? day-and-time)))
        (meeting whole-company (? day-and-time)))))
Assertion added to data base.
;;; Query input:
(meeting-time (Hacker Alyssa P) (Wednesday ? time))
;;; Query results:

debug:simple-query
apply-a-rule
rule=(rule (meeting-time (? person) (? day-and-time))
           (or
            (and (job (? person) ((? dept) ? rest))
                 (meeting (? dept) (? day-and-time)))
            (meeting whole-company (? day-and-time))))
pattern=(meeting-time (Hacker Alyssa P) (Wednesday ? time))
frame=()

unify-result=(((? 1 day-and-time) Wednesday ? time)
              ((? 1 person) Hacker Alyssa P))

debug:simple-query

debug:simple-query
(meeting-time (Hacker Alyssa P) (Wednesday "3pm"))

debug:simple-query
(meeting-time (Hacker Alyssa P) (Wednesday "4pm"))

;;; Query input:
exit
#+end_src

Hmm, neat. Structured requests.

***** DONE Exercise 4.60 pairs live near
      CLOSED: [2020-02-19 Wed 23:20]

Well, in some sense what the interpreter is doing is correct. Unlike a
supervisor relationship, the relationship of living near is
reflexive. If Alyssa lives near Cy, Cy lives near Alyssa, that is
logically correct. The interpreter produces this output because it
does a function on a tensor product of two lists, and the product has
both pairs of (a b) and (b a) satisfying the predicate. Can we
simplify such relations for mere mortals?

#+name: prolog-lives-near
#+begin_src shell :exports code :results verbatim output scalar code
  printf "%s" '
  <<prolog-input-sample-database>>
  <<prolog-input-canned-rules>>
  (lives-near ?person (Hacker Alyssa P))
  (lives-near ?person1 ?person2)
  (assert! (rule (lives-near-once ?person1 ?person2)
               (and (lives-near ?person1 ?person2)
                    (lisp-value name-is-less ?person1 ?person2))))
  (lives-near-once ?person1 ?person2)
  exit'
#+end_src


#+header: :stdin prolog-lives-near
#+begin_src shell :shebang "#! /usr/bin/chibi-scheme" :exports both :results output scalar code :exports both
  <<prolog-glue>>
  <<put-and-get>>
  <<streams-common>>
  <<streams-2>>
  <<stream-append>>
  <<prolog-driver-loop>>
  <<prolog-instantiate>>
  <<prolog-qeval>>
  <<prolog-simple-queries>>
  <<prolog-conjoin>>
  <<prolog-conjoin-installation>>
  <<prolog-disjoin>>
  <<prolog-disjoin-installation>>
  <<prolog-negate>>
  <<prolog-negate-installation>>
  <<prolog-lisp-filter>>
  <<prolog-lisp-filter-installation>>
  <<prolog-always-true>>
  <<prolog-pattern-matching>>
  <<prolog-rules-and-unification>>
  <<prolog-database>>
  <<prolog-database-add-assertion-original>>
  <<prolog-database-store-assertion-in-index>>
  <<prolog-stream-operations>>
  <<prolog-stream-flatmap>>
  <<prolog-flatten-stream>>
  <<streams-singleton>>
  <<prolog-query>>
  <<prolog-frames-and-bindings>>
  (define (name-is-less a b)
     (cond ((null? a) a)
           ((null? b) b)
           (else (string<? (symbol->string (car a)) (symbol->string (car b))))))
  (query-driver-loop)
#+end_src

#+RESULTS[ec565026b6cb4bb7918f688b8ff761c403f93c90]:
#+begin_src shell

;;; Query input:
(assert! (address (Bitdiddle Ben) (Slumerville (Ridge Road) 10)))
Assertion added to data base.
;;; Query input:
(assert! (job (Bitdiddle Ben) (computer wizard)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Bitdiddle Ben) 60000))
Assertion added to data base.
;;; Query input:
(assert! (address (Hacker Alyssa P) (Cambridge (Mass Ave) 78)))
Assertion added to data base.
;;; Query input:
(assert! (job (Hacker Alyssa P) (computer programmer)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Hacker Alyssa P) 40000))
Assertion added to data base.
;;; Query input:
(assert! (supervisor (Hacker Alyssa P) (Bitdiddle Ben)))
Assertion added to data base.
;;; Query input:
(assert! (address (Fect Cy D) (Cambridge (Ames Street) 3)))
Assertion added to data base.
;;; Query input:
(assert! (job (Fect Cy D) (computer programmer)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Fect Cy D) 35000))
Assertion added to data base.
;;; Query input:
(assert! (supervisor (Fect Cy D) (Bitdiddle Ben)))
Assertion added to data base.
;;; Query input:
(assert! (address (Tweakit Lem E) (Boston (Bay State Road) 22)))
Assertion added to data base.
;;; Query input:
(assert! (job (Tweakit Lem E) (computer technician)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Tweakit Lem E) 25000))
Assertion added to data base.
;;; Query input:
(assert! (supervisor (Tweakit Lem E) (Bitdiddle Ben)))
Assertion added to data base.
;;; Query input:
(assert! (address (Reasoner Louis) (Slumerville (Pine Tree Road) 80)))
Assertion added to data base.
;;; Query input:
(assert! (job (Reasoner Louis) (computer programmer trainee)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Reasoner Louis) 30000))
Assertion added to data base.
;;; Query input:
(assert! (supervisor (Reasoner Louis) (Hacker Alyssa P)))
Assertion added to data base.
;;; Query input:
(assert! (supervisor (Bitdiddle Ben) (Warbucks Oliver)))
Assertion added to data base.
;;; Query input:
(assert! (address (Warbucks Oliver) (Swellesley (Top Heap Road))))
Assertion added to data base.
;;; Query input:
(assert! (job (Warbucks Oliver) (administration big wheel)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Warbucks Oliver) 150000))
Assertion added to data base.
;;; Query input:
(assert! (address (Scrooge Eben) (Weston (Shady Lane) 10)))
Assertion added to data base.
;;; Query input:
(assert! (job (Scrooge Eben) (accounting chief accountant)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Scrooge Eben) 75000))
Assertion added to data base.
;;; Query input:
(assert! (supervisor (Scrooge Eben) (Warbucks Oliver)))
Assertion added to data base.
;;; Query input:
(assert! (address (Cratchet Robert) (Allston (N Harvard Street) 16)))
Assertion added to data base.
;;; Query input:
(assert! (job (Cratchet Robert) (accounting scrivener)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Cratchet Robert) 18000))
Assertion added to data base.
;;; Query input:
(assert! (supervisor (Cratchet Robert) (Scrooge Eben)))
Assertion added to data base.
;;; Query input:
(assert! (address (Aull DeWitt) (Slumerville (Onion Square) 5)))
Assertion added to data base.
;;; Query input:
(assert! (job (Aull DeWitt) (administration secretary)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Aull DeWitt) 25000))
Assertion added to data base.
;;; Query input:
(assert! (supervisor (Aull DeWitt) (Warbucks Oliver)))
Assertion added to data base.
;;; Query input:
(assert! (can-do-job (computer wizard) (computer programmer)))
Assertion added to data base.
;;; Query input:
(assert! (can-do-job (computer wizard) (computer technician)))
Assertion added to data base.
;;; Query input:
(assert! (can-do-job (computer programmer) (computer programmer trainee)))
Assertion added to data base.
;;; Query input:
(assert! (can-do-job (administration secretary) (administration big wheel)))
Assertion added to data base.
;;; Query input:
(assert!
 (rule (lives-near (? person-1) (? person-2))
       (and (address (? person-1) ((? town) ? rest-1))
            (address (? person-2) ((? town) ? rest-2))
            (not (same (? person-1) (? person-2))))))
Assertion added to data base.
;;; Query input:
(assert! (rule (same (? x) (? x))))
Assertion added to data base.
;;; Query input:
(assert!
 (rule (wheel (? person))
       (and (supervisor (? middle-manager) (? person))
            (supervisor (? x) (? middle-manager)))))
Assertion added to data base.
;;; Query input:
(assert!
 (rule (outranked-by (? staff-person) (? boss))
       (or (supervisor (? staff-person) (? boss))
           (and (supervisor (? staff-person) (? middle-manager))
                (outranked-by (? middle-manager) (? boss))))))
Assertion added to data base.
;;; Query input:
(assert! (rule (append-to-form () (? y) (? y))))
Assertion added to data base.
;;; Query input:
(assert!
 (rule (append-to-form ((? u) ? v) (? y) ((? u) ? z))
       (append-to-form (? v) (? y) (? z))))
Assertion added to data base.
;;; Query input:
(lives-near (? person) (Hacker Alyssa P))
;;; Query results:

debug:simple-query
apply-a-rule
rule=(rule (lives-near (? person-1) (? person-2))
           (and (address (? person-1) ((? town) ? rest-1))
                (address (? person-2) ((? town) ? rest-2))
                (not (same (? person-1) (? person-2)))))
pattern=(lives-near (? person) (Hacker Alyssa P))
frame=()

unify-result=(((? 1 person-2) Hacker Alyssa P) ((? person) ? 1 person-1))

debug:simple-query

debug:simple-query

debug:simple-query
apply-a-rule
rule=(rule (same (? x) (? x)))
pattern=(same (? 1 person-1) (? 1 person-2))
frame=(((? 1 rest-2) (Mass Ave) 78) ((? 1 rest-1) (Ames Street) 3)
                                    ((? 1 town) . Cambridge)
                                    ((? 1 person-1) Fect Cy D)
                                    ((? 1 person-2) Hacker Alyssa P)
                                    ((? person) ? 1 person-1))

unify-result=failed
(lives-near (Fect Cy D) (Hacker Alyssa P))

debug:simple-query
apply-a-rule
rule=(rule (same (? x) (? x)))
pattern=(same (? 1 person-1) (? 1 person-2))
frame=(((? 1 rest-2) (Mass Ave) 78) ((? 1 rest-1) (Mass Ave) 78)
                                    ((? 1 town) . Cambridge)
                                    ((? 1 person-1) Hacker Alyssa P)
                                    ((? 1 person-2) Hacker Alyssa P)
                                    ((? person) ? 1 person-1))

unify-result=(((? 3 x) Hacker Alyssa P) ((? 1 rest-2) (Mass Ave) 78)
                                        ((? 1 rest-1) (Mass Ave) 78)
                                        ((? 1 town) . Cambridge)
                                        ((? 1 person-1) Hacker Alyssa P)
                                        ((? 1 person-2) Hacker Alyssa P)
                                        ((? person) ? 1 person-1))

;;; Query input:
(lives-near (? person1) (? person2))
;;; Query results:

debug:simple-query
apply-a-rule
rule=(rule (lives-near (? person-1) (? person-2))
           (and (address (? person-1) ((? town) ? rest-1))
                (address (? person-2) ((? town) ? rest-2))
                (not (same (? person-1) (? person-2)))))
pattern=(lives-near (? person1) (? person2))
frame=()

unify-result=(((? person2) ? 4 person-2) ((? person1) ? 4 person-1))

debug:simple-query

debug:simple-query

debug:simple-query
apply-a-rule
rule=(rule (same (? x) (? x)))
pattern=(same (? 4 person-1) (? 4 person-2))
frame=(((? 4 rest-2) (Onion Square) 5) ((? 4 person-2) Aull DeWitt)
                                       ((? 4 rest-1) (Onion Square) 5)
                                       ((? 4 town) . Slumerville)
                                       ((? 4 person-1) Aull DeWitt)
                                       ((? person2) ? 4 person-2)
                                       ((? person1) ? 4 person-1))

unify-result=(((? 5 x) Aull DeWitt) ((? 4 rest-2) (Onion Square) 5)
                                    ((? 4 person-2) Aull DeWitt)
                                    ((? 4 rest-1) (Onion Square) 5)
                                    ((? 4 town) . Slumerville)
                                    ((? 4 person-1) Aull DeWitt)
                                    ((? person2) ? 4 person-2)
                                    ((? person1) ? 4 person-1))

debug:simple-query
apply-a-rule
rule=(rule (same (? x) (? x)))
pattern=(same (? 4 person-1) (? 4 person-2))
frame=(((? 4 rest-2) (N Harvard Street) 16) ((? 4 person-2) Cratchet Robert)
                                            ((? 4 rest-1) (N Harvard Street)
                                                          16)
                                            ((? 4 town) . Allston)
                                            ((? 4 person-1) Cratchet Robert)
                                            ((? person2) ? 4 person-2)
                                            ((? person1) ? 4 person-1))

unify-result=(((? 6 x) Cratchet Robert) ((? 4 rest-2) (N Harvard Street) 16)
                                        ((? 4 person-2) Cratchet Robert)
                                        ((? 4 rest-1) (N Harvard Street) 16)
                                        ((? 4 town) . Allston)
                                        ((? 4 person-1) Cratchet Robert)
                                        ((? person2) ? 4 person-2)
                                        ((? person1) ? 4 person-1))

debug:simple-query
apply-a-rule
rule=(rule (same (? x) (? x)))
pattern=(same (? 4 person-1) (? 4 person-2))
frame=(((? 4 rest-2) (Pine Tree Road) 80) ((? 4 person-2) Reasoner Louis)
                                          ((? 4 rest-1) (Onion Square) 5)
                                          ((? 4 town) . Slumerville)
                                          ((? 4 person-1) Aull DeWitt)
                                          ((? person2) ? 4 person-2)
                                          ((? person1) ? 4 person-1))

unify-result=failed
(lives-near (Aull DeWitt) (Reasoner Louis))

debug:simple-query
apply-a-rule
rule=(rule (same (? x) (? x)))
pattern=(same (? 4 person-1) (? 4 person-2))
frame=(((? 4 rest-2) (Shady Lane) 10) ((? 4 person-2) Scrooge Eben)
                                      ((? 4 rest-1) (Shady Lane) 10)
                                      ((? 4 town) . Weston)
                                      ((? 4 person-1) Scrooge Eben)
                                      ((? person2) ? 4 person-2)
                                      ((? person1) ? 4 person-1))

unify-result=(((? 8 x) Scrooge Eben) ((? 4 rest-2) (Shady Lane) 10)
                                     ((? 4 person-2) Scrooge Eben)
                                     ((? 4 rest-1) (Shady Lane) 10)
                                     ((? 4 town) . Weston)
                                     ((? 4 person-1) Scrooge Eben)
                                     ((? person2) ? 4 person-2)
                                     ((? person1) ? 4 person-1))

debug:simple-query
apply-a-rule
rule=(rule (same (? x) (? x)))
pattern=(same (? 4 person-1) (? 4 person-2))
frame=(((? 4 rest-2) (Ridge Road) 10) ((? 4 person-2) Bitdiddle Ben)
                                      ((? 4 rest-1) (Onion Square) 5)
                                      ((? 4 town) . Slumerville)
                                      ((? 4 person-1) Aull DeWitt)
                                      ((? person2) ? 4 person-2)
                                      ((? person1) ? 4 person-1))

unify-result=failed
(lives-near (Aull DeWitt) (Bitdiddle Ben))

debug:simple-query
apply-a-rule
rule=(rule (same (? x) (? x)))
pattern=(same (? 4 person-1) (? 4 person-2))
frame=(((? 4 rest-2) (Top Heap Road)) ((? 4 person-2) Warbucks Oliver)
                                      ((? 4 rest-1) (Top Heap Road))
                                      ((? 4 town) . Swellesley)
                                      ((? 4 person-1) Warbucks Oliver)
                                      ((? person2) ? 4 person-2)
                                      ((? person1) ? 4 person-1))

unify-result=(((? 10 x) Warbucks Oliver) ((? 4 rest-2) (Top Heap Road))
                                         ((? 4 person-2) Warbucks Oliver)
                                         ((? 4 rest-1) (Top Heap Road))
                                         ((? 4 town) . Swellesley)
                                         ((? 4 person-1) Warbucks Oliver)
                                         ((? person2) ? 4 person-2)
                                         ((? person1) ? 4 person-1))

debug:simple-query
apply-a-rule
rule=(rule (same (? x) (? x)))
pattern=(same (? 4 person-1) (? 4 person-2))
frame=(((? 4 rest-2) (Onion Square) 5) ((? 4 person-2) Aull DeWitt)
                                       ((? 4 rest-1) (Pine Tree Road) 80)
                                       ((? 4 town) . Slumerville)
                                       ((? 4 person-1) Reasoner Louis)
                                       ((? person2) ? 4 person-2)
                                       ((? person1) ? 4 person-1))

unify-result=failed
(lives-near (Reasoner Louis) (Aull DeWitt))

debug:simple-query
apply-a-rule
rule=(rule (same (? x) (? x)))
pattern=(same (? 4 person-1) (? 4 person-2))
frame=(((? 4 rest-2) (Bay State Road) 22) ((? 4 person-2) Tweakit Lem E)
                                          ((? 4 rest-1) (Bay State Road) 22)
                                          ((? 4 town) . Boston)
                                          ((? 4 person-1) Tweakit Lem E)
                                          ((? person2) ? 4 person-2)
                                          ((? person1) ? 4 person-1))

unify-result=(((? 12 x) Tweakit Lem E) ((? 4 rest-2) (Bay State Road) 22)
                                       ((? 4 person-2) Tweakit Lem E)
                                       ((? 4 rest-1) (Bay State Road) 22)
                                       ((? 4 town) . Boston)
                                       ((? 4 person-1) Tweakit Lem E)
                                       ((? person2) ? 4 person-2)
                                       ((? person1) ? 4 person-1))

debug:simple-query
apply-a-rule
rule=(rule (same (? x) (? x)))
pattern=(same (? 4 person-1) (? 4 person-2))
frame=(((? 4 rest-2) (Pine Tree Road) 80) ((? 4 person-2) Reasoner Louis)
                                          ((? 4 rest-1) (Pine Tree Road) 80)
                                          ((? 4 town) . Slumerville)
                                          ((? 4 person-1) Reasoner Louis)
                                          ((? person2) ? 4 person-2)
                                          ((? person1) ? 4 person-1))

unify-result=(((? 13 x) Reasoner Louis) ((? 4 rest-2) (Pine Tree Road) 80)
                                        ((? 4 person-2) Reasoner Louis)
                                        ((? 4 rest-1) (Pine Tree Road) 80)
                                        ((? 4 town) . Slumerville)
                                        ((? 4 person-1) Reasoner Louis)
                                        ((? person2) ? 4 person-2)
                                        ((? person1) ? 4 person-1))

debug:simple-query
apply-a-rule
rule=(rule (same (? x) (? x)))
pattern=(same (? 4 person-1) (? 4 person-2))
frame=(((? 4 rest-2) (Ames Street) 3) ((? 4 person-2) Fect Cy D)
                                      ((? 4 rest-1) (Ames Street) 3)
                                      ((? 4 town) . Cambridge)
                                      ((? 4 person-1) Fect Cy D)
                                      ((? person2) ? 4 person-2)
                                      ((? person1) ? 4 person-1))

unify-result=(((? 14 x) Fect Cy D) ((? 4 rest-2) (Ames Street) 3)
                                   ((? 4 person-2) Fect Cy D)
                                   ((? 4 rest-1) (Ames Street) 3)
                                   ((? 4 town) . Cambridge)
                                   ((? 4 person-1) Fect Cy D)
                                   ((? person2) ? 4 person-2)
                                   ((? person1) ? 4 person-1))

debug:simple-query
apply-a-rule
rule=(rule (same (? x) (? x)))
pattern=(same (? 4 person-1) (? 4 person-2))
frame=(((? 4 rest-2) (Ridge Road) 10) ((? 4 person-2) Bitdiddle Ben)
                                      ((? 4 rest-1) (Pine Tree Road) 80)
                                      ((? 4 town) . Slumerville)
                                      ((? 4 person-1) Reasoner Louis)
                                      ((? person2) ? 4 person-2)
                                      ((? person1) ? 4 person-1))

unify-result=failed
(lives-near (Reasoner Louis) (Bitdiddle Ben))

debug:simple-query
apply-a-rule
rule=(rule (same (? x) (? x)))
pattern=(same (? 4 person-1) (? 4 person-2))
frame=(((? 4 rest-2) (Ames Street) 3) ((? 4 person-2) Fect Cy D)
                                      ((? 4 rest-1) (Mass Ave) 78)
                                      ((? 4 town) . Cambridge)
                                      ((? 4 person-1) Hacker Alyssa P)
                                      ((? person2) ? 4 person-2)
                                      ((? person1) ? 4 person-1))

unify-result=failed
(lives-near (Hacker Alyssa P) (Fect Cy D))

debug:simple-query
apply-a-rule
rule=(rule (same (? x) (? x)))
pattern=(same (? 4 person-1) (? 4 person-2))
frame=(((? 4 rest-2) (Mass Ave) 78) ((? 4 person-2) Hacker Alyssa P)
                                    ((? 4 rest-1) (Ames Street) 3)
                                    ((? 4 town) . Cambridge)
                                    ((? 4 person-1) Fect Cy D)
                                    ((? person2) ? 4 person-2)
                                    ((? person1) ? 4 person-1))

unify-result=failed
(lives-near (Fect Cy D) (Hacker Alyssa P))

debug:simple-query
apply-a-rule
rule=(rule (same (? x) (? x)))
pattern=(same (? 4 person-1) (? 4 person-2))
frame=(((? 4 rest-2) (Onion Square) 5) ((? 4 person-2) Aull DeWitt)
                                       ((? 4 rest-1) (Ridge Road) 10)
                                       ((? 4 town) . Slumerville)
                                       ((? 4 person-1) Bitdiddle Ben)
                                       ((? person2) ? 4 person-2)
                                       ((? person1) ? 4 person-1))

unify-result=failed
(lives-near (Bitdiddle Ben) (Aull DeWitt))

debug:simple-query
apply-a-rule
rule=(rule (same (? x) (? x)))
pattern=(same (? 4 person-1) (? 4 person-2))
frame=(((? 4 rest-2) (Mass Ave) 78) ((? 4 person-2) Hacker Alyssa P)
                                    ((? 4 rest-1) (Mass Ave) 78)
                                    ((? 4 town) . Cambridge)
                                    ((? 4 person-1) Hacker Alyssa P)
                                    ((? person2) ? 4 person-2)
                                    ((? person1) ? 4 person-1))

unify-result=(((? 19 x) Hacker Alyssa P) ((? 4 rest-2) (Mass Ave) 78)
                                         ((? 4 person-2) Hacker Alyssa P)
                                         ((? 4 rest-1) (Mass Ave) 78)
                                         ((? 4 town) . Cambridge)
                                         ((? 4 person-1) Hacker Alyssa P)
                                         ((? person2) ? 4 person-2)
                                         ((? person1) ? 4 person-1))

debug:simple-query
apply-a-rule
rule=(rule (same (? x) (? x)))
pattern=(same (? 4 person-1) (? 4 person-2))
frame=(((? 4 rest-2) (Pine Tree Road) 80) ((? 4 person-2) Reasoner Louis)
                                          ((? 4 rest-1) (Ridge Road) 10)
                                          ((? 4 town) . Slumerville)
                                          ((? 4 person-1) Bitdiddle Ben)
                                          ((? person2) ? 4 person-2)
                                          ((? person1) ? 4 person-1))

unify-result=failed
(lives-near (Bitdiddle Ben) (Reasoner Louis))

debug:simple-query
apply-a-rule
rule=(rule (same (? x) (? x)))
pattern=(same (? 4 person-1) (? 4 person-2))
frame=(((? 4 rest-2) (Ridge Road) 10) ((? 4 person-2) Bitdiddle Ben)
                                      ((? 4 rest-1) (Ridge Road) 10)
                                      ((? 4 town) . Slumerville)
                                      ((? 4 person-1) Bitdiddle Ben)
                                      ((? person2) ? 4 person-2)
                                      ((? person1) ? 4 person-1))

unify-result=(((? 21 x) Bitdiddle Ben) ((? 4 rest-2) (Ridge Road) 10)
                                       ((? 4 person-2) Bitdiddle Ben)
                                       ((? 4 rest-1) (Ridge Road) 10)
                                       ((? 4 town) . Slumerville)
                                       ((? 4 person-1) Bitdiddle Ben)
                                       ((? person2) ? 4 person-2)
                                       ((? person1) ? 4 person-1))

;;; Query input:
(assert!
 (rule (lives-near-once (? person1) (? person2))
       (and (lives-near (? person1) (? person2))
            (lisp-value name-is-less (? person1) (? person2)))))
Assertion added to data base.
;;; Query input:
(lives-near-once (? person1) (? person2))
;;; Query results:

debug:simple-query
apply-a-rule
rule=(rule (lives-near-once (? person1) (? person2))
           (and (lives-near (? person1) (? person2))
                (lisp-value name-is-less (? person1) (? person2))))
pattern=(lives-near-once (? person1) (? person2))
frame=()

unify-result=(((? person2) ? 22 person2) ((? person1) ? 22 person1))

debug:simple-query
apply-a-rule
rule=(rule (lives-near (? person-1) (? person-2))
           (and (address (? person-1) ((? town) ? rest-1))
                (address (? person-2) ((? town) ? rest-2))
                (not (same (? person-1) (? person-2)))))
pattern=(lives-near (? 22 person1) (? 22 person2))
frame=(((? person2) ? 22 person2) ((? person1) ? 22 person1))

unify-result=(((? 22 person2) ? 23 person-2) ((? 22 person1) ? 23 person-1)
                                             ((? person2) ? 22 person2)
                                             ((? person1) ? 22 person1))

debug:simple-query

debug:simple-query

debug:simple-query
apply-a-rule
rule=(rule (same (? x) (? x)))
pattern=(same (? 23 person-1) (? 23 person-2))
frame=(((? 23 rest-2) (Onion Square) 5) ((? 23 person-2) Aull DeWitt)
                                        ((? 23 rest-1) (Onion Square) 5)
                                        ((? 23 town) . Slumerville)
                                        ((? 23 person-1) Aull DeWitt)
                                        ((? 22 person2) ? 23 person-2)
                                        ((? 22 person1) ? 23 person-1)
                                        ((? person2) ? 22 person2)
                                        ((? person1) ? 22 person1))

unify-result=(((? 24 x) Aull DeWitt) ((? 23 rest-2) (Onion Square) 5)
                                     ((? 23 person-2) Aull DeWitt)
                                     ((? 23 rest-1) (Onion Square) 5)
                                     ((? 23 town) . Slumerville)
                                     ((? 23 person-1) Aull DeWitt)
                                     ((? 22 person2) ? 23 person-2)
                                     ((? 22 person1) ? 23 person-1)
                                     ((? person2) ? 22 person2)
                                     ((? person1) ? 22 person1))

debug:simple-query
apply-a-rule
rule=(rule (same (? x) (? x)))
pattern=(same (? 23 person-1) (? 23 person-2))
frame=(((? 23 rest-2) (N Harvard Street) 16)
       ((? 23 person-2) Cratchet Robert)
       ((? 23 rest-1) (N Harvard Street) 16)
       ((? 23 town) . Allston)
       ((? 23 person-1) Cratchet Robert)
       ((? 22 person2) ? 23 person-2)
       ((? 22 person1) ? 23 person-1)
       ((? person2) ? 22 person2)
       ((? person1) ? 22 person1))

unify-result=(((? 25 x) Cratchet Robert)
              ((? 23 rest-2) (N Harvard Street) 16)
              ((? 23 person-2) Cratchet Robert)
              ((? 23 rest-1) (N Harvard Street) 16)
              ((? 23 town) . Allston)
              ((? 23 person-1) Cratchet Robert)
              ((? 22 person2) ? 23 person-2)
              ((? 22 person1) ? 23 person-1)
              ((? person2) ? 22 person2)
              ((? person1) ? 22 person1))

debug:simple-query
apply-a-rule
rule=(rule (same (? x) (? x)))
pattern=(same (? 23 person-1) (? 23 person-2))
frame=(((? 23 rest-2) (Pine Tree Road) 80) ((? 23 person-2) Reasoner Louis)
                                           ((? 23 rest-1) (Onion Square) 5)
                                           ((? 23 town) . Slumerville)
                                           ((? 23 person-1) Aull DeWitt)
                                           ((? 22 person2) ? 23 person-2)
                                           ((? 22 person1) ? 23 person-1)
                                           ((? person2) ? 22 person2)
                                           ((? person1) ? 22 person1))

unify-result=failed
(lives-near-once (Aull DeWitt) (Reasoner Louis))

debug:simple-query
apply-a-rule
rule=(rule (same (? x) (? x)))
pattern=(same (? 23 person-1) (? 23 person-2))
frame=(((? 23 rest-2) (Shady Lane) 10) ((? 23 person-2) Scrooge Eben)
                                       ((? 23 rest-1) (Shady Lane) 10)
                                       ((? 23 town) . Weston)
                                       ((? 23 person-1) Scrooge Eben)
                                       ((? 22 person2) ? 23 person-2)
                                       ((? 22 person1) ? 23 person-1)
                                       ((? person2) ? 22 person2)
                                       ((? person1) ? 22 person1))

unify-result=(((? 27 x) Scrooge Eben) ((? 23 rest-2) (Shady Lane) 10)
                                      ((? 23 person-2) Scrooge Eben)
                                      ((? 23 rest-1) (Shady Lane) 10)
                                      ((? 23 town) . Weston)
                                      ((? 23 person-1) Scrooge Eben)
                                      ((? 22 person2) ? 23 person-2)
                                      ((? 22 person1) ? 23 person-1)
                                      ((? person2) ? 22 person2)
                                      ((? person1) ? 22 person1))

debug:simple-query
apply-a-rule
rule=(rule (same (? x) (? x)))
pattern=(same (? 23 person-1) (? 23 person-2))
frame=(((? 23 rest-2) (Ridge Road) 10) ((? 23 person-2) Bitdiddle Ben)
                                       ((? 23 rest-1) (Onion Square) 5)
                                       ((? 23 town) . Slumerville)
                                       ((? 23 person-1) Aull DeWitt)
                                       ((? 22 person2) ? 23 person-2)
                                       ((? 22 person1) ? 23 person-1)
                                       ((? person2) ? 22 person2)
                                       ((? person1) ? 22 person1))

unify-result=failed
(lives-near-once (Aull DeWitt) (Bitdiddle Ben))

debug:simple-query
apply-a-rule
rule=(rule (same (? x) (? x)))
pattern=(same (? 23 person-1) (? 23 person-2))
frame=(((? 23 rest-2) (Top Heap Road)) ((? 23 person-2) Warbucks Oliver)
                                       ((? 23 rest-1) (Top Heap Road))
                                       ((? 23 town) . Swellesley)
                                       ((? 23 person-1) Warbucks Oliver)
                                       ((? 22 person2) ? 23 person-2)
                                       ((? 22 person1) ? 23 person-1)
                                       ((? person2) ? 22 person2)
                                       ((? person1) ? 22 person1))

unify-result=(((? 29 x) Warbucks Oliver) ((? 23 rest-2) (Top Heap Road))
                                         ((? 23 person-2) Warbucks Oliver)
                                         ((? 23 rest-1) (Top Heap Road))
                                         ((? 23 town) . Swellesley)
                                         ((? 23 person-1) Warbucks Oliver)
                                         ((? 22 person2) ? 23 person-2)
                                         ((? 22 person1) ? 23 person-1)
                                         ((? person2) ? 22 person2)
                                         ((? person1) ? 22 person1))

debug:simple-query
apply-a-rule
rule=(rule (same (? x) (? x)))
pattern=(same (? 23 person-1) (? 23 person-2))
frame=(((? 23 rest-2) (Onion Square) 5) ((? 23 person-2) Aull DeWitt)
                                        ((? 23 rest-1) (Pine Tree Road) 80)
                                        ((? 23 town) . Slumerville)
                                        ((? 23 person-1) Reasoner Louis)
                                        ((? 22 person2) ? 23 person-2)
                                        ((? 22 person1) ? 23 person-1)
                                        ((? person2) ? 22 person2)
                                        ((? person1) ? 22 person1))

unify-result=failed

debug:simple-query
apply-a-rule
rule=(rule (same (? x) (? x)))
pattern=(same (? 23 person-1) (? 23 person-2))
frame=(((? 23 rest-2) (Bay State Road) 22) ((? 23 person-2) Tweakit Lem E)
                                           ((? 23 rest-1) (Bay State Road) 22)
                                           ((? 23 town) . Boston)
                                           ((? 23 person-1) Tweakit Lem E)
                                           ((? 22 person2) ? 23 person-2)
                                           ((? 22 person1) ? 23 person-1)
                                           ((? person2) ? 22 person2)
                                           ((? person1) ? 22 person1))

unify-result=(((? 31 x) Tweakit Lem E) ((? 23 rest-2) (Bay State Road) 22)
                                       ((? 23 person-2) Tweakit Lem E)
                                       ((? 23 rest-1) (Bay State Road) 22)
                                       ((? 23 town) . Boston)
                                       ((? 23 person-1) Tweakit Lem E)
                                       ((? 22 person2) ? 23 person-2)
                                       ((? 22 person1) ? 23 person-1)
                                       ((? person2) ? 22 person2)
                                       ((? person1) ? 22 person1))

debug:simple-query
apply-a-rule
rule=(rule (same (? x) (? x)))
pattern=(same (? 23 person-1) (? 23 person-2))
frame=(((? 23 rest-2) (Pine Tree Road) 80) ((? 23 person-2) Reasoner Louis)
                                           ((? 23 rest-1) (Pine Tree Road) 80)
                                           ((? 23 town) . Slumerville)
                                           ((? 23 person-1) Reasoner Louis)
                                           ((? 22 person2) ? 23 person-2)
                                           ((? 22 person1) ? 23 person-1)
                                           ((? person2) ? 22 person2)
                                           ((? person1) ? 22 person1))

unify-result=(((? 32 x) Reasoner Louis) ((? 23 rest-2) (Pine Tree Road) 80)
                                        ((? 23 person-2) Reasoner Louis)
                                        ((? 23 rest-1) (Pine Tree Road) 80)
                                        ((? 23 town) . Slumerville)
                                        ((? 23 person-1) Reasoner Louis)
                                        ((? 22 person2) ? 23 person-2)
                                        ((? 22 person1) ? 23 person-1)
                                        ((? person2) ? 22 person2)
                                        ((? person1) ? 22 person1))

debug:simple-query
apply-a-rule
rule=(rule (same (? x) (? x)))
pattern=(same (? 23 person-1) (? 23 person-2))
frame=(((? 23 rest-2) (Ames Street) 3) ((? 23 person-2) Fect Cy D)
                                       ((? 23 rest-1) (Ames Street) 3)
                                       ((? 23 town) . Cambridge)
                                       ((? 23 person-1) Fect Cy D)
                                       ((? 22 person2) ? 23 person-2)
                                       ((? 22 person1) ? 23 person-1)
                                       ((? person2) ? 22 person2)
                                       ((? person1) ? 22 person1))

unify-result=(((? 33 x) Fect Cy D) ((? 23 rest-2) (Ames Street) 3)
                                   ((? 23 person-2) Fect Cy D)
                                   ((? 23 rest-1) (Ames Street) 3)
                                   ((? 23 town) . Cambridge)
                                   ((? 23 person-1) Fect Cy D)
                                   ((? 22 person2) ? 23 person-2)
                                   ((? 22 person1) ? 23 person-1)
                                   ((? person2) ? 22 person2)
                                   ((? person1) ? 22 person1))

debug:simple-query
apply-a-rule
rule=(rule (same (? x) (? x)))
pattern=(same (? 23 person-1) (? 23 person-2))
frame=(((? 23 rest-2) (Ridge Road) 10) ((? 23 person-2) Bitdiddle Ben)
                                       ((? 23 rest-1) (Pine Tree Road) 80)
                                       ((? 23 town) . Slumerville)
                                       ((? 23 person-1) Reasoner Louis)
                                       ((? 22 person2) ? 23 person-2)
                                       ((? 22 person1) ? 23 person-1)
                                       ((? person2) ? 22 person2)
                                       ((? person1) ? 22 person1))

unify-result=failed

debug:simple-query
apply-a-rule
rule=(rule (same (? x) (? x)))
pattern=(same (? 23 person-1) (? 23 person-2))
frame=(((? 23 rest-2) (Ames Street) 3) ((? 23 person-2) Fect Cy D)
                                       ((? 23 rest-1) (Mass Ave) 78)
                                       ((? 23 town) . Cambridge)
                                       ((? 23 person-1) Hacker Alyssa P)
                                       ((? 22 person2) ? 23 person-2)
                                       ((? 22 person1) ? 23 person-1)
                                       ((? person2) ? 22 person2)
                                       ((? person1) ? 22 person1))

unify-result=failed

debug:simple-query
apply-a-rule
rule=(rule (same (? x) (? x)))
pattern=(same (? 23 person-1) (? 23 person-2))
frame=(((? 23 rest-2) (Mass Ave) 78) ((? 23 person-2) Hacker Alyssa P)
                                     ((? 23 rest-1) (Ames Street) 3)
                                     ((? 23 town) . Cambridge)
                                     ((? 23 person-1) Fect Cy D)
                                     ((? 22 person2) ? 23 person-2)
                                     ((? 22 person1) ? 23 person-1)
                                     ((? person2) ? 22 person2)
                                     ((? person1) ? 22 person1))

unify-result=failed
(lives-near-once (Fect Cy D) (Hacker Alyssa P))

debug:simple-query
apply-a-rule
rule=(rule (same (? x) (? x)))
pattern=(same (? 23 person-1) (? 23 person-2))
frame=(((? 23 rest-2) (Onion Square) 5) ((? 23 person-2) Aull DeWitt)
                                        ((? 23 rest-1) (Ridge Road) 10)
                                        ((? 23 town) . Slumerville)
                                        ((? 23 person-1) Bitdiddle Ben)
                                        ((? 22 person2) ? 23 person-2)
                                        ((? 22 person1) ? 23 person-1)
                                        ((? person2) ? 22 person2)
                                        ((? person1) ? 22 person1))

unify-result=failed

debug:simple-query
apply-a-rule
rule=(rule (same (? x) (? x)))
pattern=(same (? 23 person-1) (? 23 person-2))
frame=(((? 23 rest-2) (Mass Ave) 78) ((? 23 person-2) Hacker Alyssa P)
                                     ((? 23 rest-1) (Mass Ave) 78)
                                     ((? 23 town) . Cambridge)
                                     ((? 23 person-1) Hacker Alyssa P)
                                     ((? 22 person2) ? 23 person-2)
                                     ((? 22 person1) ? 23 person-1)
                                     ((? person2) ? 22 person2)
                                     ((? person1) ? 22 person1))

unify-result=(((? 38 x) Hacker Alyssa P) ((? 23 rest-2) (Mass Ave) 78)
                                         ((? 23 person-2) Hacker Alyssa P)
                                         ((? 23 rest-1) (Mass Ave) 78)
                                         ((? 23 town) . Cambridge)
                                         ((? 23 person-1) Hacker Alyssa P)
                                         ((? 22 person2) ? 23 person-2)
                                         ((? 22 person1) ? 23 person-1)
                                         ((? person2) ? 22 person2)
                                         ((? person1) ? 22 person1))

debug:simple-query
apply-a-rule
rule=(rule (same (? x) (? x)))
pattern=(same (? 23 person-1) (? 23 person-2))
frame=(((? 23 rest-2) (Pine Tree Road) 80) ((? 23 person-2) Reasoner Louis)
                                           ((? 23 rest-1) (Ridge Road) 10)
                                           ((? 23 town) . Slumerville)
                                           ((? 23 person-1) Bitdiddle Ben)
                                           ((? 22 person2) ? 23 person-2)
                                           ((? 22 person1) ? 23 person-1)
                                           ((? person2) ? 22 person2)
                                           ((? person1) ? 22 person1))

unify-result=failed
(lives-near-once (Bitdiddle Ben) (Reasoner Louis))

debug:simple-query
apply-a-rule
rule=(rule (same (? x) (? x)))
pattern=(same (? 23 person-1) (? 23 person-2))
frame=(((? 23 rest-2) (Ridge Road) 10) ((? 23 person-2) Bitdiddle Ben)
                                       ((? 23 rest-1) (Ridge Road) 10)
                                       ((? 23 town) . Slumerville)
                                       ((? 23 person-1) Bitdiddle Ben)
                                       ((? 22 person2) ? 23 person-2)
                                       ((? 22 person1) ? 23 person-1)
                                       ((? person2) ? 22 person2)
                                       ((? person1) ? 22 person1))

unify-result=(((? 40 x) Bitdiddle Ben) ((? 23 rest-2) (Ridge Road) 10)
                                       ((? 23 person-2) Bitdiddle Ben)
                                       ((? 23 rest-1) (Ridge Road) 10)
                                       ((? 23 town) . Slumerville)
                                       ((? 23 person-1) Bitdiddle Ben)
                                       ((? 22 person2) ? 23 person-2)
                                       ((? 22 person1) ? 23 person-1)
                                       ((? person2) ? 22 person2)
                                       ((? person1) ? 22 person1))

;;; Query input:
exit
#+end_src

***** DONE Exercise 4.61 next-to relation
      CLOSED: [2020-02-19 Wed 23:31]

#+name: prolog-input-next-to
#+begin_src shell :exports code :results verbatim output scalar code
  printf "%s" '
  (assert! (rule (?x next-to ?y in (?x ?y . ?u))))
  (assert! (rule (?x next-to ?y in (?v . ?z))
        (?x next-to ?y in ?z)))
  (?x next-to ?y in (1 (2 3) 4))
  (?x next-to  1 in (2 1 3 1))
  exit'
#+end_src

#+header: :stdin prolog-input-next-to
#+begin_src shell :shebang "#! /usr/bin/chibi-scheme" :exports both :results output scalar code :exports both
  <<prolog-glue>>
  <<put-and-get>>
  <<streams-common>>
  <<streams-2>>
  <<stream-append>>
  <<prolog-driver-loop>>
  <<prolog-instantiate>>
  <<prolog-qeval>>
  <<prolog-simple-queries>>
  <<prolog-conjoin>>
  <<prolog-conjoin-installation>>
  <<prolog-disjoin>>
  <<prolog-disjoin-installation>>
  <<prolog-negate>>
  <<prolog-negate-installation>>
  <<prolog-lisp-filter>>
  <<prolog-lisp-filter-installation>>
  <<prolog-always-true>>
  <<prolog-pattern-matching>>
  <<prolog-rules-and-unification>>
  <<prolog-database>>
  <<prolog-database-add-assertion-original>>
  <<prolog-database-store-assertion-in-index>>
  <<prolog-stream-operations>>
  <<prolog-stream-flatmap>>
  <<prolog-flatten-stream>>
  <<streams-singleton>>
  <<prolog-query>>
  <<prolog-frames-and-bindings>>
  (query-driver-loop)
#+end_src

#+RESULTS[9762e1759318eb8a63360828f95ecf86dab74653]:
#+begin_src shell

;;; Query input:
(assert! (rule ((? x) next-to (? y) in ((? x) (? y) ? u))))
Assertion added to data base.
;;; Query input:
(assert!
 (rule ((? x) next-to (? y) in ((? v) ? z)) ((? x) next-to (? y) in (? z))))
Assertion added to data base.
;;; Query input:
((? x) next-to (? y) in (1 (2 3) 4))
;;; Query results:

debug:simple-query
apply-a-rule
rule=(rule ((? x) next-to (? y) in ((? v) ? z))
           ((? x) next-to (? y) in (? z)))
pattern=((? x) next-to (? y) in (1 (2 3) 4))
frame=()

unify-result=(((? 1 z) (2 3) 4) ((? 1 v) . 1) ((? y) ? 1 y) ((? x) ? 1 x))

debug:simple-query
apply-a-rule
rule=(rule ((? x) next-to (? y) in ((? v) ? z))
           ((? x) next-to (? y) in (? z)))
pattern=((? 1 x) next-to (? 1 y) in (? 1 z))
frame=(((? 1 z) (2 3) 4) ((? 1 v) . 1) ((? y) ? 1 y) ((? x) ? 1 x))

unify-result=(((? 2 z) 4) ((? 2 v) 2 3)
                          ((? 1 y) ? 2 y)
                          ((? 1 x) ? 2 x)
                          ((? 1 z) (2 3) 4)
                          ((? 1 v) . 1)
                          ((? y) ? 1 y)
                          ((? x) ? 1 x))

debug:simple-query
apply-a-rule
rule=(rule ((? x) next-to (? y) in ((? v) ? z))
           ((? x) next-to (? y) in (? z)))
pattern=((? 2 x) next-to (? 2 y) in (? 2 z))
frame=(((? 2 z) 4) ((? 2 v) 2 3)
                   ((? 1 y) ? 2 y)
                   ((? 1 x) ? 2 x)
                   ((? 1 z) (2 3) 4)
                   ((? 1 v) . 1)
                   ((? y) ? 1 y)
                   ((? x) ? 1 x))

unify-result=(((? 3 z)) ((? 3 v) . 4)
                        ((? 2 y) ? 3 y)
                        ((? 2 x) ? 3 x)
                        ((? 2 z) 4)
                        ((? 2 v) 2 3)
                        ((? 1 y) ? 2 y)
                        ((? 1 x) ? 2 x)
                        ((? 1 z) (2 3) 4)
                        ((? 1 v) . 1)
                        ((? y) ? 1 y)
                        ((? x) ? 1 x))

debug:simple-query
apply-a-rule
rule=(rule ((? x) next-to (? y) in ((? v) ? z))
           ((? x) next-to (? y) in (? z)))
pattern=((? 3 x) next-to (? 3 y) in (? 3 z))
frame=(((? 3 z)) ((? 3 v) . 4)
                 ((? 2 y) ? 3 y)
                 ((? 2 x) ? 3 x)
                 ((? 2 z) 4)
                 ((? 2 v) 2 3)
                 ((? 1 y) ? 2 y)
                 ((? 1 x) ? 2 x)
                 ((? 1 z) (2 3) 4)
                 ((? 1 v) . 1)
                 ((? y) ? 1 y)
                 ((? x) ? 1 x))

unify-result=failed
apply-a-rule
rule=(rule ((? x) next-to (? y) in ((? x) (? y) ? u)))
pattern=((? 3 x) next-to (? 3 y) in (? 3 z))
frame=(((? 3 z)) ((? 3 v) . 4)
                 ((? 2 y) ? 3 y)
                 ((? 2 x) ? 3 x)
                 ((? 2 z) 4)
                 ((? 2 v) 2 3)
                 ((? 1 y) ? 2 y)
                 ((? 1 x) ? 2 x)
                 ((? 1 z) (2 3) 4)
                 ((? 1 v) . 1)
                 ((? y) ? 1 y)
                 ((? x) ? 1 x))

unify-result=failed
apply-a-rule
rule=(rule ((? x) next-to (? y) in ((? x) (? y) ? u)))
pattern=((? 2 x) next-to (? 2 y) in (? 2 z))
frame=(((? 2 z) 4) ((? 2 v) 2 3)
                   ((? 1 y) ? 2 y)
                   ((? 1 x) ? 2 x)
                   ((? 1 z) (2 3) 4)
                   ((? 1 v) . 1)
                   ((? y) ? 1 y)
                   ((? x) ? 1 x))

unify-result=failed
apply-a-rule
rule=(rule ((? x) next-to (? y) in ((? x) (? y) ? u)))
pattern=((? 1 x) next-to (? 1 y) in (? 1 z))
frame=(((? 1 z) (2 3) 4) ((? 1 v) . 1) ((? y) ? 1 y) ((? x) ? 1 x))

unify-result=(((? 7 u)) ((? 7 y) . 4)
                        ((? 7 x) 2 3)
                        ((? 1 y) ? 7 y)
                        ((? 1 x) ? 7 x)
                        ((? 1 z) (2 3) 4)
                        ((? 1 v) . 1)
                        ((? y) ? 1 y)
                        ((? x) ? 1 x))
((2 3) next-to 4 in (1 (2 3) 4))
apply-a-rule
rule=(rule ((? x) next-to (? y) in ((? x) (? y) ? u)))
pattern=((? x) next-to (? y) in (1 (2 3) 4))
frame=()

unify-result=(((? 8 u) 4) ((? 8 y) 2 3)
                          ((? 8 x) . 1)
                          ((? y) ? 8 y)
                          ((? x) ? 8 x))
(1 next-to (2 3) in (1 (2 3) 4))

;;; Query input:
((? x) next-to 1 in (2 1 3 1))
;;; Query results:

debug:simple-query
apply-a-rule
rule=(rule ((? x) next-to (? y) in ((? v) ? z))
           ((? x) next-to (? y) in (? z)))
pattern=((? x) next-to 1 in (2 1 3 1))
frame=()

unify-result=(((? 9 z) 1 3 1) ((? 9 v) . 2) ((? 9 y) . 1) ((? x) ? 9 x))

debug:simple-query
apply-a-rule
rule=(rule ((? x) next-to (? y) in ((? v) ? z))
           ((? x) next-to (? y) in (? z)))
pattern=((? 9 x) next-to (? 9 y) in (? 9 z))
frame=(((? 9 z) 1 3 1) ((? 9 v) . 2) ((? 9 y) . 1) ((? x) ? 9 x))

unify-result=(((? 10 z) 3 1) ((? 10 v) . 1)
                             ((? 10 y) . 1)
                             ((? 9 x) ? 10 x)
                             ((? 9 z) 1 3 1)
                             ((? 9 v) . 2)
                             ((? 9 y) . 1)
                             ((? x) ? 9 x))

debug:simple-query
apply-a-rule
rule=(rule ((? x) next-to (? y) in ((? v) ? z))
           ((? x) next-to (? y) in (? z)))
pattern=((? 10 x) next-to (? 10 y) in (? 10 z))
frame=(((? 10 z) 3 1) ((? 10 v) . 1)
                      ((? 10 y) . 1)
                      ((? 9 x) ? 10 x)
                      ((? 9 z) 1 3 1)
                      ((? 9 v) . 2)
                      ((? 9 y) . 1)
                      ((? x) ? 9 x))

unify-result=(((? 11 z) 1) ((? 11 v) . 3)
                           ((? 11 y) . 1)
                           ((? 10 x) ? 11 x)
                           ((? 10 z) 3 1)
                           ((? 10 v) . 1)
                           ((? 10 y) . 1)
                           ((? 9 x) ? 10 x)
                           ((? 9 z) 1 3 1)
                           ((? 9 v) . 2)
                           ((? 9 y) . 1)
                           ((? x) ? 9 x))

debug:simple-query
apply-a-rule
rule=(rule ((? x) next-to (? y) in ((? v) ? z))
           ((? x) next-to (? y) in (? z)))
pattern=((? 11 x) next-to (? 11 y) in (? 11 z))
frame=(((? 11 z) 1) ((? 11 v) . 3)
                    ((? 11 y) . 1)
                    ((? 10 x) ? 11 x)
                    ((? 10 z) 3 1)
                    ((? 10 v) . 1)
                    ((? 10 y) . 1)
                    ((? 9 x) ? 10 x)
                    ((? 9 z) 1 3 1)
                    ((? 9 v) . 2)
                    ((? 9 y) . 1)
                    ((? x) ? 9 x))

unify-result=(((? 12 z)) ((? 12 v) . 1)
                         ((? 12 y) . 1)
                         ((? 11 x) ? 12 x)
                         ((? 11 z) 1)
                         ((? 11 v) . 3)
                         ((? 11 y) . 1)
                         ((? 10 x) ? 11 x)
                         ((? 10 z) 3 1)
                         ((? 10 v) . 1)
                         ((? 10 y) . 1)
                         ((? 9 x) ? 10 x)
                         ((? 9 z) 1 3 1)
                         ((? 9 v) . 2)
                         ((? 9 y) . 1)
                         ((? x) ? 9 x))

debug:simple-query
apply-a-rule
rule=(rule ((? x) next-to (? y) in ((? v) ? z))
           ((? x) next-to (? y) in (? z)))
pattern=((? 12 x) next-to (? 12 y) in (? 12 z))
frame=(((? 12 z)) ((? 12 v) . 1)
                  ((? 12 y) . 1)
                  ((? 11 x) ? 12 x)
                  ((? 11 z) 1)
                  ((? 11 v) . 3)
                  ((? 11 y) . 1)
                  ((? 10 x) ? 11 x)
                  ((? 10 z) 3 1)
                  ((? 10 v) . 1)
                  ((? 10 y) . 1)
                  ((? 9 x) ? 10 x)
                  ((? 9 z) 1 3 1)
                  ((? 9 v) . 2)
                  ((? 9 y) . 1)
                  ((? x) ? 9 x))

unify-result=failed
apply-a-rule
rule=(rule ((? x) next-to (? y) in ((? x) (? y) ? u)))
pattern=((? 12 x) next-to (? 12 y) in (? 12 z))
frame=(((? 12 z)) ((? 12 v) . 1)
                  ((? 12 y) . 1)
                  ((? 11 x) ? 12 x)
                  ((? 11 z) 1)
                  ((? 11 v) . 3)
                  ((? 11 y) . 1)
                  ((? 10 x) ? 11 x)
                  ((? 10 z) 3 1)
                  ((? 10 v) . 1)
                  ((? 10 y) . 1)
                  ((? 9 x) ? 10 x)
                  ((? 9 z) 1 3 1)
                  ((? 9 v) . 2)
                  ((? 9 y) . 1)
                  ((? x) ? 9 x))

unify-result=failed
apply-a-rule
rule=(rule ((? x) next-to (? y) in ((? x) (? y) ? u)))
pattern=((? 11 x) next-to (? 11 y) in (? 11 z))
frame=(((? 11 z) 1) ((? 11 v) . 3)
                    ((? 11 y) . 1)
                    ((? 10 x) ? 11 x)
                    ((? 10 z) 3 1)
                    ((? 10 v) . 1)
                    ((? 10 y) . 1)
                    ((? 9 x) ? 10 x)
                    ((? 9 z) 1 3 1)
                    ((? 9 v) . 2)
                    ((? 9 y) . 1)
                    ((? x) ? 9 x))

unify-result=failed
apply-a-rule
rule=(rule ((? x) next-to (? y) in ((? x) (? y) ? u)))
pattern=((? 10 x) next-to (? 10 y) in (? 10 z))
frame=(((? 10 z) 3 1) ((? 10 v) . 1)
                      ((? 10 y) . 1)
                      ((? 9 x) ? 10 x)
                      ((? 9 z) 1 3 1)
                      ((? 9 v) . 2)
                      ((? 9 y) . 1)
                      ((? x) ? 9 x))

unify-result=(((? 16 u)) ((? 16 x) . 3)
                         ((? 16 y) . 1)
                         ((? 10 x) ? 16 x)
                         ((? 10 z) 3 1)
                         ((? 10 v) . 1)
                         ((? 10 y) . 1)
                         ((? 9 x) ? 10 x)
                         ((? 9 z) 1 3 1)
                         ((? 9 v) . 2)
                         ((? 9 y) . 1)
                         ((? x) ? 9 x))
(3 next-to 1 in (2 1 3 1))
apply-a-rule
rule=(rule ((? x) next-to (? y) in ((? x) (? y) ? u)))
pattern=((? x) next-to 1 in (2 1 3 1))
frame=()

unify-result=(((? 17 u) 3 1) ((? 17 x) . 2) ((? 17 y) . 1) ((? x) ? 17 x))
(2 next-to 1 in (2 1 3 1))
apply-a-rule
rule=(rule ((? x) next-to (? y) in ((? x) (? y) ? u)))
pattern=((? 9 x) next-to (? 9 y) in (? 9 z))
frame=(((? 9 z) 1 3 1) ((? 9 v) . 2) ((? 9 y) . 1) ((? x) ? 9 x))

unify-result=failed

;;; Query input:
exit
#+end_src

Seems to find neighbours well.

***** DONE Exercise 4.62 last-pair
      CLOSED: [2020-02-20 Thu 00:19]

#+name: prolog-input-last-pair
#+begin_src shell :exports code :results verbatim output scalar code
  printf "%s" '

  (assert! (rule (last-pair (?y . ?z) ?x)
                 (last-pair ?z ?x)))
  (assert! (rule (last-pair (?x) (?x))))

  (last-pair (3) ?x)
  (last-pair (1 2 3) ?x)
  (last-pair (2 ?x) (3))
;  (last-pair ?x (3))
  exit'
#+end_src

#+header: :stdin prolog-input-last-pair
#+begin_src shell :shebang "#! /usr/bin/chibi-scheme" :exports both :results output scalar code :exports both
  <<prolog-glue>>
  <<put-and-get>>
  <<streams-common>>
  <<streams-2>>
  <<stream-append>>
  <<prolog-driver-loop>>
  <<prolog-instantiate>>
  <<prolog-qeval>>
  <<prolog-simple-queries>>
  <<prolog-conjoin>>
  <<prolog-conjoin-installation>>
  <<prolog-disjoin>>
  <<prolog-disjoin-installation>>
  <<prolog-negate>>
  <<prolog-negate-installation>>
  <<prolog-lisp-filter>>
  <<prolog-lisp-filter-installation>>
  <<prolog-always-true>>
  <<prolog-pattern-matching>>
  <<prolog-rules-and-unification>>
  <<prolog-database>>
  <<prolog-database-add-assertion-original>>
  <<prolog-database-store-assertion-in-index>>
  <<prolog-stream-operations>>
  <<prolog-stream-flatmap>>
  <<prolog-flatten-stream>>
  <<streams-singleton>>
  <<prolog-query>>
  <<prolog-frames-and-bindings>>
  (query-driver-loop)
#+end_src

#+RESULTS[eb596501d96e480f9deac0d5af4080203a1f924c]:
#+begin_src shell

;;; Query input:
(assert! (rule (last-pair ((? y) ? z) (? x)) (last-pair (? z) (? x))))
Assertion added to data base.
;;; Query input:
(assert! (rule (last-pair ((? x)) ((? x)))))
Assertion added to data base.
;;; Query input:
(last-pair (3) (? x))
;;; Query results:

debug:simple-query
apply-a-rule
rule=(rule (last-pair ((? x)) ((? x))))
pattern=(last-pair (3) (? x))
frame=()

unify-result=(((? x) (? 1 x)) ((? 1 x) . 3))
(last-pair (3) (3))
apply-a-rule
rule=(rule (last-pair ((? y) ? z) (? x)) (last-pair (? z) (? x)))
pattern=(last-pair (3) (? x))
frame=()

unify-result=(((? x) ? 2 x) ((? 2 z)) ((? 2 y) . 3))

debug:simple-query
apply-a-rule
rule=(rule (last-pair ((? x)) ((? x))))
pattern=(last-pair (? 2 z) (? 2 x))
frame=(((? x) ? 2 x) ((? 2 z)) ((? 2 y) . 3))

unify-result=failed
apply-a-rule
rule=(rule (last-pair ((? y) ? z) (? x)) (last-pair (? z) (? x)))
pattern=(last-pair (? 2 z) (? 2 x))
frame=(((? x) ? 2 x) ((? 2 z)) ((? 2 y) . 3))

unify-result=failed

;;; Query input:
(last-pair (1 2 3) (? x))
;;; Query results:

debug:simple-query
apply-a-rule
rule=(rule (last-pair ((? x)) ((? x))))
pattern=(last-pair (1 2 3) (? x))
frame=()

unify-result=failed
apply-a-rule
rule=(rule (last-pair ((? y) ? z) (? x)) (last-pair (? z) (? x)))
pattern=(last-pair (1 2 3) (? x))
frame=()

unify-result=(((? x) ? 6 x) ((? 6 z) 2 3) ((? 6 y) . 1))

debug:simple-query
apply-a-rule
rule=(rule (last-pair ((? x)) ((? x))))
pattern=(last-pair (? 6 z) (? 6 x))
frame=(((? x) ? 6 x) ((? 6 z) 2 3) ((? 6 y) . 1))

unify-result=failed
apply-a-rule
rule=(rule (last-pair ((? y) ? z) (? x)) (last-pair (? z) (? x)))
pattern=(last-pair (? 6 z) (? 6 x))
frame=(((? x) ? 6 x) ((? 6 z) 2 3) ((? 6 y) . 1))

unify-result=(((? 6 x) ? 8 x) ((? 8 z) 3)
                              ((? 8 y) . 2)
                              ((? x) ? 6 x)
                              ((? 6 z) 2 3)
                              ((? 6 y) . 1))

debug:simple-query
apply-a-rule
rule=(rule (last-pair ((? x)) ((? x))))
pattern=(last-pair (? 8 z) (? 8 x))
frame=(((? 6 x) ? 8 x) ((? 8 z) 3)
                       ((? 8 y) . 2)
                       ((? x) ? 6 x)
                       ((? 6 z) 2 3)
                       ((? 6 y) . 1))

unify-result=(((? 8 x) (? 9 x)) ((? 9 x) . 3)
                                ((? 6 x) ? 8 x)
                                ((? 8 z) 3)
                                ((? 8 y) . 2)
                                ((? x) ? 6 x)
                                ((? 6 z) 2 3)
                                ((? 6 y) . 1))
(last-pair (1 2 3) (3))
apply-a-rule
rule=(rule (last-pair ((? y) ? z) (? x)) (last-pair (? z) (? x)))
pattern=(last-pair (? 8 z) (? 8 x))
frame=(((? 6 x) ? 8 x) ((? 8 z) 3)
                       ((? 8 y) . 2)
                       ((? x) ? 6 x)
                       ((? 6 z) 2 3)
                       ((? 6 y) . 1))

unify-result=(((? 8 x) ? 10 x) ((? 10 z))
                               ((? 10 y) . 3)
                               ((? 6 x) ? 8 x)
                               ((? 8 z) 3)
                               ((? 8 y) . 2)
                               ((? x) ? 6 x)
                               ((? 6 z) 2 3)
                               ((? 6 y) . 1))

debug:simple-query
apply-a-rule
rule=(rule (last-pair ((? x)) ((? x))))
pattern=(last-pair (? 10 z) (? 10 x))
frame=(((? 8 x) ? 10 x) ((? 10 z))
                        ((? 10 y) . 3)
                        ((? 6 x) ? 8 x)
                        ((? 8 z) 3)
                        ((? 8 y) . 2)
                        ((? x) ? 6 x)
                        ((? 6 z) 2 3)
                        ((? 6 y) . 1))

unify-result=failed
apply-a-rule
rule=(rule (last-pair ((? y) ? z) (? x)) (last-pair (? z) (? x)))
pattern=(last-pair (? 10 z) (? 10 x))
frame=(((? 8 x) ? 10 x) ((? 10 z))
                        ((? 10 y) . 3)
                        ((? 6 x) ? 8 x)
                        ((? 8 z) 3)
                        ((? 8 y) . 2)
                        ((? x) ? 6 x)
                        ((? 6 z) 2 3)
                        ((? 6 y) . 1))

unify-result=failed

;;; Query input:
(last-pair (2 (? x)) (3))
;;; Query results:

debug:simple-query
apply-a-rule
rule=(rule (last-pair ((? x)) ((? x))))
pattern=(last-pair (2 (? x)) (3))
frame=()

unify-result=failed
apply-a-rule
rule=(rule (last-pair ((? y) ? z) (? x)) (last-pair (? z) (? x)))
pattern=(last-pair (2 (? x)) (3))
frame=()

unify-result=(((? 14 x) 3) ((? 14 z) (? x)) ((? 14 y) . 2))

debug:simple-query
apply-a-rule
rule=(rule (last-pair ((? x)) ((? x))))
pattern=(last-pair (? 14 z) (? 14 x))
frame=(((? 14 x) 3) ((? 14 z) (? x)) ((? 14 y) . 2))

unify-result=(((? 15 x) . 3)   ((? x) ? 15 x)   ((? 14 x) 3)     ((? 14 z) (? x))
              ((? 14 y) . 2))
(last-pair (2 3) (3))
apply-a-rule
rule=(rule (last-pair ((? y) ? z) (? x)) (last-pair (? z) (? x)))
pattern=(last-pair (? 14 z) (? 14 x))
frame=(((? 14 x) 3) ((? 14 z) (? x)) ((? 14 y) . 2))

unify-result=(((? 16 x) 3) ((? 16 z))
                           ((? x) ? 16 y)
                           ((? 14 x) 3)
                           ((? 14 z) (? x))
                           ((? 14 y) . 2))

debug:simple-query
apply-a-rule
rule=(rule (last-pair ((? x)) ((? x))))
pattern=(last-pair (? 16 z) (? 16 x))
frame=(((? 16 x) 3) ((? 16 z))
                    ((? x) ? 16 y)
                    ((? 14 x) 3)
                    ((? 14 z) (? x))
                    ((? 14 y) . 2))

unify-result=failed
apply-a-rule
rule=(rule (last-pair ((? y) ? z) (? x)) (last-pair (? z) (? x)))
pattern=(last-pair (? 16 z) (? 16 x))
frame=(((? 16 x) 3) ((? 16 z))
                    ((? x) ? 16 y)
                    ((? 14 x) 3)
                    ((? 14 z) (? x))
                    ((? 14 y) . 2))

unify-result=failed

;;; Query input:
exit
#+end_src

I didn't manage to get the last query working. Indeed, there are
infinitely many solutions, but there should be a way to make the
matcher less greedy...

***** DONE Exercise 4.63 Genesis
      CLOSED: [2020-02-20 Thu 10:28]
#+name: prolog-input-genesis
#+begin_src shell :exports code :results verbatim output scalar code
  printf "%s" '

  (assert! (rule (last-pair (?y . ?z) ?x)
                 (last-pair ?z ?x)))
  (assert! (rule (last-pair (?x) (?x))))

  (assert! (son Adam Cain))
  (assert! (son Cain Enoch))
  (assert! (son Enoch Irad))
  (assert! (son Irad Mehujael))
  (assert! (son Mehujael Methushael))
  (assert! (son Methushael Lamech))
  (assert! (wife Lamech Ada))
  (assert! (son Ada Jabal))
  (assert! (son Ada Jubal))
  (assert! (rule (grandson ?grandpa ?grandson)
              (and (son ?grandpa ?dad)
                   (son ?dad ?grandson))))

  (assert! (rule (son ?man ?boy)
               (and (wife ?man ?woman)
                    (son  ?woman ?boy))))
  (grandson Cain ?who)
  (son Lamech ?who)
  (grandson Methushael ?who)
  exit'
#+end_src

#+header: :stdin prolog-input-genesis
#+begin_src shell :shebang "#! /usr/bin/chibi-scheme" :exports both :results output scalar code :exports both
  <<prolog-glue>>
  <<put-and-get>>
  <<streams-common>>
  <<streams-2>>
  <<stream-append>>
  <<prolog-driver-loop>>
  <<prolog-instantiate>>
  <<prolog-qeval>>
  <<prolog-simple-queries>>
  <<prolog-conjoin>>
  <<prolog-conjoin-installation>>
  <<prolog-disjoin>>
  <<prolog-disjoin-installation>>
  <<prolog-negate>>
  <<prolog-negate-installation>>
  <<prolog-lisp-filter>>
  <<prolog-lisp-filter-installation>>
  <<prolog-always-true>>
  <<prolog-pattern-matching>>
  <<prolog-rules-and-unification>>
  <<prolog-database>>
  <<prolog-database-add-assertion-original>>
  <<prolog-database-store-assertion-in-index>>
  <<prolog-stream-operations>>
  <<prolog-stream-flatmap>>
  <<prolog-flatten-stream>>
  <<streams-singleton>>
  <<prolog-query>>
  <<prolog-frames-and-bindings>>
  (query-driver-loop)
#+end_src

#+RESULTS[7dd2ff1da25b9ff4392e81dcebbe0aecea77d7c7]:
#+begin_src shell

;;; Query input:
(assert! (rule (last-pair ((? y) ? z) (? x)) (last-pair (? z) (? x))))
Assertion added to data base.
;;; Query input:
(assert! (rule (last-pair ((? x)) ((? x)))))
Assertion added to data base.
;;; Query input:
(assert! (son Adam Cain))
Assertion added to data base.
;;; Query input:
(assert! (son Cain Enoch))
Assertion added to data base.
;;; Query input:
(assert! (son Enoch Irad))
Assertion added to data base.
;;; Query input:
(assert! (son Irad Mehujael))
Assertion added to data base.
;;; Query input:
(assert! (son Mehujael Methushael))
Assertion added to data base.
;;; Query input:
(assert! (son Methushael Lamech))
Assertion added to data base.
;;; Query input:
(assert! (wife Lamech Ada))
Assertion added to data base.
;;; Query input:
(assert! (son Ada Jabal))
Assertion added to data base.
;;; Query input:
(assert! (son Ada Jubal))
Assertion added to data base.
;;; Query input:
(assert!
 (rule (grandson (? grandpa) (? grandson))
       (and (son (? grandpa) (? dad)) (son (? dad) (? grandson)))))
Assertion added to data base.
;;; Query input:
(assert!
 (rule (son (? man) (? boy))
       (and (wife (? man) (? woman)) (son (? woman) (? boy)))))
Assertion added to data base.
;;; Query input:
(grandson Cain (? who))
;;; Query results:

debug:simple-query
apply-a-rule
rule=(rule (grandson (? grandpa) (? grandson))
           (and (son (? grandpa) (? dad)) (son (? dad) (? grandson))))
pattern=(grandson Cain (? who))
frame=()

unify-result=(((? who) ? 1 grandson) ((? 1 grandpa) . Cain))

debug:simple-query

debug:simple-query
(grandson Cain Irad)
apply-a-rule
rule=(rule (son (? man) (? boy))
           (and (wife (? man) (? woman)) (son (? woman) (? boy))))
pattern=(son (? 1 grandpa) (? 1 dad))
frame=(((? who) ? 1 grandson) ((? 1 grandpa) . Cain))

unify-result=(((? 1 dad) ? 2 boy) ((? 2 man) . Cain)
                                  ((? who) ? 1 grandson)
                                  ((? 1 grandpa) . Cain))

debug:simple-query

debug:simple-query
apply-a-rule
rule=(rule (son (? man) (? boy))
           (and (wife (? man) (? woman)) (son (? woman) (? boy))))
pattern=(son (? 1 dad) (? 1 grandson))
frame=(((? 1 dad) . Enoch) ((? who) ? 1 grandson) ((? 1 grandpa) . Cain))

unify-result=(((? 1 grandson) ? 3 boy) ((? 3 man) . Enoch)
                                       ((? 1 dad) . Enoch)
                                       ((? who) ? 1 grandson)
                                       ((? 1 grandpa) . Cain))

debug:simple-query

debug:simple-query

;;; Query input:
(son Lamech (? who))
;;; Query results:

debug:simple-query
apply-a-rule
rule=(rule (son (? man) (? boy))
           (and (wife (? man) (? woman)) (son (? woman) (? boy))))
pattern=(son Lamech (? who))
frame=()

unify-result=(((? who) ? 4 boy) ((? 4 man) . Lamech))

debug:simple-query

debug:simple-query
(son Lamech Jubal)
(son Lamech Jabal)
apply-a-rule
rule=(rule (son (? man) (? boy))
           (and (wife (? man) (? woman)) (son (? woman) (? boy))))
pattern=(son (? 4 woman) (? 4 boy))
frame=(((? 4 woman) . Ada) ((? who) ? 4 boy) ((? 4 man) . Lamech))

unify-result=(((? 4 boy) ? 5 boy) ((? 5 man) . Ada)
                                  ((? 4 woman) . Ada)
                                  ((? who) ? 4 boy)
                                  ((? 4 man) . Lamech))

debug:simple-query

debug:simple-query

;;; Query input:
(grandson Methushael (? who))
;;; Query results:

debug:simple-query
apply-a-rule
rule=(rule (grandson (? grandpa) (? grandson))
           (and (son (? grandpa) (? dad)) (son (? dad) (? grandson))))
pattern=(grandson Methushael (? who))
frame=()

unify-result=(((? who) ? 6 grandson) ((? 6 grandpa) . Methushael))

debug:simple-query

debug:simple-query
apply-a-rule
rule=(rule (son (? man) (? boy))
           (and (wife (? man) (? woman)) (son (? woman) (? boy))))
pattern=(son (? 6 dad) (? 6 grandson))
frame=(((? 6 dad) . Lamech)
       ((? who) ? 6 grandson)
       ((? 6 grandpa) . Methushael))

unify-result=(((? 6 grandson) ? 7 boy) ((? 7 man) . Lamech)
                                       ((? 6 dad) . Lamech)
                                       ((? who) ? 6 grandson)
                                       ((? 6 grandpa) . Methushael))

debug:simple-query

debug:simple-query
(grandson Methushael Jubal)
apply-a-rule
rule=(rule (son (? man) (? boy))
           (and (wife (? man) (? woman)) (son (? woman) (? boy))))
pattern=(son (? 6 grandpa) (? 6 dad))
frame=(((? who) ? 6 grandson) ((? 6 grandpa) . Methushael))

unify-result=(((? 6 dad) ? 8 boy) ((? 8 man) . Methushael)
                                  ((? who) ? 6 grandson)
                                  ((? 6 grandpa) . Methushael))

debug:simple-query

debug:simple-query
(grandson Methushael Jabal)
apply-a-rule
rule=(rule (son (? man) (? boy))
           (and (wife (? man) (? woman)) (son (? woman) (? boy))))
pattern=(son (? 7 woman) (? 7 boy))
frame=(((? 7 woman) . Ada)          ((? 6 grandson) ? 7 boy)
       ((? 7 man) . Lamech)         ((? 6 dad) . Lamech)
       ((? who) ? 6 grandson)       ((? 6 grandpa) . Methushael))

unify-result=(((? 7 boy) ? 9 boy) ((? 9 man) . Ada)
                                  ((? 7 woman) . Ada)
                                  ((? 6 grandson) ? 7 boy)
                                  ((? 7 man) . Lamech)
                                  ((? 6 dad) . Lamech)
                                  ((? who) ? 6 grandson)
                                  ((? 6 grandpa) . Methushael))

debug:simple-query

debug:simple-query

;;; Query input:
exit
#+end_src

Seems right.

**** 4.4.2 How the Query System Works [1/1]
***** DONE Figure 4.6 The ~or~ combination of two queries
      CLOSED: [2020-02-20 Thu 10:59]
#+name: figure-4-6.png
#+begin_src plantuml :exports both :file figure-4-6.png
@startuml
skinparam monochrome true
skinparam componentStyle uml2

interface "input stream\n of frames" as input
package "(or A B)" {
  top to bottom direction
  component A as A
  component merge as merge
  component B as B
  interface " " as fake1
  interface " " as fake2
}
interface "output stream\n of frames" as output
interface "data base" as db

input -right-> fake1

merge -right-> output
db -up-> fake2
fake1 -right-> A
fake1 -right-> B
fake2 -up-> A
fake2 -up-> B
A -right-> merge
B -right-> merge
B -[hidden]up-> A

@enduml
#+end_src

#+RESULTS[a9b23c71c4b0d8ad23d7e493c9e334f3f7fd409a]: figure-4-6.png
[[file:figure-4-6.png]]

[[file:figure-4-6.png]]

A bit ugly, as most of UML, but simplicity matters.

**** 4.4.3 Is Logic Programming Mathematical Logic [6/6]
***** DONE Exercise 4.64 broken outranked-by
      CLOSED: [2020-02-20 Thu 12:33]

#+name: prolog-input-broken-outranked-by
#+begin_src shell :exports code :results verbatim output scalar code
  printf "%s" '
  <<prolog-input-sample-database>>
  (assert! (rule (outranked-by ?staff-person ?boss)
                 (or (supervisor ?staff-person ?boss)
                     (and (outranked-by ?middle-manager ?boss)
                          (supervisor ?staff-person ?middle-manager)))))
  (outranked-by (Bitdiddle Ben) ?who)

  exit'
#+end_src


#+header: :stdin prolog-input-broken-outranked-by
#+begin_src shell :shebang "#! /usr/bin/chibi-scheme" :exports code :results none
  <<prolog-glue>>
  <<put-and-get>>
  <<streams-common>>
  <<streams-2>>
  <<stream-append>>
  <<prolog-driver-loop>>
  <<prolog-instantiate>>
  <<prolog-qeval>>
  <<prolog-simple-queries>>
  <<prolog-conjoin>>
  <<prolog-conjoin-installation>>
  <<prolog-disjoin>>
  <<prolog-disjoin-installation>>
  <<prolog-negate>>
  <<prolog-negate-installation>>
  <<prolog-lisp-filter>>
  <<prolog-lisp-filter-installation>>
  <<prolog-always-true>>
  <<prolog-pattern-matching>>
  <<prolog-rules-and-unification>>
  <<prolog-database>>
  <<prolog-database-add-assertion-original>>
  <<prolog-database-store-assertion-in-index>>
  <<prolog-stream-operations>>
  <<prolog-stream-flatmap>>
  <<prolog-flatten-stream>>
  <<streams-singleton>>
  <<prolog-query>>
  <<prolog-frames-and-bindings>>

  (query-driver-loop)
#+end_src

The loop indeed occurs. The problem is that we have an ~or~ clause,
which doesn't filter the results, but rather expands them. It So the
first clause in the ~or~ selects all supervisor-supervisée pairs, and
the second loops into the same ~outranked-by~ clause, which results in
a loop, since ?middle-manager is unbound.

***** DONE Exercise 4.65 second-degree subordinates
      CLOSED: [2020-02-20 Thu 12:50]

#+name: prolog-wheel
#+begin_src shell :exports code :results verbatim output scalar code
  printf "%s" '
  <<prolog-input-sample-database>>
  <<prolog-input-canned-rules>>
  (wheel ?who)
  exit'
#+end_src


#+header: :stdin prolog-wheel
#+begin_src shell :shebang "#! /usr/bin/chibi-scheme" :exports code :results output scalar code :exports both
  <<prolog-glue>>
  <<put-and-get>>
  <<streams-common>>
  <<streams-2>>
  <<stream-append>>
  <<prolog-driver-loop>>
  <<prolog-instantiate>>
  <<prolog-qeval>>
  <<prolog-simple-queries>>
  <<prolog-conjoin>>
  <<prolog-conjoin-installation>>
  <<prolog-disjoin>>
  <<prolog-disjoin-installation>>
  <<prolog-negate>>
  <<prolog-negate-installation>>
  <<prolog-lisp-filter>>
  <<prolog-lisp-filter-installation>>
  <<prolog-always-true>>
  <<prolog-pattern-matching>>
  <<prolog-rules-and-unification>>
  <<prolog-database>>
  <<prolog-database-add-assertion-original>>
  <<prolog-database-store-assertion-in-index>>
  <<prolog-stream-operations>>
  <<prolog-stream-flatmap>>
  <<prolog-flatten-stream>>
  <<streams-singleton>>
  <<prolog-query>>
  <<prolog-frames-and-bindings>>

  (query-driver-loop)
#+end_src

#+RESULTS[9b28b8d82783f471b95deae3f3fd342a743b3a15]:
#+begin_src shell

;;; Query input:
(assert! (address (Bitdiddle Ben) (Slumerville (Ridge Road) 10)))
Assertion added to data base.
;;; Query input:
(assert! (job (Bitdiddle Ben) (computer wizard)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Bitdiddle Ben) 60000))
Assertion added to data base.
;;; Query input:
(assert! (address (Hacker Alyssa P) (Cambridge (Mass Ave) 78)))
Assertion added to data base.
;;; Query input:
(assert! (job (Hacker Alyssa P) (computer programmer)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Hacker Alyssa P) 40000))
Assertion added to data base.
;;; Query input:
(assert! (supervisor (Hacker Alyssa P) (Bitdiddle Ben)))
Assertion added to data base.
;;; Query input:
(assert! (address (Fect Cy D) (Cambridge (Ames Street) 3)))
Assertion added to data base.
;;; Query input:
(assert! (job (Fect Cy D) (computer programmer)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Fect Cy D) 35000))
Assertion added to data base.
;;; Query input:
(assert! (supervisor (Fect Cy D) (Bitdiddle Ben)))
Assertion added to data base.
;;; Query input:
(assert! (address (Tweakit Lem E) (Boston (Bay State Road) 22)))
Assertion added to data base.
;;; Query input:
(assert! (job (Tweakit Lem E) (computer technician)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Tweakit Lem E) 25000))
Assertion added to data base.
;;; Query input:
(assert! (supervisor (Tweakit Lem E) (Bitdiddle Ben)))
Assertion added to data base.
;;; Query input:
(assert! (address (Reasoner Louis) (Slumerville (Pine Tree Road) 80)))
Assertion added to data base.
;;; Query input:
(assert! (job (Reasoner Louis) (computer programmer trainee)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Reasoner Louis) 30000))
Assertion added to data base.
;;; Query input:
(assert! (supervisor (Reasoner Louis) (Hacker Alyssa P)))
Assertion added to data base.
;;; Query input:
(assert! (supervisor (Bitdiddle Ben) (Warbucks Oliver)))
Assertion added to data base.
;;; Query input:
(assert! (address (Warbucks Oliver) (Swellesley (Top Heap Road))))
Assertion added to data base.
;;; Query input:
(assert! (job (Warbucks Oliver) (administration big wheel)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Warbucks Oliver) 150000))
Assertion added to data base.
;;; Query input:
(assert! (address (Scrooge Eben) (Weston (Shady Lane) 10)))
Assertion added to data base.
;;; Query input:
(assert! (job (Scrooge Eben) (accounting chief accountant)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Scrooge Eben) 75000))
Assertion added to data base.
;;; Query input:
(assert! (supervisor (Scrooge Eben) (Warbucks Oliver)))
Assertion added to data base.
;;; Query input:
(assert! (address (Cratchet Robert) (Allston (N Harvard Street) 16)))
Assertion added to data base.
;;; Query input:
(assert! (job (Cratchet Robert) (accounting scrivener)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Cratchet Robert) 18000))
Assertion added to data base.
;;; Query input:
(assert! (supervisor (Cratchet Robert) (Scrooge Eben)))
Assertion added to data base.
;;; Query input:
(assert! (address (Aull DeWitt) (Slumerville (Onion Square) 5)))
Assertion added to data base.
;;; Query input:
(assert! (job (Aull DeWitt) (administration secretary)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Aull DeWitt) 25000))
Assertion added to data base.
;;; Query input:
(assert! (supervisor (Aull DeWitt) (Warbucks Oliver)))
Assertion added to data base.
;;; Query input:
(assert! (can-do-job (computer wizard) (computer programmer)))
Assertion added to data base.
;;; Query input:
(assert! (can-do-job (computer wizard) (computer technician)))
Assertion added to data base.
;;; Query input:
(assert! (can-do-job (computer programmer) (computer programmer trainee)))
Assertion added to data base.
;;; Query input:
(assert! (can-do-job (administration secretary) (administration big wheel)))
Assertion added to data base.
;;; Query input:
(assert!
 (rule (lives-near (? person-1) (? person-2))
       (and (address (? person-1) ((? town) ? rest-1))
            (address (? person-2) ((? town) ? rest-2))
            (not (same (? person-1) (? person-2))))))
Assertion added to data base.
;;; Query input:
(assert! (rule (same (? x) (? x))))
Assertion added to data base.
;;; Query input:
(assert!
 (rule (wheel (? person))
       (and (supervisor (? middle-manager) (? person))
            (supervisor (? x) (? middle-manager)))))
Assertion added to data base.
;;; Query input:
(assert!
 (rule (outranked-by (? staff-person) (? boss))
       (or (supervisor (? staff-person) (? boss))
           (and (supervisor (? staff-person) (? middle-manager))
                (outranked-by (? middle-manager) (? boss))))))
Assertion added to data base.
;;; Query input:
(assert! (rule (append-to-form () (? y) (? y))))
Assertion added to data base.
;;; Query input:
(assert!
 (rule (append-to-form ((? u) ? v) (? y) ((? u) ? z))
       (append-to-form (? v) (? y) (? z))))
Assertion added to data base.
;;; Query input:
(wheel (? who))
;;; Query results:

debug:simple-query
apply-a-rule
rule=(rule (wheel (? person))
           (and (supervisor (? middle-manager) (? person))
                (supervisor (? x) (? middle-manager))))
pattern=(wheel (? who))
frame=()

unify-result=(((? who) ? 1 person))

debug:simple-query

debug:simple-query
(wheel (Warbucks Oliver))
(wheel (Warbucks Oliver))
(wheel (Bitdiddle Ben))
(wheel (Warbucks Oliver))
(wheel (Warbucks Oliver))

;;; Query input:
exit
#+end_src

Indeed, four times!

This can be easily explained by making the system print one more
variable in the match.

#+name: prolog-wheel-explanation
#+begin_src shell :exports code :results verbatim output scalar code
  printf "%s" '
  <<prolog-input-sample-database>>
  (assert! (rule (wheel ?person ?x)
               (and (supervisor ?middle-manager ?person)
                    (supervisor ?x ?middle-manager))))
  (wheel ?who ?rulee)
  exit'
#+end_src


#+header: :stdin prolog-wheel-explanation
#+begin_src shell :shebang "#! /usr/bin/chibi-scheme" :exports code :results output scalar code :exports both
  <<prolog-glue>>
  <<put-and-get>>
  <<streams-common>>
  <<streams-2>>
  <<stream-append>>
  <<prolog-driver-loop>>
  <<prolog-instantiate>>
  <<prolog-qeval>>
  <<prolog-simple-queries>>
  <<prolog-conjoin>>
  <<prolog-conjoin-installation>>
  <<prolog-disjoin>>
  <<prolog-disjoin-installation>>
  <<prolog-negate>>
  <<prolog-negate-installation>>
  <<prolog-lisp-filter>>
  <<prolog-lisp-filter-installation>>
  <<prolog-always-true>>
  <<prolog-pattern-matching>>
  <<prolog-rules-and-unification>>
  <<prolog-database>>
  <<prolog-database-add-assertion-original>>
  <<prolog-database-store-assertion-in-index>>
  <<prolog-stream-operations>>
  <<prolog-stream-flatmap>>
  <<prolog-flatten-stream>>
  <<streams-singleton>>
  <<prolog-query>>
  <<prolog-frames-and-bindings>>

  (query-driver-loop)
#+end_src

#+RESULTS[4d0f9bbe84ab67f6ae2d4bdf849977179d167e37]:
#+begin_src shell

;;; Query input:
(assert! (address (Bitdiddle Ben) (Slumerville (Ridge Road) 10)))
Assertion added to data base.
;;; Query input:
(assert! (job (Bitdiddle Ben) (computer wizard)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Bitdiddle Ben) 60000))
Assertion added to data base.
;;; Query input:
(assert! (address (Hacker Alyssa P) (Cambridge (Mass Ave) 78)))
Assertion added to data base.
;;; Query input:
(assert! (job (Hacker Alyssa P) (computer programmer)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Hacker Alyssa P) 40000))
Assertion added to data base.
;;; Query input:
(assert! (supervisor (Hacker Alyssa P) (Bitdiddle Ben)))
Assertion added to data base.
;;; Query input:
(assert! (address (Fect Cy D) (Cambridge (Ames Street) 3)))
Assertion added to data base.
;;; Query input:
(assert! (job (Fect Cy D) (computer programmer)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Fect Cy D) 35000))
Assertion added to data base.
;;; Query input:
(assert! (supervisor (Fect Cy D) (Bitdiddle Ben)))
Assertion added to data base.
;;; Query input:
(assert! (address (Tweakit Lem E) (Boston (Bay State Road) 22)))
Assertion added to data base.
;;; Query input:
(assert! (job (Tweakit Lem E) (computer technician)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Tweakit Lem E) 25000))
Assertion added to data base.
;;; Query input:
(assert! (supervisor (Tweakit Lem E) (Bitdiddle Ben)))
Assertion added to data base.
;;; Query input:
(assert! (address (Reasoner Louis) (Slumerville (Pine Tree Road) 80)))
Assertion added to data base.
;;; Query input:
(assert! (job (Reasoner Louis) (computer programmer trainee)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Reasoner Louis) 30000))
Assertion added to data base.
;;; Query input:
(assert! (supervisor (Reasoner Louis) (Hacker Alyssa P)))
Assertion added to data base.
;;; Query input:
(assert! (supervisor (Bitdiddle Ben) (Warbucks Oliver)))
Assertion added to data base.
;;; Query input:
(assert! (address (Warbucks Oliver) (Swellesley (Top Heap Road))))
Assertion added to data base.
;;; Query input:
(assert! (job (Warbucks Oliver) (administration big wheel)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Warbucks Oliver) 150000))
Assertion added to data base.
;;; Query input:
(assert! (address (Scrooge Eben) (Weston (Shady Lane) 10)))
Assertion added to data base.
;;; Query input:
(assert! (job (Scrooge Eben) (accounting chief accountant)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Scrooge Eben) 75000))
Assertion added to data base.
;;; Query input:
(assert! (supervisor (Scrooge Eben) (Warbucks Oliver)))
Assertion added to data base.
;;; Query input:
(assert! (address (Cratchet Robert) (Allston (N Harvard Street) 16)))
Assertion added to data base.
;;; Query input:
(assert! (job (Cratchet Robert) (accounting scrivener)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Cratchet Robert) 18000))
Assertion added to data base.
;;; Query input:
(assert! (supervisor (Cratchet Robert) (Scrooge Eben)))
Assertion added to data base.
;;; Query input:
(assert! (address (Aull DeWitt) (Slumerville (Onion Square) 5)))
Assertion added to data base.
;;; Query input:
(assert! (job (Aull DeWitt) (administration secretary)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Aull DeWitt) 25000))
Assertion added to data base.
;;; Query input:
(assert! (supervisor (Aull DeWitt) (Warbucks Oliver)))
Assertion added to data base.
;;; Query input:
(assert! (can-do-job (computer wizard) (computer programmer)))
Assertion added to data base.
;;; Query input:
(assert! (can-do-job (computer wizard) (computer technician)))
Assertion added to data base.
;;; Query input:
(assert! (can-do-job (computer programmer) (computer programmer trainee)))
Assertion added to data base.
;;; Query input:
(assert! (can-do-job (administration secretary) (administration big wheel)))
Assertion added to data base.
;;; Query input:
(assert!
 (rule (wheel (? person) (? x))
       (and (supervisor (? middle-manager) (? person))
            (supervisor (? x) (? middle-manager)))))
Assertion added to data base.
;;; Query input:
(wheel (? who) (? rulee))
;;; Query results:

debug:simple-query
apply-a-rule
rule=(rule (wheel (? person) (? x))
           (and (supervisor (? middle-manager) (? person))
                (supervisor (? x) (? middle-manager))))
pattern=(wheel (? who) (? rulee))
frame=()

unify-result=(((? rulee) ? 1 x) ((? who) ? 1 person))

debug:simple-query

debug:simple-query
(wheel (Warbucks Oliver) (Cratchet Robert))
(wheel (Warbucks Oliver) (Tweakit Lem E))
(wheel (Bitdiddle Ben) (Reasoner Louis))
(wheel (Warbucks Oliver) (Fect Cy D))
(wheel (Warbucks Oliver) (Hacker Alyssa P))

;;; Query input:
exit
#+end_src

Indeed, Oliver has four second-degree subordinates.

***** DONE Exercise 4.66 Ben's accumulation
      CLOSED: [2020-02-20 Thu 13:08]
#+name: prolog-input-accumulation
#+begin_src shell :exports code :results verbatim output scalar code
  printf "%s" '
  <<prolog-input-sample-database>>
  <<prolog-input-canned-rules>>
  (assert! (rule (bens-query ?amount)
                 (and (job ?x (computer programmer))
                      (salary ?x ?amount))))
  (bens-query ?howmuch)
  exit'
#+end_src

#+header: :stdin prolog-input-accumulation
#+begin_src shell :shebang "#! /usr/bin/chibi-scheme" :exports code :results output scalar code :exports both

  <<prolog-glue>>
  <<put-and-get>>
  <<streams-common>>
  <<streams-2>>
  <<stream-append>>
  <<prolog-driver-loop>>
  <<prolog-instantiate>>
  <<prolog-qeval>>
  <<prolog-simple-queries>>
  <<prolog-conjoin>>
  <<prolog-conjoin-installation>>
  <<prolog-disjoin>>
  <<prolog-disjoin-installation>>
  <<prolog-negate>>
  <<prolog-negate-installation>>
  <<prolog-lisp-filter>>
  <<prolog-lisp-filter-installation>>
  <<prolog-always-true>>
  <<prolog-pattern-matching>>
  <<prolog-rules-and-unification>>
  <<prolog-database>>
  <<prolog-database-add-assertion-original>>
  <<prolog-database-store-assertion-in-index>>
  <<prolog-stream-operations>>
  <<prolog-stream-flatmap>>
  <<prolog-flatten-stream>>
  <<streams-singleton>>
  <<prolog-query>>
  <<prolog-frames-and-bindings>>

  (query-driver-loop)
#+end_src

#+RESULTS[962c27c37d3629eb647190bd51ad35fdf456883b]:
#+begin_src shell

;;; Query input:
(assert! (address (Bitdiddle Ben) (Slumerville (Ridge Road) 10)))
Assertion added to data base.
;;; Query input:
(assert! (job (Bitdiddle Ben) (computer wizard)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Bitdiddle Ben) 60000))
Assertion added to data base.
;;; Query input:
(assert! (address (Hacker Alyssa P) (Cambridge (Mass Ave) 78)))
Assertion added to data base.
;;; Query input:
(assert! (job (Hacker Alyssa P) (computer programmer)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Hacker Alyssa P) 40000))
Assertion added to data base.
;;; Query input:
(assert! (supervisor (Hacker Alyssa P) (Bitdiddle Ben)))
Assertion added to data base.
;;; Query input:
(assert! (address (Fect Cy D) (Cambridge (Ames Street) 3)))
Assertion added to data base.
;;; Query input:
(assert! (job (Fect Cy D) (computer programmer)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Fect Cy D) 35000))
Assertion added to data base.
;;; Query input:
(assert! (supervisor (Fect Cy D) (Bitdiddle Ben)))
Assertion added to data base.
;;; Query input:
(assert! (address (Tweakit Lem E) (Boston (Bay State Road) 22)))
Assertion added to data base.
;;; Query input:
(assert! (job (Tweakit Lem E) (computer technician)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Tweakit Lem E) 25000))
Assertion added to data base.
;;; Query input:
(assert! (supervisor (Tweakit Lem E) (Bitdiddle Ben)))
Assertion added to data base.
;;; Query input:
(assert! (address (Reasoner Louis) (Slumerville (Pine Tree Road) 80)))
Assertion added to data base.
;;; Query input:
(assert! (job (Reasoner Louis) (computer programmer trainee)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Reasoner Louis) 30000))
Assertion added to data base.
;;; Query input:
(assert! (supervisor (Reasoner Louis) (Hacker Alyssa P)))
Assertion added to data base.
;;; Query input:
(assert! (supervisor (Bitdiddle Ben) (Warbucks Oliver)))
Assertion added to data base.
;;; Query input:
(assert! (address (Warbucks Oliver) (Swellesley (Top Heap Road))))
Assertion added to data base.
;;; Query input:
(assert! (job (Warbucks Oliver) (administration big wheel)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Warbucks Oliver) 150000))
Assertion added to data base.
;;; Query input:
(assert! (address (Scrooge Eben) (Weston (Shady Lane) 10)))
Assertion added to data base.
;;; Query input:
(assert! (job (Scrooge Eben) (accounting chief accountant)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Scrooge Eben) 75000))
Assertion added to data base.
;;; Query input:
(assert! (supervisor (Scrooge Eben) (Warbucks Oliver)))
Assertion added to data base.
;;; Query input:
(assert! (address (Cratchet Robert) (Allston (N Harvard Street) 16)))
Assertion added to data base.
;;; Query input:
(assert! (job (Cratchet Robert) (accounting scrivener)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Cratchet Robert) 18000))
Assertion added to data base.
;;; Query input:
(assert! (supervisor (Cratchet Robert) (Scrooge Eben)))
Assertion added to data base.
;;; Query input:
(assert! (address (Aull DeWitt) (Slumerville (Onion Square) 5)))
Assertion added to data base.
;;; Query input:
(assert! (job (Aull DeWitt) (administration secretary)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Aull DeWitt) 25000))
Assertion added to data base.
;;; Query input:
(assert! (supervisor (Aull DeWitt) (Warbucks Oliver)))
Assertion added to data base.
;;; Query input:
(assert! (can-do-job (computer wizard) (computer programmer)))
Assertion added to data base.
;;; Query input:
(assert! (can-do-job (computer wizard) (computer technician)))
Assertion added to data base.
;;; Query input:
(assert! (can-do-job (computer programmer) (computer programmer trainee)))
Assertion added to data base.
;;; Query input:
(assert! (can-do-job (administration secretary) (administration big wheel)))
Assertion added to data base.
;;; Query input:
(assert!
 (rule (lives-near (? person-1) (? person-2))
       (and (address (? person-1) ((? town) ? rest-1))
            (address (? person-2) ((? town) ? rest-2))
            (not (same (? person-1) (? person-2))))))
Assertion added to data base.
;;; Query input:
(assert! (rule (same (? x) (? x))))
Assertion added to data base.
;;; Query input:
(assert!
 (rule (wheel (? person))
       (and (supervisor (? middle-manager) (? person))
            (supervisor (? x) (? middle-manager)))))
Assertion added to data base.
;;; Query input:
(assert!
 (rule (outranked-by (? staff-person) (? boss))
       (or (supervisor (? staff-person) (? boss))
           (and (supervisor (? staff-person) (? middle-manager))
                (outranked-by (? middle-manager) (? boss))))))
Assertion added to data base.
;;; Query input:
(assert! (rule (append-to-form () (? y) (? y))))
Assertion added to data base.
;;; Query input:
(assert!
 (rule (append-to-form ((? u) ? v) (? y) ((? u) ? z))
       (append-to-form (? v) (? y) (? z))))
Assertion added to data base.
;;; Query input:
(assert!
 (rule (bens-query (? amount))
       (and (job (? x) (computer programmer)) (salary (? x) (? amount)))))
Assertion added to data base.
;;; Query input:
(bens-query (? howmuch))
;;; Query results:

debug:simple-query
apply-a-rule
rule=(rule (bens-query (? amount))
           (and (job (? x) (computer programmer)) (salary (? x) (? amount))))
pattern=(bens-query (? howmuch))
frame=()

unify-result=(((? howmuch) ? 1 amount))

debug:simple-query

debug:simple-query
(bens-query 35000)
(bens-query 40000)

;;; Query input:
exit
#+end_src

Well, firstly, there may be infinite-length query results. Secondly,
there may be duplicates. For example, if we wanted to get the summary
of all the wheels in the company and fed the ~(wheel ?who)~ into the
accumulator, we would get four times Oliver's salary. We would
apparently need a ~unique~ filter for the stream of frames.

***** DONE Exercise 4.67 loop detector
      CLOSED: [2020-02-20 Thu 23:20]

The first thought here is that a loop may only appear if the system
has a rule in it. Indeed the example below illustrates the simplest
recursive infinite rule.



#+name: prolog-input-loop-detector
#+begin_src shell :exports code :results verbatim output scalar code
  printf "%s" '
  <<prolog-input-sample-database>>

  (assert! (rule (loop ?x)
               (or (loop ?x))))
  (assert! (rule (outranked-by ?staff-person ?boss)
                 (or (supervisor ?staff-person ?boss)
                     (and (outranked-by ?middle-manager ?boss)
                          (supervisor ?staff-person ?middle-manager)))))
  (outranked-by (Bitdiddle Ben) ?who)
  ;(loop ?x)

  exit'
#+end_src

#+header: :stdin prolog-input-loop-detector
#+begin_src shell :shebang "#! /usr/bin/chibi-scheme" :exports code :results output scalar code :exports both

  <<prolog-glue>>

  <<prolog-debugging-help>>
  <<put-and-get>>
  <<streams-common>>
  <<streams-2>>
  <<stream-append>>
  <<prolog-driver-loop>>
  <<prolog-instantiate>>
  <<prolog-qeval>>
  <<prolog-simple-queries>>
  <<prolog-conjoin>>
  <<prolog-conjoin-installation>>
  <<prolog-disjoin>>
  <<prolog-disjoin-installation>>
  <<prolog-negate>>
  <<prolog-negate-installation>>
  <<prolog-lisp-filter>>
  <<prolog-lisp-filter-installation>>
  <<prolog-always-true>>
  <<prolog-pattern-matching>>
  <<prolog-rules-and-unification>>
  <<prolog-database>>
  <<prolog-database-add-assertion-original>>
  <<prolog-database-store-assertion-in-index>>
  <<prolog-stream-operations>>
  <<prolog-stream-flatmap>>
  <<prolog-flatten-stream>>
  <<streams-singleton>>
  <<prolog-query>>
  <<prolog-frames-and-bindings>>

  (query-driver-loop)
#+end_src

#+RESULTS[8da666e47d74accc50fb25361e5f027d61d71d7f]:
#+begin_src shell

;;; Query input:
(assert! (address (Bitdiddle Ben) (Slumerville (Ridge Road) 10)))
Assertion added to data base.
;;; Query input:
(assert! (job (Bitdiddle Ben) (computer wizard)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Bitdiddle Ben) 60000))
Assertion added to data base.
;;; Query input:
(assert! (address (Hacker Alyssa P) (Cambridge (Mass Ave) 78)))
Assertion added to data base.
;;; Query input:
(assert! (job (Hacker Alyssa P) (computer programmer)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Hacker Alyssa P) 40000))
Assertion added to data base.
;;; Query input:
(assert! (supervisor (Hacker Alyssa P) (Bitdiddle Ben)))
Assertion added to data base.
;;; Query input:
(assert! (address (Fect Cy D) (Cambridge (Ames Street) 3)))
Assertion added to data base.
;;; Query input:
(assert! (job (Fect Cy D) (computer programmer)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Fect Cy D) 35000))
Assertion added to data base.
;;; Query input:
(assert! (supervisor (Fect Cy D) (Bitdiddle Ben)))
Assertion added to data base.
;;; Query input:
(assert! (address (Tweakit Lem E) (Boston (Bay State Road) 22)))
Assertion added to data base.
;;; Query input:
(assert! (job (Tweakit Lem E) (computer technician)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Tweakit Lem E) 25000))
Assertion added to data base.
;;; Query input:
(assert! (supervisor (Tweakit Lem E) (Bitdiddle Ben)))
Assertion added to data base.
;;; Query input:
(assert! (address (Reasoner Louis) (Slumerville (Pine Tree Road) 80)))
Assertion added to data base.
;;; Query input:
(assert! (job (Reasoner Louis) (computer programmer trainee)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Reasoner Louis) 30000))
Assertion added to data base.
;;; Query input:
(assert! (supervisor (Reasoner Louis) (Hacker Alyssa P)))
Assertion added to data base.
;;; Query input:
(assert! (supervisor (Bitdiddle Ben) (Warbucks Oliver)))
Assertion added to data base.
;;; Query input:
(assert! (address (Warbucks Oliver) (Swellesley (Top Heap Road))))
Assertion added to data base.
;;; Query input:
(assert! (job (Warbucks Oliver) (administration big wheel)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Warbucks Oliver) 150000))
Assertion added to data base.
;;; Query input:
(assert! (address (Scrooge Eben) (Weston (Shady Lane) 10)))
Assertion added to data base.
;;; Query input:
(assert! (job (Scrooge Eben) (accounting chief accountant)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Scrooge Eben) 75000))
Assertion added to data base.
;;; Query input:
(assert! (supervisor (Scrooge Eben) (Warbucks Oliver)))
Assertion added to data base.
;;; Query input:
(assert! (address (Cratchet Robert) (Allston (N Harvard Street) 16)))
Assertion added to data base.
;;; Query input:
(assert! (job (Cratchet Robert) (accounting scrivener)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Cratchet Robert) 18000))
Assertion added to data base.
;;; Query input:
(assert! (supervisor (Cratchet Robert) (Scrooge Eben)))
Assertion added to data base.
;;; Query input:
(assert! (address (Aull DeWitt) (Slumerville (Onion Square) 5)))
Assertion added to data base.
;;; Query input:
(assert! (job (Aull DeWitt) (administration secretary)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Aull DeWitt) 25000))
Assertion added to data base.
;;; Query input:
(assert! (supervisor (Aull DeWitt) (Warbucks Oliver)))
Assertion added to data base.
;;; Query input:
(assert! (can-do-job (computer wizard) (computer programmer)))
Assertion added to data base.
;;; Query input:
(assert! (can-do-job (computer wizard) (computer technician)))
Assertion added to data base.
;;; Query input:
(assert! (can-do-job (computer programmer) (computer programmer trainee)))
Assertion added to data base.
;;; Query input:
(assert! (can-do-job (administration secretary) (administration big wheel)))
Assertion added to data base.
;;; Query input:
(assert! (rule (loop (? x)) (or (loop (? x)))))
Assertion added to data base.
;;; Query input:
(assert!
 (rule (outranked-by (? staff-person) (? boss))
       (or (supervisor (? staff-person) (? boss))
           (and (outranked-by (? middle-manager) (? boss))
                (supervisor (? staff-person) (? middle-manager))))))
Assertion added to data base.
;;; Query input:
(outranked-by (Bitdiddle Ben) (? who))
;;; Query results:


qeval:depth=1
query=(outranked-by (Bitdiddle Ben) (? who))

 frame-stream=( )
debug:simple-query
apply-a-rule
rule=(rule (outranked-by (? staff-person) (? boss))
           (or (supervisor (? staff-person) (? boss))
               (and (outranked-by (? middle-manager) (? boss))
                    (supervisor (? staff-person) (? middle-manager)))))
pattern=(outranked-by (Bitdiddle Ben) (? who))
frame=()

unify-result=(((? who) ? 1 boss) ((? 1 staff-person) Bitdiddle Ben))


qeval:depth=2
query=(or (supervisor (? 1 staff-person) (? 1 boss))
    (and (outranked-by (? 1 middle-manager) (? 1 boss))
         (supervisor (? 1 staff-person) (? 1 middle-manager))))

 frame-stream=( (?who . ?boss-1) 
(?staff-person-1 . (Bitdiddle Ben)) 
)

qeval:depth=3
query=(supervisor (? 1 staff-person) (? 1 boss))

 frame-stream=( (?who . ?boss-1) 
(?staff-person-1 . (Bitdiddle Ben)) 
)
debug:simple-query

 retval=( (?boss-1 . (Warbucks Oliver)) 
(?who . ?boss-1) 
(?staff-person-1 . (Bitdiddle Ben)) 
)
 retval=( (?boss-1 . (Warbucks Oliver)) 
(?who . ?boss-1) 
(?staff-person-1 . (Bitdiddle Ben)) 
)
 retval=( (?boss-1 . (Warbucks Oliver)) 
(?who . ?boss-1) 
(?staff-person-1 . (Bitdiddle Ben)) 
)(outranked-by (Bitdiddle Ben) (Warbucks Oliver))


qeval:depth=4
query=(and (outranked-by (? 1 middle-manager) (? 1 boss))
     (supervisor (? 1 staff-person) (? 1 middle-manager)))

 frame-stream=( (?who . ?boss-1) 
(?staff-person-1 . (Bitdiddle Ben)) 
)

qeval:depth=5
query=(outranked-by (? 1 middle-manager) (? 1 boss))

 frame-stream=( (?who . ?boss-1) 
(?staff-person-1 . (Bitdiddle Ben)) 
)
debug:simple-query
apply-a-rule
rule=(rule (outranked-by (? staff-person) (? boss))
           (or (supervisor (? staff-person) (? boss))
               (and (outranked-by (? middle-manager) (? boss))
                    (supervisor (? staff-person) (? middle-manager)))))
pattern=(outranked-by (? 1 middle-manager) (? 1 boss))
frame=(((? who) ? 1 boss) ((? 1 staff-person) Bitdiddle Ben))

unify-result=(((? 1 boss) ? 2 boss) ((? 1 middle-manager) ? 2 staff-person)
                                    ((? who) ? 1 boss)
                                    ((? 1 staff-person) Bitdiddle Ben))


qeval:depth=6
query=(or (supervisor (? 2 staff-person) (? 2 boss))
    (and (outranked-by (? 2 middle-manager) (? 2 boss))
         (supervisor (? 2 staff-person) (? 2 middle-manager))))

 frame-stream=( (?boss-1 . ?boss-2) 
(?middle-manager-1 . ?staff-person-2) 
(?who . ?boss-1) 
(?staff-person-1 . (Bitdiddle Ben)) 
)

qeval:depth=7
query=(supervisor (? 2 staff-person) (? 2 boss))

 frame-stream=( (?boss-1 . ?boss-2) 
(?middle-manager-1 . ?staff-person-2) 
(?who . ?boss-1) 
(?staff-person-1 . (Bitdiddle Ben)) 
)
debug:simple-query

 retval=( (?boss-2 . (Warbucks Oliver)) 
(?staff-person-2 . (Aull DeWitt)) 
(?boss-1 . ?boss-2) 
(?middle-manager-1 . ?staff-person-2) 
(?who . ?boss-1) 
(?staff-person-1 . (Bitdiddle Ben)) 
)
 retval=( (?boss-2 . (Warbucks Oliver)) 
(?staff-person-2 . (Aull DeWitt)) 
(?boss-1 . ?boss-2) 
(?middle-manager-1 . ?staff-person-2) 
(?who . ?boss-1) 
(?staff-person-1 . (Bitdiddle Ben)) 
)
 retval=( (?boss-2 . (Warbucks Oliver)) 
(?staff-person-2 . (Aull DeWitt)) 
(?boss-1 . ?boss-2) 
(?middle-manager-1 . ?staff-person-2) 
(?who . ?boss-1) 
(?staff-person-1 . (Bitdiddle Ben)) 
)

qeval:depth=8
query=(supervisor (? 1 staff-person) (? 1 middle-manager))

 frame-stream=( (?boss-2 . (Warbucks Oliver)) 
(?staff-person-2 . (Aull DeWitt)) 
(?boss-1 . ?boss-2) 
(?middle-manager-1 . ?staff-person-2) 
(?who . ?boss-1) 
(?staff-person-1 . (Bitdiddle Ben)) 
)
debug:simple-query


qeval:depth=9
query=(and (outranked-by (? 2 middle-manager) (? 2 boss))
     (supervisor (? 2 staff-person) (? 2 middle-manager)))

 frame-stream=( (?boss-1 . ?boss-2) 
(?middle-manager-1 . ?staff-person-2) 
(?who . ?boss-1) 
(?staff-person-1 . (Bitdiddle Ben)) 
)

qeval:depth=10
query=(outranked-by (? 2 middle-manager) (? 2 boss))

 frame-stream=( (?boss-1 . ?boss-2) 
(?middle-manager-1 . ?staff-person-2) 
(?who . ?boss-1) 
(?staff-person-1 . (Bitdiddle Ben)) 
)
debug:simple-query
apply-a-rule
rule=(rule (outranked-by (? staff-person) (? boss))
           (or (supervisor (? staff-person) (? boss))
               (and (outranked-by (? middle-manager) (? boss))
                    (supervisor (? staff-person) (? middle-manager)))))
pattern=(outranked-by (? 2 middle-manager) (? 2 boss))
frame=(((? 1 boss) ? 2 boss) ((? 1 middle-manager) ? 2 staff-person)
                             ((? who) ? 1 boss)
                             ((? 1 staff-person) Bitdiddle Ben))

unify-result=(((? 2 boss) ? 3 boss) ((? 2 middle-manager) ? 3 staff-person)
                                    ((? 1 boss) ? 2 boss)
                                    ((? 1 middle-manager) ? 2 staff-person)
                                    ((? who) ? 1 boss)
                                    ((? 1 staff-person) Bitdiddle Ben))


qeval:depth=11
query=(or (supervisor (? 3 staff-person) (? 3 boss))
    (and (outranked-by (? 3 middle-manager) (? 3 boss))
         (supervisor (? 3 staff-person) (? 3 middle-manager))))

 frame-stream=( (?boss-2 . ?boss-3) 
(?middle-manager-2 . ?staff-person-3) 
(?boss-1 . ?boss-2) 
(?middle-manager-1 . ?staff-person-2) 
(?who . ?boss-1) 
(?staff-person-1 . (Bitdiddle Ben)) 
)

qeval:depth=12
query=(supervisor (? 3 staff-person) (? 3 boss))

 frame-stream=( (?boss-2 . ?boss-3) 
(?middle-manager-2 . ?staff-person-3) 
(?boss-1 . ?boss-2) 
(?middle-manager-1 . ?staff-person-2) 
(?who . ?boss-1) 
(?staff-person-1 . (Bitdiddle Ben)) 
)
debug:simple-query

 retval=( (?boss-3 . (Warbucks Oliver)) 
(?staff-person-3 . (Aull DeWitt)) 
(?boss-2 . ?boss-3) 
(?middle-manager-2 . ?staff-person-3) 
(?boss-1 . ?boss-2) 
(?middle-manager-1 . ?staff-person-2) 
(?who . ?boss-1) 
(?staff-person-1 . (Bitdiddle Ben)) 
)
 retval=( (?boss-3 . (Warbucks Oliver)) 
(?staff-person-3 . (Aull DeWitt)) 
(?boss-2 . ?boss-3) 
(?middle-manager-2 . ?staff-person-3) 
(?boss-1 . ?boss-2) 
(?middle-manager-1 . ?staff-person-2) 
(?who . ?boss-1) 
(?staff-person-1 . (Bitdiddle Ben)) 
)
 retval=( (?boss-3 . (Warbucks Oliver)) 
(?staff-person-3 . (Aull DeWitt)) 
(?boss-2 . ?boss-3) 
(?middle-manager-2 . ?staff-person-3) 
(?boss-1 . ?boss-2) 
(?middle-manager-1 . ?staff-person-2) 
(?who . ?boss-1) 
(?staff-person-1 . (Bitdiddle Ben)) 
)

qeval:depth=13
query=(supervisor (? 2 staff-person) (? 2 middle-manager))

 frame-stream=( (?boss-3 . (Warbucks Oliver)) 
(?staff-person-3 . (Aull DeWitt)) 
(?boss-2 . ?boss-3) 
(?middle-manager-2 . ?staff-person-3) 
(?boss-1 . ?boss-2) 
(?middle-manager-1 . ?staff-person-2) 
(?who . ?boss-1) 
(?staff-person-1 . (Bitdiddle Ben)) 
)
debug:simple-query


qeval:depth=14
query=(and (outranked-by (? 3 middle-manager) (? 3 boss))
     (supervisor (? 3 staff-person) (? 3 middle-manager)))

 frame-stream=( (?boss-2 . ?boss-3) 
(?middle-manager-2 . ?staff-person-3) 
(?boss-1 . ?boss-2) 
(?middle-manager-1 . ?staff-person-2) 
(?who . ?boss-1) 
(?staff-person-1 . (Bitdiddle Ben)) 
)

qeval:depth=15
query=(outranked-by (? 3 middle-manager) (? 3 boss))

 frame-stream=( (?boss-2 . ?boss-3) 
(?middle-manager-2 . ?staff-person-3) 
(?boss-1 . ?boss-2) 
(?middle-manager-1 . ?staff-person-2) 
(?who . ?boss-1) 
(?staff-person-1 . (Bitdiddle Ben)) 
)
debug:simple-query
apply-a-rule
rule=(rule (outranked-by (? staff-person) (? boss))
           (or (supervisor (? staff-person) (? boss))
               (and (outranked-by (? middle-manager) (? boss))
                    (supervisor (? staff-person) (? middle-manager)))))
pattern=(outranked-by (? 3 middle-manager) (? 3 boss))
frame=(((? 2 boss) ? 3 boss) ((? 2 middle-manager) ? 3 staff-person)
                             ((? 1 boss) ? 2 boss)
                             ((? 1 middle-manager) ? 2 staff-person)
                             ((? who) ? 1 boss)
                             ((? 1 staff-person) Bitdiddle Ben))

unify-result=(((? 3 boss) ? 4 boss) ((? 3 middle-manager) ? 4 staff-person)
                                    ((? 2 boss) ? 3 boss)
                                    ((? 2 middle-manager) ? 3 staff-person)
                                    ((? 1 boss) ? 2 boss)
                                    ((? 1 middle-manager) ? 2 staff-person)
                                    ((? who) ? 1 boss)
                                    ((? 1 staff-person) Bitdiddle Ben))


qeval:depth=16
query=(or (supervisor (? 4 staff-person) (? 4 boss))
    (and (outranked-by (? 4 middle-manager) (? 4 boss))
         (supervisor (? 4 staff-person) (? 4 middle-manager))))

 frame-stream=( (?boss-3 . ?boss-4) 
(?middle-manager-3 . ?staff-person-4) 
(?boss-2 . ?boss-3) 
(?middle-manager-2 . ?staff-person-3) 
(?boss-1 . ?boss-2) 
(?middle-manager-1 . ?staff-person-2) 
(?who . ?boss-1) 
(?staff-person-1 . (Bitdiddle Ben)) 
)

qeval:depth=17
query=(supervisor (? 4 staff-person) (? 4 boss))

 frame-stream=( (?boss-3 . ?boss-4) 
(?middle-manager-3 . ?staff-person-4) 
(?boss-2 . ?boss-3) 
(?middle-manager-2 . ?staff-person-3) 
(?boss-1 . ?boss-2) 
(?middle-manager-1 . ?staff-person-2) 
(?who . ?boss-1) 
(?staff-person-1 . (Bitdiddle Ben)) 
)
debug:simple-query

 retval=( (?boss-4 . (Warbucks Oliver)) 
(?staff-person-4 . (Aull DeWitt)) 
(?boss-3 . ?boss-4) 
(?middle-manager-3 . ?staff-person-4) 
(?boss-2 . ?boss-3) 
(?middle-manager-2 . ?staff-person-3) 
(?boss-1 . ?boss-2) 
(?middle-manager-1 . ?staff-person-2) 
(?who . ?boss-1) 
(?staff-person-1 . (Bitdiddle Ben)) 
)
 retval=( (?boss-4 . (Warbucks Oliver)) 
(?staff-person-4 . (Aull DeWitt)) 
(?boss-3 . ?boss-4) 
(?middle-manager-3 . ?staff-person-4) 
(?boss-2 . ?boss-3) 
(?middle-manager-2 . ?staff-person-3) 
(?boss-1 . ?boss-2) 
(?middle-manager-1 . ?staff-person-2) 
(?who . ?boss-1) 
(?staff-person-1 . (Bitdiddle Ben)) 
)
 retval=( (?boss-4 . (Warbucks Oliver)) 
(?staff-person-4 . (Aull DeWitt)) 
(?boss-3 . ?boss-4) 
(?middle-manager-3 . ?staff-person-4) 
(?boss-2 . ?boss-3) 
(?middle-manager-2 . ?staff-person-3) 
(?boss-1 . ?boss-2) 
(?middle-manager-1 . ?staff-person-2) 
(?who . ?boss-1) 
(?staff-person-1 . (Bitdiddle Ben)) 
)

qeval:depth=18
query=(supervisor (? 3 staff-person) (? 3 middle-manager))

 frame-stream=( (?boss-4 . (Warbucks Oliver)) 
(?staff-person-4 . (Aull DeWitt)) 
(?boss-3 . ?boss-4) 
(?middle-manager-3 . ?staff-person-4) 
(?boss-2 . ?boss-3) 
(?middle-manager-2 . ?staff-person-3) 
(?boss-1 . ?boss-2) 
(?middle-manager-1 . ?staff-person-2) 
(?who . ?boss-1) 
(?staff-person-1 . (Bitdiddle Ben)) 
)
debug:simple-query


qeval:depth=19
query=(and (outranked-by (? 4 middle-manager) (? 4 boss))
     (supervisor (? 4 staff-person) (? 4 middle-manager)))

 frame-stream=( (?boss-3 . ?boss-4) 
(?middle-manager-3 . ?staff-person-4) 
(?boss-2 . ?boss-3) 
(?middle-manager-2 . ?staff-person-3) 
(?boss-1 . ?boss-2) 
(?middle-manager-1 . ?staff-person-2) 
(?who . ?boss-1) 
(?staff-person-1 . (Bitdiddle Ben)) 
)

qeval:depth=20
query=(outranked-by (? 4 middle-manager) (? 4 boss))

 frame-stream=( (?boss-3 . ?boss-4) 
(?middle-manager-3 . ?staff-person-4) 
(?boss-2 . ?boss-3) 
(?middle-manager-2 . ?staff-person-3) 
(?boss-1 . ?boss-2) 
(?middle-manager-1 . ?staff-person-2) 
(?who . ?boss-1) 
(?staff-person-1 . (Bitdiddle Ben)) 
)
debug:simple-query
apply-a-rule
rule=(rule (outranked-by (? staff-person) (? boss))
           (or (supervisor (? staff-person) (? boss))
               (and (outranked-by (? middle-manager) (? boss))
                    (supervisor (? staff-person) (? middle-manager)))))
pattern=(outranked-by (? 4 middle-manager) (? 4 boss))
frame=(((? 3 boss) ? 4 boss) ((? 3 middle-manager) ? 4 staff-person)
                             ((? 2 boss) ? 3 boss)
                             ((? 2 middle-manager) ? 3 staff-person)
                             ((? 1 boss) ? 2 boss)
                             ((? 1 middle-manager) ? 2 staff-person)
                             ((? who) ? 1 boss)
                             ((? 1 staff-person) Bitdiddle Ben))

unify-result=(((? 4 boss) ? 5 boss) ((? 4 middle-manager) ? 5 staff-person)
                                    ((? 3 boss) ? 4 boss)
                                    ((? 3 middle-manager) ? 4 staff-person)
                                    ((? 2 boss) ? 3 boss)
                                    ((? 2 middle-manager) ? 3 staff-person)
                                    ((? 1 boss) ? 2 boss)
                                    ((? 1 middle-manager) ? 2 staff-person)
                                    ((? who) ? 1 boss)
                                    ((? 1 staff-person) Bitdiddle Ben))


qeval:depth=21
query=(or (supervisor (? 5 staff-person) (? 5 boss))
    (and (outranked-by (? 5 middle-manager) (? 5 boss))
         (supervisor (? 5 staff-person) (? 5 middle-manager))))

 frame-stream=( (?boss-4 . ?boss-5) 
(?middle-manager-4 . ?staff-person-5) 
(?boss-3 . ?boss-4) 
(?middle-manager-3 . ?staff-person-4) 
(?boss-2 . ?boss-3) 
(?middle-manager-2 . ?staff-person-3) 
(?boss-1 . ?boss-2) 
(?middle-manager-1 . ?staff-person-2) 
(?who . ?boss-1) 
(?staff-person-1 . (Bitdiddle Ben)) 
)
Maximum depth reached.
 retval=

qeval:depth=21
query=(supervisor (? 4 staff-person) (? 4 middle-manager))

 frame-stream=
Maximum depth reached.
 retval=
 retval=( (?staff-person-3 . (Cratchet Robert)) 
(?boss-4 . (Warbucks Oliver)) 
(?staff-person-4 . (Scrooge Eben)) 
(?boss-3 . ?boss-4) 
(?middle-manager-3 . ?staff-person-4) 
(?boss-2 . ?boss-3) 
(?middle-manager-2 . ?staff-person-3) 
(?boss-1 . ?boss-2) 
(?middle-manager-1 . ?staff-person-2) 
(?who . ?boss-1) 
(?staff-person-1 . (Bitdiddle Ben)) 
)
 retval=( (?staff-person-3 . (Cratchet Robert)) 
(?boss-4 . (Warbucks Oliver)) 
(?staff-person-4 . (Scrooge Eben)) 
(?boss-3 . ?boss-4) 
(?middle-manager-3 . ?staff-person-4) 
(?boss-2 . ?boss-3) 
(?middle-manager-2 . ?staff-person-3) 
(?boss-1 . ?boss-2) 
(?middle-manager-1 . ?staff-person-2) 
(?who . ?boss-1) 
(?staff-person-1 . (Bitdiddle Ben)) 
)
 retval=( (?staff-person-2 . (Cratchet Robert)) 
(?boss-3 . (Warbucks Oliver)) 
(?staff-person-3 . (Scrooge Eben)) 
(?boss-2 . ?boss-3) 
(?middle-manager-2 . ?staff-person-3) 
(?boss-1 . ?boss-2) 
(?middle-manager-1 . ?staff-person-2) 
(?who . ?boss-1) 
(?staff-person-1 . (Bitdiddle Ben)) 
)
 retval=( (?staff-person-2 . (Cratchet Robert)) 
(?boss-3 . (Warbucks Oliver)) 
(?staff-person-3 . (Scrooge Eben)) 
(?boss-2 . ?boss-3) 
(?middle-manager-2 . ?staff-person-3) 
(?boss-1 . ?boss-2) 
(?middle-manager-1 . ?staff-person-2) 
(?who . ?boss-1) 
(?staff-person-1 . (Bitdiddle Ben)) 
)
 retval=
 retval=
;;; Query input:
exit
#+end_src

So if my history includes (query . frame) as a history element, and I
can do the following: match my current query with some previous query to
establish the correspondence of variables and whether the chain of
bindings eventually makes these variables equivalent. Then this would
mean that we are essentially in a loop.

I am not sure this is easy to implement or would be useful in the
future, but I have written most of the debugging code during the
thinking about this exercise.

Took me about 12 hours.

***** DONE Exercise 4.68 reverse rule
      CLOSED: [2020-02-21 Fri 15:48]

Okay, I have written ~reverse-right~ and ~reverse-left~, but I don't
seem to be able to write a symmetric ~reverse~. My bad.

#+name: prolog-input-reverse-rule
#+begin_src shell :exports code :results verbatim output scalar code
  printf "%s" '
  <<prolog-input-canned-rules>>

  (assert! (rule (bad-reverse ((). ?x) (?x . ()))))
  (bad-reverse ?x (a))

  (assert! (rule (empty-list ())))

  (assert! (rule (one-element-listp (?x . ?y))
		 (empty-list ?y)))
  (one-element-listp (a))
  (one-element-listp (b a))

  (assert! (rule (not-list ?x)
		 (and (not (empty-list ?x))
		      (not (same (?a . ?b) ?x)))))
  (not-list a)
  (not-list (a))

  (assert! (rule (carcdr (?car .  ?cdr) ?car ?cdr)))
  (carcdr (a b) ?car ?cdr)
  (carcdr ?l a (b))

  (assert! (rule (last-element ?x ?e)
		 (and (carcdr ?x ?car ?cdr)
		      (or (and (empty-list ?cdr)
			       (same ?e ?car))
		          (last-element ?cdr ?e)))))
  (last-element (a b c) ?e)

  (append-to-form (a b) c ?form)
  (append-to-form (a b) (c) ?form)

  (assert! (rule (all-but-last ?l ?abl ?e)
                 (and (last-element ?l ?e)
                      (append-to-form ?abl (?e) ?l)
                      )))

  (all-but-last (a b c) ?abl ?e )

  #;(assert! (rule (reverse () ())))
  #;(assert! (rule (reverse ?x ?y)
                 (and (one-element-listp ?x)
                      (one-element-listp ?y)
                      (same ?x ?y))))
  (assert! (rule (reverse-left () ())))
  (assert! (rule (reverse-left ?a ?b)
                 (and (carcdr ?a ?car ?cdr)
                      (reverse-left ?cdr ?rcdr)
                      (append-to-form ?rcdr (?car) ?b))))
  (assert! (rule (reverse-right () ())))
  (assert! (rule (reverse-right ?a ?b)
                 (and (carcdr ?b ?car ?cdr)
                      (reverse-right ?rcdr ?cdr)
                      (append-to-form ?rcdr (?car) ?a))))
  (reverse-left () ?y)
  (reverse-left (a) ?y)
  (reverse-left (a b) ?y)
  (reverse-left (a b c) ?y)
  (reverse-right ?x (a b c))

  (assert! (rule (palindrome ?x)
                 (and (reverse-left ?x ?rx)
                      (same ?x ?rx))))
  (palindrome (1 2 2 1))

  (assert! (rule (interleave ?x ?y ?z)
                 (or  (and (empty-list ?x)
                           (same ?y ?z))
                      (and (empty-list ?y)
                           (same ?y ?z)))))

  (assert! (rule (interleave ?x ?y ?res)
                 (and (and (carcdr ?x ?x-car ?x-cdr)
                           (carcdr ?y ?y-car ?y-cdr))
                      (interleave ?x-cdr ?y-cdr ?int)
                      (append-to-form (?x-car ?y-car) ?int ?res)
                    )))
  #;(assert! (rule (reverse ?x ?y)
                 (and (interleave ?x ?y ?int)
                      (palindrome ?int))))
  exit'
#+end_src

#+header: :stdin prolog-input-reverse-rule
#+begin_src shell :shebang "#! /usr/bin/chibi-scheme" :exports code :results output scalar code :exports both

  <<prolog-glue>>
  <<put-and-get>>
  <<streams-common>>
  <<streams-2>>
  <<stream-append>>
  <<prolog-driver-loop>>
  <<prolog-instantiate>>
  <<prolog-qeval>>
  <<prolog-simple-queries>>
  <<prolog-conjoin>>
  <<prolog-conjoin-installation>>
  <<prolog-disjoin>>
  <<prolog-disjoin-installation>>
  <<prolog-negate>>
  <<prolog-negate-installation>>
  <<prolog-lisp-filter>>
  <<prolog-lisp-filter-installation>>
  <<prolog-always-true>>
  <<prolog-pattern-matching>>
  <<prolog-rules-and-unification>>
  <<prolog-database>>
  <<prolog-database-add-assertion-original>>
  <<prolog-database-store-assertion-in-index>>
  <<prolog-stream-operations>>
  <<prolog-stream-flatmap>>
  <<prolog-flatten-stream>>
  <<streams-singleton>>
  <<prolog-query>>
  <<prolog-frames-and-bindings>>

  (query-driver-loop)
#+end_src

#+RESULTS[c12ce22a1c30ac8f26e104e4ed39f2d06ecca9e3]:
#+begin_src shell

;;; Query input:
(assert!
 (rule (lives-near (? person-1) (? person-2))
       (and (address (? person-1) ((? town) ? rest-1))
            (address (? person-2) ((? town) ? rest-2))
            (not (same (? person-1) (? person-2))))))
Assertion added to data base.
;;; Query input:
(assert! (rule (same (? x) (? x))))
Assertion added to data base.
;;; Query input:
(assert!
 (rule (wheel (? person))
       (and (supervisor (? middle-manager) (? person))
            (supervisor (? x) (? middle-manager)))))
Assertion added to data base.
;;; Query input:
(assert!
 (rule (outranked-by (? staff-person) (? boss))
       (or (supervisor (? staff-person) (? boss))
           (and (supervisor (? staff-person) (? middle-manager))
                (outranked-by (? middle-manager) (? boss))))))
Assertion added to data base.
;;; Query input:
(assert! (rule (append-to-form () (? y) (? y))))
Assertion added to data base.
;;; Query input:
(assert!
 (rule (append-to-form ((? u) ? v) (? y) ((? u) ? z))
       (append-to-form (? v) (? y) (? z))))
Assertion added to data base.
;;; Query input:
(assert! (rule (bad-reverse (() ? x) ((? x)))))
Assertion added to data base.
;;; Query input:
(bad-reverse (? x) (a))
;;; Query results:

debug:simple-query
apply-a-rule
rule=(rule (bad-reverse (() ? x) ((? x))))
pattern=(bad-reverse (? x) (a))
frame=()

unify-result=(((? 1 x) . a) ((? x) () ? 1 x))
(bad-reverse (() . a) (a))

;;; Query input:
(assert! (rule (empty-list ())))
Assertion added to data base.
;;; Query input:
(assert! (rule (one-element-listp ((? x) ? y)) (empty-list (? y))))
Assertion added to data base.
;;; Query input:
(one-element-listp (a))
;;; Query results:

debug:simple-query
apply-a-rule
rule=(rule (one-element-listp ((? x) ? y)) (empty-list (? y)))
pattern=(one-element-listp (a))
frame=()

unify-result=(((? 2 y)) ((? 2 x) . a))

debug:simple-query
apply-a-rule
rule=(rule (empty-list ()))
pattern=(empty-list (? 2 y))
frame=(((? 2 y)) ((? 2 x) . a))

unify-result=(((? 2 y)) ((? 2 x) . a))
(one-element-listp (a))

;;; Query input:
(one-element-listp (b a))
;;; Query results:

debug:simple-query
apply-a-rule
rule=(rule (one-element-listp ((? x) ? y)) (empty-list (? y)))
pattern=(one-element-listp (b a))
frame=()

unify-result=(((? 4 y) a) ((? 4 x) . b))

debug:simple-query
apply-a-rule
rule=(rule (empty-list ()))
pattern=(empty-list (? 4 y))
frame=(((? 4 y) a) ((? 4 x) . b))

unify-result=failed

;;; Query input:
(assert!
 (rule (not-list (? x))
       (and (not (empty-list (? x))) (not (same ((? a) ? b) (? x))))))
Assertion added to data base.
;;; Query input:
(not-list a)
;;; Query results:

debug:simple-query
apply-a-rule
rule=(rule (not-list (? x))
           (and (not (empty-list (? x))) (not (same ((? a) ? b) (? x)))))
pattern=(not-list a)
frame=()

unify-result=(((? 6 x) . a))

debug:simple-query
apply-a-rule
rule=(rule (empty-list ()))
pattern=(empty-list (? 6 x))
frame=(((? 6 x) . a))

unify-result=failed

debug:simple-query
apply-a-rule
rule=(rule (same (? x) (? x)))
pattern=(same ((? 6 a) ? 6 b) (? 6 x))
frame=(((? 6 x) . a))

unify-result=failed
(not-list a)

;;; Query input:
(not-list (a))
;;; Query results:

debug:simple-query
apply-a-rule
rule=(rule (not-list (? x))
           (and (not (empty-list (? x))) (not (same ((? a) ? b) (? x)))))
pattern=(not-list (a))
frame=()

unify-result=(((? 9 x) a))

debug:simple-query
apply-a-rule
rule=(rule (empty-list ()))
pattern=(empty-list (? 9 x))
frame=(((? 9 x) a))

unify-result=failed

debug:simple-query
apply-a-rule
rule=(rule (same (? x) (? x)))
pattern=(same ((? 9 a) ? 9 b) (? 9 x))
frame=(((? 9 x) a))

unify-result=(((? 9 b)) ((? 9 a) . a) ((? 11 x) (? 9 a) ? 9 b) ((? 9 x) a))

;;; Query input:
(assert! (rule (carcdr ((? car) ? cdr) (? car) (? cdr))))
Assertion added to data base.
;;; Query input:
(carcdr (a b) (? car) (? cdr))
;;; Query results:

debug:simple-query
apply-a-rule
rule=(rule (carcdr ((? car) ? cdr) (? car) (? cdr)))
pattern=(carcdr (a b) (? car) (? cdr))
frame=()

unify-result=(((? cdr) b) ((? car) . a) ((? 12 cdr) b) ((? 12 car) . a))
(carcdr (a b) a (b))

;;; Query input:
(carcdr (? l) a (b))
;;; Query results:

debug:simple-query
apply-a-rule
rule=(rule (carcdr ((? car) ? cdr) (? car) (? cdr)))
pattern=(carcdr (? l) a (b))
frame=()

unify-result=(((? 13 cdr) b) ((? 13 car) . a) ((? l) (? 13 car) ? 13 cdr))
(carcdr (a b) a (b))

;;; Query input:
(assert!
 (rule (last-element (? x) (? e))
       (and (carcdr (? x) (? car) (? cdr))
            (or (and (empty-list (? cdr)) (same (? e) (? car)))
                (last-element (? cdr) (? e))))))
Assertion added to data base.
;;; Query input:
(last-element (a b c) (? e))
;;; Query results:

debug:simple-query
apply-a-rule
rule=(rule (last-element (? x) (? e))
           (and (carcdr (? x) (? car) (? cdr))
                (or (and (empty-list (? cdr)) (same (? e) (? car)))
                    (last-element (? cdr) (? e)))))
pattern=(last-element (a b c) (? e))
frame=()

unify-result=(((? e) ? 14 e) ((? 14 x) a b c))

debug:simple-query
apply-a-rule
rule=(rule (carcdr ((? car) ? cdr) (? car) (? cdr)))
pattern=(carcdr (? 14 x) (? 14 car) (? 14 cdr))
frame=(((? e) ? 14 e) ((? 14 x) a b c))

unify-result=(((? 14 cdr) b c) ((? 14 car) . a)
                               ((? 15 cdr) b c)
                               ((? 15 car) . a)
                               ((? e) ? 14 e)
                               ((? 14 x) a b c))

debug:simple-query
apply-a-rule
rule=(rule (empty-list ()))
pattern=(empty-list (? 14 cdr))
frame=(((? 14 cdr) b c) ((? 14 car) . a)
                        ((? 15 cdr) b c)
                        ((? 15 car) . a)
                        ((? e) ? 14 e)
                        ((? 14 x) a b c))

unify-result=failed

debug:simple-query

debug:simple-query
apply-a-rule
rule=(rule (last-element (? x) (? e))
           (and (carcdr (? x) (? car) (? cdr))
                (or (and (empty-list (? cdr)) (same (? e) (? car)))
                    (last-element (? cdr) (? e)))))
pattern=(last-element (? 14 cdr) (? 14 e))
frame=(((? 14 cdr) b c) ((? 14 car) . a)
                        ((? 15 cdr) b c)
                        ((? 15 car) . a)
                        ((? e) ? 14 e)
                        ((? 14 x) a b c))

unify-result=(((? 14 e) ? 17 e) ((? 17 x) b c)
                                ((? 14 cdr) b c)
                                ((? 14 car) . a)
                                ((? 15 cdr) b c)
                                ((? 15 car) . a)
                                ((? e) ? 14 e)
                                ((? 14 x) a b c))

debug:simple-query
apply-a-rule
rule=(rule (carcdr ((? car) ? cdr) (? car) (? cdr)))
pattern=(carcdr (? 17 x) (? 17 car) (? 17 cdr))
frame=(((? 14 e) ? 17 e) ((? 17 x) b c)
                         ((? 14 cdr) b c)
                         ((? 14 car) . a)
                         ((? 15 cdr) b c)
                         ((? 15 car) . a)
                         ((? e) ? 14 e)
                         ((? 14 x) a b c))

unify-result=(((? 17 cdr) c) ((? 17 car) . b)
                             ((? 18 cdr) c)
                             ((? 18 car) . b)
                             ((? 14 e) ? 17 e)
                             ((? 17 x) b c)
                             ((? 14 cdr) b c)
                             ((? 14 car) . a)
                             ((? 15 cdr) b c)
                             ((? 15 car) . a)
                             ((? e) ? 14 e)
                             ((? 14 x) a b c))

debug:simple-query
apply-a-rule
rule=(rule (empty-list ()))
pattern=(empty-list (? 17 cdr))
frame=(((? 17 cdr) c) ((? 17 car) . b)
                      ((? 18 cdr) c)
                      ((? 18 car) . b)
                      ((? 14 e) ? 17 e)
                      ((? 17 x) b c)
                      ((? 14 cdr) b c)
                      ((? 14 car) . a)
                      ((? 15 cdr) b c)
                      ((? 15 car) . a)
                      ((? e) ? 14 e)
                      ((? 14 x) a b c))

unify-result=failed

debug:simple-query

debug:simple-query
apply-a-rule
rule=(rule (last-element (? x) (? e))
           (and (carcdr (? x) (? car) (? cdr))
                (or (and (empty-list (? cdr)) (same (? e) (? car)))
                    (last-element (? cdr) (? e)))))
pattern=(last-element (? 17 cdr) (? 17 e))
frame=(((? 17 cdr) c) ((? 17 car) . b)
                      ((? 18 cdr) c)
                      ((? 18 car) . b)
                      ((? 14 e) ? 17 e)
                      ((? 17 x) b c)
                      ((? 14 cdr) b c)
                      ((? 14 car) . a)
                      ((? 15 cdr) b c)
                      ((? 15 car) . a)
                      ((? e) ? 14 e)
                      ((? 14 x) a b c))

unify-result=(((? 17 e) ? 20 e) ((? 20 x) c)
                                ((? 17 cdr) c)
                                ((? 17 car) . b)
                                ((? 18 cdr) c)
                                ((? 18 car) . b)
                                ((? 14 e) ? 17 e)
                                ((? 17 x) b c)
                                ((? 14 cdr) b c)
                                ((? 14 car) . a)
                                ((? 15 cdr) b c)
                                ((? 15 car) . a)
                                ((? e) ? 14 e)
                                ((? 14 x) a b c))

debug:simple-query
apply-a-rule
rule=(rule (carcdr ((? car) ? cdr) (? car) (? cdr)))
pattern=(carcdr (? 20 x) (? 20 car) (? 20 cdr))
frame=(((? 17 e) ? 20 e) ((? 20 x) c)
                         ((? 17 cdr) c)
                         ((? 17 car) . b)
                         ((? 18 cdr) c)
                         ((? 18 car) . b)
                         ((? 14 e) ? 17 e)
                         ((? 17 x) b c)
                         ((? 14 cdr) b c)
                         ((? 14 car) . a)
                         ((? 15 cdr) b c)
                         ((? 15 car) . a)
                         ((? e) ? 14 e)
                         ((? 14 x) a b c))

unify-result=(((? 20 cdr)) ((? 20 car) . c)
                           ((? 21 cdr))
                           ((? 21 car) . c)
                           ((? 17 e) ? 20 e)
                           ((? 20 x) c)
                           ((? 17 cdr) c)
                           ((? 17 car) . b)
                           ((? 18 cdr) c)
                           ((? 18 car) . b)
                           ((? 14 e) ? 17 e)
                           ((? 17 x) b c)
                           ((? 14 cdr) b c)
                           ((? 14 car) . a)
                           ((? 15 cdr) b c)
                           ((? 15 car) . a)
                           ((? e) ? 14 e)
                           ((? 14 x) a b c))

debug:simple-query
apply-a-rule
rule=(rule (empty-list ()))
pattern=(empty-list (? 20 cdr))
frame=(((? 20 cdr)) ((? 20 car) . c)
                    ((? 21 cdr))
                    ((? 21 car) . c)
                    ((? 17 e) ? 20 e)
                    ((? 20 x) c)
                    ((? 17 cdr) c)
                    ((? 17 car) . b)
                    ((? 18 cdr) c)
                    ((? 18 car) . b)
                    ((? 14 e) ? 17 e)
                    ((? 17 x) b c)
                    ((? 14 cdr) b c)
                    ((? 14 car) . a)
                    ((? 15 cdr) b c)
                    ((? 15 car) . a)
                    ((? e) ? 14 e)
                    ((? 14 x) a b c))

unify-result=(((? 20 cdr)) ((? 20 car) . c)
                           ((? 21 cdr))
                           ((? 21 car) . c)
                           ((? 17 e) ? 20 e)
                           ((? 20 x) c)
                           ((? 17 cdr) c)
                           ((? 17 car) . b)
                           ((? 18 cdr) c)
                           ((? 18 car) . b)
                           ((? 14 e) ? 17 e)
                           ((? 17 x) b c)
                           ((? 14 cdr) b c)
                           ((? 14 car) . a)
                           ((? 15 cdr) b c)
                           ((? 15 car) . a)
                           ((? e) ? 14 e)
                           ((? 14 x) a b c))

debug:simple-query
apply-a-rule
rule=(rule (same (? x) (? x)))
pattern=(same (? 20 e) (? 20 car))
frame=(((? 20 cdr)) ((? 20 car) . c)
                    ((? 21 cdr))
                    ((? 21 car) . c)
                    ((? 17 e) ? 20 e)
                    ((? 20 x) c)
                    ((? 17 cdr) c)
                    ((? 17 car) . b)
                    ((? 18 cdr) c)
                    ((? 18 car) . b)
                    ((? 14 e) ? 17 e)
                    ((? 17 x) b c)
                    ((? 14 cdr) b c)
                    ((? 14 car) . a)
                    ((? 15 cdr) b c)
                    ((? 15 car) . a)
                    ((? e) ? 14 e)
                    ((? 14 x) a b c))

unify-result=(((? 23 x) . c)    ((? 20 e) ? 23 x) ((? 20 cdr))      ((? 20 car) . c)
              ((? 21 cdr))      ((? 21 car) . c)  ((? 17 e) ? 20 e) ((? 20 x) c)
              ((? 17 cdr) c)    ((? 17 car) . b)  ((? 18 cdr) c)    ((? 18 car) . b)
              ((? 14 e) ? 17 e) ((? 17 x) b c)    ((? 14 cdr) b c)  ((? 14 car) . a)
              ((? 15 cdr) b c)  ((? 15 car) . a)  ((? e) ? 14 e)    ((? 14 x) a b c))
(last-element (a b c) c)

debug:simple-query
apply-a-rule
rule=(rule (last-element (? x) (? e))
           (and (carcdr (? x) (? car) (? cdr))
                (or (and (empty-list (? cdr)) (same (? e) (? car)))
                    (last-element (? cdr) (? e)))))
pattern=(last-element (? 20 cdr) (? 20 e))
frame=(((? 20 cdr)) ((? 20 car) . c)
                    ((? 21 cdr))
                    ((? 21 car) . c)
                    ((? 17 e) ? 20 e)
                    ((? 20 x) c)
                    ((? 17 cdr) c)
                    ((? 17 car) . b)
                    ((? 18 cdr) c)
                    ((? 18 car) . b)
                    ((? 14 e) ? 17 e)
                    ((? 17 x) b c)
                    ((? 14 cdr) b c)
                    ((? 14 car) . a)
                    ((? 15 cdr) b c)
                    ((? 15 car) . a)
                    ((? e) ? 14 e)
                    ((? 14 x) a b c))

unify-result=(((? 20 e) ? 24 e) ((? 24 x))
                                ((? 20 cdr))
                                ((? 20 car) . c)
                                ((? 21 cdr))
                                ((? 21 car) . c)
                                ((? 17 e) ? 20 e)
                                ((? 20 x) c)
                                ((? 17 cdr) c)
                                ((? 17 car) . b)
                                ((? 18 cdr) c)
                                ((? 18 car) . b)
                                ((? 14 e) ? 17 e)
                                ((? 17 x) b c)
                                ((? 14 cdr) b c)
                                ((? 14 car) . a)
                                ((? 15 cdr) b c)
                                ((? 15 car) . a)
                                ((? e) ? 14 e)
                                ((? 14 x) a b c))

debug:simple-query
apply-a-rule
rule=(rule (carcdr ((? car) ? cdr) (? car) (? cdr)))
pattern=(carcdr (? 24 x) (? 24 car) (? 24 cdr))
frame=(((? 20 e) ? 24 e) ((? 24 x))
                         ((? 20 cdr))
                         ((? 20 car) . c)
                         ((? 21 cdr))
                         ((? 21 car) . c)
                         ((? 17 e) ? 20 e)
                         ((? 20 x) c)
                         ((? 17 cdr) c)
                         ((? 17 car) . b)
                         ((? 18 cdr) c)
                         ((? 18 car) . b)
                         ((? 14 e) ? 17 e)
                         ((? 17 x) b c)
                         ((? 14 cdr) b c)
                         ((? 14 car) . a)
                         ((? 15 cdr) b c)
                         ((? 15 car) . a)
                         ((? e) ? 14 e)
                         ((? 14 x) a b c))

unify-result=failed

debug:simple-query

debug:simple-query

debug:simple-query

;;; Query input:
(append-to-form (a b) c (? form))
;;; Query results:

debug:simple-query
apply-a-rule
rule=(rule (append-to-form ((? u) ? v) (? y) ((? u) ? z))
           (append-to-form (? v) (? y) (? z)))
pattern=(append-to-form (a b) c (? form))
frame=()

unify-result=(((? form) (? 26 u) ? 26 z) ((? 26 y) . c)
                                         ((? 26 v) b)
                                         ((? 26 u) . a))

debug:simple-query
apply-a-rule
rule=(rule (append-to-form ((? u) ? v) (? y) ((? u) ? z))
           (append-to-form (? v) (? y) (? z)))
pattern=(append-to-form (? 26 v) (? 26 y) (? 26 z))
frame=(((? form) (? 26 u) ? 26 z) ((? 26 y) . c) ((? 26 v) b) ((? 26 u) . a))

unify-result=(((? 26 z) (? 27 u) ? 27 z) ((? 27 y) . c)
                                         ((? 27 v))
                                         ((? 27 u) . b)
                                         ((? form) (? 26 u) ? 26 z)
                                         ((? 26 y) . c)
                                         ((? 26 v) b)
                                         ((? 26 u) . a))

debug:simple-query
apply-a-rule
rule=(rule (append-to-form ((? u) ? v) (? y) ((? u) ? z))
           (append-to-form (? v) (? y) (? z)))
pattern=(append-to-form (? 27 v) (? 27 y) (? 27 z))
frame=(((? 26 z) (? 27 u) ? 27 z) ((? 27 y) . c)
                                  ((? 27 v))
                                  ((? 27 u) . b)
                                  ((? form) (? 26 u) ? 26 z)
                                  ((? 26 y) . c)
                                  ((? 26 v) b)
                                  ((? 26 u) . a))

unify-result=failed
apply-a-rule
rule=(rule (append-to-form () (? y) (? y)))
pattern=(append-to-form (? 27 v) (? 27 y) (? 27 z))
frame=(((? 26 z) (? 27 u) ? 27 z) ((? 27 y) . c)
                                  ((? 27 v))
                                  ((? 27 u) . b)
                                  ((? form) (? 26 u) ? 26 z)
                                  ((? 26 y) . c)
                                  ((? 26 v) b)
                                  ((? 26 u) . a))

unify-result=(((? 27 z) . c)             ((? 29 y) . c)
              ((? 26 z) (? 27 u) ? 27 z) ((? 27 y) . c)
              ((? 27 v))                 ((? 27 u) . b)
              ((? form) (? 26 u) ? 26 z) ((? 26 y) . c)
              ((? 26 v) b)               ((? 26 u) . a))
(append-to-form (a b) c (a b . c))
apply-a-rule
rule=(rule (append-to-form () (? y) (? y)))
pattern=(append-to-form (a b) c (? form))
frame=()

unify-result=failed
apply-a-rule
rule=(rule (append-to-form () (? y) (? y)))
pattern=(append-to-form (? 26 v) (? 26 y) (? 26 z))
frame=(((? form) (? 26 u) ? 26 z) ((? 26 y) . c) ((? 26 v) b) ((? 26 u) . a))

unify-result=failed

;;; Query input:
(append-to-form (a b) (c) (? form))
;;; Query results:

debug:simple-query
apply-a-rule
rule=(rule (append-to-form ((? u) ? v) (? y) ((? u) ? z))
           (append-to-form (? v) (? y) (? z)))
pattern=(append-to-form (a b) (c) (? form))
frame=()

unify-result=(((? form) (? 32 u) ? 32 z) ((? 32 y) c)
                                         ((? 32 v) b)
                                         ((? 32 u) . a))

debug:simple-query
apply-a-rule
rule=(rule (append-to-form ((? u) ? v) (? y) ((? u) ? z))
           (append-to-form (? v) (? y) (? z)))
pattern=(append-to-form (? 32 v) (? 32 y) (? 32 z))
frame=(((? form) (? 32 u) ? 32 z) ((? 32 y) c) ((? 32 v) b) ((? 32 u) . a))

unify-result=(((? 32 z) (? 33 u) ? 33 z) ((? 33 y) c)
                                         ((? 33 v))
                                         ((? 33 u) . b)
                                         ((? form) (? 32 u) ? 32 z)
                                         ((? 32 y) c)
                                         ((? 32 v) b)
                                         ((? 32 u) . a))

debug:simple-query
apply-a-rule
rule=(rule (append-to-form ((? u) ? v) (? y) ((? u) ? z))
           (append-to-form (? v) (? y) (? z)))
pattern=(append-to-form (? 33 v) (? 33 y) (? 33 z))
frame=(((? 32 z) (? 33 u) ? 33 z) ((? 33 y) c)
                                  ((? 33 v))
                                  ((? 33 u) . b)
                                  ((? form) (? 32 u) ? 32 z)
                                  ((? 32 y) c)
                                  ((? 32 v) b)
                                  ((? 32 u) . a))

unify-result=failed
apply-a-rule
rule=(rule (append-to-form () (? y) (? y)))
pattern=(append-to-form (? 33 v) (? 33 y) (? 33 z))
frame=(((? 32 z) (? 33 u) ? 33 z) ((? 33 y) c)
                                  ((? 33 v))
                                  ((? 33 u) . b)
                                  ((? form) (? 32 u) ? 32 z)
                                  ((? 32 y) c)
                                  ((? 32 v) b)
                                  ((? 32 u) . a))

unify-result=(((? 33 z) c) ((? 35 y) c)
                           ((? 32 z) (? 33 u) ? 33 z)
                           ((? 33 y) c)
                           ((? 33 v))
                           ((? 33 u) . b)
                           ((? form) (? 32 u) ? 32 z)
                           ((? 32 y) c)
                           ((? 32 v) b)
                           ((? 32 u) . a))
(append-to-form (a b) (c) (a b c))
apply-a-rule
rule=(rule (append-to-form () (? y) (? y)))
pattern=(append-to-form (a b) (c) (? form))
frame=()

unify-result=failed
apply-a-rule
rule=(rule (append-to-form () (? y) (? y)))
pattern=(append-to-form (? 32 v) (? 32 y) (? 32 z))
frame=(((? form) (? 32 u) ? 32 z) ((? 32 y) c) ((? 32 v) b) ((? 32 u) . a))

unify-result=failed

;;; Query input:
(assert!
 (rule (all-but-last (? l) (? abl) (? e))
       (and (last-element (? l) (? e)) (append-to-form (? abl) ((? e)) (? l)))))
Assertion added to data base.
;;; Query input:
(all-but-last (a b c) (? abl) (? e))
;;; Query results:

debug:simple-query
apply-a-rule
rule=(rule (all-but-last (? l) (? abl) (? e))
           (and (last-element (? l) (? e))
                (append-to-form (? abl) ((? e)) (? l))))
pattern=(all-but-last (a b c) (? abl) (? e))
frame=()

unify-result=(((? e) ? 38 e) ((? abl) ? 38 abl) ((? 38 l) a b c))

debug:simple-query
apply-a-rule
rule=(rule (last-element (? x) (? e))
           (and (carcdr (? x) (? car) (? cdr))
                (or (and (empty-list (? cdr)) (same (? e) (? car)))
                    (last-element (? cdr) (? e)))))
pattern=(last-element (? 38 l) (? 38 e))
frame=(((? e) ? 38 e) ((? abl) ? 38 abl) ((? 38 l) a b c))

unify-result=(((? 38 e) ? 39 e) ((? 39 x) a b c)
                                ((? e) ? 38 e)
                                ((? abl) ? 38 abl)
                                ((? 38 l) a b c))

debug:simple-query
apply-a-rule
rule=(rule (carcdr ((? car) ? cdr) (? car) (? cdr)))
pattern=(carcdr (? 39 x) (? 39 car) (? 39 cdr))
frame=(((? 38 e) ? 39 e) ((? 39 x) a b c)
                         ((? e) ? 38 e)
                         ((? abl) ? 38 abl)
                         ((? 38 l) a b c))

unify-result=(((? 39 cdr) b c) ((? 39 car) . a)
                               ((? 40 cdr) b c)
                               ((? 40 car) . a)
                               ((? 38 e) ? 39 e)
                               ((? 39 x) a b c)
                               ((? e) ? 38 e)
                               ((? abl) ? 38 abl)
                               ((? 38 l) a b c))

debug:simple-query
apply-a-rule
rule=(rule (empty-list ()))
pattern=(empty-list (? 39 cdr))
frame=(((? 39 cdr) b c) ((? 39 car) . a)
                        ((? 40 cdr) b c)
                        ((? 40 car) . a)
                        ((? 38 e) ? 39 e)
                        ((? 39 x) a b c)
                        ((? e) ? 38 e)
                        ((? abl) ? 38 abl)
                        ((? 38 l) a b c))

unify-result=failed

debug:simple-query

debug:simple-query
apply-a-rule
rule=(rule (last-element (? x) (? e))
           (and (carcdr (? x) (? car) (? cdr))
                (or (and (empty-list (? cdr)) (same (? e) (? car)))
                    (last-element (? cdr) (? e)))))
pattern=(last-element (? 39 cdr) (? 39 e))
frame=(((? 39 cdr) b c) ((? 39 car) . a)
                        ((? 40 cdr) b c)
                        ((? 40 car) . a)
                        ((? 38 e) ? 39 e)
                        ((? 39 x) a b c)
                        ((? e) ? 38 e)
                        ((? abl) ? 38 abl)
                        ((? 38 l) a b c))

unify-result=(((? 39 e) ? 42 e) ((? 42 x) b c)
                                ((? 39 cdr) b c)
                                ((? 39 car) . a)
                                ((? 40 cdr) b c)
                                ((? 40 car) . a)
                                ((? 38 e) ? 39 e)
                                ((? 39 x) a b c)
                                ((? e) ? 38 e)
                                ((? abl) ? 38 abl)
                                ((? 38 l) a b c))

debug:simple-query
apply-a-rule
rule=(rule (carcdr ((? car) ? cdr) (? car) (? cdr)))
pattern=(carcdr (? 42 x) (? 42 car) (? 42 cdr))
frame=(((? 39 e) ? 42 e) ((? 42 x) b c)
                         ((? 39 cdr) b c)
                         ((? 39 car) . a)
                         ((? 40 cdr) b c)
                         ((? 40 car) . a)
                         ((? 38 e) ? 39 e)
                         ((? 39 x) a b c)
                         ((? e) ? 38 e)
                         ((? abl) ? 38 abl)
                         ((? 38 l) a b c))

unify-result=(((? 42 cdr) c) ((? 42 car) . b)
                             ((? 43 cdr) c)
                             ((? 43 car) . b)
                             ((? 39 e) ? 42 e)
                             ((? 42 x) b c)
                             ((? 39 cdr) b c)
                             ((? 39 car) . a)
                             ((? 40 cdr) b c)
                             ((? 40 car) . a)
                             ((? 38 e) ? 39 e)
                             ((? 39 x) a b c)
                             ((? e) ? 38 e)
                             ((? abl) ? 38 abl)
                             ((? 38 l) a b c))

debug:simple-query
apply-a-rule
rule=(rule (empty-list ()))
pattern=(empty-list (? 42 cdr))
frame=(((? 42 cdr) c) ((? 42 car) . b)
                      ((? 43 cdr) c)
                      ((? 43 car) . b)
                      ((? 39 e) ? 42 e)
                      ((? 42 x) b c)
                      ((? 39 cdr) b c)
                      ((? 39 car) . a)
                      ((? 40 cdr) b c)
                      ((? 40 car) . a)
                      ((? 38 e) ? 39 e)
                      ((? 39 x) a b c)
                      ((? e) ? 38 e)
                      ((? abl) ? 38 abl)
                      ((? 38 l) a b c))

unify-result=failed

debug:simple-query

debug:simple-query
apply-a-rule
rule=(rule (last-element (? x) (? e))
           (and (carcdr (? x) (? car) (? cdr))
                (or (and (empty-list (? cdr)) (same (? e) (? car)))
                    (last-element (? cdr) (? e)))))
pattern=(last-element (? 42 cdr) (? 42 e))
frame=(((? 42 cdr) c) ((? 42 car) . b)
                      ((? 43 cdr) c)
                      ((? 43 car) . b)
                      ((? 39 e) ? 42 e)
                      ((? 42 x) b c)
                      ((? 39 cdr) b c)
                      ((? 39 car) . a)
                      ((? 40 cdr) b c)
                      ((? 40 car) . a)
                      ((? 38 e) ? 39 e)
                      ((? 39 x) a b c)
                      ((? e) ? 38 e)
                      ((? abl) ? 38 abl)
                      ((? 38 l) a b c))

unify-result=(((? 42 e) ? 45 e) ((? 45 x) c)
                                ((? 42 cdr) c)
                                ((? 42 car) . b)
                                ((? 43 cdr) c)
                                ((? 43 car) . b)
                                ((? 39 e) ? 42 e)
                                ((? 42 x) b c)
                                ((? 39 cdr) b c)
                                ((? 39 car) . a)
                                ((? 40 cdr) b c)
                                ((? 40 car) . a)
                                ((? 38 e) ? 39 e)
                                ((? 39 x) a b c)
                                ((? e) ? 38 e)
                                ((? abl) ? 38 abl)
                                ((? 38 l) a b c))

debug:simple-query
apply-a-rule
rule=(rule (carcdr ((? car) ? cdr) (? car) (? cdr)))
pattern=(carcdr (? 45 x) (? 45 car) (? 45 cdr))
frame=(((? 42 e) ? 45 e) ((? 45 x) c)
                         ((? 42 cdr) c)
                         ((? 42 car) . b)
                         ((? 43 cdr) c)
                         ((? 43 car) . b)
                         ((? 39 e) ? 42 e)
                         ((? 42 x) b c)
                         ((? 39 cdr) b c)
                         ((? 39 car) . a)
                         ((? 40 cdr) b c)
                         ((? 40 car) . a)
                         ((? 38 e) ? 39 e)
                         ((? 39 x) a b c)
                         ((? e) ? 38 e)
                         ((? abl) ? 38 abl)
                         ((? 38 l) a b c))

unify-result=(((? 45 cdr)) ((? 45 car) . c)
                           ((? 46 cdr))
                           ((? 46 car) . c)
                           ((? 42 e) ? 45 e)
                           ((? 45 x) c)
                           ((? 42 cdr) c)
                           ((? 42 car) . b)
                           ((? 43 cdr) c)
                           ((? 43 car) . b)
                           ((? 39 e) ? 42 e)
                           ((? 42 x) b c)
                           ((? 39 cdr) b c)
                           ((? 39 car) . a)
                           ((? 40 cdr) b c)
                           ((? 40 car) . a)
                           ((? 38 e) ? 39 e)
                           ((? 39 x) a b c)
                           ((? e) ? 38 e)
                           ((? abl) ? 38 abl)
                           ((? 38 l) a b c))

debug:simple-query
apply-a-rule
rule=(rule (empty-list ()))
pattern=(empty-list (? 45 cdr))
frame=(((? 45 cdr)) ((? 45 car) . c)
                    ((? 46 cdr))
                    ((? 46 car) . c)
                    ((? 42 e) ? 45 e)
                    ((? 45 x) c)
                    ((? 42 cdr) c)
                    ((? 42 car) . b)
                    ((? 43 cdr) c)
                    ((? 43 car) . b)
                    ((? 39 e) ? 42 e)
                    ((? 42 x) b c)
                    ((? 39 cdr) b c)
                    ((? 39 car) . a)
                    ((? 40 cdr) b c)
                    ((? 40 car) . a)
                    ((? 38 e) ? 39 e)
                    ((? 39 x) a b c)
                    ((? e) ? 38 e)
                    ((? abl) ? 38 abl)
                    ((? 38 l) a b c))

unify-result=(((? 45 cdr)) ((? 45 car) . c)
                           ((? 46 cdr))
                           ((? 46 car) . c)
                           ((? 42 e) ? 45 e)
                           ((? 45 x) c)
                           ((? 42 cdr) c)
                           ((? 42 car) . b)
                           ((? 43 cdr) c)
                           ((? 43 car) . b)
                           ((? 39 e) ? 42 e)
                           ((? 42 x) b c)
                           ((? 39 cdr) b c)
                           ((? 39 car) . a)
                           ((? 40 cdr) b c)
                           ((? 40 car) . a)
                           ((? 38 e) ? 39 e)
                           ((? 39 x) a b c)
                           ((? e) ? 38 e)
                           ((? abl) ? 38 abl)
                           ((? 38 l) a b c))

debug:simple-query
apply-a-rule
rule=(rule (same (? x) (? x)))
pattern=(same (? 45 e) (? 45 car))
frame=(((? 45 cdr)) ((? 45 car) . c)
                    ((? 46 cdr))
                    ((? 46 car) . c)
                    ((? 42 e) ? 45 e)
                    ((? 45 x) c)
                    ((? 42 cdr) c)
                    ((? 42 car) . b)
                    ((? 43 cdr) c)
                    ((? 43 car) . b)
                    ((? 39 e) ? 42 e)
                    ((? 42 x) b c)
                    ((? 39 cdr) b c)
                    ((? 39 car) . a)
                    ((? 40 cdr) b c)
                    ((? 40 car) . a)
                    ((? 38 e) ? 39 e)
                    ((? 39 x) a b c)
                    ((? e) ? 38 e)
                    ((? abl) ? 38 abl)
                    ((? 38 l) a b c))

unify-result=(((? 48 x) . c)     ((? 45 e) ? 48 x)  ((? 45 cdr))       ((? 45 car) . c)
              ((? 46 cdr))       ((? 46 car) . c)   ((? 42 e) ? 45 e)  ((? 45 x) c)
              ((? 42 cdr) c)     ((? 42 car) . b)   ((? 43 cdr) c)     ((? 43 car) . b)
              ((? 39 e) ? 42 e)  ((? 42 x) b c)     ((? 39 cdr) b c)   ((? 39 car) . a)
              ((? 40 cdr) b c)   ((? 40 car) . a)   ((? 38 e) ? 39 e)  ((? 39 x) a b c)
              ((? e) ? 38 e)     ((? abl) ? 38 abl) ((? 38 l) a b c))

debug:simple-query
apply-a-rule
rule=(rule (append-to-form ((? u) ? v) (? y) ((? u) ? z))
           (append-to-form (? v) (? y) (? z)))
pattern=(append-to-form (? 38 abl) ((? 38 e)) (? 38 l))
frame=(((? 48 x) . c)     ((? 45 e) ? 48 x)  ((? 45 cdr))       ((? 45 car) . c)
       ((? 46 cdr))       ((? 46 car) . c)   ((? 42 e) ? 45 e)  ((? 45 x) c)
       ((? 42 cdr) c)     ((? 42 car) . b)   ((? 43 cdr) c)     ((? 43 car) . b)
       ((? 39 e) ? 42 e)  ((? 42 x) b c)     ((? 39 cdr) b c)   ((? 39 car) . a)
       ((? 40 cdr) b c)   ((? 40 car) . a)   ((? 38 e) ? 39 e)  ((? 39 x) a b c)
       ((? e) ? 38 e)     ((? abl) ? 38 abl) ((? 38 l) a b c))

unify-result=(((? 49 z) b c) ((? 49 u) . a)
                             ((? 49 y) (? 38 e))
                             ((? 38 abl) (? 49 u) ? 49 v)
                             ((? 48 x) . c)
                             ((? 45 e) ? 48 x)
                             ((? 45 cdr))
                             ((? 45 car) . c)
                             ((? 46 cdr))
                             ((? 46 car) . c)
                             ((? 42 e) ? 45 e)
                             ((? 45 x) c)
                             ((? 42 cdr) c)
                             ((? 42 car) . b)
                             ((? 43 cdr) c)
                             ((? 43 car) . b)
                             ((? 39 e) ? 42 e)
                             ((? 42 x) b c)
                             ((? 39 cdr) b c)
                             ((? 39 car) . a)
                             ((? 40 cdr) b c)
                             ((? 40 car) . a)
                             ((? 38 e) ? 39 e)
                             ((? 39 x) a b c)
                             ((? e) ? 38 e)
                             ((? abl) ? 38 abl)
                             ((? 38 l) a b c))

debug:simple-query
apply-a-rule
rule=(rule (append-to-form ((? u) ? v) (? y) ((? u) ? z))
           (append-to-form (? v) (? y) (? z)))
pattern=(append-to-form (? 49 v) (? 49 y) (? 49 z))
frame=(((? 49 z) b c) ((? 49 u) . a)
                      ((? 49 y) (? 38 e))
                      ((? 38 abl) (? 49 u) ? 49 v)
                      ((? 48 x) . c)
                      ((? 45 e) ? 48 x)
                      ((? 45 cdr))
                      ((? 45 car) . c)
                      ((? 46 cdr))
                      ((? 46 car) . c)
                      ((? 42 e) ? 45 e)
                      ((? 45 x) c)
                      ((? 42 cdr) c)
                      ((? 42 car) . b)
                      ((? 43 cdr) c)
                      ((? 43 car) . b)
                      ((? 39 e) ? 42 e)
                      ((? 42 x) b c)
                      ((? 39 cdr) b c)
                      ((? 39 car) . a)
                      ((? 40 cdr) b c)
                      ((? 40 car) . a)
                      ((? 38 e) ? 39 e)
                      ((? 39 x) a b c)
                      ((? e) ? 38 e)
                      ((? abl) ? 38 abl)
                      ((? 38 l) a b c))

unify-result=(((? 50 z) c) ((? 50 u) . b)
                           ((? 50 y) (? 38 e))
                           ((? 49 v) (? 50 u) ? 50 v)
                           ((? 49 z) b c)
                           ((? 49 u) . a)
                           ((? 49 y) (? 38 e))
                           ((? 38 abl) (? 49 u) ? 49 v)
                           ((? 48 x) . c)
                           ((? 45 e) ? 48 x)
                           ((? 45 cdr))
                           ((? 45 car) . c)
                           ((? 46 cdr))
                           ((? 46 car) . c)
                           ((? 42 e) ? 45 e)
                           ((? 45 x) c)
                           ((? 42 cdr) c)
                           ((? 42 car) . b)
                           ((? 43 cdr) c)
                           ((? 43 car) . b)
                           ((? 39 e) ? 42 e)
                           ((? 42 x) b c)
                           ((? 39 cdr) b c)
                           ((? 39 car) . a)
                           ((? 40 cdr) b c)
                           ((? 40 car) . a)
                           ((? 38 e) ? 39 e)
                           ((? 39 x) a b c)
                           ((? e) ? 38 e)
                           ((? abl) ? 38 abl)
                           ((? 38 l) a b c))

debug:simple-query
apply-a-rule
rule=(rule (append-to-form ((? u) ? v) (? y) ((? u) ? z))
           (append-to-form (? v) (? y) (? z)))
pattern=(append-to-form (? 50 v) (? 50 y) (? 50 z))
frame=(((? 50 z) c) ((? 50 u) . b)
                    ((? 50 y) (? 38 e))
                    ((? 49 v) (? 50 u) ? 50 v)
                    ((? 49 z) b c)
                    ((? 49 u) . a)
                    ((? 49 y) (? 38 e))
                    ((? 38 abl) (? 49 u) ? 49 v)
                    ((? 48 x) . c)
                    ((? 45 e) ? 48 x)
                    ((? 45 cdr))
                    ((? 45 car) . c)
                    ((? 46 cdr))
                    ((? 46 car) . c)
                    ((? 42 e) ? 45 e)
                    ((? 45 x) c)
                    ((? 42 cdr) c)
                    ((? 42 car) . b)
                    ((? 43 cdr) c)
                    ((? 43 car) . b)
                    ((? 39 e) ? 42 e)
                    ((? 42 x) b c)
                    ((? 39 cdr) b c)
                    ((? 39 car) . a)
                    ((? 40 cdr) b c)
                    ((? 40 car) . a)
                    ((? 38 e) ? 39 e)
                    ((? 39 x) a b c)
                    ((? e) ? 38 e)
                    ((? abl) ? 38 abl)
                    ((? 38 l) a b c))

unify-result=(((? 51 z)) ((? 51 u) . c)
                         ((? 51 y) (? 38 e))
                         ((? 50 v) (? 51 u) ? 51 v)
                         ((? 50 z) c)
                         ((? 50 u) . b)
                         ((? 50 y) (? 38 e))
                         ((? 49 v) (? 50 u) ? 50 v)
                         ((? 49 z) b c)
                         ((? 49 u) . a)
                         ((? 49 y) (? 38 e))
                         ((? 38 abl) (? 49 u) ? 49 v)
                         ((? 48 x) . c)
                         ((? 45 e) ? 48 x)
                         ((? 45 cdr))
                         ((? 45 car) . c)
                         ((? 46 cdr))
                         ((? 46 car) . c)
                         ((? 42 e) ? 45 e)
                         ((? 45 x) c)
                         ((? 42 cdr) c)
                         ((? 42 car) . b)
                         ((? 43 cdr) c)
                         ((? 43 car) . b)
                         ((? 39 e) ? 42 e)
                         ((? 42 x) b c)
                         ((? 39 cdr) b c)
                         ((? 39 car) . a)
                         ((? 40 cdr) b c)
                         ((? 40 car) . a)
                         ((? 38 e) ? 39 e)
                         ((? 39 x) a b c)
                         ((? e) ? 38 e)
                         ((? abl) ? 38 abl)
                         ((? 38 l) a b c))

debug:simple-query
apply-a-rule
rule=(rule (append-to-form ((? u) ? v) (? y) ((? u) ? z))
           (append-to-form (? v) (? y) (? z)))
pattern=(append-to-form (? 51 v) (? 51 y) (? 51 z))
frame=(((? 51 z)) ((? 51 u) . c)
                  ((? 51 y) (? 38 e))
                  ((? 50 v) (? 51 u) ? 51 v)
                  ((? 50 z) c)
                  ((? 50 u) . b)
                  ((? 50 y) (? 38 e))
                  ((? 49 v) (? 50 u) ? 50 v)
                  ((? 49 z) b c)
                  ((? 49 u) . a)
                  ((? 49 y) (? 38 e))
                  ((? 38 abl) (? 49 u) ? 49 v)
                  ((? 48 x) . c)
                  ((? 45 e) ? 48 x)
                  ((? 45 cdr))
                  ((? 45 car) . c)
                  ((? 46 cdr))
                  ((? 46 car) . c)
                  ((? 42 e) ? 45 e)
                  ((? 45 x) c)
                  ((? 42 cdr) c)
                  ((? 42 car) . b)
                  ((? 43 cdr) c)
                  ((? 43 car) . b)
                  ((? 39 e) ? 42 e)
                  ((? 42 x) b c)
                  ((? 39 cdr) b c)
                  ((? 39 car) . a)
                  ((? 40 cdr) b c)
                  ((? 40 car) . a)
                  ((? 38 e) ? 39 e)
                  ((? 39 x) a b c)
                  ((? e) ? 38 e)
                  ((? abl) ? 38 abl)
                  ((? 38 l) a b c))

unify-result=failed
apply-a-rule
rule=(rule (append-to-form () (? y) (? y)))
pattern=(append-to-form (? 51 v) (? 51 y) (? 51 z))
frame=(((? 51 z)) ((? 51 u) . c)
                  ((? 51 y) (? 38 e))
                  ((? 50 v) (? 51 u) ? 51 v)
                  ((? 50 z) c)
                  ((? 50 u) . b)
                  ((? 50 y) (? 38 e))
                  ((? 49 v) (? 50 u) ? 50 v)
                  ((? 49 z) b c)
                  ((? 49 u) . a)
                  ((? 49 y) (? 38 e))
                  ((? 38 abl) (? 49 u) ? 49 v)
                  ((? 48 x) . c)
                  ((? 45 e) ? 48 x)
                  ((? 45 cdr))
                  ((? 45 car) . c)
                  ((? 46 cdr))
                  ((? 46 car) . c)
                  ((? 42 e) ? 45 e)
                  ((? 45 x) c)
                  ((? 42 cdr) c)
                  ((? 42 car) . b)
                  ((? 43 cdr) c)
                  ((? 43 car) . b)
                  ((? 39 e) ? 42 e)
                  ((? 42 x) b c)
                  ((? 39 cdr) b c)
                  ((? 39 car) . a)
                  ((? 40 cdr) b c)
                  ((? 40 car) . a)
                  ((? 38 e) ? 39 e)
                  ((? 39 x) a b c)
                  ((? e) ? 38 e)
                  ((? abl) ? 38 abl)
                  ((? 38 l) a b c))

unify-result=failed
apply-a-rule
rule=(rule (append-to-form () (? y) (? y)))
pattern=(append-to-form (? 50 v) (? 50 y) (? 50 z))
frame=(((? 50 z) c) ((? 50 u) . b)
                    ((? 50 y) (? 38 e))
                    ((? 49 v) (? 50 u) ? 50 v)
                    ((? 49 z) b c)
                    ((? 49 u) . a)
                    ((? 49 y) (? 38 e))
                    ((? 38 abl) (? 49 u) ? 49 v)
                    ((? 48 x) . c)
                    ((? 45 e) ? 48 x)
                    ((? 45 cdr))
                    ((? 45 car) . c)
                    ((? 46 cdr))
                    ((? 46 car) . c)
                    ((? 42 e) ? 45 e)
                    ((? 45 x) c)
                    ((? 42 cdr) c)
                    ((? 42 car) . b)
                    ((? 43 cdr) c)
                    ((? 43 car) . b)
                    ((? 39 e) ? 42 e)
                    ((? 42 x) b c)
                    ((? 39 cdr) b c)
                    ((? 39 car) . a)
                    ((? 40 cdr) b c)
                    ((? 40 car) . a)
                    ((? 38 e) ? 39 e)
                    ((? 39 x) a b c)
                    ((? e) ? 38 e)
                    ((? abl) ? 38 abl)
                    ((? 38 l) a b c))

unify-result=(((? 54 y) (? 38 e)) ((? 50 v))
                                  ((? 50 z) c)
                                  ((? 50 u) . b)
                                  ((? 50 y) (? 38 e))
                                  ((? 49 v) (? 50 u) ? 50 v)
                                  ((? 49 z) b c)
                                  ((? 49 u) . a)
                                  ((? 49 y) (? 38 e))
                                  ((? 38 abl) (? 49 u) ? 49 v)
                                  ((? 48 x) . c)
                                  ((? 45 e) ? 48 x)
                                  ((? 45 cdr))
                                  ((? 45 car) . c)
                                  ((? 46 cdr))
                                  ((? 46 car) . c)
                                  ((? 42 e) ? 45 e)
                                  ((? 45 x) c)
                                  ((? 42 cdr) c)
                                  ((? 42 car) . b)
                                  ((? 43 cdr) c)
                                  ((? 43 car) . b)
                                  ((? 39 e) ? 42 e)
                                  ((? 42 x) b c)
                                  ((? 39 cdr) b c)
                                  ((? 39 car) . a)
                                  ((? 40 cdr) b c)
                                  ((? 40 car) . a)
                                  ((? 38 e) ? 39 e)
                                  ((? 39 x) a b c)
                                  ((? e) ? 38 e)
                                  ((? abl) ? 38 abl)
                                  ((? 38 l) a b c))
(all-but-last (a b c) (a b) c)

debug:simple-query
apply-a-rule
rule=(rule (last-element (? x) (? e))
           (and (carcdr (? x) (? car) (? cdr))
                (or (and (empty-list (? cdr)) (same (? e) (? car)))
                    (last-element (? cdr) (? e)))))
pattern=(last-element (? 45 cdr) (? 45 e))
frame=(((? 45 cdr)) ((? 45 car) . c)
                    ((? 46 cdr))
                    ((? 46 car) . c)
                    ((? 42 e) ? 45 e)
                    ((? 45 x) c)
                    ((? 42 cdr) c)
                    ((? 42 car) . b)
                    ((? 43 cdr) c)
                    ((? 43 car) . b)
                    ((? 39 e) ? 42 e)
                    ((? 42 x) b c)
                    ((? 39 cdr) b c)
                    ((? 39 car) . a)
                    ((? 40 cdr) b c)
                    ((? 40 car) . a)
                    ((? 38 e) ? 39 e)
                    ((? 39 x) a b c)
                    ((? e) ? 38 e)
                    ((? abl) ? 38 abl)
                    ((? 38 l) a b c))

unify-result=(((? 45 e) ? 55 e) ((? 55 x))
                                ((? 45 cdr))
                                ((? 45 car) . c)
                                ((? 46 cdr))
                                ((? 46 car) . c)
                                ((? 42 e) ? 45 e)
                                ((? 45 x) c)
                                ((? 42 cdr) c)
                                ((? 42 car) . b)
                                ((? 43 cdr) c)
                                ((? 43 car) . b)
                                ((? 39 e) ? 42 e)
                                ((? 42 x) b c)
                                ((? 39 cdr) b c)
                                ((? 39 car) . a)
                                ((? 40 cdr) b c)
                                ((? 40 car) . a)
                                ((? 38 e) ? 39 e)
                                ((? 39 x) a b c)
                                ((? e) ? 38 e)
                                ((? abl) ? 38 abl)
                                ((? 38 l) a b c))

debug:simple-query
apply-a-rule
rule=(rule (carcdr ((? car) ? cdr) (? car) (? cdr)))
pattern=(carcdr (? 55 x) (? 55 car) (? 55 cdr))
frame=(((? 45 e) ? 55 e) ((? 55 x))
                         ((? 45 cdr))
                         ((? 45 car) . c)
                         ((? 46 cdr))
                         ((? 46 car) . c)
                         ((? 42 e) ? 45 e)
                         ((? 45 x) c)
                         ((? 42 cdr) c)
                         ((? 42 car) . b)
                         ((? 43 cdr) c)
                         ((? 43 car) . b)
                         ((? 39 e) ? 42 e)
                         ((? 42 x) b c)
                         ((? 39 cdr) b c)
                         ((? 39 car) . a)
                         ((? 40 cdr) b c)
                         ((? 40 car) . a)
                         ((? 38 e) ? 39 e)
                         ((? 39 x) a b c)
                         ((? e) ? 38 e)
                         ((? abl) ? 38 abl)
                         ((? 38 l) a b c))

unify-result=failed

debug:simple-query

debug:simple-query

debug:simple-query
apply-a-rule
rule=(rule (append-to-form () (? y) (? y)))
pattern=(append-to-form (? 38 abl) ((? 38 e)) (? 38 l))
frame=(((? 48 x) . c)     ((? 45 e) ? 48 x)  ((? 45 cdr))       ((? 45 car) . c)
       ((? 46 cdr))       ((? 46 car) . c)   ((? 42 e) ? 45 e)  ((? 45 x) c)
       ((? 42 cdr) c)     ((? 42 car) . b)   ((? 43 cdr) c)     ((? 43 car) . b)
       ((? 39 e) ? 42 e)  ((? 42 x) b c)     ((? 39 cdr) b c)   ((? 39 car) . a)
       ((? 40 cdr) b c)   ((? 40 car) . a)   ((? 38 e) ? 39 e)  ((? 39 x) a b c)
       ((? e) ? 38 e)     ((? abl) ? 38 abl) ((? 38 l) a b c))

unify-result=failed
apply-a-rule
rule=(rule (append-to-form () (? y) (? y)))
pattern=(append-to-form (? 49 v) (? 49 y) (? 49 z))
frame=(((? 49 z) b c) ((? 49 u) . a)
                      ((? 49 y) (? 38 e))
                      ((? 38 abl) (? 49 u) ? 49 v)
                      ((? 48 x) . c)
                      ((? 45 e) ? 48 x)
                      ((? 45 cdr))
                      ((? 45 car) . c)
                      ((? 46 cdr))
                      ((? 46 car) . c)
                      ((? 42 e) ? 45 e)
                      ((? 45 x) c)
                      ((? 42 cdr) c)
                      ((? 42 car) . b)
                      ((? 43 cdr) c)
                      ((? 43 car) . b)
                      ((? 39 e) ? 42 e)
                      ((? 42 x) b c)
                      ((? 39 cdr) b c)
                      ((? 39 car) . a)
                      ((? 40 cdr) b c)
                      ((? 40 car) . a)
                      ((? 38 e) ? 39 e)
                      ((? 39 x) a b c)
                      ((? e) ? 38 e)
                      ((? abl) ? 38 abl)
                      ((? 38 l) a b c))

unify-result=failed

;;; Query input:
(assert! (rule (reverse-left () ())))
Assertion added to data base.
;;; Query input:
(assert!
 (rule (reverse-left (? a) (? b))
       (and (carcdr (? a) (? car) (? cdr))
            (reverse-left (? cdr) (? rcdr))
            (append-to-form (? rcdr) ((? car)) (? b)))))
Assertion added to data base.
;;; Query input:
(assert! (rule (reverse-right () ())))
Assertion added to data base.
;;; Query input:
(assert!
 (rule (reverse-right (? a) (? b))
       (and (carcdr (? b) (? car) (? cdr))
            (reverse-right (? rcdr) (? cdr))
            (append-to-form (? rcdr) ((? car)) (? a)))))
Assertion added to data base.
;;; Query input:
(reverse-left () (? y))
;;; Query results:

debug:simple-query
apply-a-rule
rule=(rule (reverse-left (? a) (? b))
           (and (carcdr (? a) (? car) (? cdr))
                (reverse-left (? cdr) (? rcdr))
                (append-to-form (? rcdr) ((? car)) (? b))))
pattern=(reverse-left () (? y))
frame=()

unify-result=(((? y) ? 59 b) ((? 59 a)))

debug:simple-query
apply-a-rule
rule=(rule (carcdr ((? car) ? cdr) (? car) (? cdr)))
pattern=(carcdr (? 59 a) (? 59 car) (? 59 cdr))
frame=(((? y) ? 59 b) ((? 59 a)))

unify-result=failed

debug:simple-query

debug:simple-query
apply-a-rule
rule=(rule (reverse-left () ()))
pattern=(reverse-left () (? y))
frame=()

unify-result=(((? y)))
(reverse-left () ())

;;; Query input:
(reverse-left (a) (? y))
;;; Query results:

debug:simple-query
apply-a-rule
rule=(rule (reverse-left (? a) (? b))
           (and (carcdr (? a) (? car) (? cdr))
                (reverse-left (? cdr) (? rcdr))
                (append-to-form (? rcdr) ((? car)) (? b))))
pattern=(reverse-left (a) (? y))
frame=()

unify-result=(((? y) ? 62 b) ((? 62 a) a))

debug:simple-query
apply-a-rule
rule=(rule (carcdr ((? car) ? cdr) (? car) (? cdr)))
pattern=(carcdr (? 62 a) (? 62 car) (? 62 cdr))
frame=(((? y) ? 62 b) ((? 62 a) a))

unify-result=(((? 62 cdr)) ((? 62 car) . a)
                           ((? 63 cdr))
                           ((? 63 car) . a)
                           ((? y) ? 62 b)
                           ((? 62 a) a))

debug:simple-query
apply-a-rule
rule=(rule (reverse-left (? a) (? b))
           (and (carcdr (? a) (? car) (? cdr))
                (reverse-left (? cdr) (? rcdr))
                (append-to-form (? rcdr) ((? car)) (? b))))
pattern=(reverse-left (? 62 cdr) (? 62 rcdr))
frame=(((? 62 cdr)) ((? 62 car) . a)
                    ((? 63 cdr))
                    ((? 63 car) . a)
                    ((? y) ? 62 b)
                    ((? 62 a) a))

unify-result=(((? 62 rcdr) ? 64 b) ((? 64 a))
                                   ((? 62 cdr))
                                   ((? 62 car) . a)
                                   ((? 63 cdr))
                                   ((? 63 car) . a)
                                   ((? y) ? 62 b)
                                   ((? 62 a) a))

debug:simple-query
apply-a-rule
rule=(rule (carcdr ((? car) ? cdr) (? car) (? cdr)))
pattern=(carcdr (? 64 a) (? 64 car) (? 64 cdr))
frame=(((? 62 rcdr) ? 64 b) ((? 64 a))
                            ((? 62 cdr))
                            ((? 62 car) . a)
                            ((? 63 cdr))
                            ((? 63 car) . a)
                            ((? y) ? 62 b)
                            ((? 62 a) a))

unify-result=failed

debug:simple-query

debug:simple-query
apply-a-rule
rule=(rule (reverse-left () ()))
pattern=(reverse-left (? 62 cdr) (? 62 rcdr))
frame=(((? 62 cdr)) ((? 62 car) . a)
                    ((? 63 cdr))
                    ((? 63 car) . a)
                    ((? y) ? 62 b)
                    ((? 62 a) a))

unify-result=(((? 62 rcdr)) ((? 62 cdr))
                            ((? 62 car) . a)
                            ((? 63 cdr))
                            ((? 63 car) . a)
                            ((? y) ? 62 b)
                            ((? 62 a) a))

debug:simple-query
apply-a-rule
rule=(rule (append-to-form ((? u) ? v) (? y) ((? u) ? z))
           (append-to-form (? v) (? y) (? z)))
pattern=(append-to-form (? 62 rcdr) ((? 62 car)) (? 62 b))
frame=(((? 62 rcdr)) ((? 62 cdr))
                     ((? 62 car) . a)
                     ((? 63 cdr))
                     ((? 63 car) . a)
                     ((? y) ? 62 b)
                     ((? 62 a) a))

unify-result=failed
apply-a-rule
rule=(rule (append-to-form () (? y) (? y)))
pattern=(append-to-form (? 62 rcdr) ((? 62 car)) (? 62 b))
frame=(((? 62 rcdr)) ((? 62 cdr))
                     ((? 62 car) . a)
                     ((? 63 cdr))
                     ((? 63 car) . a)
                     ((? y) ? 62 b)
                     ((? 62 a) a))

unify-result=(((? 62 b) (? 62 car)) ((? 68 y) (? 62 car))
                                    ((? 62 rcdr))
                                    ((? 62 cdr))
                                    ((? 62 car) . a)
                                    ((? 63 cdr))
                                    ((? 63 car) . a)
                                    ((? y) ? 62 b)
                                    ((? 62 a) a))
(reverse-left (a) (a))
apply-a-rule
rule=(rule (reverse-left () ()))
pattern=(reverse-left (a) (? y))
frame=()

unify-result=failed

;;; Query input:
(reverse-left (a b) (? y))
;;; Query results:

debug:simple-query
apply-a-rule
rule=(rule (reverse-left (? a) (? b))
           (and (carcdr (? a) (? car) (? cdr))
                (reverse-left (? cdr) (? rcdr))
                (append-to-form (? rcdr) ((? car)) (? b))))
pattern=(reverse-left (a b) (? y))
frame=()

unify-result=(((? y) ? 70 b) ((? 70 a) a b))

debug:simple-query
apply-a-rule
rule=(rule (carcdr ((? car) ? cdr) (? car) (? cdr)))
pattern=(carcdr (? 70 a) (? 70 car) (? 70 cdr))
frame=(((? y) ? 70 b) ((? 70 a) a b))

unify-result=(((? 70 cdr) b) ((? 70 car) . a)
                             ((? 71 cdr) b)
                             ((? 71 car) . a)
                             ((? y) ? 70 b)
                             ((? 70 a) a b))

debug:simple-query
apply-a-rule
rule=(rule (reverse-left (? a) (? b))
           (and (carcdr (? a) (? car) (? cdr))
                (reverse-left (? cdr) (? rcdr))
                (append-to-form (? rcdr) ((? car)) (? b))))
pattern=(reverse-left (? 70 cdr) (? 70 rcdr))
frame=(((? 70 cdr) b) ((? 70 car) . a)
                      ((? 71 cdr) b)
                      ((? 71 car) . a)
                      ((? y) ? 70 b)
                      ((? 70 a) a b))

unify-result=(((? 70 rcdr) ? 72 b) ((? 72 a) b)
                                   ((? 70 cdr) b)
                                   ((? 70 car) . a)
                                   ((? 71 cdr) b)
                                   ((? 71 car) . a)
                                   ((? y) ? 70 b)
                                   ((? 70 a) a b))

debug:simple-query
apply-a-rule
rule=(rule (carcdr ((? car) ? cdr) (? car) (? cdr)))
pattern=(carcdr (? 72 a) (? 72 car) (? 72 cdr))
frame=(((? 70 rcdr) ? 72 b) ((? 72 a) b)
                            ((? 70 cdr) b)
                            ((? 70 car) . a)
                            ((? 71 cdr) b)
                            ((? 71 car) . a)
                            ((? y) ? 70 b)
                            ((? 70 a) a b))

unify-result=(((? 72 cdr)) ((? 72 car) . b)
                           ((? 73 cdr))
                           ((? 73 car) . b)
                           ((? 70 rcdr) ? 72 b)
                           ((? 72 a) b)
                           ((? 70 cdr) b)
                           ((? 70 car) . a)
                           ((? 71 cdr) b)
                           ((? 71 car) . a)
                           ((? y) ? 70 b)
                           ((? 70 a) a b))

debug:simple-query
apply-a-rule
rule=(rule (reverse-left (? a) (? b))
           (and (carcdr (? a) (? car) (? cdr))
                (reverse-left (? cdr) (? rcdr))
                (append-to-form (? rcdr) ((? car)) (? b))))
pattern=(reverse-left (? 72 cdr) (? 72 rcdr))
frame=(((? 72 cdr)) ((? 72 car) . b)
                    ((? 73 cdr))
                    ((? 73 car) . b)
                    ((? 70 rcdr) ? 72 b)
                    ((? 72 a) b)
                    ((? 70 cdr) b)
                    ((? 70 car) . a)
                    ((? 71 cdr) b)
                    ((? 71 car) . a)
                    ((? y) ? 70 b)
                    ((? 70 a) a b))

unify-result=(((? 72 rcdr) ? 74 b) ((? 74 a))
                                   ((? 72 cdr))
                                   ((? 72 car) . b)
                                   ((? 73 cdr))
                                   ((? 73 car) . b)
                                   ((? 70 rcdr) ? 72 b)
                                   ((? 72 a) b)
                                   ((? 70 cdr) b)
                                   ((? 70 car) . a)
                                   ((? 71 cdr) b)
                                   ((? 71 car) . a)
                                   ((? y) ? 70 b)
                                   ((? 70 a) a b))

debug:simple-query
apply-a-rule
rule=(rule (carcdr ((? car) ? cdr) (? car) (? cdr)))
pattern=(carcdr (? 74 a) (? 74 car) (? 74 cdr))
frame=(((? 72 rcdr) ? 74 b) ((? 74 a))
                            ((? 72 cdr))
                            ((? 72 car) . b)
                            ((? 73 cdr))
                            ((? 73 car) . b)
                            ((? 70 rcdr) ? 72 b)
                            ((? 72 a) b)
                            ((? 70 cdr) b)
                            ((? 70 car) . a)
                            ((? 71 cdr) b)
                            ((? 71 car) . a)
                            ((? y) ? 70 b)
                            ((? 70 a) a b))

unify-result=failed

debug:simple-query

debug:simple-query
apply-a-rule
rule=(rule (reverse-left () ()))
pattern=(reverse-left (? 72 cdr) (? 72 rcdr))
frame=(((? 72 cdr)) ((? 72 car) . b)
                    ((? 73 cdr))
                    ((? 73 car) . b)
                    ((? 70 rcdr) ? 72 b)
                    ((? 72 a) b)
                    ((? 70 cdr) b)
                    ((? 70 car) . a)
                    ((? 71 cdr) b)
                    ((? 71 car) . a)
                    ((? y) ? 70 b)
                    ((? 70 a) a b))

unify-result=(((? 72 rcdr)) ((? 72 cdr))
                            ((? 72 car) . b)
                            ((? 73 cdr))
                            ((? 73 car) . b)
                            ((? 70 rcdr) ? 72 b)
                            ((? 72 a) b)
                            ((? 70 cdr) b)
                            ((? 70 car) . a)
                            ((? 71 cdr) b)
                            ((? 71 car) . a)
                            ((? y) ? 70 b)
                            ((? 70 a) a b))

debug:simple-query
apply-a-rule
rule=(rule (append-to-form ((? u) ? v) (? y) ((? u) ? z))
           (append-to-form (? v) (? y) (? z)))
pattern=(append-to-form (? 72 rcdr) ((? 72 car)) (? 72 b))
frame=(((? 72 rcdr)) ((? 72 cdr))
                     ((? 72 car) . b)
                     ((? 73 cdr))
                     ((? 73 car) . b)
                     ((? 70 rcdr) ? 72 b)
                     ((? 72 a) b)
                     ((? 70 cdr) b)
                     ((? 70 car) . a)
                     ((? 71 cdr) b)
                     ((? 71 car) . a)
                     ((? y) ? 70 b)
                     ((? 70 a) a b))

unify-result=failed
apply-a-rule
rule=(rule (append-to-form () (? y) (? y)))
pattern=(append-to-form (? 72 rcdr) ((? 72 car)) (? 72 b))
frame=(((? 72 rcdr)) ((? 72 cdr))
                     ((? 72 car) . b)
                     ((? 73 cdr))
                     ((? 73 car) . b)
                     ((? 70 rcdr) ? 72 b)
                     ((? 72 a) b)
                     ((? 70 cdr) b)
                     ((? 70 car) . a)
                     ((? 71 cdr) b)
                     ((? 71 car) . a)
                     ((? y) ? 70 b)
                     ((? 70 a) a b))

unify-result=(((? 72 b) (? 72 car)) ((? 78 y) (? 72 car))
                                    ((? 72 rcdr))
                                    ((? 72 cdr))
                                    ((? 72 car) . b)
                                    ((? 73 cdr))
                                    ((? 73 car) . b)
                                    ((? 70 rcdr) ? 72 b)
                                    ((? 72 a) b)
                                    ((? 70 cdr) b)
                                    ((? 70 car) . a)
                                    ((? 71 cdr) b)
                                    ((? 71 car) . a)
                                    ((? y) ? 70 b)
                                    ((? 70 a) a b))

debug:simple-query
apply-a-rule
rule=(rule (append-to-form ((? u) ? v) (? y) ((? u) ? z))
           (append-to-form (? v) (? y) (? z)))
pattern=(append-to-form (? 70 rcdr) ((? 70 car)) (? 70 b))
frame=(((? 72 b) (? 72 car)) ((? 78 y) (? 72 car))
                             ((? 72 rcdr))
                             ((? 72 cdr))
                             ((? 72 car) . b)
                             ((? 73 cdr))
                             ((? 73 car) . b)
                             ((? 70 rcdr) ? 72 b)
                             ((? 72 a) b)
                             ((? 70 cdr) b)
                             ((? 70 car) . a)
                             ((? 71 cdr) b)
                             ((? 71 car) . a)
                             ((? y) ? 70 b)
                             ((? 70 a) a b))

unify-result=(((? 70 b) (? 79 u) ? 79 z) ((? 79 y) (? 70 car))
                                         ((? 79 v))
                                         ((? 79 u) . b)
                                         ((? 72 b) (? 72 car))
                                         ((? 78 y) (? 72 car))
                                         ((? 72 rcdr))
                                         ((? 72 cdr))
                                         ((? 72 car) . b)
                                         ((? 73 cdr))
                                         ((? 73 car) . b)
                                         ((? 70 rcdr) ? 72 b)
                                         ((? 72 a) b)
                                         ((? 70 cdr) b)
                                         ((? 70 car) . a)
                                         ((? 71 cdr) b)
                                         ((? 71 car) . a)
                                         ((? y) ? 70 b)
                                         ((? 70 a) a b))

debug:simple-query
apply-a-rule
rule=(rule (append-to-form ((? u) ? v) (? y) ((? u) ? z))
           (append-to-form (? v) (? y) (? z)))
pattern=(append-to-form (? 79 v) (? 79 y) (? 79 z))
frame=(((? 70 b) (? 79 u) ? 79 z) ((? 79 y) (? 70 car))
                                  ((? 79 v))
                                  ((? 79 u) . b)
                                  ((? 72 b) (? 72 car))
                                  ((? 78 y) (? 72 car))
                                  ((? 72 rcdr))
                                  ((? 72 cdr))
                                  ((? 72 car) . b)
                                  ((? 73 cdr))
                                  ((? 73 car) . b)
                                  ((? 70 rcdr) ? 72 b)
                                  ((? 72 a) b)
                                  ((? 70 cdr) b)
                                  ((? 70 car) . a)
                                  ((? 71 cdr) b)
                                  ((? 71 car) . a)
                                  ((? y) ? 70 b)
                                  ((? 70 a) a b))

unify-result=failed
apply-a-rule
rule=(rule (append-to-form () (? y) (? y)))
pattern=(append-to-form (? 79 v) (? 79 y) (? 79 z))
frame=(((? 70 b) (? 79 u) ? 79 z) ((? 79 y) (? 70 car))
                                  ((? 79 v))
                                  ((? 79 u) . b)
                                  ((? 72 b) (? 72 car))
                                  ((? 78 y) (? 72 car))
                                  ((? 72 rcdr))
                                  ((? 72 cdr))
                                  ((? 72 car) . b)
                                  ((? 73 cdr))
                                  ((? 73 car) . b)
                                  ((? 70 rcdr) ? 72 b)
                                  ((? 72 a) b)
                                  ((? 70 cdr) b)
                                  ((? 70 car) . a)
                                  ((? 71 cdr) b)
                                  ((? 71 car) . a)
                                  ((? y) ? 70 b)
                                  ((? 70 a) a b))

unify-result=(((? 79 z) (? 70 car)) ((? 81 y) (? 70 car))
                                    ((? 70 b) (? 79 u) ? 79 z)
                                    ((? 79 y) (? 70 car))
                                    ((? 79 v))
                                    ((? 79 u) . b)
                                    ((? 72 b) (? 72 car))
                                    ((? 78 y) (? 72 car))
                                    ((? 72 rcdr))
                                    ((? 72 cdr))
                                    ((? 72 car) . b)
                                    ((? 73 cdr))
                                    ((? 73 car) . b)
                                    ((? 70 rcdr) ? 72 b)
                                    ((? 72 a) b)
                                    ((? 70 cdr) b)
                                    ((? 70 car) . a)
                                    ((? 71 cdr) b)
                                    ((? 71 car) . a)
                                    ((? y) ? 70 b)
                                    ((? 70 a) a b))
(reverse-left (a b) (b a))
apply-a-rule
rule=(rule (reverse-left () ()))
pattern=(reverse-left (a b) (? y))
frame=()

unify-result=failed
apply-a-rule
rule=(rule (reverse-left () ()))
pattern=(reverse-left (? 70 cdr) (? 70 rcdr))
frame=(((? 70 cdr) b) ((? 70 car) . a)
                      ((? 71 cdr) b)
                      ((? 71 car) . a)
                      ((? y) ? 70 b)
                      ((? 70 a) a b))

unify-result=failed
apply-a-rule
rule=(rule (append-to-form () (? y) (? y)))
pattern=(append-to-form (? 70 rcdr) ((? 70 car)) (? 70 b))
frame=(((? 72 b) (? 72 car)) ((? 78 y) (? 72 car))
                             ((? 72 rcdr))
                             ((? 72 cdr))
                             ((? 72 car) . b)
                             ((? 73 cdr))
                             ((? 73 car) . b)
                             ((? 70 rcdr) ? 72 b)
                             ((? 72 a) b)
                             ((? 70 cdr) b)
                             ((? 70 car) . a)
                             ((? 71 cdr) b)
                             ((? 71 car) . a)
                             ((? y) ? 70 b)
                             ((? 70 a) a b))

unify-result=failed

;;; Query input:
(reverse-left (a b c) (? y))
;;; Query results:

debug:simple-query
apply-a-rule
rule=(rule (reverse-left (? a) (? b))
           (and (carcdr (? a) (? car) (? cdr))
                (reverse-left (? cdr) (? rcdr))
                (append-to-form (? rcdr) ((? car)) (? b))))
pattern=(reverse-left (a b c) (? y))
frame=()

unify-result=(((? y) ? 85 b) ((? 85 a) a b c))

debug:simple-query
apply-a-rule
rule=(rule (carcdr ((? car) ? cdr) (? car) (? cdr)))
pattern=(carcdr (? 85 a) (? 85 car) (? 85 cdr))
frame=(((? y) ? 85 b) ((? 85 a) a b c))

unify-result=(((? 85 cdr) b c) ((? 85 car) . a)
                               ((? 86 cdr) b c)
                               ((? 86 car) . a)
                               ((? y) ? 85 b)
                               ((? 85 a) a b c))

debug:simple-query
apply-a-rule
rule=(rule (reverse-left (? a) (? b))
           (and (carcdr (? a) (? car) (? cdr))
                (reverse-left (? cdr) (? rcdr))
                (append-to-form (? rcdr) ((? car)) (? b))))
pattern=(reverse-left (? 85 cdr) (? 85 rcdr))
frame=(((? 85 cdr) b c) ((? 85 car) . a)
                        ((? 86 cdr) b c)
                        ((? 86 car) . a)
                        ((? y) ? 85 b)
                        ((? 85 a) a b c))

unify-result=(((? 85 rcdr) ? 87 b) ((? 87 a) b c)
                                   ((? 85 cdr) b c)
                                   ((? 85 car) . a)
                                   ((? 86 cdr) b c)
                                   ((? 86 car) . a)
                                   ((? y) ? 85 b)
                                   ((? 85 a) a b c))

debug:simple-query
apply-a-rule
rule=(rule (carcdr ((? car) ? cdr) (? car) (? cdr)))
pattern=(carcdr (? 87 a) (? 87 car) (? 87 cdr))
frame=(((? 85 rcdr) ? 87 b) ((? 87 a) b c)
                            ((? 85 cdr) b c)
                            ((? 85 car) . a)
                            ((? 86 cdr) b c)
                            ((? 86 car) . a)
                            ((? y) ? 85 b)
                            ((? 85 a) a b c))

unify-result=(((? 87 cdr) c) ((? 87 car) . b)
                             ((? 88 cdr) c)
                             ((? 88 car) . b)
                             ((? 85 rcdr) ? 87 b)
                             ((? 87 a) b c)
                             ((? 85 cdr) b c)
                             ((? 85 car) . a)
                             ((? 86 cdr) b c)
                             ((? 86 car) . a)
                             ((? y) ? 85 b)
                             ((? 85 a) a b c))

debug:simple-query
apply-a-rule
rule=(rule (reverse-left (? a) (? b))
           (and (carcdr (? a) (? car) (? cdr))
                (reverse-left (? cdr) (? rcdr))
                (append-to-form (? rcdr) ((? car)) (? b))))
pattern=(reverse-left (? 87 cdr) (? 87 rcdr))
frame=(((? 87 cdr) c) ((? 87 car) . b)
                      ((? 88 cdr) c)
                      ((? 88 car) . b)
                      ((? 85 rcdr) ? 87 b)
                      ((? 87 a) b c)
                      ((? 85 cdr) b c)
                      ((? 85 car) . a)
                      ((? 86 cdr) b c)
                      ((? 86 car) . a)
                      ((? y) ? 85 b)
                      ((? 85 a) a b c))

unify-result=(((? 87 rcdr) ? 89 b) ((? 89 a) c)
                                   ((? 87 cdr) c)
                                   ((? 87 car) . b)
                                   ((? 88 cdr) c)
                                   ((? 88 car) . b)
                                   ((? 85 rcdr) ? 87 b)
                                   ((? 87 a) b c)
                                   ((? 85 cdr) b c)
                                   ((? 85 car) . a)
                                   ((? 86 cdr) b c)
                                   ((? 86 car) . a)
                                   ((? y) ? 85 b)
                                   ((? 85 a) a b c))

debug:simple-query
apply-a-rule
rule=(rule (carcdr ((? car) ? cdr) (? car) (? cdr)))
pattern=(carcdr (? 89 a) (? 89 car) (? 89 cdr))
frame=(((? 87 rcdr) ? 89 b) ((? 89 a) c)
                            ((? 87 cdr) c)
                            ((? 87 car) . b)
                            ((? 88 cdr) c)
                            ((? 88 car) . b)
                            ((? 85 rcdr) ? 87 b)
                            ((? 87 a) b c)
                            ((? 85 cdr) b c)
                            ((? 85 car) . a)
                            ((? 86 cdr) b c)
                            ((? 86 car) . a)
                            ((? y) ? 85 b)
                            ((? 85 a) a b c))

unify-result=(((? 89 cdr)) ((? 89 car) . c)
                           ((? 90 cdr))
                           ((? 90 car) . c)
                           ((? 87 rcdr) ? 89 b)
                           ((? 89 a) c)
                           ((? 87 cdr) c)
                           ((? 87 car) . b)
                           ((? 88 cdr) c)
                           ((? 88 car) . b)
                           ((? 85 rcdr) ? 87 b)
                           ((? 87 a) b c)
                           ((? 85 cdr) b c)
                           ((? 85 car) . a)
                           ((? 86 cdr) b c)
                           ((? 86 car) . a)
                           ((? y) ? 85 b)
                           ((? 85 a) a b c))

debug:simple-query
apply-a-rule
rule=(rule (reverse-left (? a) (? b))
           (and (carcdr (? a) (? car) (? cdr))
                (reverse-left (? cdr) (? rcdr))
                (append-to-form (? rcdr) ((? car)) (? b))))
pattern=(reverse-left (? 89 cdr) (? 89 rcdr))
frame=(((? 89 cdr)) ((? 89 car) . c)
                    ((? 90 cdr))
                    ((? 90 car) . c)
                    ((? 87 rcdr) ? 89 b)
                    ((? 89 a) c)
                    ((? 87 cdr) c)
                    ((? 87 car) . b)
                    ((? 88 cdr) c)
                    ((? 88 car) . b)
                    ((? 85 rcdr) ? 87 b)
                    ((? 87 a) b c)
                    ((? 85 cdr) b c)
                    ((? 85 car) . a)
                    ((? 86 cdr) b c)
                    ((? 86 car) . a)
                    ((? y) ? 85 b)
                    ((? 85 a) a b c))

unify-result=(((? 89 rcdr) ? 91 b) ((? 91 a))
                                   ((? 89 cdr))
                                   ((? 89 car) . c)
                                   ((? 90 cdr))
                                   ((? 90 car) . c)
                                   ((? 87 rcdr) ? 89 b)
                                   ((? 89 a) c)
                                   ((? 87 cdr) c)
                                   ((? 87 car) . b)
                                   ((? 88 cdr) c)
                                   ((? 88 car) . b)
                                   ((? 85 rcdr) ? 87 b)
                                   ((? 87 a) b c)
                                   ((? 85 cdr) b c)
                                   ((? 85 car) . a)
                                   ((? 86 cdr) b c)
                                   ((? 86 car) . a)
                                   ((? y) ? 85 b)
                                   ((? 85 a) a b c))

debug:simple-query
apply-a-rule
rule=(rule (carcdr ((? car) ? cdr) (? car) (? cdr)))
pattern=(carcdr (? 91 a) (? 91 car) (? 91 cdr))
frame=(((? 89 rcdr) ? 91 b) ((? 91 a))
                            ((? 89 cdr))
                            ((? 89 car) . c)
                            ((? 90 cdr))
                            ((? 90 car) . c)
                            ((? 87 rcdr) ? 89 b)
                            ((? 89 a) c)
                            ((? 87 cdr) c)
                            ((? 87 car) . b)
                            ((? 88 cdr) c)
                            ((? 88 car) . b)
                            ((? 85 rcdr) ? 87 b)
                            ((? 87 a) b c)
                            ((? 85 cdr) b c)
                            ((? 85 car) . a)
                            ((? 86 cdr) b c)
                            ((? 86 car) . a)
                            ((? y) ? 85 b)
                            ((? 85 a) a b c))

unify-result=failed

debug:simple-query

debug:simple-query
apply-a-rule
rule=(rule (reverse-left () ()))
pattern=(reverse-left (? 89 cdr) (? 89 rcdr))
frame=(((? 89 cdr)) ((? 89 car) . c)
                    ((? 90 cdr))
                    ((? 90 car) . c)
                    ((? 87 rcdr) ? 89 b)
                    ((? 89 a) c)
                    ((? 87 cdr) c)
                    ((? 87 car) . b)
                    ((? 88 cdr) c)
                    ((? 88 car) . b)
                    ((? 85 rcdr) ? 87 b)
                    ((? 87 a) b c)
                    ((? 85 cdr) b c)
                    ((? 85 car) . a)
                    ((? 86 cdr) b c)
                    ((? 86 car) . a)
                    ((? y) ? 85 b)
                    ((? 85 a) a b c))

unify-result=(((? 89 rcdr)) ((? 89 cdr))
                            ((? 89 car) . c)
                            ((? 90 cdr))
                            ((? 90 car) . c)
                            ((? 87 rcdr) ? 89 b)
                            ((? 89 a) c)
                            ((? 87 cdr) c)
                            ((? 87 car) . b)
                            ((? 88 cdr) c)
                            ((? 88 car) . b)
                            ((? 85 rcdr) ? 87 b)
                            ((? 87 a) b c)
                            ((? 85 cdr) b c)
                            ((? 85 car) . a)
                            ((? 86 cdr) b c)
                            ((? 86 car) . a)
                            ((? y) ? 85 b)
                            ((? 85 a) a b c))

debug:simple-query
apply-a-rule
rule=(rule (append-to-form ((? u) ? v) (? y) ((? u) ? z))
           (append-to-form (? v) (? y) (? z)))
pattern=(append-to-form (? 89 rcdr) ((? 89 car)) (? 89 b))
frame=(((? 89 rcdr)) ((? 89 cdr))
                     ((? 89 car) . c)
                     ((? 90 cdr))
                     ((? 90 car) . c)
                     ((? 87 rcdr) ? 89 b)
                     ((? 89 a) c)
                     ((? 87 cdr) c)
                     ((? 87 car) . b)
                     ((? 88 cdr) c)
                     ((? 88 car) . b)
                     ((? 85 rcdr) ? 87 b)
                     ((? 87 a) b c)
                     ((? 85 cdr) b c)
                     ((? 85 car) . a)
                     ((? 86 cdr) b c)
                     ((? 86 car) . a)
                     ((? y) ? 85 b)
                     ((? 85 a) a b c))

unify-result=failed
apply-a-rule
rule=(rule (append-to-form () (? y) (? y)))
pattern=(append-to-form (? 89 rcdr) ((? 89 car)) (? 89 b))
frame=(((? 89 rcdr)) ((? 89 cdr))
                     ((? 89 car) . c)
                     ((? 90 cdr))
                     ((? 90 car) . c)
                     ((? 87 rcdr) ? 89 b)
                     ((? 89 a) c)
                     ((? 87 cdr) c)
                     ((? 87 car) . b)
                     ((? 88 cdr) c)
                     ((? 88 car) . b)
                     ((? 85 rcdr) ? 87 b)
                     ((? 87 a) b c)
                     ((? 85 cdr) b c)
                     ((? 85 car) . a)
                     ((? 86 cdr) b c)
                     ((? 86 car) . a)
                     ((? y) ? 85 b)
                     ((? 85 a) a b c))

unify-result=(((? 89 b) (? 89 car)) ((? 95 y) (? 89 car))
                                    ((? 89 rcdr))
                                    ((? 89 cdr))
                                    ((? 89 car) . c)
                                    ((? 90 cdr))
                                    ((? 90 car) . c)
                                    ((? 87 rcdr) ? 89 b)
                                    ((? 89 a) c)
                                    ((? 87 cdr) c)
                                    ((? 87 car) . b)
                                    ((? 88 cdr) c)
                                    ((? 88 car) . b)
                                    ((? 85 rcdr) ? 87 b)
                                    ((? 87 a) b c)
                                    ((? 85 cdr) b c)
                                    ((? 85 car) . a)
                                    ((? 86 cdr) b c)
                                    ((? 86 car) . a)
                                    ((? y) ? 85 b)
                                    ((? 85 a) a b c))

debug:simple-query
apply-a-rule
rule=(rule (append-to-form ((? u) ? v) (? y) ((? u) ? z))
           (append-to-form (? v) (? y) (? z)))
pattern=(append-to-form (? 87 rcdr) ((? 87 car)) (? 87 b))
frame=(((? 89 b) (? 89 car)) ((? 95 y) (? 89 car))
                             ((? 89 rcdr))
                             ((? 89 cdr))
                             ((? 89 car) . c)
                             ((? 90 cdr))
                             ((? 90 car) . c)
                             ((? 87 rcdr) ? 89 b)
                             ((? 89 a) c)
                             ((? 87 cdr) c)
                             ((? 87 car) . b)
                             ((? 88 cdr) c)
                             ((? 88 car) . b)
                             ((? 85 rcdr) ? 87 b)
                             ((? 87 a) b c)
                             ((? 85 cdr) b c)
                             ((? 85 car) . a)
                             ((? 86 cdr) b c)
                             ((? 86 car) . a)
                             ((? y) ? 85 b)
                             ((? 85 a) a b c))

unify-result=(((? 87 b) (? 96 u) ? 96 z) ((? 96 y) (? 87 car))
                                         ((? 96 v))
                                         ((? 96 u) . c)
                                         ((? 89 b) (? 89 car))
                                         ((? 95 y) (? 89 car))
                                         ((? 89 rcdr))
                                         ((? 89 cdr))
                                         ((? 89 car) . c)
                                         ((? 90 cdr))
                                         ((? 90 car) . c)
                                         ((? 87 rcdr) ? 89 b)
                                         ((? 89 a) c)
                                         ((? 87 cdr) c)
                                         ((? 87 car) . b)
                                         ((? 88 cdr) c)
                                         ((? 88 car) . b)
                                         ((? 85 rcdr) ? 87 b)
                                         ((? 87 a) b c)
                                         ((? 85 cdr) b c)
                                         ((? 85 car) . a)
                                         ((? 86 cdr) b c)
                                         ((? 86 car) . a)
                                         ((? y) ? 85 b)
                                         ((? 85 a) a b c))

debug:simple-query
apply-a-rule
rule=(rule (append-to-form ((? u) ? v) (? y) ((? u) ? z))
           (append-to-form (? v) (? y) (? z)))
pattern=(append-to-form (? 96 v) (? 96 y) (? 96 z))
frame=(((? 87 b) (? 96 u) ? 96 z) ((? 96 y) (? 87 car))
                                  ((? 96 v))
                                  ((? 96 u) . c)
                                  ((? 89 b) (? 89 car))
                                  ((? 95 y) (? 89 car))
                                  ((? 89 rcdr))
                                  ((? 89 cdr))
                                  ((? 89 car) . c)
                                  ((? 90 cdr))
                                  ((? 90 car) . c)
                                  ((? 87 rcdr) ? 89 b)
                                  ((? 89 a) c)
                                  ((? 87 cdr) c)
                                  ((? 87 car) . b)
                                  ((? 88 cdr) c)
                                  ((? 88 car) . b)
                                  ((? 85 rcdr) ? 87 b)
                                  ((? 87 a) b c)
                                  ((? 85 cdr) b c)
                                  ((? 85 car) . a)
                                  ((? 86 cdr) b c)
                                  ((? 86 car) . a)
                                  ((? y) ? 85 b)
                                  ((? 85 a) a b c))

unify-result=failed
apply-a-rule
rule=(rule (append-to-form () (? y) (? y)))
pattern=(append-to-form (? 96 v) (? 96 y) (? 96 z))
frame=(((? 87 b) (? 96 u) ? 96 z) ((? 96 y) (? 87 car))
                                  ((? 96 v))
                                  ((? 96 u) . c)
                                  ((? 89 b) (? 89 car))
                                  ((? 95 y) (? 89 car))
                                  ((? 89 rcdr))
                                  ((? 89 cdr))
                                  ((? 89 car) . c)
                                  ((? 90 cdr))
                                  ((? 90 car) . c)
                                  ((? 87 rcdr) ? 89 b)
                                  ((? 89 a) c)
                                  ((? 87 cdr) c)
                                  ((? 87 car) . b)
                                  ((? 88 cdr) c)
                                  ((? 88 car) . b)
                                  ((? 85 rcdr) ? 87 b)
                                  ((? 87 a) b c)
                                  ((? 85 cdr) b c)
                                  ((? 85 car) . a)
                                  ((? 86 cdr) b c)
                                  ((? 86 car) . a)
                                  ((? y) ? 85 b)
                                  ((? 85 a) a b c))

unify-result=(((? 96 z) (? 87 car)) ((? 98 y) (? 87 car))
                                    ((? 87 b) (? 96 u) ? 96 z)
                                    ((? 96 y) (? 87 car))
                                    ((? 96 v))
                                    ((? 96 u) . c)
                                    ((? 89 b) (? 89 car))
                                    ((? 95 y) (? 89 car))
                                    ((? 89 rcdr))
                                    ((? 89 cdr))
                                    ((? 89 car) . c)
                                    ((? 90 cdr))
                                    ((? 90 car) . c)
                                    ((? 87 rcdr) ? 89 b)
                                    ((? 89 a) c)
                                    ((? 87 cdr) c)
                                    ((? 87 car) . b)
                                    ((? 88 cdr) c)
                                    ((? 88 car) . b)
                                    ((? 85 rcdr) ? 87 b)
                                    ((? 87 a) b c)
                                    ((? 85 cdr) b c)
                                    ((? 85 car) . a)
                                    ((? 86 cdr) b c)
                                    ((? 86 car) . a)
                                    ((? y) ? 85 b)
                                    ((? 85 a) a b c))

debug:simple-query
apply-a-rule
rule=(rule (append-to-form ((? u) ? v) (? y) ((? u) ? z))
           (append-to-form (? v) (? y) (? z)))
pattern=(append-to-form (? 85 rcdr) ((? 85 car)) (? 85 b))
frame=(((? 96 z) (? 87 car)) ((? 98 y) (? 87 car))
                             ((? 87 b) (? 96 u) ? 96 z)
                             ((? 96 y) (? 87 car))
                             ((? 96 v))
                             ((? 96 u) . c)
                             ((? 89 b) (? 89 car))
                             ((? 95 y) (? 89 car))
                             ((? 89 rcdr))
                             ((? 89 cdr))
                             ((? 89 car) . c)
                             ((? 90 cdr))
                             ((? 90 car) . c)
                             ((? 87 rcdr) ? 89 b)
                             ((? 89 a) c)
                             ((? 87 cdr) c)
                             ((? 87 car) . b)
                             ((? 88 cdr) c)
                             ((? 88 car) . b)
                             ((? 85 rcdr) ? 87 b)
                             ((? 87 a) b c)
                             ((? 85 cdr) b c)
                             ((? 85 car) . a)
                             ((? 86 cdr) b c)
                             ((? 86 car) . a)
                             ((? y) ? 85 b)
                             ((? 85 a) a b c))

unify-result=(((? 85 b) (? 99 u) ? 99 z) ((? 99 y) (? 85 car))
                                         ((? 99 v) (? 87 car))
                                         ((? 99 u) . c)
                                         ((? 96 z) (? 87 car))
                                         ((? 98 y) (? 87 car))
                                         ((? 87 b) (? 96 u) ? 96 z)
                                         ((? 96 y) (? 87 car))
                                         ((? 96 v))
                                         ((? 96 u) . c)
                                         ((? 89 b) (? 89 car))
                                         ((? 95 y) (? 89 car))
                                         ((? 89 rcdr))
                                         ((? 89 cdr))
                                         ((? 89 car) . c)
                                         ((? 90 cdr))
                                         ((? 90 car) . c)
                                         ((? 87 rcdr) ? 89 b)
                                         ((? 89 a) c)
                                         ((? 87 cdr) c)
                                         ((? 87 car) . b)
                                         ((? 88 cdr) c)
                                         ((? 88 car) . b)
                                         ((? 85 rcdr) ? 87 b)
                                         ((? 87 a) b c)
                                         ((? 85 cdr) b c)
                                         ((? 85 car) . a)
                                         ((? 86 cdr) b c)
                                         ((? 86 car) . a)
                                         ((? y) ? 85 b)
                                         ((? 85 a) a b c))

debug:simple-query
apply-a-rule
rule=(rule (append-to-form ((? u) ? v) (? y) ((? u) ? z))
           (append-to-form (? v) (? y) (? z)))
pattern=(append-to-form (? 99 v) (? 99 y) (? 99 z))
frame=(((? 85 b) (? 99 u) ? 99 z) ((? 99 y) (? 85 car))
                                  ((? 99 v) (? 87 car))
                                  ((? 99 u) . c)
                                  ((? 96 z) (? 87 car))
                                  ((? 98 y) (? 87 car))
                                  ((? 87 b) (? 96 u) ? 96 z)
                                  ((? 96 y) (? 87 car))
                                  ((? 96 v))
                                  ((? 96 u) . c)
                                  ((? 89 b) (? 89 car))
                                  ((? 95 y) (? 89 car))
                                  ((? 89 rcdr))
                                  ((? 89 cdr))
                                  ((? 89 car) . c)
                                  ((? 90 cdr))
                                  ((? 90 car) . c)
                                  ((? 87 rcdr) ? 89 b)
                                  ((? 89 a) c)
                                  ((? 87 cdr) c)
                                  ((? 87 car) . b)
                                  ((? 88 cdr) c)
                                  ((? 88 car) . b)
                                  ((? 85 rcdr) ? 87 b)
                                  ((? 87 a) b c)
                                  ((? 85 cdr) b c)
                                  ((? 85 car) . a)
                                  ((? 86 cdr) b c)
                                  ((? 86 car) . a)
                                  ((? y) ? 85 b)
                                  ((? 85 a) a b c))

unify-result=(((? 99 z) (? 100 u) ? 100 z) ((? 100 y) (? 85 car))
                                           ((? 100 v))
                                           ((? 100 u) . b)
                                           ((? 85 b) (? 99 u) ? 99 z)
                                           ((? 99 y) (? 85 car))
                                           ((? 99 v) (? 87 car))
                                           ((? 99 u) . c)
                                           ((? 96 z) (? 87 car))
                                           ((? 98 y) (? 87 car))
                                           ((? 87 b) (? 96 u) ? 96 z)
                                           ((? 96 y) (? 87 car))
                                           ((? 96 v))
                                           ((? 96 u) . c)
                                           ((? 89 b) (? 89 car))
                                           ((? 95 y) (? 89 car))
                                           ((? 89 rcdr))
                                           ((? 89 cdr))
                                           ((? 89 car) . c)
                                           ((? 90 cdr))
                                           ((? 90 car) . c)
                                           ((? 87 rcdr) ? 89 b)
                                           ((? 89 a) c)
                                           ((? 87 cdr) c)
                                           ((? 87 car) . b)
                                           ((? 88 cdr) c)
                                           ((? 88 car) . b)
                                           ((? 85 rcdr) ? 87 b)
                                           ((? 87 a) b c)
                                           ((? 85 cdr) b c)
                                           ((? 85 car) . a)
                                           ((? 86 cdr) b c)
                                           ((? 86 car) . a)
                                           ((? y) ? 85 b)
                                           ((? 85 a) a b c))

debug:simple-query
apply-a-rule
rule=(rule (append-to-form ((? u) ? v) (? y) ((? u) ? z))
           (append-to-form (? v) (? y) (? z)))
pattern=(append-to-form (? 100 v) (? 100 y) (? 100 z))
frame=(((? 99 z) (? 100 u) ? 100 z) ((? 100 y) (? 85 car))
                                    ((? 100 v))
                                    ((? 100 u) . b)
                                    ((? 85 b) (? 99 u) ? 99 z)
                                    ((? 99 y) (? 85 car))
                                    ((? 99 v) (? 87 car))
                                    ((? 99 u) . c)
                                    ((? 96 z) (? 87 car))
                                    ((? 98 y) (? 87 car))
                                    ((? 87 b) (? 96 u) ? 96 z)
                                    ((? 96 y) (? 87 car))
                                    ((? 96 v))
                                    ((? 96 u) . c)
                                    ((? 89 b) (? 89 car))
                                    ((? 95 y) (? 89 car))
                                    ((? 89 rcdr))
                                    ((? 89 cdr))
                                    ((? 89 car) . c)
                                    ((? 90 cdr))
                                    ((? 90 car) . c)
                                    ((? 87 rcdr) ? 89 b)
                                    ((? 89 a) c)
                                    ((? 87 cdr) c)
                                    ((? 87 car) . b)
                                    ((? 88 cdr) c)
                                    ((? 88 car) . b)
                                    ((? 85 rcdr) ? 87 b)
                                    ((? 87 a) b c)
                                    ((? 85 cdr) b c)
                                    ((? 85 car) . a)
                                    ((? 86 cdr) b c)
                                    ((? 86 car) . a)
                                    ((? y) ? 85 b)
                                    ((? 85 a) a b c))

unify-result=failed
apply-a-rule
rule=(rule (append-to-form () (? y) (? y)))
pattern=(append-to-form (? 100 v) (? 100 y) (? 100 z))
frame=(((? 99 z) (? 100 u) ? 100 z) ((? 100 y) (? 85 car))
                                    ((? 100 v))
                                    ((? 100 u) . b)
                                    ((? 85 b) (? 99 u) ? 99 z)
                                    ((? 99 y) (? 85 car))
                                    ((? 99 v) (? 87 car))
                                    ((? 99 u) . c)
                                    ((? 96 z) (? 87 car))
                                    ((? 98 y) (? 87 car))
                                    ((? 87 b) (? 96 u) ? 96 z)
                                    ((? 96 y) (? 87 car))
                                    ((? 96 v))
                                    ((? 96 u) . c)
                                    ((? 89 b) (? 89 car))
                                    ((? 95 y) (? 89 car))
                                    ((? 89 rcdr))
                                    ((? 89 cdr))
                                    ((? 89 car) . c)
                                    ((? 90 cdr))
                                    ((? 90 car) . c)
                                    ((? 87 rcdr) ? 89 b)
                                    ((? 89 a) c)
                                    ((? 87 cdr) c)
                                    ((? 87 car) . b)
                                    ((? 88 cdr) c)
                                    ((? 88 car) . b)
                                    ((? 85 rcdr) ? 87 b)
                                    ((? 87 a) b c)
                                    ((? 85 cdr) b c)
                                    ((? 85 car) . a)
                                    ((? 86 cdr) b c)
                                    ((? 86 car) . a)
                                    ((? y) ? 85 b)
                                    ((? 85 a) a b c))

unify-result=(((? 100 z) (? 85 car)) ((? 102 y) (? 85 car))
                                     ((? 99 z) (? 100 u) ? 100 z)
                                     ((? 100 y) (? 85 car))
                                     ((? 100 v))
                                     ((? 100 u) . b)
                                     ((? 85 b) (? 99 u) ? 99 z)
                                     ((? 99 y) (? 85 car))
                                     ((? 99 v) (? 87 car))
                                     ((? 99 u) . c)
                                     ((? 96 z) (? 87 car))
                                     ((? 98 y) (? 87 car))
                                     ((? 87 b) (? 96 u) ? 96 z)
                                     ((? 96 y) (? 87 car))
                                     ((? 96 v))
                                     ((? 96 u) . c)
                                     ((? 89 b) (? 89 car))
                                     ((? 95 y) (? 89 car))
                                     ((? 89 rcdr))
                                     ((? 89 cdr))
                                     ((? 89 car) . c)
                                     ((? 90 cdr))
                                     ((? 90 car) . c)
                                     ((? 87 rcdr) ? 89 b)
                                     ((? 89 a) c)
                                     ((? 87 cdr) c)
                                     ((? 87 car) . b)
                                     ((? 88 cdr) c)
                                     ((? 88 car) . b)
                                     ((? 85 rcdr) ? 87 b)
                                     ((? 87 a) b c)
                                     ((? 85 cdr) b c)
                                     ((? 85 car) . a)
                                     ((? 86 cdr) b c)
                                     ((? 86 car) . a)
                                     ((? y) ? 85 b)
                                     ((? 85 a) a b c))
(reverse-left (a b c) (c b a))
apply-a-rule
rule=(rule (reverse-left () ()))
pattern=(reverse-left (a b c) (? y))
frame=()

unify-result=failed
apply-a-rule
rule=(rule (reverse-left () ()))
pattern=(reverse-left (? 85 cdr) (? 85 rcdr))
frame=(((? 85 cdr) b c) ((? 85 car) . a)
                        ((? 86 cdr) b c)
                        ((? 86 car) . a)
                        ((? y) ? 85 b)
                        ((? 85 a) a b c))

unify-result=failed
apply-a-rule
rule=(rule (reverse-left () ()))
pattern=(reverse-left (? 87 cdr) (? 87 rcdr))
frame=(((? 87 cdr) c) ((? 87 car) . b)
                      ((? 88 cdr) c)
                      ((? 88 car) . b)
                      ((? 85 rcdr) ? 87 b)
                      ((? 87 a) b c)
                      ((? 85 cdr) b c)
                      ((? 85 car) . a)
                      ((? 86 cdr) b c)
                      ((? 86 car) . a)
                      ((? y) ? 85 b)
                      ((? 85 a) a b c))

unify-result=failed
apply-a-rule
rule=(rule (append-to-form () (? y) (? y)))
pattern=(append-to-form (? 87 rcdr) ((? 87 car)) (? 87 b))
frame=(((? 89 b) (? 89 car)) ((? 95 y) (? 89 car))
                             ((? 89 rcdr))
                             ((? 89 cdr))
                             ((? 89 car) . c)
                             ((? 90 cdr))
                             ((? 90 car) . c)
                             ((? 87 rcdr) ? 89 b)
                             ((? 89 a) c)
                             ((? 87 cdr) c)
                             ((? 87 car) . b)
                             ((? 88 cdr) c)
                             ((? 88 car) . b)
                             ((? 85 rcdr) ? 87 b)
                             ((? 87 a) b c)
                             ((? 85 cdr) b c)
                             ((? 85 car) . a)
                             ((? 86 cdr) b c)
                             ((? 86 car) . a)
                             ((? y) ? 85 b)
                             ((? 85 a) a b c))

unify-result=failed
apply-a-rule
rule=(rule (append-to-form () (? y) (? y)))
pattern=(append-to-form (? 85 rcdr) ((? 85 car)) (? 85 b))
frame=(((? 96 z) (? 87 car)) ((? 98 y) (? 87 car))
                             ((? 87 b) (? 96 u) ? 96 z)
                             ((? 96 y) (? 87 car))
                             ((? 96 v))
                             ((? 96 u) . c)
                             ((? 89 b) (? 89 car))
                             ((? 95 y) (? 89 car))
                             ((? 89 rcdr))
                             ((? 89 cdr))
                             ((? 89 car) . c)
                             ((? 90 cdr))
                             ((? 90 car) . c)
                             ((? 87 rcdr) ? 89 b)
                             ((? 89 a) c)
                             ((? 87 cdr) c)
                             ((? 87 car) . b)
                             ((? 88 cdr) c)
                             ((? 88 car) . b)
                             ((? 85 rcdr) ? 87 b)
                             ((? 87 a) b c)
                             ((? 85 cdr) b c)
                             ((? 85 car) . a)
                             ((? 86 cdr) b c)
                             ((? 86 car) . a)
                             ((? y) ? 85 b)
                             ((? 85 a) a b c))

unify-result=failed
apply-a-rule
rule=(rule (append-to-form () (? y) (? y)))
pattern=(append-to-form (? 99 v) (? 99 y) (? 99 z))
frame=(((? 85 b) (? 99 u) ? 99 z) ((? 99 y) (? 85 car))
                                  ((? 99 v) (? 87 car))
                                  ((? 99 u) . c)
                                  ((? 96 z) (? 87 car))
                                  ((? 98 y) (? 87 car))
                                  ((? 87 b) (? 96 u) ? 96 z)
                                  ((? 96 y) (? 87 car))
                                  ((? 96 v))
                                  ((? 96 u) . c)
                                  ((? 89 b) (? 89 car))
                                  ((? 95 y) (? 89 car))
                                  ((? 89 rcdr))
                                  ((? 89 cdr))
                                  ((? 89 car) . c)
                                  ((? 90 cdr))
                                  ((? 90 car) . c)
                                  ((? 87 rcdr) ? 89 b)
                                  ((? 89 a) c)
                                  ((? 87 cdr) c)
                                  ((? 87 car) . b)
                                  ((? 88 cdr) c)
                                  ((? 88 car) . b)
                                  ((? 85 rcdr) ? 87 b)
                                  ((? 87 a) b c)
                                  ((? 85 cdr) b c)
                                  ((? 85 car) . a)
                                  ((? 86 cdr) b c)
                                  ((? 86 car) . a)
                                  ((? y) ? 85 b)
                                  ((? 85 a) a b c))

unify-result=failed

;;; Query input:
(reverse-right (? x) (a b c))
;;; Query results:

debug:simple-query
apply-a-rule
rule=(rule (reverse-right (? a) (? b))
           (and (carcdr (? b) (? car) (? cdr))
                (reverse-right (? rcdr) (? cdr))
                (append-to-form (? rcdr) ((? car)) (? a))))
pattern=(reverse-right (? x) (a b c))
frame=()

unify-result=(((? 109 b) a b c) ((? x) ? 109 a))

debug:simple-query
apply-a-rule
rule=(rule (carcdr ((? car) ? cdr) (? car) (? cdr)))
pattern=(carcdr (? 109 b) (? 109 car) (? 109 cdr))
frame=(((? 109 b) a b c) ((? x) ? 109 a))

unify-result=(((? 109 cdr) b c) ((? 109 car) . a)
                                ((? 110 cdr) b c)
                                ((? 110 car) . a)
                                ((? 109 b) a b c)
                                ((? x) ? 109 a))

debug:simple-query
apply-a-rule
rule=(rule (reverse-right (? a) (? b))
           (and (carcdr (? b) (? car) (? cdr))
                (reverse-right (? rcdr) (? cdr))
                (append-to-form (? rcdr) ((? car)) (? a))))
pattern=(reverse-right (? 109 rcdr) (? 109 cdr))
frame=(((? 109 cdr) b c) ((? 109 car) . a)
                         ((? 110 cdr) b c)
                         ((? 110 car) . a)
                         ((? 109 b) a b c)
                         ((? x) ? 109 a))

unify-result=(((? 111 b) b c) ((? 109 rcdr) ? 111 a)
                              ((? 109 cdr) b c)
                              ((? 109 car) . a)
                              ((? 110 cdr) b c)
                              ((? 110 car) . a)
                              ((? 109 b) a b c)
                              ((? x) ? 109 a))

debug:simple-query
apply-a-rule
rule=(rule (carcdr ((? car) ? cdr) (? car) (? cdr)))
pattern=(carcdr (? 111 b) (? 111 car) (? 111 cdr))
frame=(((? 111 b) b c) ((? 109 rcdr) ? 111 a)
                       ((? 109 cdr) b c)
                       ((? 109 car) . a)
                       ((? 110 cdr) b c)
                       ((? 110 car) . a)
                       ((? 109 b) a b c)
                       ((? x) ? 109 a))

unify-result=(((? 111 cdr) c) ((? 111 car) . b)
                              ((? 112 cdr) c)
                              ((? 112 car) . b)
                              ((? 111 b) b c)
                              ((? 109 rcdr) ? 111 a)
                              ((? 109 cdr) b c)
                              ((? 109 car) . a)
                              ((? 110 cdr) b c)
                              ((? 110 car) . a)
                              ((? 109 b) a b c)
                              ((? x) ? 109 a))

debug:simple-query
apply-a-rule
rule=(rule (reverse-right (? a) (? b))
           (and (carcdr (? b) (? car) (? cdr))
                (reverse-right (? rcdr) (? cdr))
                (append-to-form (? rcdr) ((? car)) (? a))))
pattern=(reverse-right (? 111 rcdr) (? 111 cdr))
frame=(((? 111 cdr) c) ((? 111 car) . b)
                       ((? 112 cdr) c)
                       ((? 112 car) . b)
                       ((? 111 b) b c)
                       ((? 109 rcdr) ? 111 a)
                       ((? 109 cdr) b c)
                       ((? 109 car) . a)
                       ((? 110 cdr) b c)
                       ((? 110 car) . a)
                       ((? 109 b) a b c)
                       ((? x) ? 109 a))

unify-result=(((? 113 b) c) ((? 111 rcdr) ? 113 a)
                            ((? 111 cdr) c)
                            ((? 111 car) . b)
                            ((? 112 cdr) c)
                            ((? 112 car) . b)
                            ((? 111 b) b c)
                            ((? 109 rcdr) ? 111 a)
                            ((? 109 cdr) b c)
                            ((? 109 car) . a)
                            ((? 110 cdr) b c)
                            ((? 110 car) . a)
                            ((? 109 b) a b c)
                            ((? x) ? 109 a))

debug:simple-query
apply-a-rule
rule=(rule (carcdr ((? car) ? cdr) (? car) (? cdr)))
pattern=(carcdr (? 113 b) (? 113 car) (? 113 cdr))
frame=(((? 113 b) c) ((? 111 rcdr) ? 113 a)
                     ((? 111 cdr) c)
                     ((? 111 car) . b)
                     ((? 112 cdr) c)
                     ((? 112 car) . b)
                     ((? 111 b) b c)
                     ((? 109 rcdr) ? 111 a)
                     ((? 109 cdr) b c)
                     ((? 109 car) . a)
                     ((? 110 cdr) b c)
                     ((? 110 car) . a)
                     ((? 109 b) a b c)
                     ((? x) ? 109 a))

unify-result=(((? 113 cdr)) ((? 113 car) . c)
                            ((? 114 cdr))
                            ((? 114 car) . c)
                            ((? 113 b) c)
                            ((? 111 rcdr) ? 113 a)
                            ((? 111 cdr) c)
                            ((? 111 car) . b)
                            ((? 112 cdr) c)
                            ((? 112 car) . b)
                            ((? 111 b) b c)
                            ((? 109 rcdr) ? 111 a)
                            ((? 109 cdr) b c)
                            ((? 109 car) . a)
                            ((? 110 cdr) b c)
                            ((? 110 car) . a)
                            ((? 109 b) a b c)
                            ((? x) ? 109 a))

debug:simple-query
apply-a-rule
rule=(rule (reverse-right (? a) (? b))
           (and (carcdr (? b) (? car) (? cdr))
                (reverse-right (? rcdr) (? cdr))
                (append-to-form (? rcdr) ((? car)) (? a))))
pattern=(reverse-right (? 113 rcdr) (? 113 cdr))
frame=(((? 113 cdr)) ((? 113 car) . c)
                     ((? 114 cdr))
                     ((? 114 car) . c)
                     ((? 113 b) c)
                     ((? 111 rcdr) ? 113 a)
                     ((? 111 cdr) c)
                     ((? 111 car) . b)
                     ((? 112 cdr) c)
                     ((? 112 car) . b)
                     ((? 111 b) b c)
                     ((? 109 rcdr) ? 111 a)
                     ((? 109 cdr) b c)
                     ((? 109 car) . a)
                     ((? 110 cdr) b c)
                     ((? 110 car) . a)
                     ((? 109 b) a b c)
                     ((? x) ? 109 a))

unify-result=(((? 115 b)) ((? 113 rcdr) ? 115 a)
                          ((? 113 cdr))
                          ((? 113 car) . c)
                          ((? 114 cdr))
                          ((? 114 car) . c)
                          ((? 113 b) c)
                          ((? 111 rcdr) ? 113 a)
                          ((? 111 cdr) c)
                          ((? 111 car) . b)
                          ((? 112 cdr) c)
                          ((? 112 car) . b)
                          ((? 111 b) b c)
                          ((? 109 rcdr) ? 111 a)
                          ((? 109 cdr) b c)
                          ((? 109 car) . a)
                          ((? 110 cdr) b c)
                          ((? 110 car) . a)
                          ((? 109 b) a b c)
                          ((? x) ? 109 a))

debug:simple-query
apply-a-rule
rule=(rule (carcdr ((? car) ? cdr) (? car) (? cdr)))
pattern=(carcdr (? 115 b) (? 115 car) (? 115 cdr))
frame=(((? 115 b)) ((? 113 rcdr) ? 115 a)
                   ((? 113 cdr))
                   ((? 113 car) . c)
                   ((? 114 cdr))
                   ((? 114 car) . c)
                   ((? 113 b) c)
                   ((? 111 rcdr) ? 113 a)
                   ((? 111 cdr) c)
                   ((? 111 car) . b)
                   ((? 112 cdr) c)
                   ((? 112 car) . b)
                   ((? 111 b) b c)
                   ((? 109 rcdr) ? 111 a)
                   ((? 109 cdr) b c)
                   ((? 109 car) . a)
                   ((? 110 cdr) b c)
                   ((? 110 car) . a)
                   ((? 109 b) a b c)
                   ((? x) ? 109 a))

unify-result=failed

debug:simple-query

debug:simple-query
apply-a-rule
rule=(rule (reverse-right () ()))
pattern=(reverse-right (? 113 rcdr) (? 113 cdr))
frame=(((? 113 cdr)) ((? 113 car) . c)
                     ((? 114 cdr))
                     ((? 114 car) . c)
                     ((? 113 b) c)
                     ((? 111 rcdr) ? 113 a)
                     ((? 111 cdr) c)
                     ((? 111 car) . b)
                     ((? 112 cdr) c)
                     ((? 112 car) . b)
                     ((? 111 b) b c)
                     ((? 109 rcdr) ? 111 a)
                     ((? 109 cdr) b c)
                     ((? 109 car) . a)
                     ((? 110 cdr) b c)
                     ((? 110 car) . a)
                     ((? 109 b) a b c)
                     ((? x) ? 109 a))

unify-result=(((? 113 rcdr)) ((? 113 cdr))
                             ((? 113 car) . c)
                             ((? 114 cdr))
                             ((? 114 car) . c)
                             ((? 113 b) c)
                             ((? 111 rcdr) ? 113 a)
                             ((? 111 cdr) c)
                             ((? 111 car) . b)
                             ((? 112 cdr) c)
                             ((? 112 car) . b)
                             ((? 111 b) b c)
                             ((? 109 rcdr) ? 111 a)
                             ((? 109 cdr) b c)
                             ((? 109 car) . a)
                             ((? 110 cdr) b c)
                             ((? 110 car) . a)
                             ((? 109 b) a b c)
                             ((? x) ? 109 a))

debug:simple-query
apply-a-rule
rule=(rule (append-to-form ((? u) ? v) (? y) ((? u) ? z))
           (append-to-form (? v) (? y) (? z)))
pattern=(append-to-form (? 113 rcdr) ((? 113 car)) (? 113 a))
frame=(((? 113 rcdr)) ((? 113 cdr))
                      ((? 113 car) . c)
                      ((? 114 cdr))
                      ((? 114 car) . c)
                      ((? 113 b) c)
                      ((? 111 rcdr) ? 113 a)
                      ((? 111 cdr) c)
                      ((? 111 car) . b)
                      ((? 112 cdr) c)
                      ((? 112 car) . b)
                      ((? 111 b) b c)
                      ((? 109 rcdr) ? 111 a)
                      ((? 109 cdr) b c)
                      ((? 109 car) . a)
                      ((? 110 cdr) b c)
                      ((? 110 car) . a)
                      ((? 109 b) a b c)
                      ((? x) ? 109 a))

unify-result=failed
apply-a-rule
rule=(rule (append-to-form () (? y) (? y)))
pattern=(append-to-form (? 113 rcdr) ((? 113 car)) (? 113 a))
frame=(((? 113 rcdr)) ((? 113 cdr))
                      ((? 113 car) . c)
                      ((? 114 cdr))
                      ((? 114 car) . c)
                      ((? 113 b) c)
                      ((? 111 rcdr) ? 113 a)
                      ((? 111 cdr) c)
                      ((? 111 car) . b)
                      ((? 112 cdr) c)
                      ((? 112 car) . b)
                      ((? 111 b) b c)
                      ((? 109 rcdr) ? 111 a)
                      ((? 109 cdr) b c)
                      ((? 109 car) . a)
                      ((? 110 cdr) b c)
                      ((? 110 car) . a)
                      ((? 109 b) a b c)
                      ((? x) ? 109 a))

unify-result=(((? 113 a) (? 113 car)) ((? 119 y) (? 113 car))
                                      ((? 113 rcdr))
                                      ((? 113 cdr))
                                      ((? 113 car) . c)
                                      ((? 114 cdr))
                                      ((? 114 car) . c)
                                      ((? 113 b) c)
                                      ((? 111 rcdr) ? 113 a)
                                      ((? 111 cdr) c)
                                      ((? 111 car) . b)
                                      ((? 112 cdr) c)
                                      ((? 112 car) . b)
                                      ((? 111 b) b c)
                                      ((? 109 rcdr) ? 111 a)
                                      ((? 109 cdr) b c)
                                      ((? 109 car) . a)
                                      ((? 110 cdr) b c)
                                      ((? 110 car) . a)
                                      ((? 109 b) a b c)
                                      ((? x) ? 109 a))

debug:simple-query
apply-a-rule
rule=(rule (append-to-form ((? u) ? v) (? y) ((? u) ? z))
           (append-to-form (? v) (? y) (? z)))
pattern=(append-to-form (? 111 rcdr) ((? 111 car)) (? 111 a))
frame=(((? 113 a) (? 113 car)) ((? 119 y) (? 113 car))
                               ((? 113 rcdr))
                               ((? 113 cdr))
                               ((? 113 car) . c)
                               ((? 114 cdr))
                               ((? 114 car) . c)
                               ((? 113 b) c)
                               ((? 111 rcdr) ? 113 a)
                               ((? 111 cdr) c)
                               ((? 111 car) . b)
                               ((? 112 cdr) c)
                               ((? 112 car) . b)
                               ((? 111 b) b c)
                               ((? 109 rcdr) ? 111 a)
                               ((? 109 cdr) b c)
                               ((? 109 car) . a)
                               ((? 110 cdr) b c)
                               ((? 110 car) . a)
                               ((? 109 b) a b c)
                               ((? x) ? 109 a))

unify-result=(((? 111 a) (? 120 u) ? 120 z) ((? 120 y) (? 111 car))
                                            ((? 120 v))
                                            ((? 120 u) . c)
                                            ((? 113 a) (? 113 car))
                                            ((? 119 y) (? 113 car))
                                            ((? 113 rcdr))
                                            ((? 113 cdr))
                                            ((? 113 car) . c)
                                            ((? 114 cdr))
                                            ((? 114 car) . c)
                                            ((? 113 b) c)
                                            ((? 111 rcdr) ? 113 a)
                                            ((? 111 cdr) c)
                                            ((? 111 car) . b)
                                            ((? 112 cdr) c)
                                            ((? 112 car) . b)
                                            ((? 111 b) b c)
                                            ((? 109 rcdr) ? 111 a)
                                            ((? 109 cdr) b c)
                                            ((? 109 car) . a)
                                            ((? 110 cdr) b c)
                                            ((? 110 car) . a)
                                            ((? 109 b) a b c)
                                            ((? x) ? 109 a))

debug:simple-query
apply-a-rule
rule=(rule (append-to-form ((? u) ? v) (? y) ((? u) ? z))
           (append-to-form (? v) (? y) (? z)))
pattern=(append-to-form (? 120 v) (? 120 y) (? 120 z))
frame=(((? 111 a) (? 120 u) ? 120 z) ((? 120 y) (? 111 car))
                                     ((? 120 v))
                                     ((? 120 u) . c)
                                     ((? 113 a) (? 113 car))
                                     ((? 119 y) (? 113 car))
                                     ((? 113 rcdr))
                                     ((? 113 cdr))
                                     ((? 113 car) . c)
                                     ((? 114 cdr))
                                     ((? 114 car) . c)
                                     ((? 113 b) c)
                                     ((? 111 rcdr) ? 113 a)
                                     ((? 111 cdr) c)
                                     ((? 111 car) . b)
                                     ((? 112 cdr) c)
                                     ((? 112 car) . b)
                                     ((? 111 b) b c)
                                     ((? 109 rcdr) ? 111 a)
                                     ((? 109 cdr) b c)
                                     ((? 109 car) . a)
                                     ((? 110 cdr) b c)
                                     ((? 110 car) . a)
                                     ((? 109 b) a b c)
                                     ((? x) ? 109 a))

unify-result=failed
apply-a-rule
rule=(rule (append-to-form () (? y) (? y)))
pattern=(append-to-form (? 120 v) (? 120 y) (? 120 z))
frame=(((? 111 a) (? 120 u) ? 120 z) ((? 120 y) (? 111 car))
                                     ((? 120 v))
                                     ((? 120 u) . c)
                                     ((? 113 a) (? 113 car))
                                     ((? 119 y) (? 113 car))
                                     ((? 113 rcdr))
                                     ((? 113 cdr))
                                     ((? 113 car) . c)
                                     ((? 114 cdr))
                                     ((? 114 car) . c)
                                     ((? 113 b) c)
                                     ((? 111 rcdr) ? 113 a)
                                     ((? 111 cdr) c)
                                     ((? 111 car) . b)
                                     ((? 112 cdr) c)
                                     ((? 112 car) . b)
                                     ((? 111 b) b c)
                                     ((? 109 rcdr) ? 111 a)
                                     ((? 109 cdr) b c)
                                     ((? 109 car) . a)
                                     ((? 110 cdr) b c)
                                     ((? 110 car) . a)
                                     ((? 109 b) a b c)
                                     ((? x) ? 109 a))

unify-result=(((? 120 z) (? 111 car)) ((? 122 y) (? 111 car))
                                      ((? 111 a) (? 120 u) ? 120 z)
                                      ((? 120 y) (? 111 car))
                                      ((? 120 v))
                                      ((? 120 u) . c)
                                      ((? 113 a) (? 113 car))
                                      ((? 119 y) (? 113 car))
                                      ((? 113 rcdr))
                                      ((? 113 cdr))
                                      ((? 113 car) . c)
                                      ((? 114 cdr))
                                      ((? 114 car) . c)
                                      ((? 113 b) c)
                                      ((? 111 rcdr) ? 113 a)
                                      ((? 111 cdr) c)
                                      ((? 111 car) . b)
                                      ((? 112 cdr) c)
                                      ((? 112 car) . b)
                                      ((? 111 b) b c)
                                      ((? 109 rcdr) ? 111 a)
                                      ((? 109 cdr) b c)
                                      ((? 109 car) . a)
                                      ((? 110 cdr) b c)
                                      ((? 110 car) . a)
                                      ((? 109 b) a b c)
                                      ((? x) ? 109 a))

debug:simple-query
apply-a-rule
rule=(rule (append-to-form ((? u) ? v) (? y) ((? u) ? z))
           (append-to-form (? v) (? y) (? z)))
pattern=(append-to-form (? 109 rcdr) ((? 109 car)) (? 109 a))
frame=(((? 120 z) (? 111 car)) ((? 122 y) (? 111 car))
                               ((? 111 a) (? 120 u) ? 120 z)
                               ((? 120 y) (? 111 car))
                               ((? 120 v))
                               ((? 120 u) . c)
                               ((? 113 a) (? 113 car))
                               ((? 119 y) (? 113 car))
                               ((? 113 rcdr))
                               ((? 113 cdr))
                               ((? 113 car) . c)
                               ((? 114 cdr))
                               ((? 114 car) . c)
                               ((? 113 b) c)
                               ((? 111 rcdr) ? 113 a)
                               ((? 111 cdr) c)
                               ((? 111 car) . b)
                               ((? 112 cdr) c)
                               ((? 112 car) . b)
                               ((? 111 b) b c)
                               ((? 109 rcdr) ? 111 a)
                               ((? 109 cdr) b c)
                               ((? 109 car) . a)
                               ((? 110 cdr) b c)
                               ((? 110 car) . a)
                               ((? 109 b) a b c)
                               ((? x) ? 109 a))

unify-result=(((? 109 a) (? 123 u) ? 123 z) ((? 123 y) (? 109 car))
                                            ((? 123 v) (? 111 car))
                                            ((? 123 u) . c)
                                            ((? 120 z) (? 111 car))
                                            ((? 122 y) (? 111 car))
                                            ((? 111 a) (? 120 u) ? 120 z)
                                            ((? 120 y) (? 111 car))
                                            ((? 120 v))
                                            ((? 120 u) . c)
                                            ((? 113 a) (? 113 car))
                                            ((? 119 y) (? 113 car))
                                            ((? 113 rcdr))
                                            ((? 113 cdr))
                                            ((? 113 car) . c)
                                            ((? 114 cdr))
                                            ((? 114 car) . c)
                                            ((? 113 b) c)
                                            ((? 111 rcdr) ? 113 a)
                                            ((? 111 cdr) c)
                                            ((? 111 car) . b)
                                            ((? 112 cdr) c)
                                            ((? 112 car) . b)
                                            ((? 111 b) b c)
                                            ((? 109 rcdr) ? 111 a)
                                            ((? 109 cdr) b c)
                                            ((? 109 car) . a)
                                            ((? 110 cdr) b c)
                                            ((? 110 car) . a)
                                            ((? 109 b) a b c)
                                            ((? x) ? 109 a))

debug:simple-query
apply-a-rule
rule=(rule (append-to-form ((? u) ? v) (? y) ((? u) ? z))
           (append-to-form (? v) (? y) (? z)))
pattern=(append-to-form (? 123 v) (? 123 y) (? 123 z))
frame=(((? 109 a) (? 123 u) ? 123 z) ((? 123 y) (? 109 car))
                                     ((? 123 v) (? 111 car))
                                     ((? 123 u) . c)
                                     ((? 120 z) (? 111 car))
                                     ((? 122 y) (? 111 car))
                                     ((? 111 a) (? 120 u) ? 120 z)
                                     ((? 120 y) (? 111 car))
                                     ((? 120 v))
                                     ((? 120 u) . c)
                                     ((? 113 a) (? 113 car))
                                     ((? 119 y) (? 113 car))
                                     ((? 113 rcdr))
                                     ((? 113 cdr))
                                     ((? 113 car) . c)
                                     ((? 114 cdr))
                                     ((? 114 car) . c)
                                     ((? 113 b) c)
                                     ((? 111 rcdr) ? 113 a)
                                     ((? 111 cdr) c)
                                     ((? 111 car) . b)
                                     ((? 112 cdr) c)
                                     ((? 112 car) . b)
                                     ((? 111 b) b c)
                                     ((? 109 rcdr) ? 111 a)
                                     ((? 109 cdr) b c)
                                     ((? 109 car) . a)
                                     ((? 110 cdr) b c)
                                     ((? 110 car) . a)
                                     ((? 109 b) a b c)
                                     ((? x) ? 109 a))

unify-result=(((? 123 z) (? 124 u) ? 124 z) ((? 124 y) (? 109 car))
                                            ((? 124 v))
                                            ((? 124 u) . b)
                                            ((? 109 a) (? 123 u) ? 123 z)
                                            ((? 123 y) (? 109 car))
                                            ((? 123 v) (? 111 car))
                                            ((? 123 u) . c)
                                            ((? 120 z) (? 111 car))
                                            ((? 122 y) (? 111 car))
                                            ((? 111 a) (? 120 u) ? 120 z)
                                            ((? 120 y) (? 111 car))
                                            ((? 120 v))
                                            ((? 120 u) . c)
                                            ((? 113 a) (? 113 car))
                                            ((? 119 y) (? 113 car))
                                            ((? 113 rcdr))
                                            ((? 113 cdr))
                                            ((? 113 car) . c)
                                            ((? 114 cdr))
                                            ((? 114 car) . c)
                                            ((? 113 b) c)
                                            ((? 111 rcdr) ? 113 a)
                                            ((? 111 cdr) c)
                                            ((? 111 car) . b)
                                            ((? 112 cdr) c)
                                            ((? 112 car) . b)
                                            ((? 111 b) b c)
                                            ((? 109 rcdr) ? 111 a)
                                            ((? 109 cdr) b c)
                                            ((? 109 car) . a)
                                            ((? 110 cdr) b c)
                                            ((? 110 car) . a)
                                            ((? 109 b) a b c)
                                            ((? x) ? 109 a))

debug:simple-query
apply-a-rule
rule=(rule (append-to-form ((? u) ? v) (? y) ((? u) ? z))
           (append-to-form (? v) (? y) (? z)))
pattern=(append-to-form (? 124 v) (? 124 y) (? 124 z))
frame=(((? 123 z) (? 124 u) ? 124 z) ((? 124 y) (? 109 car))
                                     ((? 124 v))
                                     ((? 124 u) . b)
                                     ((? 109 a) (? 123 u) ? 123 z)
                                     ((? 123 y) (? 109 car))
                                     ((? 123 v) (? 111 car))
                                     ((? 123 u) . c)
                                     ((? 120 z) (? 111 car))
                                     ((? 122 y) (? 111 car))
                                     ((? 111 a) (? 120 u) ? 120 z)
                                     ((? 120 y) (? 111 car))
                                     ((? 120 v))
                                     ((? 120 u) . c)
                                     ((? 113 a) (? 113 car))
                                     ((? 119 y) (? 113 car))
                                     ((? 113 rcdr))
                                     ((? 113 cdr))
                                     ((? 113 car) . c)
                                     ((? 114 cdr))
                                     ((? 114 car) . c)
                                     ((? 113 b) c)
                                     ((? 111 rcdr) ? 113 a)
                                     ((? 111 cdr) c)
                                     ((? 111 car) . b)
                                     ((? 112 cdr) c)
                                     ((? 112 car) . b)
                                     ((? 111 b) b c)
                                     ((? 109 rcdr) ? 111 a)
                                     ((? 109 cdr) b c)
                                     ((? 109 car) . a)
                                     ((? 110 cdr) b c)
                                     ((? 110 car) . a)
                                     ((? 109 b) a b c)
                                     ((? x) ? 109 a))

unify-result=failed
apply-a-rule
rule=(rule (append-to-form () (? y) (? y)))
pattern=(append-to-form (? 124 v) (? 124 y) (? 124 z))
frame=(((? 123 z) (? 124 u) ? 124 z) ((? 124 y) (? 109 car))
                                     ((? 124 v))
                                     ((? 124 u) . b)
                                     ((? 109 a) (? 123 u) ? 123 z)
                                     ((? 123 y) (? 109 car))
                                     ((? 123 v) (? 111 car))
                                     ((? 123 u) . c)
                                     ((? 120 z) (? 111 car))
                                     ((? 122 y) (? 111 car))
                                     ((? 111 a) (? 120 u) ? 120 z)
                                     ((? 120 y) (? 111 car))
                                     ((? 120 v))
                                     ((? 120 u) . c)
                                     ((? 113 a) (? 113 car))
                                     ((? 119 y) (? 113 car))
                                     ((? 113 rcdr))
                                     ((? 113 cdr))
                                     ((? 113 car) . c)
                                     ((? 114 cdr))
                                     ((? 114 car) . c)
                                     ((? 113 b) c)
                                     ((? 111 rcdr) ? 113 a)
                                     ((? 111 cdr) c)
                                     ((? 111 car) . b)
                                     ((? 112 cdr) c)
                                     ((? 112 car) . b)
                                     ((? 111 b) b c)
                                     ((? 109 rcdr) ? 111 a)
                                     ((? 109 cdr) b c)
                                     ((? 109 car) . a)
                                     ((? 110 cdr) b c)
                                     ((? 110 car) . a)
                                     ((? 109 b) a b c)
                                     ((? x) ? 109 a))

unify-result=(((? 124 z) (? 109 car)) ((? 126 y) (? 109 car))
                                      ((? 123 z) (? 124 u) ? 124 z)
                                      ((? 124 y) (? 109 car))
                                      ((? 124 v))
                                      ((? 124 u) . b)
                                      ((? 109 a) (? 123 u) ? 123 z)
                                      ((? 123 y) (? 109 car))
                                      ((? 123 v) (? 111 car))
                                      ((? 123 u) . c)
                                      ((? 120 z) (? 111 car))
                                      ((? 122 y) (? 111 car))
                                      ((? 111 a) (? 120 u) ? 120 z)
                                      ((? 120 y) (? 111 car))
                                      ((? 120 v))
                                      ((? 120 u) . c)
                                      ((? 113 a) (? 113 car))
                                      ((? 119 y) (? 113 car))
                                      ((? 113 rcdr))
                                      ((? 113 cdr))
                                      ((? 113 car) . c)
                                      ((? 114 cdr))
                                      ((? 114 car) . c)
                                      ((? 113 b) c)
                                      ((? 111 rcdr) ? 113 a)
                                      ((? 111 cdr) c)
                                      ((? 111 car) . b)
                                      ((? 112 cdr) c)
                                      ((? 112 car) . b)
                                      ((? 111 b) b c)
                                      ((? 109 rcdr) ? 111 a)
                                      ((? 109 cdr) b c)
                                      ((? 109 car) . a)
                                      ((? 110 cdr) b c)
                                      ((? 110 car) . a)
                                      ((? 109 b) a b c)
                                      ((? x) ? 109 a))
(reverse-right (c b a) (a b c))
apply-a-rule
rule=(rule (reverse-right () ()))
pattern=(reverse-right (? x) (a b c))
frame=()

unify-result=failed
apply-a-rule
rule=(rule (reverse-right () ()))
pattern=(reverse-right (? 109 rcdr) (? 109 cdr))
frame=(((? 109 cdr) b c) ((? 109 car) . a)
                         ((? 110 cdr) b c)
                         ((? 110 car) . a)
                         ((? 109 b) a b c)
                         ((? x) ? 109 a))

unify-result=failed
apply-a-rule
rule=(rule (reverse-right () ()))
pattern=(reverse-right (? 111 rcdr) (? 111 cdr))
frame=(((? 111 cdr) c) ((? 111 car) . b)
                       ((? 112 cdr) c)
                       ((? 112 car) . b)
                       ((? 111 b) b c)
                       ((? 109 rcdr) ? 111 a)
                       ((? 109 cdr) b c)
                       ((? 109 car) . a)
                       ((? 110 cdr) b c)
                       ((? 110 car) . a)
                       ((? 109 b) a b c)
                       ((? x) ? 109 a))

unify-result=failed
apply-a-rule
rule=(rule (append-to-form () (? y) (? y)))
pattern=(append-to-form (? 111 rcdr) ((? 111 car)) (? 111 a))
frame=(((? 113 a) (? 113 car)) ((? 119 y) (? 113 car))
                               ((? 113 rcdr))
                               ((? 113 cdr))
                               ((? 113 car) . c)
                               ((? 114 cdr))
                               ((? 114 car) . c)
                               ((? 113 b) c)
                               ((? 111 rcdr) ? 113 a)
                               ((? 111 cdr) c)
                               ((? 111 car) . b)
                               ((? 112 cdr) c)
                               ((? 112 car) . b)
                               ((? 111 b) b c)
                               ((? 109 rcdr) ? 111 a)
                               ((? 109 cdr) b c)
                               ((? 109 car) . a)
                               ((? 110 cdr) b c)
                               ((? 110 car) . a)
                               ((? 109 b) a b c)
                               ((? x) ? 109 a))

unify-result=failed
apply-a-rule
rule=(rule (append-to-form () (? y) (? y)))
pattern=(append-to-form (? 109 rcdr) ((? 109 car)) (? 109 a))
frame=(((? 120 z) (? 111 car)) ((? 122 y) (? 111 car))
                               ((? 111 a) (? 120 u) ? 120 z)
                               ((? 120 y) (? 111 car))
                               ((? 120 v))
                               ((? 120 u) . c)
                               ((? 113 a) (? 113 car))
                               ((? 119 y) (? 113 car))
                               ((? 113 rcdr))
                               ((? 113 cdr))
                               ((? 113 car) . c)
                               ((? 114 cdr))
                               ((? 114 car) . c)
                               ((? 113 b) c)
                               ((? 111 rcdr) ? 113 a)
                               ((? 111 cdr) c)
                               ((? 111 car) . b)
                               ((? 112 cdr) c)
                               ((? 112 car) . b)
                               ((? 111 b) b c)
                               ((? 109 rcdr) ? 111 a)
                               ((? 109 cdr) b c)
                               ((? 109 car) . a)
                               ((? 110 cdr) b c)
                               ((? 110 car) . a)
                               ((? 109 b) a b c)
                               ((? x) ? 109 a))

unify-result=failed
apply-a-rule
rule=(rule (append-to-form () (? y) (? y)))
pattern=(append-to-form (? 123 v) (? 123 y) (? 123 z))
frame=(((? 109 a) (? 123 u) ? 123 z) ((? 123 y) (? 109 car))
                                     ((? 123 v) (? 111 car))
                                     ((? 123 u) . c)
                                     ((? 120 z) (? 111 car))
                                     ((? 122 y) (? 111 car))
                                     ((? 111 a) (? 120 u) ? 120 z)
                                     ((? 120 y) (? 111 car))
                                     ((? 120 v))
                                     ((? 120 u) . c)
                                     ((? 113 a) (? 113 car))
                                     ((? 119 y) (? 113 car))
                                     ((? 113 rcdr))
                                     ((? 113 cdr))
                                     ((? 113 car) . c)
                                     ((? 114 cdr))
                                     ((? 114 car) . c)
                                     ((? 113 b) c)
                                     ((? 111 rcdr) ? 113 a)
                                     ((? 111 cdr) c)
                                     ((? 111 car) . b)
                                     ((? 112 cdr) c)
                                     ((? 112 car) . b)
                                     ((? 111 b) b c)
                                     ((? 109 rcdr) ? 111 a)
                                     ((? 109 cdr) b c)
                                     ((? 109 car) . a)
                                     ((? 110 cdr) b c)
                                     ((? 110 car) . a)
                                     ((? 109 b) a b c)
                                     ((? x) ? 109 a))

unify-result=failed

;;; Query input:
(assert!
 (rule (palindrome (? x))
       (and (reverse-left (? x) (? rx)) (same (? x) (? rx)))))
Assertion added to data base.
;;; Query input:
(palindrome (1 2 2 1))
;;; Query results:

debug:simple-query
apply-a-rule
rule=(rule (palindrome (? x))
           (and (reverse-left (? x) (? rx)) (same (? x) (? rx))))
pattern=(palindrome (1 2 2 1))
frame=()

unify-result=(((? 133 x) 1 2 2 1))

debug:simple-query
apply-a-rule
rule=(rule (reverse-left (? a) (? b))
           (and (carcdr (? a) (? car) (? cdr))
                (reverse-left (? cdr) (? rcdr))
                (append-to-form (? rcdr) ((? car)) (? b))))
pattern=(reverse-left (? 133 x) (? 133 rx))
frame=(((? 133 x) 1 2 2 1))

unify-result=(((? 133 rx) ? 134 b) ((? 134 a) 1 2 2 1) ((? 133 x) 1 2 2 1))

debug:simple-query
apply-a-rule
rule=(rule (carcdr ((? car) ? cdr) (? car) (? cdr)))
pattern=(carcdr (? 134 a) (? 134 car) (? 134 cdr))
frame=(((? 133 rx) ? 134 b) ((? 134 a) 1 2 2 1) ((? 133 x) 1 2 2 1))

unify-result=(((? 134 cdr) 2 2 1) ((? 134 car) . 1)
                                  ((? 135 cdr) 2 2 1)
                                  ((? 135 car) . 1)
                                  ((? 133 rx) ? 134 b)
                                  ((? 134 a) 1 2 2 1)
                                  ((? 133 x) 1 2 2 1))

debug:simple-query
apply-a-rule
rule=(rule (reverse-left (? a) (? b))
           (and (carcdr (? a) (? car) (? cdr))
                (reverse-left (? cdr) (? rcdr))
                (append-to-form (? rcdr) ((? car)) (? b))))
pattern=(reverse-left (? 134 cdr) (? 134 rcdr))
frame=(((? 134 cdr) 2 2 1) ((? 134 car) . 1)
                           ((? 135 cdr) 2 2 1)
                           ((? 135 car) . 1)
                           ((? 133 rx) ? 134 b)
                           ((? 134 a) 1 2 2 1)
                           ((? 133 x) 1 2 2 1))

unify-result=(((? 134 rcdr) ? 136 b) ((? 136 a) 2 2 1)
                                     ((? 134 cdr) 2 2 1)
                                     ((? 134 car) . 1)
                                     ((? 135 cdr) 2 2 1)
                                     ((? 135 car) . 1)
                                     ((? 133 rx) ? 134 b)
                                     ((? 134 a) 1 2 2 1)
                                     ((? 133 x) 1 2 2 1))

debug:simple-query
apply-a-rule
rule=(rule (carcdr ((? car) ? cdr) (? car) (? cdr)))
pattern=(carcdr (? 136 a) (? 136 car) (? 136 cdr))
frame=(((? 134 rcdr) ? 136 b) ((? 136 a) 2 2 1)
                              ((? 134 cdr) 2 2 1)
                              ((? 134 car) . 1)
                              ((? 135 cdr) 2 2 1)
                              ((? 135 car) . 1)
                              ((? 133 rx) ? 134 b)
                              ((? 134 a) 1 2 2 1)
                              ((? 133 x) 1 2 2 1))

unify-result=(((? 136 cdr) 2 1) ((? 136 car) . 2)
                                ((? 137 cdr) 2 1)
                                ((? 137 car) . 2)
                                ((? 134 rcdr) ? 136 b)
                                ((? 136 a) 2 2 1)
                                ((? 134 cdr) 2 2 1)
                                ((? 134 car) . 1)
                                ((? 135 cdr) 2 2 1)
                                ((? 135 car) . 1)
                                ((? 133 rx) ? 134 b)
                                ((? 134 a) 1 2 2 1)
                                ((? 133 x) 1 2 2 1))

debug:simple-query
apply-a-rule
rule=(rule (reverse-left (? a) (? b))
           (and (carcdr (? a) (? car) (? cdr))
                (reverse-left (? cdr) (? rcdr))
                (append-to-form (? rcdr) ((? car)) (? b))))
pattern=(reverse-left (? 136 cdr) (? 136 rcdr))
frame=(((? 136 cdr) 2 1) ((? 136 car) . 2)
                         ((? 137 cdr) 2 1)
                         ((? 137 car) . 2)
                         ((? 134 rcdr) ? 136 b)
                         ((? 136 a) 2 2 1)
                         ((? 134 cdr) 2 2 1)
                         ((? 134 car) . 1)
                         ((? 135 cdr) 2 2 1)
                         ((? 135 car) . 1)
                         ((? 133 rx) ? 134 b)
                         ((? 134 a) 1 2 2 1)
                         ((? 133 x) 1 2 2 1))

unify-result=(((? 136 rcdr) ? 138 b) ((? 138 a) 2 1)
                                     ((? 136 cdr) 2 1)
                                     ((? 136 car) . 2)
                                     ((? 137 cdr) 2 1)
                                     ((? 137 car) . 2)
                                     ((? 134 rcdr) ? 136 b)
                                     ((? 136 a) 2 2 1)
                                     ((? 134 cdr) 2 2 1)
                                     ((? 134 car) . 1)
                                     ((? 135 cdr) 2 2 1)
                                     ((? 135 car) . 1)
                                     ((? 133 rx) ? 134 b)
                                     ((? 134 a) 1 2 2 1)
                                     ((? 133 x) 1 2 2 1))

debug:simple-query
apply-a-rule
rule=(rule (carcdr ((? car) ? cdr) (? car) (? cdr)))
pattern=(carcdr (? 138 a) (? 138 car) (? 138 cdr))
frame=(((? 136 rcdr) ? 138 b) ((? 138 a) 2 1)
                              ((? 136 cdr) 2 1)
                              ((? 136 car) . 2)
                              ((? 137 cdr) 2 1)
                              ((? 137 car) . 2)
                              ((? 134 rcdr) ? 136 b)
                              ((? 136 a) 2 2 1)
                              ((? 134 cdr) 2 2 1)
                              ((? 134 car) . 1)
                              ((? 135 cdr) 2 2 1)
                              ((? 135 car) . 1)
                              ((? 133 rx) ? 134 b)
                              ((? 134 a) 1 2 2 1)
                              ((? 133 x) 1 2 2 1))

unify-result=(((? 138 cdr) 1) ((? 138 car) . 2)
                              ((? 139 cdr) 1)
                              ((? 139 car) . 2)
                              ((? 136 rcdr) ? 138 b)
                              ((? 138 a) 2 1)
                              ((? 136 cdr) 2 1)
                              ((? 136 car) . 2)
                              ((? 137 cdr) 2 1)
                              ((? 137 car) . 2)
                              ((? 134 rcdr) ? 136 b)
                              ((? 136 a) 2 2 1)
                              ((? 134 cdr) 2 2 1)
                              ((? 134 car) . 1)
                              ((? 135 cdr) 2 2 1)
                              ((? 135 car) . 1)
                              ((? 133 rx) ? 134 b)
                              ((? 134 a) 1 2 2 1)
                              ((? 133 x) 1 2 2 1))

debug:simple-query
apply-a-rule
rule=(rule (reverse-left (? a) (? b))
           (and (carcdr (? a) (? car) (? cdr))
                (reverse-left (? cdr) (? rcdr))
                (append-to-form (? rcdr) ((? car)) (? b))))
pattern=(reverse-left (? 138 cdr) (? 138 rcdr))
frame=(((? 138 cdr) 1) ((? 138 car) . 2)
                       ((? 139 cdr) 1)
                       ((? 139 car) . 2)
                       ((? 136 rcdr) ? 138 b)
                       ((? 138 a) 2 1)
                       ((? 136 cdr) 2 1)
                       ((? 136 car) . 2)
                       ((? 137 cdr) 2 1)
                       ((? 137 car) . 2)
                       ((? 134 rcdr) ? 136 b)
                       ((? 136 a) 2 2 1)
                       ((? 134 cdr) 2 2 1)
                       ((? 134 car) . 1)
                       ((? 135 cdr) 2 2 1)
                       ((? 135 car) . 1)
                       ((? 133 rx) ? 134 b)
                       ((? 134 a) 1 2 2 1)
                       ((? 133 x) 1 2 2 1))

unify-result=(((? 138 rcdr) ? 140 b) ((? 140 a) 1)
                                     ((? 138 cdr) 1)
                                     ((? 138 car) . 2)
                                     ((? 139 cdr) 1)
                                     ((? 139 car) . 2)
                                     ((? 136 rcdr) ? 138 b)
                                     ((? 138 a) 2 1)
                                     ((? 136 cdr) 2 1)
                                     ((? 136 car) . 2)
                                     ((? 137 cdr) 2 1)
                                     ((? 137 car) . 2)
                                     ((? 134 rcdr) ? 136 b)
                                     ((? 136 a) 2 2 1)
                                     ((? 134 cdr) 2 2 1)
                                     ((? 134 car) . 1)
                                     ((? 135 cdr) 2 2 1)
                                     ((? 135 car) . 1)
                                     ((? 133 rx) ? 134 b)
                                     ((? 134 a) 1 2 2 1)
                                     ((? 133 x) 1 2 2 1))

debug:simple-query
apply-a-rule
rule=(rule (carcdr ((? car) ? cdr) (? car) (? cdr)))
pattern=(carcdr (? 140 a) (? 140 car) (? 140 cdr))
frame=(((? 138 rcdr) ? 140 b) ((? 140 a) 1)
                              ((? 138 cdr) 1)
                              ((? 138 car) . 2)
                              ((? 139 cdr) 1)
                              ((? 139 car) . 2)
                              ((? 136 rcdr) ? 138 b)
                              ((? 138 a) 2 1)
                              ((? 136 cdr) 2 1)
                              ((? 136 car) . 2)
                              ((? 137 cdr) 2 1)
                              ((? 137 car) . 2)
                              ((? 134 rcdr) ? 136 b)
                              ((? 136 a) 2 2 1)
                              ((? 134 cdr) 2 2 1)
                              ((? 134 car) . 1)
                              ((? 135 cdr) 2 2 1)
                              ((? 135 car) . 1)
                              ((? 133 rx) ? 134 b)
                              ((? 134 a) 1 2 2 1)
                              ((? 133 x) 1 2 2 1))

unify-result=(((? 140 cdr)) ((? 140 car) . 1)
                            ((? 141 cdr))
                            ((? 141 car) . 1)
                            ((? 138 rcdr) ? 140 b)
                            ((? 140 a) 1)
                            ((? 138 cdr) 1)
                            ((? 138 car) . 2)
                            ((? 139 cdr) 1)
                            ((? 139 car) . 2)
                            ((? 136 rcdr) ? 138 b)
                            ((? 138 a) 2 1)
                            ((? 136 cdr) 2 1)
                            ((? 136 car) . 2)
                            ((? 137 cdr) 2 1)
                            ((? 137 car) . 2)
                            ((? 134 rcdr) ? 136 b)
                            ((? 136 a) 2 2 1)
                            ((? 134 cdr) 2 2 1)
                            ((? 134 car) . 1)
                            ((? 135 cdr) 2 2 1)
                            ((? 135 car) . 1)
                            ((? 133 rx) ? 134 b)
                            ((? 134 a) 1 2 2 1)
                            ((? 133 x) 1 2 2 1))

debug:simple-query
apply-a-rule
rule=(rule (reverse-left (? a) (? b))
           (and (carcdr (? a) (? car) (? cdr))
                (reverse-left (? cdr) (? rcdr))
                (append-to-form (? rcdr) ((? car)) (? b))))
pattern=(reverse-left (? 140 cdr) (? 140 rcdr))
frame=(((? 140 cdr)) ((? 140 car) . 1)
                     ((? 141 cdr))
                     ((? 141 car) . 1)
                     ((? 138 rcdr) ? 140 b)
                     ((? 140 a) 1)
                     ((? 138 cdr) 1)
                     ((? 138 car) . 2)
                     ((? 139 cdr) 1)
                     ((? 139 car) . 2)
                     ((? 136 rcdr) ? 138 b)
                     ((? 138 a) 2 1)
                     ((? 136 cdr) 2 1)
                     ((? 136 car) . 2)
                     ((? 137 cdr) 2 1)
                     ((? 137 car) . 2)
                     ((? 134 rcdr) ? 136 b)
                     ((? 136 a) 2 2 1)
                     ((? 134 cdr) 2 2 1)
                     ((? 134 car) . 1)
                     ((? 135 cdr) 2 2 1)
                     ((? 135 car) . 1)
                     ((? 133 rx) ? 134 b)
                     ((? 134 a) 1 2 2 1)
                     ((? 133 x) 1 2 2 1))

unify-result=(((? 140 rcdr) ? 142 b) ((? 142 a))
                                     ((? 140 cdr))
                                     ((? 140 car) . 1)
                                     ((? 141 cdr))
                                     ((? 141 car) . 1)
                                     ((? 138 rcdr) ? 140 b)
                                     ((? 140 a) 1)
                                     ((? 138 cdr) 1)
                                     ((? 138 car) . 2)
                                     ((? 139 cdr) 1)
                                     ((? 139 car) . 2)
                                     ((? 136 rcdr) ? 138 b)
                                     ((? 138 a) 2 1)
                                     ((? 136 cdr) 2 1)
                                     ((? 136 car) . 2)
                                     ((? 137 cdr) 2 1)
                                     ((? 137 car) . 2)
                                     ((? 134 rcdr) ? 136 b)
                                     ((? 136 a) 2 2 1)
                                     ((? 134 cdr) 2 2 1)
                                     ((? 134 car) . 1)
                                     ((? 135 cdr) 2 2 1)
                                     ((? 135 car) . 1)
                                     ((? 133 rx) ? 134 b)
                                     ((? 134 a) 1 2 2 1)
                                     ((? 133 x) 1 2 2 1))

debug:simple-query
apply-a-rule
rule=(rule (carcdr ((? car) ? cdr) (? car) (? cdr)))
pattern=(carcdr (? 142 a) (? 142 car) (? 142 cdr))
frame=(((? 140 rcdr) ? 142 b) ((? 142 a))
                              ((? 140 cdr))
                              ((? 140 car) . 1)
                              ((? 141 cdr))
                              ((? 141 car) . 1)
                              ((? 138 rcdr) ? 140 b)
                              ((? 140 a) 1)
                              ((? 138 cdr) 1)
                              ((? 138 car) . 2)
                              ((? 139 cdr) 1)
                              ((? 139 car) . 2)
                              ((? 136 rcdr) ? 138 b)
                              ((? 138 a) 2 1)
                              ((? 136 cdr) 2 1)
                              ((? 136 car) . 2)
                              ((? 137 cdr) 2 1)
                              ((? 137 car) . 2)
                              ((? 134 rcdr) ? 136 b)
                              ((? 136 a) 2 2 1)
                              ((? 134 cdr) 2 2 1)
                              ((? 134 car) . 1)
                              ((? 135 cdr) 2 2 1)
                              ((? 135 car) . 1)
                              ((? 133 rx) ? 134 b)
                              ((? 134 a) 1 2 2 1)
                              ((? 133 x) 1 2 2 1))

unify-result=failed

debug:simple-query

debug:simple-query
apply-a-rule
rule=(rule (reverse-left () ()))
pattern=(reverse-left (? 140 cdr) (? 140 rcdr))
frame=(((? 140 cdr)) ((? 140 car) . 1)
                     ((? 141 cdr))
                     ((? 141 car) . 1)
                     ((? 138 rcdr) ? 140 b)
                     ((? 140 a) 1)
                     ((? 138 cdr) 1)
                     ((? 138 car) . 2)
                     ((? 139 cdr) 1)
                     ((? 139 car) . 2)
                     ((? 136 rcdr) ? 138 b)
                     ((? 138 a) 2 1)
                     ((? 136 cdr) 2 1)
                     ((? 136 car) . 2)
                     ((? 137 cdr) 2 1)
                     ((? 137 car) . 2)
                     ((? 134 rcdr) ? 136 b)
                     ((? 136 a) 2 2 1)
                     ((? 134 cdr) 2 2 1)
                     ((? 134 car) . 1)
                     ((? 135 cdr) 2 2 1)
                     ((? 135 car) . 1)
                     ((? 133 rx) ? 134 b)
                     ((? 134 a) 1 2 2 1)
                     ((? 133 x) 1 2 2 1))

unify-result=(((? 140 rcdr)) ((? 140 cdr))
                             ((? 140 car) . 1)
                             ((? 141 cdr))
                             ((? 141 car) . 1)
                             ((? 138 rcdr) ? 140 b)
                             ((? 140 a) 1)
                             ((? 138 cdr) 1)
                             ((? 138 car) . 2)
                             ((? 139 cdr) 1)
                             ((? 139 car) . 2)
                             ((? 136 rcdr) ? 138 b)
                             ((? 138 a) 2 1)
                             ((? 136 cdr) 2 1)
                             ((? 136 car) . 2)
                             ((? 137 cdr) 2 1)
                             ((? 137 car) . 2)
                             ((? 134 rcdr) ? 136 b)
                             ((? 136 a) 2 2 1)
                             ((? 134 cdr) 2 2 1)
                             ((? 134 car) . 1)
                             ((? 135 cdr) 2 2 1)
                             ((? 135 car) . 1)
                             ((? 133 rx) ? 134 b)
                             ((? 134 a) 1 2 2 1)
                             ((? 133 x) 1 2 2 1))

debug:simple-query
apply-a-rule
rule=(rule (append-to-form ((? u) ? v) (? y) ((? u) ? z))
           (append-to-form (? v) (? y) (? z)))
pattern=(append-to-form (? 140 rcdr) ((? 140 car)) (? 140 b))
frame=(((? 140 rcdr)) ((? 140 cdr))
                      ((? 140 car) . 1)
                      ((? 141 cdr))
                      ((? 141 car) . 1)
                      ((? 138 rcdr) ? 140 b)
                      ((? 140 a) 1)
                      ((? 138 cdr) 1)
                      ((? 138 car) . 2)
                      ((? 139 cdr) 1)
                      ((? 139 car) . 2)
                      ((? 136 rcdr) ? 138 b)
                      ((? 138 a) 2 1)
                      ((? 136 cdr) 2 1)
                      ((? 136 car) . 2)
                      ((? 137 cdr) 2 1)
                      ((? 137 car) . 2)
                      ((? 134 rcdr) ? 136 b)
                      ((? 136 a) 2 2 1)
                      ((? 134 cdr) 2 2 1)
                      ((? 134 car) . 1)
                      ((? 135 cdr) 2 2 1)
                      ((? 135 car) . 1)
                      ((? 133 rx) ? 134 b)
                      ((? 134 a) 1 2 2 1)
                      ((? 133 x) 1 2 2 1))

unify-result=failed
apply-a-rule
rule=(rule (append-to-form () (? y) (? y)))
pattern=(append-to-form (? 140 rcdr) ((? 140 car)) (? 140 b))
frame=(((? 140 rcdr)) ((? 140 cdr))
                      ((? 140 car) . 1)
                      ((? 141 cdr))
                      ((? 141 car) . 1)
                      ((? 138 rcdr) ? 140 b)
                      ((? 140 a) 1)
                      ((? 138 cdr) 1)
                      ((? 138 car) . 2)
                      ((? 139 cdr) 1)
                      ((? 139 car) . 2)
                      ((? 136 rcdr) ? 138 b)
                      ((? 138 a) 2 1)
                      ((? 136 cdr) 2 1)
                      ((? 136 car) . 2)
                      ((? 137 cdr) 2 1)
                      ((? 137 car) . 2)
                      ((? 134 rcdr) ? 136 b)
                      ((? 136 a) 2 2 1)
                      ((? 134 cdr) 2 2 1)
                      ((? 134 car) . 1)
                      ((? 135 cdr) 2 2 1)
                      ((? 135 car) . 1)
                      ((? 133 rx) ? 134 b)
                      ((? 134 a) 1 2 2 1)
                      ((? 133 x) 1 2 2 1))

unify-result=(((? 140 b) (? 140 car)) ((? 146 y) (? 140 car))
                                      ((? 140 rcdr))
                                      ((? 140 cdr))
                                      ((? 140 car) . 1)
                                      ((? 141 cdr))
                                      ((? 141 car) . 1)
                                      ((? 138 rcdr) ? 140 b)
                                      ((? 140 a) 1)
                                      ((? 138 cdr) 1)
                                      ((? 138 car) . 2)
                                      ((? 139 cdr) 1)
                                      ((? 139 car) . 2)
                                      ((? 136 rcdr) ? 138 b)
                                      ((? 138 a) 2 1)
                                      ((? 136 cdr) 2 1)
                                      ((? 136 car) . 2)
                                      ((? 137 cdr) 2 1)
                                      ((? 137 car) . 2)
                                      ((? 134 rcdr) ? 136 b)
                                      ((? 136 a) 2 2 1)
                                      ((? 134 cdr) 2 2 1)
                                      ((? 134 car) . 1)
                                      ((? 135 cdr) 2 2 1)
                                      ((? 135 car) . 1)
                                      ((? 133 rx) ? 134 b)
                                      ((? 134 a) 1 2 2 1)
                                      ((? 133 x) 1 2 2 1))

debug:simple-query
apply-a-rule
rule=(rule (append-to-form ((? u) ? v) (? y) ((? u) ? z))
           (append-to-form (? v) (? y) (? z)))
pattern=(append-to-form (? 138 rcdr) ((? 138 car)) (? 138 b))
frame=(((? 140 b) (? 140 car)) ((? 146 y) (? 140 car))
                               ((? 140 rcdr))
                               ((? 140 cdr))
                               ((? 140 car) . 1)
                               ((? 141 cdr))
                               ((? 141 car) . 1)
                               ((? 138 rcdr) ? 140 b)
                               ((? 140 a) 1)
                               ((? 138 cdr) 1)
                               ((? 138 car) . 2)
                               ((? 139 cdr) 1)
                               ((? 139 car) . 2)
                               ((? 136 rcdr) ? 138 b)
                               ((? 138 a) 2 1)
                               ((? 136 cdr) 2 1)
                               ((? 136 car) . 2)
                               ((? 137 cdr) 2 1)
                               ((? 137 car) . 2)
                               ((? 134 rcdr) ? 136 b)
                               ((? 136 a) 2 2 1)
                               ((? 134 cdr) 2 2 1)
                               ((? 134 car) . 1)
                               ((? 135 cdr) 2 2 1)
                               ((? 135 car) . 1)
                               ((? 133 rx) ? 134 b)
                               ((? 134 a) 1 2 2 1)
                               ((? 133 x) 1 2 2 1))

unify-result=(((? 138 b) (? 147 u) ? 147 z) ((? 147 y) (? 138 car))
                                            ((? 147 v))
                                            ((? 147 u) . 1)
                                            ((? 140 b) (? 140 car))
                                            ((? 146 y) (? 140 car))
                                            ((? 140 rcdr))
                                            ((? 140 cdr))
                                            ((? 140 car) . 1)
                                            ((? 141 cdr))
                                            ((? 141 car) . 1)
                                            ((? 138 rcdr) ? 140 b)
                                            ((? 140 a) 1)
                                            ((? 138 cdr) 1)
                                            ((? 138 car) . 2)
                                            ((? 139 cdr) 1)
                                            ((? 139 car) . 2)
                                            ((? 136 rcdr) ? 138 b)
                                            ((? 138 a) 2 1)
                                            ((? 136 cdr) 2 1)
                                            ((? 136 car) . 2)
                                            ((? 137 cdr) 2 1)
                                            ((? 137 car) . 2)
                                            ((? 134 rcdr) ? 136 b)
                                            ((? 136 a) 2 2 1)
                                            ((? 134 cdr) 2 2 1)
                                            ((? 134 car) . 1)
                                            ((? 135 cdr) 2 2 1)
                                            ((? 135 car) . 1)
                                            ((? 133 rx) ? 134 b)
                                            ((? 134 a) 1 2 2 1)
                                            ((? 133 x) 1 2 2 1))

debug:simple-query
apply-a-rule
rule=(rule (append-to-form ((? u) ? v) (? y) ((? u) ? z))
           (append-to-form (? v) (? y) (? z)))
pattern=(append-to-form (? 147 v) (? 147 y) (? 147 z))
frame=(((? 138 b) (? 147 u) ? 147 z) ((? 147 y) (? 138 car))
                                     ((? 147 v))
                                     ((? 147 u) . 1)
                                     ((? 140 b) (? 140 car))
                                     ((? 146 y) (? 140 car))
                                     ((? 140 rcdr))
                                     ((? 140 cdr))
                                     ((? 140 car) . 1)
                                     ((? 141 cdr))
                                     ((? 141 car) . 1)
                                     ((? 138 rcdr) ? 140 b)
                                     ((? 140 a) 1)
                                     ((? 138 cdr) 1)
                                     ((? 138 car) . 2)
                                     ((? 139 cdr) 1)
                                     ((? 139 car) . 2)
                                     ((? 136 rcdr) ? 138 b)
                                     ((? 138 a) 2 1)
                                     ((? 136 cdr) 2 1)
                                     ((? 136 car) . 2)
                                     ((? 137 cdr) 2 1)
                                     ((? 137 car) . 2)
                                     ((? 134 rcdr) ? 136 b)
                                     ((? 136 a) 2 2 1)
                                     ((? 134 cdr) 2 2 1)
                                     ((? 134 car) . 1)
                                     ((? 135 cdr) 2 2 1)
                                     ((? 135 car) . 1)
                                     ((? 133 rx) ? 134 b)
                                     ((? 134 a) 1 2 2 1)
                                     ((? 133 x) 1 2 2 1))

unify-result=failed
apply-a-rule
rule=(rule (append-to-form () (? y) (? y)))
pattern=(append-to-form (? 147 v) (? 147 y) (? 147 z))
frame=(((? 138 b) (? 147 u) ? 147 z) ((? 147 y) (? 138 car))
                                     ((? 147 v))
                                     ((? 147 u) . 1)
                                     ((? 140 b) (? 140 car))
                                     ((? 146 y) (? 140 car))
                                     ((? 140 rcdr))
                                     ((? 140 cdr))
                                     ((? 140 car) . 1)
                                     ((? 141 cdr))
                                     ((? 141 car) . 1)
                                     ((? 138 rcdr) ? 140 b)
                                     ((? 140 a) 1)
                                     ((? 138 cdr) 1)
                                     ((? 138 car) . 2)
                                     ((? 139 cdr) 1)
                                     ((? 139 car) . 2)
                                     ((? 136 rcdr) ? 138 b)
                                     ((? 138 a) 2 1)
                                     ((? 136 cdr) 2 1)
                                     ((? 136 car) . 2)
                                     ((? 137 cdr) 2 1)
                                     ((? 137 car) . 2)
                                     ((? 134 rcdr) ? 136 b)
                                     ((? 136 a) 2 2 1)
                                     ((? 134 cdr) 2 2 1)
                                     ((? 134 car) . 1)
                                     ((? 135 cdr) 2 2 1)
                                     ((? 135 car) . 1)
                                     ((? 133 rx) ? 134 b)
                                     ((? 134 a) 1 2 2 1)
                                     ((? 133 x) 1 2 2 1))

unify-result=(((? 147 z) (? 138 car)) ((? 149 y) (? 138 car))
                                      ((? 138 b) (? 147 u) ? 147 z)
                                      ((? 147 y) (? 138 car))
                                      ((? 147 v))
                                      ((? 147 u) . 1)
                                      ((? 140 b) (? 140 car))
                                      ((? 146 y) (? 140 car))
                                      ((? 140 rcdr))
                                      ((? 140 cdr))
                                      ((? 140 car) . 1)
                                      ((? 141 cdr))
                                      ((? 141 car) . 1)
                                      ((? 138 rcdr) ? 140 b)
                                      ((? 140 a) 1)
                                      ((? 138 cdr) 1)
                                      ((? 138 car) . 2)
                                      ((? 139 cdr) 1)
                                      ((? 139 car) . 2)
                                      ((? 136 rcdr) ? 138 b)
                                      ((? 138 a) 2 1)
                                      ((? 136 cdr) 2 1)
                                      ((? 136 car) . 2)
                                      ((? 137 cdr) 2 1)
                                      ((? 137 car) . 2)
                                      ((? 134 rcdr) ? 136 b)
                                      ((? 136 a) 2 2 1)
                                      ((? 134 cdr) 2 2 1)
                                      ((? 134 car) . 1)
                                      ((? 135 cdr) 2 2 1)
                                      ((? 135 car) . 1)
                                      ((? 133 rx) ? 134 b)
                                      ((? 134 a) 1 2 2 1)
                                      ((? 133 x) 1 2 2 1))

debug:simple-query
apply-a-rule
rule=(rule (append-to-form ((? u) ? v) (? y) ((? u) ? z))
           (append-to-form (? v) (? y) (? z)))
pattern=(append-to-form (? 136 rcdr) ((? 136 car)) (? 136 b))
frame=(((? 147 z) (? 138 car)) ((? 149 y) (? 138 car))
                               ((? 138 b) (? 147 u) ? 147 z)
                               ((? 147 y) (? 138 car))
                               ((? 147 v))
                               ((? 147 u) . 1)
                               ((? 140 b) (? 140 car))
                               ((? 146 y) (? 140 car))
                               ((? 140 rcdr))
                               ((? 140 cdr))
                               ((? 140 car) . 1)
                               ((? 141 cdr))
                               ((? 141 car) . 1)
                               ((? 138 rcdr) ? 140 b)
                               ((? 140 a) 1)
                               ((? 138 cdr) 1)
                               ((? 138 car) . 2)
                               ((? 139 cdr) 1)
                               ((? 139 car) . 2)
                               ((? 136 rcdr) ? 138 b)
                               ((? 138 a) 2 1)
                               ((? 136 cdr) 2 1)
                               ((? 136 car) . 2)
                               ((? 137 cdr) 2 1)
                               ((? 137 car) . 2)
                               ((? 134 rcdr) ? 136 b)
                               ((? 136 a) 2 2 1)
                               ((? 134 cdr) 2 2 1)
                               ((? 134 car) . 1)
                               ((? 135 cdr) 2 2 1)
                               ((? 135 car) . 1)
                               ((? 133 rx) ? 134 b)
                               ((? 134 a) 1 2 2 1)
                               ((? 133 x) 1 2 2 1))

unify-result=(((? 136 b) (? 150 u) ? 150 z) ((? 150 y) (? 136 car))
                                            ((? 150 v) (? 138 car))
                                            ((? 150 u) . 1)
                                            ((? 147 z) (? 138 car))
                                            ((? 149 y) (? 138 car))
                                            ((? 138 b) (? 147 u) ? 147 z)
                                            ((? 147 y) (? 138 car))
                                            ((? 147 v))
                                            ((? 147 u) . 1)
                                            ((? 140 b) (? 140 car))
                                            ((? 146 y) (? 140 car))
                                            ((? 140 rcdr))
                                            ((? 140 cdr))
                                            ((? 140 car) . 1)
                                            ((? 141 cdr))
                                            ((? 141 car) . 1)
                                            ((? 138 rcdr) ? 140 b)
                                            ((? 140 a) 1)
                                            ((? 138 cdr) 1)
                                            ((? 138 car) . 2)
                                            ((? 139 cdr) 1)
                                            ((? 139 car) . 2)
                                            ((? 136 rcdr) ? 138 b)
                                            ((? 138 a) 2 1)
                                            ((? 136 cdr) 2 1)
                                            ((? 136 car) . 2)
                                            ((? 137 cdr) 2 1)
                                            ((? 137 car) . 2)
                                            ((? 134 rcdr) ? 136 b)
                                            ((? 136 a) 2 2 1)
                                            ((? 134 cdr) 2 2 1)
                                            ((? 134 car) . 1)
                                            ((? 135 cdr) 2 2 1)
                                            ((? 135 car) . 1)
                                            ((? 133 rx) ? 134 b)
                                            ((? 134 a) 1 2 2 1)
                                            ((? 133 x) 1 2 2 1))

debug:simple-query
apply-a-rule
rule=(rule (append-to-form ((? u) ? v) (? y) ((? u) ? z))
           (append-to-form (? v) (? y) (? z)))
pattern=(append-to-form (? 150 v) (? 150 y) (? 150 z))
frame=(((? 136 b) (? 150 u) ? 150 z) ((? 150 y) (? 136 car))
                                     ((? 150 v) (? 138 car))
                                     ((? 150 u) . 1)
                                     ((? 147 z) (? 138 car))
                                     ((? 149 y) (? 138 car))
                                     ((? 138 b) (? 147 u) ? 147 z)
                                     ((? 147 y) (? 138 car))
                                     ((? 147 v))
                                     ((? 147 u) . 1)
                                     ((? 140 b) (? 140 car))
                                     ((? 146 y) (? 140 car))
                                     ((? 140 rcdr))
                                     ((? 140 cdr))
                                     ((? 140 car) . 1)
                                     ((? 141 cdr))
                                     ((? 141 car) . 1)
                                     ((? 138 rcdr) ? 140 b)
                                     ((? 140 a) 1)
                                     ((? 138 cdr) 1)
                                     ((? 138 car) . 2)
                                     ((? 139 cdr) 1)
                                     ((? 139 car) . 2)
                                     ((? 136 rcdr) ? 138 b)
                                     ((? 138 a) 2 1)
                                     ((? 136 cdr) 2 1)
                                     ((? 136 car) . 2)
                                     ((? 137 cdr) 2 1)
                                     ((? 137 car) . 2)
                                     ((? 134 rcdr) ? 136 b)
                                     ((? 136 a) 2 2 1)
                                     ((? 134 cdr) 2 2 1)
                                     ((? 134 car) . 1)
                                     ((? 135 cdr) 2 2 1)
                                     ((? 135 car) . 1)
                                     ((? 133 rx) ? 134 b)
                                     ((? 134 a) 1 2 2 1)
                                     ((? 133 x) 1 2 2 1))

unify-result=(((? 150 z) (? 151 u) ? 151 z) ((? 151 y) (? 136 car))
                                            ((? 151 v))
                                            ((? 151 u) . 2)
                                            ((? 136 b) (? 150 u) ? 150 z)
                                            ((? 150 y) (? 136 car))
                                            ((? 150 v) (? 138 car))
                                            ((? 150 u) . 1)
                                            ((? 147 z) (? 138 car))
                                            ((? 149 y) (? 138 car))
                                            ((? 138 b) (? 147 u) ? 147 z)
                                            ((? 147 y) (? 138 car))
                                            ((? 147 v))
                                            ((? 147 u) . 1)
                                            ((? 140 b) (? 140 car))
                                            ((? 146 y) (? 140 car))
                                            ((? 140 rcdr))
                                            ((? 140 cdr))
                                            ((? 140 car) . 1)
                                            ((? 141 cdr))
                                            ((? 141 car) . 1)
                                            ((? 138 rcdr) ? 140 b)
                                            ((? 140 a) 1)
                                            ((? 138 cdr) 1)
                                            ((? 138 car) . 2)
                                            ((? 139 cdr) 1)
                                            ((? 139 car) . 2)
                                            ((? 136 rcdr) ? 138 b)
                                            ((? 138 a) 2 1)
                                            ((? 136 cdr) 2 1)
                                            ((? 136 car) . 2)
                                            ((? 137 cdr) 2 1)
                                            ((? 137 car) . 2)
                                            ((? 134 rcdr) ? 136 b)
                                            ((? 136 a) 2 2 1)
                                            ((? 134 cdr) 2 2 1)
                                            ((? 134 car) . 1)
                                            ((? 135 cdr) 2 2 1)
                                            ((? 135 car) . 1)
                                            ((? 133 rx) ? 134 b)
                                            ((? 134 a) 1 2 2 1)
                                            ((? 133 x) 1 2 2 1))

debug:simple-query
apply-a-rule
rule=(rule (append-to-form ((? u) ? v) (? y) ((? u) ? z))
           (append-to-form (? v) (? y) (? z)))
pattern=(append-to-form (? 151 v) (? 151 y) (? 151 z))
frame=(((? 150 z) (? 151 u) ? 151 z) ((? 151 y) (? 136 car))
                                     ((? 151 v))
                                     ((? 151 u) . 2)
                                     ((? 136 b) (? 150 u) ? 150 z)
                                     ((? 150 y) (? 136 car))
                                     ((? 150 v) (? 138 car))
                                     ((? 150 u) . 1)
                                     ((? 147 z) (? 138 car))
                                     ((? 149 y) (? 138 car))
                                     ((? 138 b) (? 147 u) ? 147 z)
                                     ((? 147 y) (? 138 car))
                                     ((? 147 v))
                                     ((? 147 u) . 1)
                                     ((? 140 b) (? 140 car))
                                     ((? 146 y) (? 140 car))
                                     ((? 140 rcdr))
                                     ((? 140 cdr))
                                     ((? 140 car) . 1)
                                     ((? 141 cdr))
                                     ((? 141 car) . 1)
                                     ((? 138 rcdr) ? 140 b)
                                     ((? 140 a) 1)
                                     ((? 138 cdr) 1)
                                     ((? 138 car) . 2)
                                     ((? 139 cdr) 1)
                                     ((? 139 car) . 2)
                                     ((? 136 rcdr) ? 138 b)
                                     ((? 138 a) 2 1)
                                     ((? 136 cdr) 2 1)
                                     ((? 136 car) . 2)
                                     ((? 137 cdr) 2 1)
                                     ((? 137 car) . 2)
                                     ((? 134 rcdr) ? 136 b)
                                     ((? 136 a) 2 2 1)
                                     ((? 134 cdr) 2 2 1)
                                     ((? 134 car) . 1)
                                     ((? 135 cdr) 2 2 1)
                                     ((? 135 car) . 1)
                                     ((? 133 rx) ? 134 b)
                                     ((? 134 a) 1 2 2 1)
                                     ((? 133 x) 1 2 2 1))

unify-result=failed
apply-a-rule
rule=(rule (append-to-form () (? y) (? y)))
pattern=(append-to-form (? 151 v) (? 151 y) (? 151 z))
frame=(((? 150 z) (? 151 u) ? 151 z) ((? 151 y) (? 136 car))
                                     ((? 151 v))
                                     ((? 151 u) . 2)
                                     ((? 136 b) (? 150 u) ? 150 z)
                                     ((? 150 y) (? 136 car))
                                     ((? 150 v) (? 138 car))
                                     ((? 150 u) . 1)
                                     ((? 147 z) (? 138 car))
                                     ((? 149 y) (? 138 car))
                                     ((? 138 b) (? 147 u) ? 147 z)
                                     ((? 147 y) (? 138 car))
                                     ((? 147 v))
                                     ((? 147 u) . 1)
                                     ((? 140 b) (? 140 car))
                                     ((? 146 y) (? 140 car))
                                     ((? 140 rcdr))
                                     ((? 140 cdr))
                                     ((? 140 car) . 1)
                                     ((? 141 cdr))
                                     ((? 141 car) . 1)
                                     ((? 138 rcdr) ? 140 b)
                                     ((? 140 a) 1)
                                     ((? 138 cdr) 1)
                                     ((? 138 car) . 2)
                                     ((? 139 cdr) 1)
                                     ((? 139 car) . 2)
                                     ((? 136 rcdr) ? 138 b)
                                     ((? 138 a) 2 1)
                                     ((? 136 cdr) 2 1)
                                     ((? 136 car) . 2)
                                     ((? 137 cdr) 2 1)
                                     ((? 137 car) . 2)
                                     ((? 134 rcdr) ? 136 b)
                                     ((? 136 a) 2 2 1)
                                     ((? 134 cdr) 2 2 1)
                                     ((? 134 car) . 1)
                                     ((? 135 cdr) 2 2 1)
                                     ((? 135 car) . 1)
                                     ((? 133 rx) ? 134 b)
                                     ((? 134 a) 1 2 2 1)
                                     ((? 133 x) 1 2 2 1))

unify-result=(((? 151 z) (? 136 car)) ((? 153 y) (? 136 car))
                                      ((? 150 z) (? 151 u) ? 151 z)
                                      ((? 151 y) (? 136 car))
                                      ((? 151 v))
                                      ((? 151 u) . 2)
                                      ((? 136 b) (? 150 u) ? 150 z)
                                      ((? 150 y) (? 136 car))
                                      ((? 150 v) (? 138 car))
                                      ((? 150 u) . 1)
                                      ((? 147 z) (? 138 car))
                                      ((? 149 y) (? 138 car))
                                      ((? 138 b) (? 147 u) ? 147 z)
                                      ((? 147 y) (? 138 car))
                                      ((? 147 v))
                                      ((? 147 u) . 1)
                                      ((? 140 b) (? 140 car))
                                      ((? 146 y) (? 140 car))
                                      ((? 140 rcdr))
                                      ((? 140 cdr))
                                      ((? 140 car) . 1)
                                      ((? 141 cdr))
                                      ((? 141 car) . 1)
                                      ((? 138 rcdr) ? 140 b)
                                      ((? 140 a) 1)
                                      ((? 138 cdr) 1)
                                      ((? 138 car) . 2)
                                      ((? 139 cdr) 1)
                                      ((? 139 car) . 2)
                                      ((? 136 rcdr) ? 138 b)
                                      ((? 138 a) 2 1)
                                      ((? 136 cdr) 2 1)
                                      ((? 136 car) . 2)
                                      ((? 137 cdr) 2 1)
                                      ((? 137 car) . 2)
                                      ((? 134 rcdr) ? 136 b)
                                      ((? 136 a) 2 2 1)
                                      ((? 134 cdr) 2 2 1)
                                      ((? 134 car) . 1)
                                      ((? 135 cdr) 2 2 1)
                                      ((? 135 car) . 1)
                                      ((? 133 rx) ? 134 b)
                                      ((? 134 a) 1 2 2 1)
                                      ((? 133 x) 1 2 2 1))

debug:simple-query
apply-a-rule
rule=(rule (append-to-form ((? u) ? v) (? y) ((? u) ? z))
           (append-to-form (? v) (? y) (? z)))
pattern=(append-to-form (? 134 rcdr) ((? 134 car)) (? 134 b))
frame=(((? 151 z) (? 136 car)) ((? 153 y) (? 136 car))
                               ((? 150 z) (? 151 u) ? 151 z)
                               ((? 151 y) (? 136 car))
                               ((? 151 v))
                               ((? 151 u) . 2)
                               ((? 136 b) (? 150 u) ? 150 z)
                               ((? 150 y) (? 136 car))
                               ((? 150 v) (? 138 car))
                               ((? 150 u) . 1)
                               ((? 147 z) (? 138 car))
                               ((? 149 y) (? 138 car))
                               ((? 138 b) (? 147 u) ? 147 z)
                               ((? 147 y) (? 138 car))
                               ((? 147 v))
                               ((? 147 u) . 1)
                               ((? 140 b) (? 140 car))
                               ((? 146 y) (? 140 car))
                               ((? 140 rcdr))
                               ((? 140 cdr))
                               ((? 140 car) . 1)
                               ((? 141 cdr))
                               ((? 141 car) . 1)
                               ((? 138 rcdr) ? 140 b)
                               ((? 140 a) 1)
                               ((? 138 cdr) 1)
                               ((? 138 car) . 2)
                               ((? 139 cdr) 1)
                               ((? 139 car) . 2)
                               ((? 136 rcdr) ? 138 b)
                               ((? 138 a) 2 1)
                               ((? 136 cdr) 2 1)
                               ((? 136 car) . 2)
                               ((? 137 cdr) 2 1)
                               ((? 137 car) . 2)
                               ((? 134 rcdr) ? 136 b)
                               ((? 136 a) 2 2 1)
                               ((? 134 cdr) 2 2 1)
                               ((? 134 car) . 1)
                               ((? 135 cdr) 2 2 1)
                               ((? 135 car) . 1)
                               ((? 133 rx) ? 134 b)
                               ((? 134 a) 1 2 2 1)
                               ((? 133 x) 1 2 2 1))

unify-result=(((? 134 b) (? 154 u) ? 154 z) ((? 154 y) (? 134 car))
                                            ((? 154 v) (? 151 u) ? 151 z)
                                            ((? 154 u) . 1)
                                            ((? 151 z) (? 136 car))
                                            ((? 153 y) (? 136 car))
                                            ((? 150 z) (? 151 u) ? 151 z)
                                            ((? 151 y) (? 136 car))
                                            ((? 151 v))
                                            ((? 151 u) . 2)
                                            ((? 136 b) (? 150 u) ? 150 z)
                                            ((? 150 y) (? 136 car))
                                            ((? 150 v) (? 138 car))
                                            ((? 150 u) . 1)
                                            ((? 147 z) (? 138 car))
                                            ((? 149 y) (? 138 car))
                                            ((? 138 b) (? 147 u) ? 147 z)
                                            ((? 147 y) (? 138 car))
                                            ((? 147 v))
                                            ((? 147 u) . 1)
                                            ((? 140 b) (? 140 car))
                                            ((? 146 y) (? 140 car))
                                            ((? 140 rcdr))
                                            ((? 140 cdr))
                                            ((? 140 car) . 1)
                                            ((? 141 cdr))
                                            ((? 141 car) . 1)
                                            ((? 138 rcdr) ? 140 b)
                                            ((? 140 a) 1)
                                            ((? 138 cdr) 1)
                                            ((? 138 car) . 2)
                                            ((? 139 cdr) 1)
                                            ((? 139 car) . 2)
                                            ((? 136 rcdr) ? 138 b)
                                            ((? 138 a) 2 1)
                                            ((? 136 cdr) 2 1)
                                            ((? 136 car) . 2)
                                            ((? 137 cdr) 2 1)
                                            ((? 137 car) . 2)
                                            ((? 134 rcdr) ? 136 b)
                                            ((? 136 a) 2 2 1)
                                            ((? 134 cdr) 2 2 1)
                                            ((? 134 car) . 1)
                                            ((? 135 cdr) 2 2 1)
                                            ((? 135 car) . 1)
                                            ((? 133 rx) ? 134 b)
                                            ((? 134 a) 1 2 2 1)
                                            ((? 133 x) 1 2 2 1))

debug:simple-query
apply-a-rule
rule=(rule (append-to-form ((? u) ? v) (? y) ((? u) ? z))
           (append-to-form (? v) (? y) (? z)))
pattern=(append-to-form (? 154 v) (? 154 y) (? 154 z))
frame=(((? 134 b) (? 154 u) ? 154 z) ((? 154 y) (? 134 car))
                                     ((? 154 v) (? 151 u) ? 151 z)
                                     ((? 154 u) . 1)
                                     ((? 151 z) (? 136 car))
                                     ((? 153 y) (? 136 car))
                                     ((? 150 z) (? 151 u) ? 151 z)
                                     ((? 151 y) (? 136 car))
                                     ((? 151 v))
                                     ((? 151 u) . 2)
                                     ((? 136 b) (? 150 u) ? 150 z)
                                     ((? 150 y) (? 136 car))
                                     ((? 150 v) (? 138 car))
                                     ((? 150 u) . 1)
                                     ((? 147 z) (? 138 car))
                                     ((? 149 y) (? 138 car))
                                     ((? 138 b) (? 147 u) ? 147 z)
                                     ((? 147 y) (? 138 car))
                                     ((? 147 v))
                                     ((? 147 u) . 1)
                                     ((? 140 b) (? 140 car))
                                     ((? 146 y) (? 140 car))
                                     ((? 140 rcdr))
                                     ((? 140 cdr))
                                     ((? 140 car) . 1)
                                     ((? 141 cdr))
                                     ((? 141 car) . 1)
                                     ((? 138 rcdr) ? 140 b)
                                     ((? 140 a) 1)
                                     ((? 138 cdr) 1)
                                     ((? 138 car) . 2)
                                     ((? 139 cdr) 1)
                                     ((? 139 car) . 2)
                                     ((? 136 rcdr) ? 138 b)
                                     ((? 138 a) 2 1)
                                     ((? 136 cdr) 2 1)
                                     ((? 136 car) . 2)
                                     ((? 137 cdr) 2 1)
                                     ((? 137 car) . 2)
                                     ((? 134 rcdr) ? 136 b)
                                     ((? 136 a) 2 2 1)
                                     ((? 134 cdr) 2 2 1)
                                     ((? 134 car) . 1)
                                     ((? 135 cdr) 2 2 1)
                                     ((? 135 car) . 1)
                                     ((? 133 rx) ? 134 b)
                                     ((? 134 a) 1 2 2 1)
                                     ((? 133 x) 1 2 2 1))

unify-result=(((? 154 z) (? 155 u) ? 155 z) ((? 155 y) (? 134 car))
                                            ((? 155 v) (? 136 car))
                                            ((? 155 u) . 2)
                                            ((? 134 b) (? 154 u) ? 154 z)
                                            ((? 154 y) (? 134 car))
                                            ((? 154 v) (? 151 u) ? 151 z)
                                            ((? 154 u) . 1)
                                            ((? 151 z) (? 136 car))
                                            ((? 153 y) (? 136 car))
                                            ((? 150 z) (? 151 u) ? 151 z)
                                            ((? 151 y) (? 136 car))
                                            ((? 151 v))
                                            ((? 151 u) . 2)
                                            ((? 136 b) (? 150 u) ? 150 z)
                                            ((? 150 y) (? 136 car))
                                            ((? 150 v) (? 138 car))
                                            ((? 150 u) . 1)
                                            ((? 147 z) (? 138 car))
                                            ((? 149 y) (? 138 car))
                                            ((? 138 b) (? 147 u) ? 147 z)
                                            ((? 147 y) (? 138 car))
                                            ((? 147 v))
                                            ((? 147 u) . 1)
                                            ((? 140 b) (? 140 car))
                                            ((? 146 y) (? 140 car))
                                            ((? 140 rcdr))
                                            ((? 140 cdr))
                                            ((? 140 car) . 1)
                                            ((? 141 cdr))
                                            ((? 141 car) . 1)
                                            ((? 138 rcdr) ? 140 b)
                                            ((? 140 a) 1)
                                            ((? 138 cdr) 1)
                                            ((? 138 car) . 2)
                                            ((? 139 cdr) 1)
                                            ((? 139 car) . 2)
                                            ((? 136 rcdr) ? 138 b)
                                            ((? 138 a) 2 1)
                                            ((? 136 cdr) 2 1)
                                            ((? 136 car) . 2)
                                            ((? 137 cdr) 2 1)
                                            ((? 137 car) . 2)
                                            ((? 134 rcdr) ? 136 b)
                                            ((? 136 a) 2 2 1)
                                            ((? 134 cdr) 2 2 1)
                                            ((? 134 car) . 1)
                                            ((? 135 cdr) 2 2 1)
                                            ((? 135 car) . 1)
                                            ((? 133 rx) ? 134 b)
                                            ((? 134 a) 1 2 2 1)
                                            ((? 133 x) 1 2 2 1))

debug:simple-query
apply-a-rule
rule=(rule (append-to-form ((? u) ? v) (? y) ((? u) ? z))
           (append-to-form (? v) (? y) (? z)))
pattern=(append-to-form (? 155 v) (? 155 y) (? 155 z))
frame=(((? 154 z) (? 155 u) ? 155 z) ((? 155 y) (? 134 car))
                                     ((? 155 v) (? 136 car))
                                     ((? 155 u) . 2)
                                     ((? 134 b) (? 154 u) ? 154 z)
                                     ((? 154 y) (? 134 car))
                                     ((? 154 v) (? 151 u) ? 151 z)
                                     ((? 154 u) . 1)
                                     ((? 151 z) (? 136 car))
                                     ((? 153 y) (? 136 car))
                                     ((? 150 z) (? 151 u) ? 151 z)
                                     ((? 151 y) (? 136 car))
                                     ((? 151 v))
                                     ((? 151 u) . 2)
                                     ((? 136 b) (? 150 u) ? 150 z)
                                     ((? 150 y) (? 136 car))
                                     ((? 150 v) (? 138 car))
                                     ((? 150 u) . 1)
                                     ((? 147 z) (? 138 car))
                                     ((? 149 y) (? 138 car))
                                     ((? 138 b) (? 147 u) ? 147 z)
                                     ((? 147 y) (? 138 car))
                                     ((? 147 v))
                                     ((? 147 u) . 1)
                                     ((? 140 b) (? 140 car))
                                     ((? 146 y) (? 140 car))
                                     ((? 140 rcdr))
                                     ((? 140 cdr))
                                     ((? 140 car) . 1)
                                     ((? 141 cdr))
                                     ((? 141 car) . 1)
                                     ((? 138 rcdr) ? 140 b)
                                     ((? 140 a) 1)
                                     ((? 138 cdr) 1)
                                     ((? 138 car) . 2)
                                     ((? 139 cdr) 1)
                                     ((? 139 car) . 2)
                                     ((? 136 rcdr) ? 138 b)
                                     ((? 138 a) 2 1)
                                     ((? 136 cdr) 2 1)
                                     ((? 136 car) . 2)
                                     ((? 137 cdr) 2 1)
                                     ((? 137 car) . 2)
                                     ((? 134 rcdr) ? 136 b)
                                     ((? 136 a) 2 2 1)
                                     ((? 134 cdr) 2 2 1)
                                     ((? 134 car) . 1)
                                     ((? 135 cdr) 2 2 1)
                                     ((? 135 car) . 1)
                                     ((? 133 rx) ? 134 b)
                                     ((? 134 a) 1 2 2 1)
                                     ((? 133 x) 1 2 2 1))

unify-result=(((? 155 z) (? 156 u) ? 156 z) ((? 156 y) (? 134 car))
                                            ((? 156 v))
                                            ((? 156 u) . 2)
                                            ((? 154 z) (? 155 u) ? 155 z)
                                            ((? 155 y) (? 134 car))
                                            ((? 155 v) (? 136 car))
                                            ((? 155 u) . 2)
                                            ((? 134 b) (? 154 u) ? 154 z)
                                            ((? 154 y) (? 134 car))
                                            ((? 154 v) (? 151 u) ? 151 z)
                                            ((? 154 u) . 1)
                                            ((? 151 z) (? 136 car))
                                            ((? 153 y) (? 136 car))
                                            ((? 150 z) (? 151 u) ? 151 z)
                                            ((? 151 y) (? 136 car))
                                            ((? 151 v))
                                            ((? 151 u) . 2)
                                            ((? 136 b) (? 150 u) ? 150 z)
                                            ((? 150 y) (? 136 car))
                                            ((? 150 v) (? 138 car))
                                            ((? 150 u) . 1)
                                            ((? 147 z) (? 138 car))
                                            ((? 149 y) (? 138 car))
                                            ((? 138 b) (? 147 u) ? 147 z)
                                            ((? 147 y) (? 138 car))
                                            ((? 147 v))
                                            ((? 147 u) . 1)
                                            ((? 140 b) (? 140 car))
                                            ((? 146 y) (? 140 car))
                                            ((? 140 rcdr))
                                            ((? 140 cdr))
                                            ((? 140 car) . 1)
                                            ((? 141 cdr))
                                            ((? 141 car) . 1)
                                            ((? 138 rcdr) ? 140 b)
                                            ((? 140 a) 1)
                                            ((? 138 cdr) 1)
                                            ((? 138 car) . 2)
                                            ((? 139 cdr) 1)
                                            ((? 139 car) . 2)
                                            ((? 136 rcdr) ? 138 b)
                                            ((? 138 a) 2 1)
                                            ((? 136 cdr) 2 1)
                                            ((? 136 car) . 2)
                                            ((? 137 cdr) 2 1)
                                            ((? 137 car) . 2)
                                            ((? 134 rcdr) ? 136 b)
                                            ((? 136 a) 2 2 1)
                                            ((? 134 cdr) 2 2 1)
                                            ((? 134 car) . 1)
                                            ((? 135 cdr) 2 2 1)
                                            ((? 135 car) . 1)
                                            ((? 133 rx) ? 134 b)
                                            ((? 134 a) 1 2 2 1)
                                            ((? 133 x) 1 2 2 1))

debug:simple-query
apply-a-rule
rule=(rule (append-to-form ((? u) ? v) (? y) ((? u) ? z))
           (append-to-form (? v) (? y) (? z)))
pattern=(append-to-form (? 156 v) (? 156 y) (? 156 z))
frame=(((? 155 z) (? 156 u) ? 156 z) ((? 156 y) (? 134 car))
                                     ((? 156 v))
                                     ((? 156 u) . 2)
                                     ((? 154 z) (? 155 u) ? 155 z)
                                     ((? 155 y) (? 134 car))
                                     ((? 155 v) (? 136 car))
                                     ((? 155 u) . 2)
                                     ((? 134 b) (? 154 u) ? 154 z)
                                     ((? 154 y) (? 134 car))
                                     ((? 154 v) (? 151 u) ? 151 z)
                                     ((? 154 u) . 1)
                                     ((? 151 z) (? 136 car))
                                     ((? 153 y) (? 136 car))
                                     ((? 150 z) (? 151 u) ? 151 z)
                                     ((? 151 y) (? 136 car))
                                     ((? 151 v))
                                     ((? 151 u) . 2)
                                     ((? 136 b) (? 150 u) ? 150 z)
                                     ((? 150 y) (? 136 car))
                                     ((? 150 v) (? 138 car))
                                     ((? 150 u) . 1)
                                     ((? 147 z) (? 138 car))
                                     ((? 149 y) (? 138 car))
                                     ((? 138 b) (? 147 u) ? 147 z)
                                     ((? 147 y) (? 138 car))
                                     ((? 147 v))
                                     ((? 147 u) . 1)
                                     ((? 140 b) (? 140 car))
                                     ((? 146 y) (? 140 car))
                                     ((? 140 rcdr))
                                     ((? 140 cdr))
                                     ((? 140 car) . 1)
                                     ((? 141 cdr))
                                     ((? 141 car) . 1)
                                     ((? 138 rcdr) ? 140 b)
                                     ((? 140 a) 1)
                                     ((? 138 cdr) 1)
                                     ((? 138 car) . 2)
                                     ((? 139 cdr) 1)
                                     ((? 139 car) . 2)
                                     ((? 136 rcdr) ? 138 b)
                                     ((? 138 a) 2 1)
                                     ((? 136 cdr) 2 1)
                                     ((? 136 car) . 2)
                                     ((? 137 cdr) 2 1)
                                     ((? 137 car) . 2)
                                     ((? 134 rcdr) ? 136 b)
                                     ((? 136 a) 2 2 1)
                                     ((? 134 cdr) 2 2 1)
                                     ((? 134 car) . 1)
                                     ((? 135 cdr) 2 2 1)
                                     ((? 135 car) . 1)
                                     ((? 133 rx) ? 134 b)
                                     ((? 134 a) 1 2 2 1)
                                     ((? 133 x) 1 2 2 1))

unify-result=failed
apply-a-rule
rule=(rule (append-to-form () (? y) (? y)))
pattern=(append-to-form (? 156 v) (? 156 y) (? 156 z))
frame=(((? 155 z) (? 156 u) ? 156 z) ((? 156 y) (? 134 car))
                                     ((? 156 v))
                                     ((? 156 u) . 2)
                                     ((? 154 z) (? 155 u) ? 155 z)
                                     ((? 155 y) (? 134 car))
                                     ((? 155 v) (? 136 car))
                                     ((? 155 u) . 2)
                                     ((? 134 b) (? 154 u) ? 154 z)
                                     ((? 154 y) (? 134 car))
                                     ((? 154 v) (? 151 u) ? 151 z)
                                     ((? 154 u) . 1)
                                     ((? 151 z) (? 136 car))
                                     ((? 153 y) (? 136 car))
                                     ((? 150 z) (? 151 u) ? 151 z)
                                     ((? 151 y) (? 136 car))
                                     ((? 151 v))
                                     ((? 151 u) . 2)
                                     ((? 136 b) (? 150 u) ? 150 z)
                                     ((? 150 y) (? 136 car))
                                     ((? 150 v) (? 138 car))
                                     ((? 150 u) . 1)
                                     ((? 147 z) (? 138 car))
                                     ((? 149 y) (? 138 car))
                                     ((? 138 b) (? 147 u) ? 147 z)
                                     ((? 147 y) (? 138 car))
                                     ((? 147 v))
                                     ((? 147 u) . 1)
                                     ((? 140 b) (? 140 car))
                                     ((? 146 y) (? 140 car))
                                     ((? 140 rcdr))
                                     ((? 140 cdr))
                                     ((? 140 car) . 1)
                                     ((? 141 cdr))
                                     ((? 141 car) . 1)
                                     ((? 138 rcdr) ? 140 b)
                                     ((? 140 a) 1)
                                     ((? 138 cdr) 1)
                                     ((? 138 car) . 2)
                                     ((? 139 cdr) 1)
                                     ((? 139 car) . 2)
                                     ((? 136 rcdr) ? 138 b)
                                     ((? 138 a) 2 1)
                                     ((? 136 cdr) 2 1)
                                     ((? 136 car) . 2)
                                     ((? 137 cdr) 2 1)
                                     ((? 137 car) . 2)
                                     ((? 134 rcdr) ? 136 b)
                                     ((? 136 a) 2 2 1)
                                     ((? 134 cdr) 2 2 1)
                                     ((? 134 car) . 1)
                                     ((? 135 cdr) 2 2 1)
                                     ((? 135 car) . 1)
                                     ((? 133 rx) ? 134 b)
                                     ((? 134 a) 1 2 2 1)
                                     ((? 133 x) 1 2 2 1))

unify-result=(((? 156 z) (? 134 car)) ((? 158 y) (? 134 car))
                                      ((? 155 z) (? 156 u) ? 156 z)
                                      ((? 156 y) (? 134 car))
                                      ((? 156 v))
                                      ((? 156 u) . 2)
                                      ((? 154 z) (? 155 u) ? 155 z)
                                      ((? 155 y) (? 134 car))
                                      ((? 155 v) (? 136 car))
                                      ((? 155 u) . 2)
                                      ((? 134 b) (? 154 u) ? 154 z)
                                      ((? 154 y) (? 134 car))
                                      ((? 154 v) (? 151 u) ? 151 z)
                                      ((? 154 u) . 1)
                                      ((? 151 z) (? 136 car))
                                      ((? 153 y) (? 136 car))
                                      ((? 150 z) (? 151 u) ? 151 z)
                                      ((? 151 y) (? 136 car))
                                      ((? 151 v))
                                      ((? 151 u) . 2)
                                      ((? 136 b) (? 150 u) ? 150 z)
                                      ((? 150 y) (? 136 car))
                                      ((? 150 v) (? 138 car))
                                      ((? 150 u) . 1)
                                      ((? 147 z) (? 138 car))
                                      ((? 149 y) (? 138 car))
                                      ((? 138 b) (? 147 u) ? 147 z)
                                      ((? 147 y) (? 138 car))
                                      ((? 147 v))
                                      ((? 147 u) . 1)
                                      ((? 140 b) (? 140 car))
                                      ((? 146 y) (? 140 car))
                                      ((? 140 rcdr))
                                      ((? 140 cdr))
                                      ((? 140 car) . 1)
                                      ((? 141 cdr))
                                      ((? 141 car) . 1)
                                      ((? 138 rcdr) ? 140 b)
                                      ((? 140 a) 1)
                                      ((? 138 cdr) 1)
                                      ((? 138 car) . 2)
                                      ((? 139 cdr) 1)
                                      ((? 139 car) . 2)
                                      ((? 136 rcdr) ? 138 b)
                                      ((? 138 a) 2 1)
                                      ((? 136 cdr) 2 1)
                                      ((? 136 car) . 2)
                                      ((? 137 cdr) 2 1)
                                      ((? 137 car) . 2)
                                      ((? 134 rcdr) ? 136 b)
                                      ((? 136 a) 2 2 1)
                                      ((? 134 cdr) 2 2 1)
                                      ((? 134 car) . 1)
                                      ((? 135 cdr) 2 2 1)
                                      ((? 135 car) . 1)
                                      ((? 133 rx) ? 134 b)
                                      ((? 134 a) 1 2 2 1)
                                      ((? 133 x) 1 2 2 1))

debug:simple-query
apply-a-rule
rule=(rule (same (? x) (? x)))
pattern=(same (? 133 x) (? 133 rx))
frame=(((? 156 z) (? 134 car)) ((? 158 y) (? 134 car))
                               ((? 155 z) (? 156 u) ? 156 z)
                               ((? 156 y) (? 134 car))
                               ((? 156 v))
                               ((? 156 u) . 2)
                               ((? 154 z) (? 155 u) ? 155 z)
                               ((? 155 y) (? 134 car))
                               ((? 155 v) (? 136 car))
                               ((? 155 u) . 2)
                               ((? 134 b) (? 154 u) ? 154 z)
                               ((? 154 y) (? 134 car))
                               ((? 154 v) (? 151 u) ? 151 z)
                               ((? 154 u) . 1)
                               ((? 151 z) (? 136 car))
                               ((? 153 y) (? 136 car))
                               ((? 150 z) (? 151 u) ? 151 z)
                               ((? 151 y) (? 136 car))
                               ((? 151 v))
                               ((? 151 u) . 2)
                               ((? 136 b) (? 150 u) ? 150 z)
                               ((? 150 y) (? 136 car))
                               ((? 150 v) (? 138 car))
                               ((? 150 u) . 1)
                               ((? 147 z) (? 138 car))
                               ((? 149 y) (? 138 car))
                               ((? 138 b) (? 147 u) ? 147 z)
                               ((? 147 y) (? 138 car))
                               ((? 147 v))
                               ((? 147 u) . 1)
                               ((? 140 b) (? 140 car))
                               ((? 146 y) (? 140 car))
                               ((? 140 rcdr))
                               ((? 140 cdr))
                               ((? 140 car) . 1)
                               ((? 141 cdr))
                               ((? 141 car) . 1)
                               ((? 138 rcdr) ? 140 b)
                               ((? 140 a) 1)
                               ((? 138 cdr) 1)
                               ((? 138 car) . 2)
                               ((? 139 cdr) 1)
                               ((? 139 car) . 2)
                               ((? 136 rcdr) ? 138 b)
                               ((? 138 a) 2 1)
                               ((? 136 cdr) 2 1)
                               ((? 136 car) . 2)
                               ((? 137 cdr) 2 1)
                               ((? 137 car) . 2)
                               ((? 134 rcdr) ? 136 b)
                               ((? 136 a) 2 2 1)
                               ((? 134 cdr) 2 2 1)
                               ((? 134 car) . 1)
                               ((? 135 cdr) 2 2 1)
                               ((? 135 car) . 1)
                               ((? 133 rx) ? 134 b)
                               ((? 134 a) 1 2 2 1)
                               ((? 133 x) 1 2 2 1))

unify-result=(((? 159 x) 1 2 2 1) ((? 156 z) (? 134 car))
                                  ((? 158 y) (? 134 car))
                                  ((? 155 z) (? 156 u) ? 156 z)
                                  ((? 156 y) (? 134 car))
                                  ((? 156 v))
                                  ((? 156 u) . 2)
                                  ((? 154 z) (? 155 u) ? 155 z)
                                  ((? 155 y) (? 134 car))
                                  ((? 155 v) (? 136 car))
                                  ((? 155 u) . 2)
                                  ((? 134 b) (? 154 u) ? 154 z)
                                  ((? 154 y) (? 134 car))
                                  ((? 154 v) (? 151 u) ? 151 z)
                                  ((? 154 u) . 1)
                                  ((? 151 z) (? 136 car))
                                  ((? 153 y) (? 136 car))
                                  ((? 150 z) (? 151 u) ? 151 z)
                                  ((? 151 y) (? 136 car))
                                  ((? 151 v))
                                  ((? 151 u) . 2)
                                  ((? 136 b) (? 150 u) ? 150 z)
                                  ((? 150 y) (? 136 car))
                                  ((? 150 v) (? 138 car))
                                  ((? 150 u) . 1)
                                  ((? 147 z) (? 138 car))
                                  ((? 149 y) (? 138 car))
                                  ((? 138 b) (? 147 u) ? 147 z)
                                  ((? 147 y) (? 138 car))
                                  ((? 147 v))
                                  ((? 147 u) . 1)
                                  ((? 140 b) (? 140 car))
                                  ((? 146 y) (? 140 car))
                                  ((? 140 rcdr))
                                  ((? 140 cdr))
                                  ((? 140 car) . 1)
                                  ((? 141 cdr))
                                  ((? 141 car) . 1)
                                  ((? 138 rcdr) ? 140 b)
                                  ((? 140 a) 1)
                                  ((? 138 cdr) 1)
                                  ((? 138 car) . 2)
                                  ((? 139 cdr) 1)
                                  ((? 139 car) . 2)
                                  ((? 136 rcdr) ? 138 b)
                                  ((? 138 a) 2 1)
                                  ((? 136 cdr) 2 1)
                                  ((? 136 car) . 2)
                                  ((? 137 cdr) 2 1)
                                  ((? 137 car) . 2)
                                  ((? 134 rcdr) ? 136 b)
                                  ((? 136 a) 2 2 1)
                                  ((? 134 cdr) 2 2 1)
                                  ((? 134 car) . 1)
                                  ((? 135 cdr) 2 2 1)
                                  ((? 135 car) . 1)
                                  ((? 133 rx) ? 134 b)
                                  ((? 134 a) 1 2 2 1)
                                  ((? 133 x) 1 2 2 1))
(palindrome (1 2 2 1))
apply-a-rule
rule=(rule (reverse-left () ()))
pattern=(reverse-left (? 133 x) (? 133 rx))
frame=(((? 133 x) 1 2 2 1))

unify-result=failed
apply-a-rule
rule=(rule (reverse-left () ()))
pattern=(reverse-left (? 134 cdr) (? 134 rcdr))
frame=(((? 134 cdr) 2 2 1) ((? 134 car) . 1)
                           ((? 135 cdr) 2 2 1)
                           ((? 135 car) . 1)
                           ((? 133 rx) ? 134 b)
                           ((? 134 a) 1 2 2 1)
                           ((? 133 x) 1 2 2 1))

unify-result=failed
apply-a-rule
rule=(rule (reverse-left () ()))
pattern=(reverse-left (? 136 cdr) (? 136 rcdr))
frame=(((? 136 cdr) 2 1) ((? 136 car) . 2)
                         ((? 137 cdr) 2 1)
                         ((? 137 car) . 2)
                         ((? 134 rcdr) ? 136 b)
                         ((? 136 a) 2 2 1)
                         ((? 134 cdr) 2 2 1)
                         ((? 134 car) . 1)
                         ((? 135 cdr) 2 2 1)
                         ((? 135 car) . 1)
                         ((? 133 rx) ? 134 b)
                         ((? 134 a) 1 2 2 1)
                         ((? 133 x) 1 2 2 1))

unify-result=failed
apply-a-rule
rule=(rule (reverse-left () ()))
pattern=(reverse-left (? 138 cdr) (? 138 rcdr))
frame=(((? 138 cdr) 1) ((? 138 car) . 2)
                       ((? 139 cdr) 1)
                       ((? 139 car) . 2)
                       ((? 136 rcdr) ? 138 b)
                       ((? 138 a) 2 1)
                       ((? 136 cdr) 2 1)
                       ((? 136 car) . 2)
                       ((? 137 cdr) 2 1)
                       ((? 137 car) . 2)
                       ((? 134 rcdr) ? 136 b)
                       ((? 136 a) 2 2 1)
                       ((? 134 cdr) 2 2 1)
                       ((? 134 car) . 1)
                       ((? 135 cdr) 2 2 1)
                       ((? 135 car) . 1)
                       ((? 133 rx) ? 134 b)
                       ((? 134 a) 1 2 2 1)
                       ((? 133 x) 1 2 2 1))

unify-result=failed
apply-a-rule
rule=(rule (append-to-form () (? y) (? y)))
pattern=(append-to-form (? 138 rcdr) ((? 138 car)) (? 138 b))
frame=(((? 140 b) (? 140 car)) ((? 146 y) (? 140 car))
                               ((? 140 rcdr))
                               ((? 140 cdr))
                               ((? 140 car) . 1)
                               ((? 141 cdr))
                               ((? 141 car) . 1)
                               ((? 138 rcdr) ? 140 b)
                               ((? 140 a) 1)
                               ((? 138 cdr) 1)
                               ((? 138 car) . 2)
                               ((? 139 cdr) 1)
                               ((? 139 car) . 2)
                               ((? 136 rcdr) ? 138 b)
                               ((? 138 a) 2 1)
                               ((? 136 cdr) 2 1)
                               ((? 136 car) . 2)
                               ((? 137 cdr) 2 1)
                               ((? 137 car) . 2)
                               ((? 134 rcdr) ? 136 b)
                               ((? 136 a) 2 2 1)
                               ((? 134 cdr) 2 2 1)
                               ((? 134 car) . 1)
                               ((? 135 cdr) 2 2 1)
                               ((? 135 car) . 1)
                               ((? 133 rx) ? 134 b)
                               ((? 134 a) 1 2 2 1)
                               ((? 133 x) 1 2 2 1))

unify-result=failed
apply-a-rule
rule=(rule (append-to-form () (? y) (? y)))
pattern=(append-to-form (? 136 rcdr) ((? 136 car)) (? 136 b))
frame=(((? 147 z) (? 138 car)) ((? 149 y) (? 138 car))
                               ((? 138 b) (? 147 u) ? 147 z)
                               ((? 147 y) (? 138 car))
                               ((? 147 v))
                               ((? 147 u) . 1)
                               ((? 140 b) (? 140 car))
                               ((? 146 y) (? 140 car))
                               ((? 140 rcdr))
                               ((? 140 cdr))
                               ((? 140 car) . 1)
                               ((? 141 cdr))
                               ((? 141 car) . 1)
                               ((? 138 rcdr) ? 140 b)
                               ((? 140 a) 1)
                               ((? 138 cdr) 1)
                               ((? 138 car) . 2)
                               ((? 139 cdr) 1)
                               ((? 139 car) . 2)
                               ((? 136 rcdr) ? 138 b)
                               ((? 138 a) 2 1)
                               ((? 136 cdr) 2 1)
                               ((? 136 car) . 2)
                               ((? 137 cdr) 2 1)
                               ((? 137 car) . 2)
                               ((? 134 rcdr) ? 136 b)
                               ((? 136 a) 2 2 1)
                               ((? 134 cdr) 2 2 1)
                               ((? 134 car) . 1)
                               ((? 135 cdr) 2 2 1)
                               ((? 135 car) . 1)
                               ((? 133 rx) ? 134 b)
                               ((? 134 a) 1 2 2 1)
                               ((? 133 x) 1 2 2 1))

unify-result=failed
apply-a-rule
rule=(rule (append-to-form () (? y) (? y)))
pattern=(append-to-form (? 150 v) (? 150 y) (? 150 z))
frame=(((? 136 b) (? 150 u) ? 150 z) ((? 150 y) (? 136 car))
                                     ((? 150 v) (? 138 car))
                                     ((? 150 u) . 1)
                                     ((? 147 z) (? 138 car))
                                     ((? 149 y) (? 138 car))
                                     ((? 138 b) (? 147 u) ? 147 z)
                                     ((? 147 y) (? 138 car))
                                     ((? 147 v))
                                     ((? 147 u) . 1)
                                     ((? 140 b) (? 140 car))
                                     ((? 146 y) (? 140 car))
                                     ((? 140 rcdr))
                                     ((? 140 cdr))
                                     ((? 140 car) . 1)
                                     ((? 141 cdr))
                                     ((? 141 car) . 1)
                                     ((? 138 rcdr) ? 140 b)
                                     ((? 140 a) 1)
                                     ((? 138 cdr) 1)
                                     ((? 138 car) . 2)
                                     ((? 139 cdr) 1)
                                     ((? 139 car) . 2)
                                     ((? 136 rcdr) ? 138 b)
                                     ((? 138 a) 2 1)
                                     ((? 136 cdr) 2 1)
                                     ((? 136 car) . 2)
                                     ((? 137 cdr) 2 1)
                                     ((? 137 car) . 2)
                                     ((? 134 rcdr) ? 136 b)
                                     ((? 136 a) 2 2 1)
                                     ((? 134 cdr) 2 2 1)
                                     ((? 134 car) . 1)
                                     ((? 135 cdr) 2 2 1)
                                     ((? 135 car) . 1)
                                     ((? 133 rx) ? 134 b)
                                     ((? 134 a) 1 2 2 1)
                                     ((? 133 x) 1 2 2 1))

unify-result=failed
apply-a-rule
rule=(rule (append-to-form () (? y) (? y)))
pattern=(append-to-form (? 134 rcdr) ((? 134 car)) (? 134 b))
frame=(((? 151 z) (? 136 car)) ((? 153 y) (? 136 car))
                               ((? 150 z) (? 151 u) ? 151 z)
                               ((? 151 y) (? 136 car))
                               ((? 151 v))
                               ((? 151 u) . 2)
                               ((? 136 b) (? 150 u) ? 150 z)
                               ((? 150 y) (? 136 car))
                               ((? 150 v) (? 138 car))
                               ((? 150 u) . 1)
                               ((? 147 z) (? 138 car))
                               ((? 149 y) (? 138 car))
                               ((? 138 b) (? 147 u) ? 147 z)
                               ((? 147 y) (? 138 car))
                               ((? 147 v))
                               ((? 147 u) . 1)
                               ((? 140 b) (? 140 car))
                               ((? 146 y) (? 140 car))
                               ((? 140 rcdr))
                               ((? 140 cdr))
                               ((? 140 car) . 1)
                               ((? 141 cdr))
                               ((? 141 car) . 1)
                               ((? 138 rcdr) ? 140 b)
                               ((? 140 a) 1)
                               ((? 138 cdr) 1)
                               ((? 138 car) . 2)
                               ((? 139 cdr) 1)
                               ((? 139 car) . 2)
                               ((? 136 rcdr) ? 138 b)
                               ((? 138 a) 2 1)
                               ((? 136 cdr) 2 1)
                               ((? 136 car) . 2)
                               ((? 137 cdr) 2 1)
                               ((? 137 car) . 2)
                               ((? 134 rcdr) ? 136 b)
                               ((? 136 a) 2 2 1)
                               ((? 134 cdr) 2 2 1)
                               ((? 134 car) . 1)
                               ((? 135 cdr) 2 2 1)
                               ((? 135 car) . 1)
                               ((? 133 rx) ? 134 b)
                               ((? 134 a) 1 2 2 1)
                               ((? 133 x) 1 2 2 1))

unify-result=failed
apply-a-rule
rule=(rule (append-to-form () (? y) (? y)))
pattern=(append-to-form (? 154 v) (? 154 y) (? 154 z))
frame=(((? 134 b) (? 154 u) ? 154 z) ((? 154 y) (? 134 car))
                                     ((? 154 v) (? 151 u) ? 151 z)
                                     ((? 154 u) . 1)
                                     ((? 151 z) (? 136 car))
                                     ((? 153 y) (? 136 car))
                                     ((? 150 z) (? 151 u) ? 151 z)
                                     ((? 151 y) (? 136 car))
                                     ((? 151 v))
                                     ((? 151 u) . 2)
                                     ((? 136 b) (? 150 u) ? 150 z)
                                     ((? 150 y) (? 136 car))
                                     ((? 150 v) (? 138 car))
                                     ((? 150 u) . 1)
                                     ((? 147 z) (? 138 car))
                                     ((? 149 y) (? 138 car))
                                     ((? 138 b) (? 147 u) ? 147 z)
                                     ((? 147 y) (? 138 car))
                                     ((? 147 v))
                                     ((? 147 u) . 1)
                                     ((? 140 b) (? 140 car))
                                     ((? 146 y) (? 140 car))
                                     ((? 140 rcdr))
                                     ((? 140 cdr))
                                     ((? 140 car) . 1)
                                     ((? 141 cdr))
                                     ((? 141 car) . 1)
                                     ((? 138 rcdr) ? 140 b)
                                     ((? 140 a) 1)
                                     ((? 138 cdr) 1)
                                     ((? 138 car) . 2)
                                     ((? 139 cdr) 1)
                                     ((? 139 car) . 2)
                                     ((? 136 rcdr) ? 138 b)
                                     ((? 138 a) 2 1)
                                     ((? 136 cdr) 2 1)
                                     ((? 136 car) . 2)
                                     ((? 137 cdr) 2 1)
                                     ((? 137 car) . 2)
                                     ((? 134 rcdr) ? 136 b)
                                     ((? 136 a) 2 2 1)
                                     ((? 134 cdr) 2 2 1)
                                     ((? 134 car) . 1)
                                     ((? 135 cdr) 2 2 1)
                                     ((? 135 car) . 1)
                                     ((? 133 rx) ? 134 b)
                                     ((? 134 a) 1 2 2 1)
                                     ((? 133 x) 1 2 2 1))

unify-result=failed
apply-a-rule
rule=(rule (append-to-form () (? y) (? y)))
pattern=(append-to-form (? 155 v) (? 155 y) (? 155 z))
frame=(((? 154 z) (? 155 u) ? 155 z) ((? 155 y) (? 134 car))
                                     ((? 155 v) (? 136 car))
                                     ((? 155 u) . 2)
                                     ((? 134 b) (? 154 u) ? 154 z)
                                     ((? 154 y) (? 134 car))
                                     ((? 154 v) (? 151 u) ? 151 z)
                                     ((? 154 u) . 1)
                                     ((? 151 z) (? 136 car))
                                     ((? 153 y) (? 136 car))
                                     ((? 150 z) (? 151 u) ? 151 z)
                                     ((? 151 y) (? 136 car))
                                     ((? 151 v))
                                     ((? 151 u) . 2)
                                     ((? 136 b) (? 150 u) ? 150 z)
                                     ((? 150 y) (? 136 car))
                                     ((? 150 v) (? 138 car))
                                     ((? 150 u) . 1)
                                     ((? 147 z) (? 138 car))
                                     ((? 149 y) (? 138 car))
                                     ((? 138 b) (? 147 u) ? 147 z)
                                     ((? 147 y) (? 138 car))
                                     ((? 147 v))
                                     ((? 147 u) . 1)
                                     ((? 140 b) (? 140 car))
                                     ((? 146 y) (? 140 car))
                                     ((? 140 rcdr))
                                     ((? 140 cdr))
                                     ((? 140 car) . 1)
                                     ((? 141 cdr))
                                     ((? 141 car) . 1)
                                     ((? 138 rcdr) ? 140 b)
                                     ((? 140 a) 1)
                                     ((? 138 cdr) 1)
                                     ((? 138 car) . 2)
                                     ((? 139 cdr) 1)
                                     ((? 139 car) . 2)
                                     ((? 136 rcdr) ? 138 b)
                                     ((? 138 a) 2 1)
                                     ((? 136 cdr) 2 1)
                                     ((? 136 car) . 2)
                                     ((? 137 cdr) 2 1)
                                     ((? 137 car) . 2)
                                     ((? 134 rcdr) ? 136 b)
                                     ((? 136 a) 2 2 1)
                                     ((? 134 cdr) 2 2 1)
                                     ((? 134 car) . 1)
                                     ((? 135 cdr) 2 2 1)
                                     ((? 135 car) . 1)
                                     ((? 133 rx) ? 134 b)
                                     ((? 134 a) 1 2 2 1)
                                     ((? 133 x) 1 2 2 1))

unify-result=failed

;;; Query input:
(assert!
 (rule (interleave (? x) (? y) (? z))
       (or (and (empty-list (? x)) (same (? y) (? z)))
           (and (empty-list (? y)) (same (? y) (? z))))))
Assertion added to data base.
;;; Query input:
(assert!
 (rule (interleave (? x) (? y) (? res))
       (and
        (and (carcdr (? x) (? x-car) (? x-cdr))
             (carcdr (? y) (? y-car) (? y-cdr)))
        (interleave (? x-cdr) (? y-cdr) (? int))
        (append-to-form ((? x-car) (? y-car)) (? int) (? res)))))
Assertion added to data base.
;;; Query input:
exit
#+end_src


***** DONE Exercise 4.69 great grandchildren
      CLOSED: [2020-02-21 Fri 17:43]

The exercise is quite ill-defined, but I think I solved it. Indeed,
the first element of a list is just another matching
criterion. However, I have to say that the book is not a very good
Prolog textbook. It is advised to read some other one.

#+name: prolog-input-great-grandchildren
#+begin_src shell :exports code :results verbatim output scalar code
  printf "%s" '

  (assert! (rule (list-ending-with-grandson (grandson))))
  (assert! (rule (list-ending-with-grandson (?x . ?y))
                 (list-ending-with-grandson ?y)))
  (list-ending-with-grandson (grandson))
  (list-ending-with-grandson (great grandson))

  (assert! (son Adam Cain))
  (assert! (son Cain Enoch))
  (assert! (son Enoch Irad))
  (assert! (son Irad Mehujael))
  (assert! (son Mehujael Methushael))
  (assert! (son Methushael Lamech))
  (assert! (wife Lamech Ada))
  (assert! (son Ada Jabal))
  (assert! (son Ada Jubal))
  (assert! (rule ((grandson) ?grandpa ?grandson)
              (and (son ?grandpa ?dad)
                   (son ?dad ?grandson))))
  (assert! (rule (son ?man ?boy)
                    (and (wife ?man ?woman)
                         (son  ?woman ?boy))))

  (grandson ?a ?b)
  ((grandson) ?a ?y)
  (assert! (rule ((great . ?rel) ?a ?b)
                (and (son ?a ?c)
                     (?rel ?c ?b)
                     (list-ending-with-grandson ?rel))))

  ((great grandson) ?g ?ggs)

  (?relationship Adam Irad)
  exit'
#+end_src


#+header: :stdin prolog-input-great-grandchildren
#+begin_src shell :shebang "#! /usr/bin/chibi-scheme" :exports both :results output scalar code :exports both
  <<prolog-glue>>
  <<put-and-get>>
  <<streams-common>>
  <<streams-2>>
  <<stream-append>>
  <<prolog-driver-loop>>
  <<prolog-instantiate>>
  <<prolog-qeval>>
  <<prolog-simple-queries>>
  <<prolog-conjoin>>
  <<prolog-conjoin-installation>>
  <<prolog-disjoin>>
  <<prolog-disjoin-installation>>
  <<prolog-negate>>
  <<prolog-negate-installation>>
  <<prolog-lisp-filter>>
  <<prolog-lisp-filter-installation>>
  <<prolog-always-true>>
  <<prolog-pattern-matching>>
  <<prolog-rules-and-unification>>
  <<prolog-database>>
  <<prolog-database-add-assertion-original>>
  <<prolog-database-store-assertion-in-index>>
  <<prolog-stream-operations>>
  <<prolog-stream-flatmap>>
  <<prolog-flatten-stream>>
  <<streams-singleton>>
  <<prolog-query>>
  <<prolog-frames-and-bindings>>
  (query-driver-loop)
#+end_src

#+RESULTS[efdf5fcd897e9660c3e1f93e8dc85f4aa7e01675]:
#+begin_src shell

;;; Query input:
(assert! (rule (list-ending-with-grandson (grandson))))
Assertion added to data base.
;;; Query input:
(assert!
 (rule (list-ending-with-grandson ((? x) ? y))
       (list-ending-with-grandson (? y))))
Assertion added to data base.
;;; Query input:
(list-ending-with-grandson (grandson))
;;; Query results:

debug:simple-query
apply-a-rule
rule=(rule (list-ending-with-grandson ((? x) ? y))
           (list-ending-with-grandson (? y)))
pattern=(list-ending-with-grandson (grandson))
frame=()

unify-result=(((? 1 y)) ((? 1 x) . grandson))

debug:simple-query
apply-a-rule
rule=(rule (list-ending-with-grandson ((? x) ? y))
           (list-ending-with-grandson (? y)))
pattern=(list-ending-with-grandson (? 1 y))
frame=(((? 1 y)) ((? 1 x) . grandson))

unify-result=failed
apply-a-rule
rule=(rule (list-ending-with-grandson (grandson)))
pattern=(list-ending-with-grandson (? 1 y))
frame=(((? 1 y)) ((? 1 x) . grandson))

unify-result=failed
apply-a-rule
rule=(rule (list-ending-with-grandson (grandson)))
pattern=(list-ending-with-grandson (grandson))
frame=()

unify-result=()
(list-ending-with-grandson (grandson))

;;; Query input:
(list-ending-with-grandson (great grandson))
;;; Query results:

debug:simple-query
apply-a-rule
rule=(rule (list-ending-with-grandson ((? x) ? y))
           (list-ending-with-grandson (? y)))
pattern=(list-ending-with-grandson (great grandson))
frame=()

unify-result=(((? 5 y) grandson) ((? 5 x) . great))

debug:simple-query
apply-a-rule
rule=(rule (list-ending-with-grandson ((? x) ? y))
           (list-ending-with-grandson (? y)))
pattern=(list-ending-with-grandson (? 5 y))
frame=(((? 5 y) grandson) ((? 5 x) . great))

unify-result=(((? 6 y)) ((? 6 x) . grandson)
                        ((? 5 y) grandson)
                        ((? 5 x) . great))

debug:simple-query
apply-a-rule
rule=(rule (list-ending-with-grandson ((? x) ? y))
           (list-ending-with-grandson (? y)))
pattern=(list-ending-with-grandson (? 6 y))
frame=(((? 6 y)) ((? 6 x) . grandson) ((? 5 y) grandson) ((? 5 x) . great))

unify-result=failed
apply-a-rule
rule=(rule (list-ending-with-grandson (grandson)))
pattern=(list-ending-with-grandson (? 6 y))
frame=(((? 6 y)) ((? 6 x) . grandson) ((? 5 y) grandson) ((? 5 x) . great))

unify-result=failed
apply-a-rule
rule=(rule (list-ending-with-grandson (grandson)))
pattern=(list-ending-with-grandson (? 5 y))
frame=(((? 5 y) grandson) ((? 5 x) . great))

unify-result=(((? 5 y) grandson) ((? 5 x) . great))
(list-ending-with-grandson (great grandson))
apply-a-rule
rule=(rule (list-ending-with-grandson (grandson)))
pattern=(list-ending-with-grandson (great grandson))
frame=()

unify-result=failed

;;; Query input:
(assert! (son Adam Cain))
Assertion added to data base.
;;; Query input:
(assert! (son Cain Enoch))
Assertion added to data base.
;;; Query input:
(assert! (son Enoch Irad))
Assertion added to data base.
;;; Query input:
(assert! (son Irad Mehujael))
Assertion added to data base.
;;; Query input:
(assert! (son Mehujael Methushael))
Assertion added to data base.
;;; Query input:
(assert! (son Methushael Lamech))
Assertion added to data base.
;;; Query input:
(assert! (wife Lamech Ada))
Assertion added to data base.
;;; Query input:
(assert! (son Ada Jabal))
Assertion added to data base.
;;; Query input:
(assert! (son Ada Jubal))
Assertion added to data base.
;;; Query input:
(assert!
 (rule ((grandson) (? grandpa) (? grandson))
       (and (son (? grandpa) (? dad)) (son (? dad) (? grandson)))))
Assertion added to data base.
;;; Query input:
(assert!
 (rule (son (? man) (? boy))
       (and (wife (? man) (? woman)) (son (? woman) (? boy)))))
Assertion added to data base.
;;; Query input:
(grandson (? a) (? b))
;;; Query results:

debug:simple-query

;;; Query input:
((grandson) (? a) (? y))
;;; Query results:

debug:simple-query
apply-a-rule
rule=(rule (son (? man) (? boy))
           (and (wife (? man) (? woman)) (son (? woman) (? boy))))
pattern=((grandson) (? a) (? y))
frame=()

unify-result=failed
apply-a-rule
rule=(rule ((grandson) (? grandpa) (? grandson))
           (and (son (? grandpa) (? dad)) (son (? dad) (? grandson))))
pattern=((grandson) (? a) (? y))
frame=()

unify-result=(((? y) ? 12 grandson) ((? a) ? 12 grandpa))

debug:simple-query

debug:simple-query
apply-a-rule
rule=(rule (son (? man) (? boy))
           (and (wife (? man) (? woman)) (son (? woman) (? boy))))
pattern=(son (? 12 dad) (? 12 grandson))
frame=(((? 12 dad) . Jubal)   ((? 12 grandpa) . Ada) ((? y) ? 12 grandson)
       ((? a) ? 12 grandpa))

unify-result=(((? 12 grandson) ? 13 boy) ((? 13 man) . Jubal)
                                         ((? 12 dad) . Jubal)
                                         ((? 12 grandpa) . Ada)
                                         ((? y) ? 12 grandson)
                                         ((? a) ? 12 grandpa))

debug:simple-query

debug:simple-query
apply-a-rule
rule=(rule (son (? man) (? boy))
           (and (wife (? man) (? woman)) (son (? woman) (? boy))))
pattern=(son (? 12 dad) (? 12 grandson))
frame=(((? 12 dad) . Jabal)   ((? 12 grandpa) . Ada) ((? y) ? 12 grandson)
       ((? a) ? 12 grandpa))

unify-result=(((? 12 grandson) ? 14 boy) ((? 14 man) . Jabal)
                                         ((? 12 dad) . Jabal)
                                         ((? 12 grandpa) . Ada)
                                         ((? y) ? 12 grandson)
                                         ((? a) ? 12 grandpa))

debug:simple-query

debug:simple-query
apply-a-rule
rule=(rule (son (? man) (? boy))
           (and (wife (? man) (? woman)) (son (? woman) (? boy))))
pattern=(son (? 12 dad) (? 12 grandson))
frame=(((? 12 dad) . Lamech)         ((? 12 grandpa) . Methushael)
       ((? y) ? 12 grandson)         ((? a) ? 12 grandpa))

unify-result=(((? 12 grandson) ? 15 boy) ((? 15 man) . Lamech)
                                         ((? 12 dad) . Lamech)
                                         ((? 12 grandpa) . Methushael)
                                         ((? y) ? 12 grandson)
                                         ((? a) ? 12 grandpa))

debug:simple-query

debug:simple-query
((grandson) Methushael Jubal)
apply-a-rule
rule=(rule (list-ending-with-grandson ((? x) ? y))
           (list-ending-with-grandson (? y)))
pattern=((grandson) (? a) (? y))
frame=()

unify-result=failed
apply-a-rule
rule=(rule (list-ending-with-grandson (grandson)))
pattern=((grandson) (? a) (? y))
frame=()

unify-result=failed
((grandson) Mehujael Lamech)
((grandson) Methushael Jabal)
((grandson) Irad Methushael)
apply-a-rule
rule=(rule (son (? man) (? boy))
           (and (wife (? man) (? woman)) (son (? woman) (? boy))))
pattern=(son (? 15 woman) (? 15 boy))
frame=(((? 15 woman) . Ada)          ((? 12 grandson) ? 15 boy)
       ((? 15 man) . Lamech)         ((? 12 dad) . Lamech)
       ((? 12 grandpa) . Methushael) ((? y) ? 12 grandson)
       ((? a) ? 12 grandpa))

unify-result=(((? 15 boy) ? 18 boy) ((? 18 man) . Ada)
                                    ((? 15 woman) . Ada)
                                    ((? 12 grandson) ? 15 boy)
                                    ((? 15 man) . Lamech)
                                    ((? 12 dad) . Lamech)
                                    ((? 12 grandpa) . Methushael)
                                    ((? y) ? 12 grandson)
                                    ((? a) ? 12 grandpa))

debug:simple-query

debug:simple-query
apply-a-rule
rule=(rule (son (? man) (? boy))
           (and (wife (? man) (? woman)) (son (? woman) (? boy))))
pattern=(son (? 12 dad) (? 12 grandson))
frame=(((? 12 dad) . Methushael)   ((? 12 grandpa) . Mehujael)
       ((? y) ? 12 grandson)       ((? a) ? 12 grandpa))

unify-result=(((? 12 grandson) ? 19 boy) ((? 19 man) . Methushael)
                                         ((? 12 dad) . Methushael)
                                         ((? 12 grandpa) . Mehujael)
                                         ((? y) ? 12 grandson)
                                         ((? a) ? 12 grandpa))

debug:simple-query

debug:simple-query
((grandson) Enoch Mehujael)
apply-a-rule
rule=(rule (son (? man) (? boy))
           (and (wife (? man) (? woman)) (son (? woman) (? boy))))
pattern=(son (? 12 dad) (? 12 grandson))
frame=(((? 12 dad) . Mehujael) ((? 12 grandpa) . Irad) ((? y) ? 12 grandson)
       ((? a) ? 12 grandpa))

unify-result=(((? 12 grandson) ? 20 boy) ((? 20 man) . Mehujael)
                                         ((? 12 dad) . Mehujael)
                                         ((? 12 grandpa) . Irad)
                                         ((? y) ? 12 grandson)
                                         ((? a) ? 12 grandpa))

debug:simple-query

debug:simple-query
((grandson) Cain Irad)
apply-a-rule
rule=(rule (son (? man) (? boy))
           (and (wife (? man) (? woman)) (son (? woman) (? boy))))
pattern=(son (? 12 dad) (? 12 grandson))
frame=(((? 12 dad) . Irad)      ((? 12 grandpa) . Enoch) ((? y) ? 12 grandson)
       ((? a) ? 12 grandpa))

unify-result=(((? 12 grandson) ? 21 boy) ((? 21 man) . Irad)
                                         ((? 12 dad) . Irad)
                                         ((? 12 grandpa) . Enoch)
                                         ((? y) ? 12 grandson)
                                         ((? a) ? 12 grandpa))

debug:simple-query

debug:simple-query
((grandson) Adam Enoch)
apply-a-rule
rule=(rule (son (? man) (? boy))
           (and (wife (? man) (? woman)) (son (? woman) (? boy))))
pattern=(son (? 12 dad) (? 12 grandson))
frame=(((? 12 dad) . Enoch)    ((? 12 grandpa) . Cain) ((? y) ? 12 grandson)
       ((? a) ? 12 grandpa))

unify-result=(((? 12 grandson) ? 22 boy) ((? 22 man) . Enoch)
                                         ((? 12 dad) . Enoch)
                                         ((? 12 grandpa) . Cain)
                                         ((? y) ? 12 grandson)
                                         ((? a) ? 12 grandpa))

debug:simple-query

debug:simple-query
apply-a-rule
rule=(rule (son (? man) (? boy))
           (and (wife (? man) (? woman)) (son (? woman) (? boy))))
pattern=(son (? 12 grandpa) (? 12 dad))
frame=(((? y) ? 12 grandson) ((? a) ? 12 grandpa))

unify-result=(((? 12 dad) ? 23 boy) ((? 12 grandpa) ? 23 man)
                                    ((? y) ? 12 grandson)
                                    ((? a) ? 12 grandpa))

debug:simple-query

debug:simple-query
apply-a-rule
rule=(rule (son (? man) (? boy))
           (and (wife (? man) (? woman)) (son (? woman) (? boy))))
pattern=(son (? 12 dad) (? 12 grandson))
frame=(((? 23 boy) . Jubal)      ((? 23 woman) . Ada)      ((? 23 man) . Lamech)
       ((? 12 dad) ? 23 boy)     ((? 12 grandpa) ? 23 man) ((? y) ? 12 grandson)
       ((? a) ? 12 grandpa))

unify-result=(((? 12 grandson) ? 24 boy) ((? 24 man) . Jubal)
                                         ((? 23 boy) . Jubal)
                                         ((? 23 woman) . Ada)
                                         ((? 23 man) . Lamech)
                                         ((? 12 dad) ? 23 boy)
                                         ((? 12 grandpa) ? 23 man)
                                         ((? y) ? 12 grandson)
                                         ((? a) ? 12 grandpa))

debug:simple-query

debug:simple-query
apply-a-rule
rule=(rule (son (? man) (? boy))
           (and (wife (? man) (? woman)) (son (? woman) (? boy))))
pattern=(son (? 12 dad) (? 12 grandson))
frame=(((? 23 boy) . Jabal)      ((? 23 woman) . Ada)      ((? 23 man) . Lamech)
       ((? 12 dad) ? 23 boy)     ((? 12 grandpa) ? 23 man) ((? y) ? 12 grandson)
       ((? a) ? 12 grandpa))

unify-result=(((? 12 grandson) ? 25 boy) ((? 25 man) . Jabal)
                                         ((? 23 boy) . Jabal)
                                         ((? 23 woman) . Ada)
                                         ((? 23 man) . Lamech)
                                         ((? 12 dad) ? 23 boy)
                                         ((? 12 grandpa) ? 23 man)
                                         ((? y) ? 12 grandson)
                                         ((? a) ? 12 grandpa))

debug:simple-query

debug:simple-query
apply-a-rule
rule=(rule (son (? man) (? boy))
           (and (wife (? man) (? woman)) (son (? woman) (? boy))))
pattern=(son (? 23 woman) (? 23 boy))
frame=(((? 23 woman) . Ada)      ((? 23 man) . Lamech)     ((? 12 dad) ? 23 boy)
       ((? 12 grandpa) ? 23 man) ((? y) ? 12 grandson)     ((? a) ? 12 grandpa))

unify-result=(((? 23 boy) ? 26 boy) ((? 26 man) . Ada)
                                    ((? 23 woman) . Ada)
                                    ((? 23 man) . Lamech)
                                    ((? 12 dad) ? 23 boy)
                                    ((? 12 grandpa) ? 23 man)
                                    ((? y) ? 12 grandson)
                                    ((? a) ? 12 grandpa))

debug:simple-query

debug:simple-query
apply-a-rule
rule=(rule (son (? man) (? boy))
           (and (wife (? man) (? woman)) (son (? woman) (? boy))))
pattern=(son (? 12 dad) (? 12 grandson))
frame=(((? 12 dad) . Cain)     ((? 12 grandpa) . Adam) ((? y) ? 12 grandson)
       ((? a) ? 12 grandpa))

unify-result=(((? 12 grandson) ? 27 boy) ((? 27 man) . Cain)
                                         ((? 12 dad) . Cain)
                                         ((? 12 grandpa) . Adam)
                                         ((? y) ? 12 grandson)
                                         ((? a) ? 12 grandpa))

debug:simple-query

debug:simple-query

;;; Query input:
(assert!
 (rule ((great ? rel) (? a) (? b))
       (and (son (? a) (? c))
            ((? rel) (? c) (? b))
            (list-ending-with-grandson (? rel)))))
Assertion added to data base.
;;; Query input:
((great grandson) (? g) (? ggs))
;;; Query results:

debug:simple-query
apply-a-rule
rule=(rule ((great ? rel) (? a) (? b))
           (and (son (? a) (? c))
                ((? rel) (? c) (? b))
                (list-ending-with-grandson (? rel))))
pattern=((great grandson) (? g) (? ggs))
frame=()

unify-result=(((? ggs) ? 28 b) ((? g) ? 28 a) ((? 28 rel) grandson))

debug:simple-query

debug:simple-query
apply-a-rule
rule=(rule ((great ? rel) (? a) (? b))
           (and (son (? a) (? c))
                ((? rel) (? c) (? b))
                (list-ending-with-grandson (? rel))))
pattern=((? 28 rel) (? 28 c) (? 28 b))
frame=(((? 28 c) . Jubal)    ((? 28 a) . Ada)      ((? ggs) ? 28 b)
       ((? g) ? 28 a)        ((? 28 rel) grandson))

unify-result=failed
apply-a-rule
rule=(rule (son (? man) (? boy))
           (and (wife (? man) (? woman)) (son (? woman) (? boy))))
pattern=((? 28 rel) (? 28 c) (? 28 b))
frame=(((? 28 c) . Jubal)    ((? 28 a) . Ada)      ((? ggs) ? 28 b)
       ((? g) ? 28 a)        ((? 28 rel) grandson))

unify-result=failed
apply-a-rule
rule=(rule ((grandson) (? grandpa) (? grandson))
           (and (son (? grandpa) (? dad)) (son (? dad) (? grandson))))
pattern=((? 28 rel) (? 28 c) (? 28 b))
frame=(((? 28 c) . Jubal)    ((? 28 a) . Ada)      ((? ggs) ? 28 b)
       ((? g) ? 28 a)        ((? 28 rel) grandson))

unify-result=(((? 28 b) ? 31 grandson) ((? 31 grandpa) . Jubal)
                                       ((? 28 c) . Jubal)
                                       ((? 28 a) . Ada)
                                       ((? ggs) ? 28 b)
                                       ((? g) ? 28 a)
                                       ((? 28 rel) grandson))

debug:simple-query
apply-a-rule
rule=(rule (son (? man) (? boy))
           (and (wife (? man) (? woman)) (son (? woman) (? boy))))
pattern=(son (? 31 grandpa) (? 31 dad))
frame=(((? 28 b) ? 31 grandson) ((? 31 grandpa) . Jubal)
                                ((? 28 c) . Jubal)
                                ((? 28 a) . Ada)
                                ((? ggs) ? 28 b)
                                ((? g) ? 28 a)
                                ((? 28 rel) grandson))

unify-result=(((? 31 dad) ? 32 boy) ((? 32 man) . Jubal)
                                    ((? 28 b) ? 31 grandson)
                                    ((? 31 grandpa) . Jubal)
                                    ((? 28 c) . Jubal)
                                    ((? 28 a) . Ada)
                                    ((? ggs) ? 28 b)
                                    ((? g) ? 28 a)
                                    ((? 28 rel) grandson))

debug:simple-query

debug:simple-query

debug:simple-query
apply-a-rule
rule=(rule (list-ending-with-grandson ((? x) ? y))
           (list-ending-with-grandson (? y)))
pattern=((? 28 rel) (? 28 c) (? 28 b))
frame=(((? 28 c) . Jubal)    ((? 28 a) . Ada)      ((? ggs) ? 28 b)
       ((? g) ? 28 a)        ((? 28 rel) grandson))

unify-result=failed
apply-a-rule
rule=(rule (list-ending-with-grandson (grandson)))
pattern=((? 28 rel) (? 28 c) (? 28 b))
frame=(((? 28 c) . Jubal)    ((? 28 a) . Ada)      ((? ggs) ? 28 b)
       ((? g) ? 28 a)        ((? 28 rel) grandson))

unify-result=failed
apply-a-rule
rule=(rule ((great ? rel) (? a) (? b))
           (and (son (? a) (? c))
                ((? rel) (? c) (? b))
                (list-ending-with-grandson (? rel))))
pattern=((? 28 rel) (? 28 c) (? 28 b))
frame=(((? 28 c) . Jabal)    ((? 28 a) . Ada)      ((? ggs) ? 28 b)
       ((? g) ? 28 a)        ((? 28 rel) grandson))

unify-result=failed
apply-a-rule
rule=(rule (son (? man) (? boy))
           (and (wife (? man) (? woman)) (son (? woman) (? boy))))
pattern=((? 28 rel) (? 28 c) (? 28 b))
frame=(((? 28 c) . Jabal)    ((? 28 a) . Ada)      ((? ggs) ? 28 b)
       ((? g) ? 28 a)        ((? 28 rel) grandson))

unify-result=failed
apply-a-rule
rule=(rule ((grandson) (? grandpa) (? grandson))
           (and (son (? grandpa) (? dad)) (son (? dad) (? grandson))))
pattern=((? 28 rel) (? 28 c) (? 28 b))
frame=(((? 28 c) . Jabal)    ((? 28 a) . Ada)      ((? ggs) ? 28 b)
       ((? g) ? 28 a)        ((? 28 rel) grandson))

unify-result=(((? 28 b) ? 37 grandson) ((? 37 grandpa) . Jabal)
                                       ((? 28 c) . Jabal)
                                       ((? 28 a) . Ada)
                                       ((? ggs) ? 28 b)
                                       ((? g) ? 28 a)
                                       ((? 28 rel) grandson))

debug:simple-query
apply-a-rule
rule=(rule (son (? man) (? boy))
           (and (wife (? man) (? woman)) (son (? woman) (? boy))))
pattern=(son (? 37 grandpa) (? 37 dad))
frame=(((? 28 b) ? 37 grandson) ((? 37 grandpa) . Jabal)
                                ((? 28 c) . Jabal)
                                ((? 28 a) . Ada)
                                ((? ggs) ? 28 b)
                                ((? g) ? 28 a)
                                ((? 28 rel) grandson))

unify-result=(((? 37 dad) ? 38 boy) ((? 38 man) . Jabal)
                                    ((? 28 b) ? 37 grandson)
                                    ((? 37 grandpa) . Jabal)
                                    ((? 28 c) . Jabal)
                                    ((? 28 a) . Ada)
                                    ((? ggs) ? 28 b)
                                    ((? g) ? 28 a)
                                    ((? 28 rel) grandson))

debug:simple-query

debug:simple-query

debug:simple-query
apply-a-rule
rule=(rule (list-ending-with-grandson ((? x) ? y))
           (list-ending-with-grandson (? y)))
pattern=((? 28 rel) (? 28 c) (? 28 b))
frame=(((? 28 c) . Jabal)    ((? 28 a) . Ada)      ((? ggs) ? 28 b)
       ((? g) ? 28 a)        ((? 28 rel) grandson))

unify-result=failed
apply-a-rule
rule=(rule (list-ending-with-grandson (grandson)))
pattern=((? 28 rel) (? 28 c) (? 28 b))
frame=(((? 28 c) . Jabal)    ((? 28 a) . Ada)      ((? ggs) ? 28 b)
       ((? g) ? 28 a)        ((? 28 rel) grandson))

unify-result=failed
apply-a-rule
rule=(rule ((great ? rel) (? a) (? b))
           (and (son (? a) (? c))
                ((? rel) (? c) (? b))
                (list-ending-with-grandson (? rel))))
pattern=((? 28 rel) (? 28 c) (? 28 b))
frame=(((? 28 c) . Lamech)     ((? 28 a) . Methushael) ((? ggs) ? 28 b)
       ((? g) ? 28 a)          ((? 28 rel) grandson))

unify-result=failed
apply-a-rule
rule=(rule (son (? man) (? boy))
           (and (wife (? man) (? woman)) (son (? woman) (? boy))))
pattern=((? 28 rel) (? 28 c) (? 28 b))
frame=(((? 28 c) . Lamech)     ((? 28 a) . Methushael) ((? ggs) ? 28 b)
       ((? g) ? 28 a)          ((? 28 rel) grandson))

unify-result=failed
apply-a-rule
rule=(rule ((grandson) (? grandpa) (? grandson))
           (and (son (? grandpa) (? dad)) (son (? dad) (? grandson))))
pattern=((? 28 rel) (? 28 c) (? 28 b))
frame=(((? 28 c) . Lamech)     ((? 28 a) . Methushael) ((? ggs) ? 28 b)
       ((? g) ? 28 a)          ((? 28 rel) grandson))

unify-result=(((? 28 b) ? 43 grandson) ((? 43 grandpa) . Lamech)
                                       ((? 28 c) . Lamech)
                                       ((? 28 a) . Methushael)
                                       ((? ggs) ? 28 b)
                                       ((? g) ? 28 a)
                                       ((? 28 rel) grandson))

debug:simple-query
apply-a-rule
rule=(rule (son (? man) (? boy))
           (and (wife (? man) (? woman)) (son (? woman) (? boy))))
pattern=(son (? 43 grandpa) (? 43 dad))
frame=(((? 28 b) ? 43 grandson) ((? 43 grandpa) . Lamech)
                                ((? 28 c) . Lamech)
                                ((? 28 a) . Methushael)
                                ((? ggs) ? 28 b)
                                ((? g) ? 28 a)
                                ((? 28 rel) grandson))

unify-result=(((? 43 dad) ? 44 boy) ((? 44 man) . Lamech)
                                    ((? 28 b) ? 43 grandson)
                                    ((? 43 grandpa) . Lamech)
                                    ((? 28 c) . Lamech)
                                    ((? 28 a) . Methushael)
                                    ((? ggs) ? 28 b)
                                    ((? g) ? 28 a)
                                    ((? 28 rel) grandson))

debug:simple-query

debug:simple-query

debug:simple-query
apply-a-rule
rule=(rule (son (? man) (? boy))
           (and (wife (? man) (? woman)) (son (? woman) (? boy))))
pattern=(son (? 43 dad) (? 43 grandson))
frame=(((? 44 boy) . Jubal)      ((? 44 woman) . Ada)      ((? 43 dad) ? 44 boy)
       ((? 44 man) . Lamech)     ((? 28 b) ? 43 grandson)  ((? 43 grandpa) . Lamech)
       ((? 28 c) . Lamech)       ((? 28 a) . Methushael)   ((? ggs) ? 28 b)
       ((? g) ? 28 a)            ((? 28 rel) grandson))

unify-result=(((? 43 grandson) ? 45 boy) ((? 45 man) . Jubal)
                                         ((? 44 boy) . Jubal)
                                         ((? 44 woman) . Ada)
                                         ((? 43 dad) ? 44 boy)
                                         ((? 44 man) . Lamech)
                                         ((? 28 b) ? 43 grandson)
                                         ((? 43 grandpa) . Lamech)
                                         ((? 28 c) . Lamech)
                                         ((? 28 a) . Methushael)
                                         ((? ggs) ? 28 b)
                                         ((? g) ? 28 a)
                                         ((? 28 rel) grandson))

debug:simple-query

debug:simple-query
apply-a-rule
rule=(rule (son (? man) (? boy))
           (and (wife (? man) (? woman)) (son (? woman) (? boy))))
pattern=(son (? 43 dad) (? 43 grandson))
frame=(((? 44 boy) . Jabal)      ((? 44 woman) . Ada)      ((? 43 dad) ? 44 boy)
       ((? 44 man) . Lamech)     ((? 28 b) ? 43 grandson)  ((? 43 grandpa) . Lamech)
       ((? 28 c) . Lamech)       ((? 28 a) . Methushael)   ((? ggs) ? 28 b)
       ((? g) ? 28 a)            ((? 28 rel) grandson))

unify-result=(((? 43 grandson) ? 46 boy) ((? 46 man) . Jabal)
                                         ((? 44 boy) . Jabal)
                                         ((? 44 woman) . Ada)
                                         ((? 43 dad) ? 44 boy)
                                         ((? 44 man) . Lamech)
                                         ((? 28 b) ? 43 grandson)
                                         ((? 43 grandpa) . Lamech)
                                         ((? 28 c) . Lamech)
                                         ((? 28 a) . Methushael)
                                         ((? ggs) ? 28 b)
                                         ((? g) ? 28 a)
                                         ((? 28 rel) grandson))

debug:simple-query

debug:simple-query
apply-a-rule
rule=(rule (son (? man) (? boy))
           (and (wife (? man) (? woman)) (son (? woman) (? boy))))
pattern=(son (? 44 woman) (? 44 boy))
frame=(((? 44 woman) . Ada)      ((? 43 dad) ? 44 boy)     ((? 44 man) . Lamech)
       ((? 28 b) ? 43 grandson)  ((? 43 grandpa) . Lamech) ((? 28 c) . Lamech)
       ((? 28 a) . Methushael)   ((? ggs) ? 28 b)          ((? g) ? 28 a)
       ((? 28 rel) grandson))

unify-result=(((? 44 boy) ? 47 boy) ((? 47 man) . Ada)
                                    ((? 44 woman) . Ada)
                                    ((? 43 dad) ? 44 boy)
                                    ((? 44 man) . Lamech)
                                    ((? 28 b) ? 43 grandson)
                                    ((? 43 grandpa) . Lamech)
                                    ((? 28 c) . Lamech)
                                    ((? 28 a) . Methushael)
                                    ((? ggs) ? 28 b)
                                    ((? g) ? 28 a)
                                    ((? 28 rel) grandson))

debug:simple-query

debug:simple-query
apply-a-rule
rule=(rule (list-ending-with-grandson ((? x) ? y))
           (list-ending-with-grandson (? y)))
pattern=((? 28 rel) (? 28 c) (? 28 b))
frame=(((? 28 c) . Lamech)     ((? 28 a) . Methushael) ((? ggs) ? 28 b)
       ((? g) ? 28 a)          ((? 28 rel) grandson))

unify-result=failed
apply-a-rule
rule=(rule (list-ending-with-grandson (grandson)))
pattern=((? 28 rel) (? 28 c) (? 28 b))
frame=(((? 28 c) . Lamech)     ((? 28 a) . Methushael) ((? ggs) ? 28 b)
       ((? g) ? 28 a)          ((? 28 rel) grandson))

unify-result=failed
apply-a-rule
rule=(rule ((great ? rel) (? a) (? b))
           (and (son (? a) (? c))
                ((? rel) (? c) (? b))
                (list-ending-with-grandson (? rel))))
pattern=((? 28 rel) (? 28 c) (? 28 b))
frame=(((? 28 c) . Methushael) ((? 28 a) . Mehujael)   ((? ggs) ? 28 b)
       ((? g) ? 28 a)          ((? 28 rel) grandson))

unify-result=failed
apply-a-rule
rule=(rule (son (? man) (? boy))
           (and (wife (? man) (? woman)) (son (? woman) (? boy))))
pattern=((? 28 rel) (? 28 c) (? 28 b))
frame=(((? 28 c) . Methushael) ((? 28 a) . Mehujael)   ((? ggs) ? 28 b)
       ((? g) ? 28 a)          ((? 28 rel) grandson))

unify-result=failed
apply-a-rule
rule=(rule ((grandson) (? grandpa) (? grandson))
           (and (son (? grandpa) (? dad)) (son (? dad) (? grandson))))
pattern=((? 28 rel) (? 28 c) (? 28 b))
frame=(((? 28 c) . Methushael) ((? 28 a) . Mehujael)   ((? ggs) ? 28 b)
       ((? g) ? 28 a)          ((? 28 rel) grandson))

unify-result=(((? 28 b) ? 52 grandson) ((? 52 grandpa) . Methushael)
                                       ((? 28 c) . Methushael)
                                       ((? 28 a) . Mehujael)
                                       ((? ggs) ? 28 b)
                                       ((? g) ? 28 a)
                                       ((? 28 rel) grandson))

debug:simple-query

debug:simple-query
apply-a-rule
rule=(rule (son (? man) (? boy))
           (and (wife (? man) (? woman)) (son (? woman) (? boy))))
pattern=(son (? 52 dad) (? 52 grandson))
frame=(((? 52 dad) . Lamech)         ((? 28 b) ? 52 grandson)
       ((? 52 grandpa) . Methushael) ((? 28 c) . Methushael)
       ((? 28 a) . Mehujael)         ((? ggs) ? 28 b)
       ((? g) ? 28 a)                ((? 28 rel) grandson))

unify-result=(((? 52 grandson) ? 53 boy) ((? 53 man) . Lamech)
                                         ((? 52 dad) . Lamech)
                                         ((? 28 b) ? 52 grandson)
                                         ((? 52 grandpa) . Methushael)
                                         ((? 28 c) . Methushael)
                                         ((? 28 a) . Mehujael)
                                         ((? ggs) ? 28 b)
                                         ((? g) ? 28 a)
                                         ((? 28 rel) grandson))

debug:simple-query

debug:simple-query

debug:simple-query
apply-a-rule
rule=(rule (list-ending-with-grandson ((? x) ? y))
           (list-ending-with-grandson (? y)))
pattern=(list-ending-with-grandson (? 28 rel))
frame=(((? 53 boy) . Jubal)          ((? 53 woman) . Ada)
       ((? 52 grandson) ? 53 boy)    ((? 53 man) . Lamech)
       ((? 52 dad) . Lamech)         ((? 28 b) ? 52 grandson)
       ((? 52 grandpa) . Methushael) ((? 28 c) . Methushael)
       ((? 28 a) . Mehujael)         ((? ggs) ? 28 b)
       ((? g) ? 28 a)                ((? 28 rel) grandson))

unify-result=(((? 54 y)) ((? 54 x) . grandson)
                         ((? 53 boy) . Jubal)
                         ((? 53 woman) . Ada)
                         ((? 52 grandson) ? 53 boy)
                         ((? 53 man) . Lamech)
                         ((? 52 dad) . Lamech)
                         ((? 28 b) ? 52 grandson)
                         ((? 52 grandpa) . Methushael)
                         ((? 28 c) . Methushael)
                         ((? 28 a) . Mehujael)
                         ((? ggs) ? 28 b)
                         ((? g) ? 28 a)
                         ((? 28 rel) grandson))

debug:simple-query
apply-a-rule
rule=(rule (list-ending-with-grandson ((? x) ? y))
           (list-ending-with-grandson (? y)))
pattern=(list-ending-with-grandson (? 54 y))
frame=(((? 54 y)) ((? 54 x) . grandson)
                  ((? 53 boy) . Jubal)
                  ((? 53 woman) . Ada)
                  ((? 52 grandson) ? 53 boy)
                  ((? 53 man) . Lamech)
                  ((? 52 dad) . Lamech)
                  ((? 28 b) ? 52 grandson)
                  ((? 52 grandpa) . Methushael)
                  ((? 28 c) . Methushael)
                  ((? 28 a) . Mehujael)
                  ((? ggs) ? 28 b)
                  ((? g) ? 28 a)
                  ((? 28 rel) grandson))

unify-result=failed
apply-a-rule
rule=(rule (list-ending-with-grandson (grandson)))
pattern=(list-ending-with-grandson (? 54 y))
frame=(((? 54 y)) ((? 54 x) . grandson)
                  ((? 53 boy) . Jubal)
                  ((? 53 woman) . Ada)
                  ((? 52 grandson) ? 53 boy)
                  ((? 53 man) . Lamech)
                  ((? 52 dad) . Lamech)
                  ((? 28 b) ? 52 grandson)
                  ((? 52 grandpa) . Methushael)
                  ((? 28 c) . Methushael)
                  ((? 28 a) . Mehujael)
                  ((? ggs) ? 28 b)
                  ((? g) ? 28 a)
                  ((? 28 rel) grandson))

unify-result=failed
apply-a-rule
rule=(rule (list-ending-with-grandson (grandson)))
pattern=(list-ending-with-grandson (? 28 rel))
frame=(((? 53 boy) . Jubal)          ((? 53 woman) . Ada)
       ((? 52 grandson) ? 53 boy)    ((? 53 man) . Lamech)
       ((? 52 dad) . Lamech)         ((? 28 b) ? 52 grandson)
       ((? 52 grandpa) . Methushael) ((? 28 c) . Methushael)
       ((? 28 a) . Mehujael)         ((? ggs) ? 28 b)
       ((? g) ? 28 a)                ((? 28 rel) grandson))

unify-result=(((? 53 boy) . Jubal)          ((? 53 woman) . Ada)
              ((? 52 grandson) ? 53 boy)    ((? 53 man) . Lamech)
              ((? 52 dad) . Lamech)         ((? 28 b) ? 52 grandson)
              ((? 52 grandpa) . Methushael) ((? 28 c) . Methushael)
              ((? 28 a) . Mehujael)         ((? ggs) ? 28 b)
              ((? g) ? 28 a)                ((? 28 rel) grandson))
((great grandson) Mehujael Jubal)
apply-a-rule
rule=(rule (son (? man) (? boy))
           (and (wife (? man) (? woman)) (son (? woman) (? boy))))
pattern=((great grandson) (? g) (? ggs))
frame=()

unify-result=failed
apply-a-rule
rule=(rule ((grandson) (? grandpa) (? grandson))
           (and (son (? grandpa) (? dad)) (son (? dad) (? grandson))))
pattern=((great grandson) (? g) (? ggs))
frame=()

unify-result=failed
apply-a-rule
rule=(rule (list-ending-with-grandson ((? x) ? y))
           (list-ending-with-grandson (? y)))
pattern=((great grandson) (? g) (? ggs))
frame=()

unify-result=failed
apply-a-rule
rule=(rule (list-ending-with-grandson (grandson)))
pattern=((great grandson) (? g) (? ggs))
frame=()

unify-result=failed
apply-a-rule
rule=(rule ((great ? rel) (? a) (? b))
           (and (son (? a) (? c))
                ((? rel) (? c) (? b))
                (list-ending-with-grandson (? rel))))
pattern=((? 28 rel) (? 28 c) (? 28 b))
frame=(((? 28 c) . Mehujael) ((? 28 a) . Irad)     ((? ggs) ? 28 b)
       ((? g) ? 28 a)        ((? 28 rel) grandson))

unify-result=failed
apply-a-rule
rule=(rule (son (? man) (? boy))
           (and (wife (? man) (? woman)) (son (? woman) (? boy))))
pattern=((? 28 rel) (? 28 c) (? 28 b))
frame=(((? 28 c) . Mehujael) ((? 28 a) . Irad)     ((? ggs) ? 28 b)
       ((? g) ? 28 a)        ((? 28 rel) grandson))

unify-result=failed
apply-a-rule
rule=(rule ((grandson) (? grandpa) (? grandson))
           (and (son (? grandpa) (? dad)) (son (? dad) (? grandson))))
pattern=((? 28 rel) (? 28 c) (? 28 b))
frame=(((? 28 c) . Mehujael) ((? 28 a) . Irad)     ((? ggs) ? 28 b)
       ((? g) ? 28 a)        ((? 28 rel) grandson))

unify-result=(((? 28 b) ? 64 grandson) ((? 64 grandpa) . Mehujael)
                                       ((? 28 c) . Mehujael)
                                       ((? 28 a) . Irad)
                                       ((? ggs) ? 28 b)
                                       ((? g) ? 28 a)
                                       ((? 28 rel) grandson))

debug:simple-query

debug:simple-query
apply-a-rule
rule=(rule (list-ending-with-grandson ((? x) ? y))
           (list-ending-with-grandson (? y)))
pattern=(list-ending-with-grandson (? 28 rel))
frame=(((? 64 grandson) . Lamech)  ((? 64 dad) . Methushael)
       ((? 28 b) ? 64 grandson)    ((? 64 grandpa) . Mehujael)
       ((? 28 c) . Mehujael)       ((? 28 a) . Irad)
       ((? ggs) ? 28 b)            ((? g) ? 28 a)
       ((? 28 rel) grandson))

unify-result=(((? 65 y)) ((? 65 x) . grandson)
                         ((? 64 grandson) . Lamech)
                         ((? 64 dad) . Methushael)
                         ((? 28 b) ? 64 grandson)
                         ((? 64 grandpa) . Mehujael)
                         ((? 28 c) . Mehujael)
                         ((? 28 a) . Irad)
                         ((? ggs) ? 28 b)
                         ((? g) ? 28 a)
                         ((? 28 rel) grandson))

debug:simple-query
apply-a-rule
rule=(rule (list-ending-with-grandson ((? x) ? y))
           (list-ending-with-grandson (? y)))
pattern=(list-ending-with-grandson (? 65 y))
frame=(((? 65 y)) ((? 65 x) . grandson)
                  ((? 64 grandson) . Lamech)
                  ((? 64 dad) . Methushael)
                  ((? 28 b) ? 64 grandson)
                  ((? 64 grandpa) . Mehujael)
                  ((? 28 c) . Mehujael)
                  ((? 28 a) . Irad)
                  ((? ggs) ? 28 b)
                  ((? g) ? 28 a)
                  ((? 28 rel) grandson))

unify-result=failed
apply-a-rule
rule=(rule (list-ending-with-grandson (grandson)))
pattern=(list-ending-with-grandson (? 65 y))
frame=(((? 65 y)) ((? 65 x) . grandson)
                  ((? 64 grandson) . Lamech)
                  ((? 64 dad) . Methushael)
                  ((? 28 b) ? 64 grandson)
                  ((? 64 grandpa) . Mehujael)
                  ((? 28 c) . Mehujael)
                  ((? 28 a) . Irad)
                  ((? ggs) ? 28 b)
                  ((? g) ? 28 a)
                  ((? 28 rel) grandson))

unify-result=failed
apply-a-rule
rule=(rule (list-ending-with-grandson (grandson)))
pattern=(list-ending-with-grandson (? 28 rel))
frame=(((? 64 grandson) . Lamech)  ((? 64 dad) . Methushael)
       ((? 28 b) ? 64 grandson)    ((? 64 grandpa) . Mehujael)
       ((? 28 c) . Mehujael)       ((? 28 a) . Irad)
       ((? ggs) ? 28 b)            ((? g) ? 28 a)
       ((? 28 rel) grandson))

unify-result=(((? 64 grandson) . Lamech)  ((? 64 dad) . Methushael)
              ((? 28 b) ? 64 grandson)    ((? 64 grandpa) . Mehujael)
              ((? 28 c) . Mehujael)       ((? 28 a) . Irad)
              ((? ggs) ? 28 b)            ((? g) ? 28 a)
              ((? 28 rel) grandson))
((great grandson) Irad Lamech)
apply-a-rule
rule=(rule (list-ending-with-grandson ((? x) ? y))
           (list-ending-with-grandson (? y)))
pattern=((? 28 rel) (? 28 c) (? 28 b))
frame=(((? 28 c) . Methushael) ((? 28 a) . Mehujael)   ((? ggs) ? 28 b)
       ((? g) ? 28 a)          ((? 28 rel) grandson))

unify-result=failed
apply-a-rule
rule=(rule (list-ending-with-grandson (grandson)))
pattern=((? 28 rel) (? 28 c) (? 28 b))
frame=(((? 28 c) . Methushael) ((? 28 a) . Mehujael)   ((? ggs) ? 28 b)
       ((? g) ? 28 a)          ((? 28 rel) grandson))

unify-result=failed
apply-a-rule
rule=(rule (son (? man) (? boy))
           (and (wife (? man) (? woman)) (son (? woman) (? boy))))
pattern=(son (? 52 grandpa) (? 52 dad))
frame=(((? 28 b) ? 52 grandson) ((? 52 grandpa) . Methushael)
                                ((? 28 c) . Methushael)
                                ((? 28 a) . Mehujael)
                                ((? ggs) ? 28 b)
                                ((? g) ? 28 a)
                                ((? 28 rel) grandson))

unify-result=(((? 52 dad) ? 71 boy) ((? 71 man) . Methushael)
                                    ((? 28 b) ? 52 grandson)
                                    ((? 52 grandpa) . Methushael)
                                    ((? 28 c) . Methushael)
                                    ((? 28 a) . Mehujael)
                                    ((? ggs) ? 28 b)
                                    ((? g) ? 28 a)
                                    ((? 28 rel) grandson))

debug:simple-query

debug:simple-query
apply-a-rule
rule=(rule (list-ending-with-grandson ((? x) ? y))
           (list-ending-with-grandson (? y)))
pattern=(list-ending-with-grandson (? 28 rel))
frame=(((? 53 boy) . Jabal)          ((? 53 woman) . Ada)
       ((? 52 grandson) ? 53 boy)    ((? 53 man) . Lamech)
       ((? 52 dad) . Lamech)         ((? 28 b) ? 52 grandson)
       ((? 52 grandpa) . Methushael) ((? 28 c) . Methushael)
       ((? 28 a) . Mehujael)         ((? ggs) ? 28 b)
       ((? g) ? 28 a)                ((? 28 rel) grandson))

unify-result=(((? 72 y)) ((? 72 x) . grandson)
                         ((? 53 boy) . Jabal)
                         ((? 53 woman) . Ada)
                         ((? 52 grandson) ? 53 boy)
                         ((? 53 man) . Lamech)
                         ((? 52 dad) . Lamech)
                         ((? 28 b) ? 52 grandson)
                         ((? 52 grandpa) . Methushael)
                         ((? 28 c) . Methushael)
                         ((? 28 a) . Mehujael)
                         ((? ggs) ? 28 b)
                         ((? g) ? 28 a)
                         ((? 28 rel) grandson))

debug:simple-query
apply-a-rule
rule=(rule (list-ending-with-grandson ((? x) ? y))
           (list-ending-with-grandson (? y)))
pattern=(list-ending-with-grandson (? 72 y))
frame=(((? 72 y)) ((? 72 x) . grandson)
                  ((? 53 boy) . Jabal)
                  ((? 53 woman) . Ada)
                  ((? 52 grandson) ? 53 boy)
                  ((? 53 man) . Lamech)
                  ((? 52 dad) . Lamech)
                  ((? 28 b) ? 52 grandson)
                  ((? 52 grandpa) . Methushael)
                  ((? 28 c) . Methushael)
                  ((? 28 a) . Mehujael)
                  ((? ggs) ? 28 b)
                  ((? g) ? 28 a)
                  ((? 28 rel) grandson))

unify-result=failed
apply-a-rule
rule=(rule (list-ending-with-grandson (grandson)))
pattern=(list-ending-with-grandson (? 72 y))
frame=(((? 72 y)) ((? 72 x) . grandson)
                  ((? 53 boy) . Jabal)
                  ((? 53 woman) . Ada)
                  ((? 52 grandson) ? 53 boy)
                  ((? 53 man) . Lamech)
                  ((? 52 dad) . Lamech)
                  ((? 28 b) ? 52 grandson)
                  ((? 52 grandpa) . Methushael)
                  ((? 28 c) . Methushael)
                  ((? 28 a) . Mehujael)
                  ((? ggs) ? 28 b)
                  ((? g) ? 28 a)
                  ((? 28 rel) grandson))

unify-result=failed
apply-a-rule
rule=(rule (list-ending-with-grandson (grandson)))
pattern=(list-ending-with-grandson (? 28 rel))
frame=(((? 53 boy) . Jabal)          ((? 53 woman) . Ada)
       ((? 52 grandson) ? 53 boy)    ((? 53 man) . Lamech)
       ((? 52 dad) . Lamech)         ((? 28 b) ? 52 grandson)
       ((? 52 grandpa) . Methushael) ((? 28 c) . Methushael)
       ((? 28 a) . Mehujael)         ((? ggs) ? 28 b)
       ((? g) ? 28 a)                ((? 28 rel) grandson))

unify-result=(((? 53 boy) . Jabal)          ((? 53 woman) . Ada)
              ((? 52 grandson) ? 53 boy)    ((? 53 man) . Lamech)
              ((? 52 dad) . Lamech)         ((? 28 b) ? 52 grandson)
              ((? 52 grandpa) . Methushael) ((? 28 c) . Methushael)
              ((? 28 a) . Mehujael)         ((? ggs) ? 28 b)
              ((? g) ? 28 a)                ((? 28 rel) grandson))
((great grandson) Mehujael Jabal)
apply-a-rule
rule=(rule ((great ? rel) (? a) (? b))
           (and (son (? a) (? c))
                ((? rel) (? c) (? b))
                (list-ending-with-grandson (? rel))))
pattern=((? 28 rel) (? 28 c) (? 28 b))
frame=(((? 28 c) . Irad)     ((? 28 a) . Enoch)    ((? ggs) ? 28 b)
       ((? g) ? 28 a)        ((? 28 rel) grandson))

unify-result=failed
apply-a-rule
rule=(rule (son (? man) (? boy))
           (and (wife (? man) (? woman)) (son (? woman) (? boy))))
pattern=((? 28 rel) (? 28 c) (? 28 b))
frame=(((? 28 c) . Irad)     ((? 28 a) . Enoch)    ((? ggs) ? 28 b)
       ((? g) ? 28 a)        ((? 28 rel) grandson))

unify-result=failed
apply-a-rule
rule=(rule ((grandson) (? grandpa) (? grandson))
           (and (son (? grandpa) (? dad)) (son (? dad) (? grandson))))
pattern=((? 28 rel) (? 28 c) (? 28 b))
frame=(((? 28 c) . Irad)     ((? 28 a) . Enoch)    ((? ggs) ? 28 b)
       ((? g) ? 28 a)        ((? 28 rel) grandson))

unify-result=(((? 28 b) ? 78 grandson) ((? 78 grandpa) . Irad)
                                       ((? 28 c) . Irad)
                                       ((? 28 a) . Enoch)
                                       ((? ggs) ? 28 b)
                                       ((? g) ? 28 a)
                                       ((? 28 rel) grandson))

debug:simple-query

debug:simple-query
apply-a-rule
rule=(rule (list-ending-with-grandson ((? x) ? y))
           (list-ending-with-grandson (? y)))
pattern=(list-ending-with-grandson (? 28 rel))
frame=(((? 78 grandson) . Methushael) ((? 78 dad) . Mehujael)
       ((? 28 b) ? 78 grandson)       ((? 78 grandpa) . Irad)
       ((? 28 c) . Irad)              ((? 28 a) . Enoch)
       ((? ggs) ? 28 b)               ((? g) ? 28 a)
       ((? 28 rel) grandson))

unify-result=(((? 79 y)) ((? 79 x) . grandson)
                         ((? 78 grandson) . Methushael)
                         ((? 78 dad) . Mehujael)
                         ((? 28 b) ? 78 grandson)
                         ((? 78 grandpa) . Irad)
                         ((? 28 c) . Irad)
                         ((? 28 a) . Enoch)
                         ((? ggs) ? 28 b)
                         ((? g) ? 28 a)
                         ((? 28 rel) grandson))

debug:simple-query
apply-a-rule
rule=(rule (list-ending-with-grandson ((? x) ? y))
           (list-ending-with-grandson (? y)))
pattern=(list-ending-with-grandson (? 79 y))
frame=(((? 79 y)) ((? 79 x) . grandson)
                  ((? 78 grandson) . Methushael)
                  ((? 78 dad) . Mehujael)
                  ((? 28 b) ? 78 grandson)
                  ((? 78 grandpa) . Irad)
                  ((? 28 c) . Irad)
                  ((? 28 a) . Enoch)
                  ((? ggs) ? 28 b)
                  ((? g) ? 28 a)
                  ((? 28 rel) grandson))

unify-result=failed
apply-a-rule
rule=(rule (list-ending-with-grandson (grandson)))
pattern=(list-ending-with-grandson (? 79 y))
frame=(((? 79 y)) ((? 79 x) . grandson)
                  ((? 78 grandson) . Methushael)
                  ((? 78 dad) . Mehujael)
                  ((? 28 b) ? 78 grandson)
                  ((? 78 grandpa) . Irad)
                  ((? 28 c) . Irad)
                  ((? 28 a) . Enoch)
                  ((? ggs) ? 28 b)
                  ((? g) ? 28 a)
                  ((? 28 rel) grandson))

unify-result=failed
apply-a-rule
rule=(rule (list-ending-with-grandson (grandson)))
pattern=(list-ending-with-grandson (? 28 rel))
frame=(((? 78 grandson) . Methushael) ((? 78 dad) . Mehujael)
       ((? 28 b) ? 78 grandson)       ((? 78 grandpa) . Irad)
       ((? 28 c) . Irad)              ((? 28 a) . Enoch)
       ((? ggs) ? 28 b)               ((? g) ? 28 a)
       ((? 28 rel) grandson))

unify-result=(((? 78 grandson) . Methushael) ((? 78 dad) . Mehujael)
              ((? 28 b) ? 78 grandson)       ((? 78 grandpa) . Irad)
              ((? 28 c) . Irad)              ((? 28 a) . Enoch)
              ((? ggs) ? 28 b)               ((? g) ? 28 a)
              ((? 28 rel) grandson))
((great grandson) Enoch Methushael)
apply-a-rule
rule=(rule (son (? man) (? boy))
           (and (wife (? man) (? woman)) (son (? woman) (? boy))))
pattern=(son (? 53 woman) (? 53 boy))
frame=(((? 53 woman) . Ada)          ((? 52 grandson) ? 53 boy)
       ((? 53 man) . Lamech)         ((? 52 dad) . Lamech)
       ((? 28 b) ? 52 grandson)      ((? 52 grandpa) . Methushael)
       ((? 28 c) . Methushael)       ((? 28 a) . Mehujael)
       ((? ggs) ? 28 b)              ((? g) ? 28 a)
       ((? 28 rel) grandson))

unify-result=(((? 53 boy) ? 83 boy) ((? 83 man) . Ada)
                                    ((? 53 woman) . Ada)
                                    ((? 52 grandson) ? 53 boy)
                                    ((? 53 man) . Lamech)
                                    ((? 52 dad) . Lamech)
                                    ((? 28 b) ? 52 grandson)
                                    ((? 52 grandpa) . Methushael)
                                    ((? 28 c) . Methushael)
                                    ((? 28 a) . Mehujael)
                                    ((? ggs) ? 28 b)
                                    ((? g) ? 28 a)
                                    ((? 28 rel) grandson))

debug:simple-query

debug:simple-query
apply-a-rule
rule=(rule (list-ending-with-grandson ((? x) ? y))
           (list-ending-with-grandson (? y)))
pattern=((? 28 rel) (? 28 c) (? 28 b))
frame=(((? 28 c) . Mehujael) ((? 28 a) . Irad)     ((? ggs) ? 28 b)
       ((? g) ? 28 a)        ((? 28 rel) grandson))

unify-result=failed
apply-a-rule
rule=(rule (list-ending-with-grandson (grandson)))
pattern=((? 28 rel) (? 28 c) (? 28 b))
frame=(((? 28 c) . Mehujael) ((? 28 a) . Irad)     ((? ggs) ? 28 b)
       ((? g) ? 28 a)        ((? 28 rel) grandson))

unify-result=failed
apply-a-rule
rule=(rule (son (? man) (? boy))
           (and (wife (? man) (? woman)) (son (? woman) (? boy))))
pattern=(son (? 64 grandpa) (? 64 dad))
frame=(((? 28 b) ? 64 grandson) ((? 64 grandpa) . Mehujael)
                                ((? 28 c) . Mehujael)
                                ((? 28 a) . Irad)
                                ((? ggs) ? 28 b)
                                ((? g) ? 28 a)
                                ((? 28 rel) grandson))

unify-result=(((? 64 dad) ? 86 boy) ((? 86 man) . Mehujael)
                                    ((? 28 b) ? 64 grandson)
                                    ((? 64 grandpa) . Mehujael)
                                    ((? 28 c) . Mehujael)
                                    ((? 28 a) . Irad)
                                    ((? ggs) ? 28 b)
                                    ((? g) ? 28 a)
                                    ((? 28 rel) grandson))

debug:simple-query

debug:simple-query
apply-a-rule
rule=(rule (son (? man) (? boy))
           (and (wife (? man) (? woman)) (son (? woman) (? boy))))
pattern=(son (? 64 dad) (? 64 grandson))
frame=(((? 64 dad) . Methushael)   ((? 28 b) ? 64 grandson)
       ((? 64 grandpa) . Mehujael) ((? 28 c) . Mehujael)
       ((? 28 a) . Irad)           ((? ggs) ? 28 b)
       ((? g) ? 28 a)              ((? 28 rel) grandson))

unify-result=(((? 64 grandson) ? 87 boy) ((? 87 man) . Methushael)
                                         ((? 64 dad) . Methushael)
                                         ((? 28 b) ? 64 grandson)
                                         ((? 64 grandpa) . Mehujael)
                                         ((? 28 c) . Mehujael)
                                         ((? 28 a) . Irad)
                                         ((? ggs) ? 28 b)
                                         ((? g) ? 28 a)
                                         ((? 28 rel) grandson))

debug:simple-query

debug:simple-query
apply-a-rule
rule=(rule ((great ? rel) (? a) (? b))
           (and (son (? a) (? c))
                ((? rel) (? c) (? b))
                (list-ending-with-grandson (? rel))))
pattern=((? 28 rel) (? 28 c) (? 28 b))
frame=(((? 28 c) . Enoch)    ((? 28 a) . Cain)     ((? ggs) ? 28 b)
       ((? g) ? 28 a)        ((? 28 rel) grandson))

unify-result=failed
apply-a-rule
rule=(rule (son (? man) (? boy))
           (and (wife (? man) (? woman)) (son (? woman) (? boy))))
pattern=((? 28 rel) (? 28 c) (? 28 b))
frame=(((? 28 c) . Enoch)    ((? 28 a) . Cain)     ((? ggs) ? 28 b)
       ((? g) ? 28 a)        ((? 28 rel) grandson))

unify-result=failed
apply-a-rule
rule=(rule ((grandson) (? grandpa) (? grandson))
           (and (son (? grandpa) (? dad)) (son (? dad) (? grandson))))
pattern=((? 28 rel) (? 28 c) (? 28 b))
frame=(((? 28 c) . Enoch)    ((? 28 a) . Cain)     ((? ggs) ? 28 b)
       ((? g) ? 28 a)        ((? 28 rel) grandson))

unify-result=(((? 28 b) ? 90 grandson) ((? 90 grandpa) . Enoch)
                                       ((? 28 c) . Enoch)
                                       ((? 28 a) . Cain)
                                       ((? ggs) ? 28 b)
                                       ((? g) ? 28 a)
                                       ((? 28 rel) grandson))

debug:simple-query

debug:simple-query
apply-a-rule
rule=(rule (list-ending-with-grandson ((? x) ? y))
           (list-ending-with-grandson (? y)))
pattern=(list-ending-with-grandson (? 28 rel))
frame=(((? 90 grandson) . Mehujael) ((? 90 dad) . Irad)
       ((? 28 b) ? 90 grandson)     ((? 90 grandpa) . Enoch)
       ((? 28 c) . Enoch)           ((? 28 a) . Cain)
       ((? ggs) ? 28 b)             ((? g) ? 28 a)
       ((? 28 rel) grandson))

unify-result=(((? 91 y)) ((? 91 x) . grandson)
                         ((? 90 grandson) . Mehujael)
                         ((? 90 dad) . Irad)
                         ((? 28 b) ? 90 grandson)
                         ((? 90 grandpa) . Enoch)
                         ((? 28 c) . Enoch)
                         ((? 28 a) . Cain)
                         ((? ggs) ? 28 b)
                         ((? g) ? 28 a)
                         ((? 28 rel) grandson))

debug:simple-query
apply-a-rule
rule=(rule (list-ending-with-grandson ((? x) ? y))
           (list-ending-with-grandson (? y)))
pattern=(list-ending-with-grandson (? 91 y))
frame=(((? 91 y)) ((? 91 x) . grandson)
                  ((? 90 grandson) . Mehujael)
                  ((? 90 dad) . Irad)
                  ((? 28 b) ? 90 grandson)
                  ((? 90 grandpa) . Enoch)
                  ((? 28 c) . Enoch)
                  ((? 28 a) . Cain)
                  ((? ggs) ? 28 b)
                  ((? g) ? 28 a)
                  ((? 28 rel) grandson))

unify-result=failed
apply-a-rule
rule=(rule (list-ending-with-grandson (grandson)))
pattern=(list-ending-with-grandson (? 91 y))
frame=(((? 91 y)) ((? 91 x) . grandson)
                  ((? 90 grandson) . Mehujael)
                  ((? 90 dad) . Irad)
                  ((? 28 b) ? 90 grandson)
                  ((? 90 grandpa) . Enoch)
                  ((? 28 c) . Enoch)
                  ((? 28 a) . Cain)
                  ((? ggs) ? 28 b)
                  ((? g) ? 28 a)
                  ((? 28 rel) grandson))

unify-result=failed
apply-a-rule
rule=(rule (list-ending-with-grandson (grandson)))
pattern=(list-ending-with-grandson (? 28 rel))
frame=(((? 90 grandson) . Mehujael) ((? 90 dad) . Irad)
       ((? 28 b) ? 90 grandson)     ((? 90 grandpa) . Enoch)
       ((? 28 c) . Enoch)           ((? 28 a) . Cain)
       ((? ggs) ? 28 b)             ((? g) ? 28 a)
       ((? 28 rel) grandson))

unify-result=(((? 90 grandson) . Mehujael) ((? 90 dad) . Irad)
              ((? 28 b) ? 90 grandson)     ((? 90 grandpa) . Enoch)
              ((? 28 c) . Enoch)           ((? 28 a) . Cain)
              ((? ggs) ? 28 b)             ((? g) ? 28 a)
              ((? 28 rel) grandson))
((great grandson) Cain Mehujael)
apply-a-rule
rule=(rule (list-ending-with-grandson ((? x) ? y))
           (list-ending-with-grandson (? y)))
pattern=((? 28 rel) (? 28 c) (? 28 b))
frame=(((? 28 c) . Irad)     ((? 28 a) . Enoch)    ((? ggs) ? 28 b)
       ((? g) ? 28 a)        ((? 28 rel) grandson))

unify-result=failed
apply-a-rule
rule=(rule (list-ending-with-grandson (grandson)))
pattern=((? 28 rel) (? 28 c) (? 28 b))
frame=(((? 28 c) . Irad)     ((? 28 a) . Enoch)    ((? ggs) ? 28 b)
       ((? g) ? 28 a)        ((? 28 rel) grandson))

unify-result=failed
apply-a-rule
rule=(rule (son (? man) (? boy))
           (and (wife (? man) (? woman)) (son (? woman) (? boy))))
pattern=(son (? 78 grandpa) (? 78 dad))
frame=(((? 28 b) ? 78 grandson) ((? 78 grandpa) . Irad)
                                ((? 28 c) . Irad)
                                ((? 28 a) . Enoch)
                                ((? ggs) ? 28 b)
                                ((? g) ? 28 a)
                                ((? 28 rel) grandson))

unify-result=(((? 78 dad) ? 97 boy) ((? 97 man) . Irad)
                                    ((? 28 b) ? 78 grandson)
                                    ((? 78 grandpa) . Irad)
                                    ((? 28 c) . Irad)
                                    ((? 28 a) . Enoch)
                                    ((? ggs) ? 28 b)
                                    ((? g) ? 28 a)
                                    ((? 28 rel) grandson))

debug:simple-query

debug:simple-query
apply-a-rule
rule=(rule (son (? man) (? boy))
           (and (wife (? man) (? woman)) (son (? woman) (? boy))))
pattern=(son (? 78 dad) (? 78 grandson))
frame=(((? 78 dad) . Mehujael)  ((? 28 b) ? 78 grandson) ((? 78 grandpa) . Irad)
       ((? 28 c) . Irad)        ((? 28 a) . Enoch)       ((? ggs) ? 28 b)
       ((? g) ? 28 a)           ((? 28 rel) grandson))

unify-result=(((? 78 grandson) ? 98 boy) ((? 98 man) . Mehujael)
                                         ((? 78 dad) . Mehujael)
                                         ((? 28 b) ? 78 grandson)
                                         ((? 78 grandpa) . Irad)
                                         ((? 28 c) . Irad)
                                         ((? 28 a) . Enoch)
                                         ((? ggs) ? 28 b)
                                         ((? g) ? 28 a)
                                         ((? 28 rel) grandson))

debug:simple-query

debug:simple-query
apply-a-rule
rule=(rule ((great ? rel) (? a) (? b))
           (and (son (? a) (? c))
                ((? rel) (? c) (? b))
                (list-ending-with-grandson (? rel))))
pattern=((? 28 rel) (? 28 c) (? 28 b))
frame=(((? 28 c) . Cain)     ((? 28 a) . Adam)     ((? ggs) ? 28 b)
       ((? g) ? 28 a)        ((? 28 rel) grandson))

unify-result=failed
apply-a-rule
rule=(rule (son (? man) (? boy))
           (and (wife (? man) (? woman)) (son (? woman) (? boy))))
pattern=((? 28 rel) (? 28 c) (? 28 b))
frame=(((? 28 c) . Cain)     ((? 28 a) . Adam)     ((? ggs) ? 28 b)
       ((? g) ? 28 a)        ((? 28 rel) grandson))

unify-result=failed
apply-a-rule
rule=(rule ((grandson) (? grandpa) (? grandson))
           (and (son (? grandpa) (? dad)) (son (? dad) (? grandson))))
pattern=((? 28 rel) (? 28 c) (? 28 b))
frame=(((? 28 c) . Cain)     ((? 28 a) . Adam)     ((? ggs) ? 28 b)
       ((? g) ? 28 a)        ((? 28 rel) grandson))

unify-result=(((? 28 b) ? 101 grandson) ((? 101 grandpa) . Cain)
                                        ((? 28 c) . Cain)
                                        ((? 28 a) . Adam)
                                        ((? ggs) ? 28 b)
                                        ((? g) ? 28 a)
                                        ((? 28 rel) grandson))

debug:simple-query

debug:simple-query
apply-a-rule
rule=(rule (list-ending-with-grandson ((? x) ? y))
           (list-ending-with-grandson (? y)))
pattern=(list-ending-with-grandson (? 28 rel))
frame=(((? 101 grandson) . Irad) ((? 101 dad) . Enoch)     ((? 28 b) ? 101 grandson)
       ((? 101 grandpa) . Cain)  ((? 28 c) . Cain)         ((? 28 a) . Adam)
       ((? ggs) ? 28 b)          ((? g) ? 28 a)            ((? 28 rel) grandson))

unify-result=(((? 102 y)) ((? 102 x) . grandson)
                          ((? 101 grandson) . Irad)
                          ((? 101 dad) . Enoch)
                          ((? 28 b) ? 101 grandson)
                          ((? 101 grandpa) . Cain)
                          ((? 28 c) . Cain)
                          ((? 28 a) . Adam)
                          ((? ggs) ? 28 b)
                          ((? g) ? 28 a)
                          ((? 28 rel) grandson))

debug:simple-query
apply-a-rule
rule=(rule (list-ending-with-grandson ((? x) ? y))
           (list-ending-with-grandson (? y)))
pattern=(list-ending-with-grandson (? 102 y))
frame=(((? 102 y)) ((? 102 x) . grandson)
                   ((? 101 grandson) . Irad)
                   ((? 101 dad) . Enoch)
                   ((? 28 b) ? 101 grandson)
                   ((? 101 grandpa) . Cain)
                   ((? 28 c) . Cain)
                   ((? 28 a) . Adam)
                   ((? ggs) ? 28 b)
                   ((? g) ? 28 a)
                   ((? 28 rel) grandson))

unify-result=failed
apply-a-rule
rule=(rule (list-ending-with-grandson (grandson)))
pattern=(list-ending-with-grandson (? 102 y))
frame=(((? 102 y)) ((? 102 x) . grandson)
                   ((? 101 grandson) . Irad)
                   ((? 101 dad) . Enoch)
                   ((? 28 b) ? 101 grandson)
                   ((? 101 grandpa) . Cain)
                   ((? 28 c) . Cain)
                   ((? 28 a) . Adam)
                   ((? ggs) ? 28 b)
                   ((? g) ? 28 a)
                   ((? 28 rel) grandson))

unify-result=failed
apply-a-rule
rule=(rule (list-ending-with-grandson (grandson)))
pattern=(list-ending-with-grandson (? 28 rel))
frame=(((? 101 grandson) . Irad) ((? 101 dad) . Enoch)     ((? 28 b) ? 101 grandson)
       ((? 101 grandpa) . Cain)  ((? 28 c) . Cain)         ((? 28 a) . Adam)
       ((? ggs) ? 28 b)          ((? g) ? 28 a)            ((? 28 rel) grandson))

unify-result=(((? 101 grandson) . Irad) ((? 101 dad) . Enoch)     ((? 28 b) ? 101 grandson)
              ((? 101 grandpa) . Cain)  ((? 28 c) . Cain)         ((? 28 a) . Adam)
              ((? ggs) ? 28 b)          ((? g) ? 28 a)            ((? 28 rel) grandson))
((great grandson) Adam Irad)
apply-a-rule
rule=(rule (list-ending-with-grandson ((? x) ? y))
           (list-ending-with-grandson (? y)))
pattern=((? 28 rel) (? 28 c) (? 28 b))
frame=(((? 28 c) . Enoch)    ((? 28 a) . Cain)     ((? ggs) ? 28 b)
       ((? g) ? 28 a)        ((? 28 rel) grandson))

unify-result=failed
apply-a-rule
rule=(rule (list-ending-with-grandson (grandson)))
pattern=((? 28 rel) (? 28 c) (? 28 b))
frame=(((? 28 c) . Enoch)    ((? 28 a) . Cain)     ((? ggs) ? 28 b)
       ((? g) ? 28 a)        ((? 28 rel) grandson))

unify-result=failed
apply-a-rule
rule=(rule (son (? man) (? boy))
           (and (wife (? man) (? woman)) (son (? woman) (? boy))))
pattern=(son (? 90 grandpa) (? 90 dad))
frame=(((? 28 b) ? 90 grandson) ((? 90 grandpa) . Enoch)
                                ((? 28 c) . Enoch)
                                ((? 28 a) . Cain)
                                ((? ggs) ? 28 b)
                                ((? g) ? 28 a)
                                ((? 28 rel) grandson))

unify-result=(((? 90 dad) ? 108 boy) ((? 108 man) . Enoch)
                                     ((? 28 b) ? 90 grandson)
                                     ((? 90 grandpa) . Enoch)
                                     ((? 28 c) . Enoch)
                                     ((? 28 a) . Cain)
                                     ((? ggs) ? 28 b)
                                     ((? g) ? 28 a)
                                     ((? 28 rel) grandson))

debug:simple-query

debug:simple-query
apply-a-rule
rule=(rule (son (? man) (? boy))
           (and (wife (? man) (? woman)) (son (? woman) (? boy))))
pattern=(son (? 90 dad) (? 90 grandson))
frame=(((? 90 dad) . Irad)      ((? 28 b) ? 90 grandson) ((? 90 grandpa) . Enoch)
       ((? 28 c) . Enoch)       ((? 28 a) . Cain)        ((? ggs) ? 28 b)
       ((? g) ? 28 a)           ((? 28 rel) grandson))

unify-result=(((? 90 grandson) ? 109 boy) ((? 109 man) . Irad)
                                          ((? 90 dad) . Irad)
                                          ((? 28 b) ? 90 grandson)
                                          ((? 90 grandpa) . Enoch)
                                          ((? 28 c) . Enoch)
                                          ((? 28 a) . Cain)
                                          ((? ggs) ? 28 b)
                                          ((? g) ? 28 a)
                                          ((? 28 rel) grandson))

debug:simple-query

debug:simple-query
apply-a-rule
rule=(rule (son (? man) (? boy))
           (and (wife (? man) (? woman)) (son (? woman) (? boy))))
pattern=(son (? 28 a) (? 28 c))
frame=(((? ggs) ? 28 b) ((? g) ? 28 a) ((? 28 rel) grandson))

unify-result=(((? 28 c) ? 110 boy) ((? 28 a) ? 110 man)
                                   ((? ggs) ? 28 b)
                                   ((? g) ? 28 a)
                                   ((? 28 rel) grandson))

debug:simple-query

debug:simple-query
apply-a-rule
rule=(rule ((great ? rel) (? a) (? b))
           (and (son (? a) (? c))
                ((? rel) (? c) (? b))
                (list-ending-with-grandson (? rel))))
pattern=((? 28 rel) (? 28 c) (? 28 b))
frame=(((? 110 boy) . Jubal)  ((? 110 woman) . Ada)  ((? 110 man) . Lamech)
       ((? 28 c) ? 110 boy)   ((? 28 a) ? 110 man)   ((? ggs) ? 28 b)
       ((? g) ? 28 a)         ((? 28 rel) grandson))

unify-result=failed
apply-a-rule
rule=(rule (son (? man) (? boy))
           (and (wife (? man) (? woman)) (son (? woman) (? boy))))
pattern=((? 28 rel) (? 28 c) (? 28 b))
frame=(((? 110 boy) . Jubal)  ((? 110 woman) . Ada)  ((? 110 man) . Lamech)
       ((? 28 c) ? 110 boy)   ((? 28 a) ? 110 man)   ((? ggs) ? 28 b)
       ((? g) ? 28 a)         ((? 28 rel) grandson))

unify-result=failed
apply-a-rule
rule=(rule ((grandson) (? grandpa) (? grandson))
           (and (son (? grandpa) (? dad)) (son (? dad) (? grandson))))
pattern=((? 28 rel) (? 28 c) (? 28 b))
frame=(((? 110 boy) . Jubal)  ((? 110 woman) . Ada)  ((? 110 man) . Lamech)
       ((? 28 c) ? 110 boy)   ((? 28 a) ? 110 man)   ((? ggs) ? 28 b)
       ((? g) ? 28 a)         ((? 28 rel) grandson))

unify-result=(((? 28 b) ? 113 grandson) ((? 113 grandpa) . Jubal)
                                        ((? 110 boy) . Jubal)
                                        ((? 110 woman) . Ada)
                                        ((? 110 man) . Lamech)
                                        ((? 28 c) ? 110 boy)
                                        ((? 28 a) ? 110 man)
                                        ((? ggs) ? 28 b)
                                        ((? g) ? 28 a)
                                        ((? 28 rel) grandson))

debug:simple-query
apply-a-rule
rule=(rule (son (? man) (? boy))
           (and (wife (? man) (? woman)) (son (? woman) (? boy))))
pattern=(son (? 113 grandpa) (? 113 dad))
frame=(((? 28 b) ? 113 grandson) ((? 113 grandpa) . Jubal)
                                 ((? 110 boy) . Jubal)
                                 ((? 110 woman) . Ada)
                                 ((? 110 man) . Lamech)
                                 ((? 28 c) ? 110 boy)
                                 ((? 28 a) ? 110 man)
                                 ((? ggs) ? 28 b)
                                 ((? g) ? 28 a)
                                 ((? 28 rel) grandson))

unify-result=(((? 113 dad) ? 114 boy) ((? 114 man) . Jubal)
                                      ((? 28 b) ? 113 grandson)
                                      ((? 113 grandpa) . Jubal)
                                      ((? 110 boy) . Jubal)
                                      ((? 110 woman) . Ada)
                                      ((? 110 man) . Lamech)
                                      ((? 28 c) ? 110 boy)
                                      ((? 28 a) ? 110 man)
                                      ((? ggs) ? 28 b)
                                      ((? g) ? 28 a)
                                      ((? 28 rel) grandson))

debug:simple-query

debug:simple-query

debug:simple-query
apply-a-rule
rule=(rule (list-ending-with-grandson ((? x) ? y))
           (list-ending-with-grandson (? y)))
pattern=((? 28 rel) (? 28 c) (? 28 b))
frame=(((? 110 boy) . Jubal)  ((? 110 woman) . Ada)  ((? 110 man) . Lamech)
       ((? 28 c) ? 110 boy)   ((? 28 a) ? 110 man)   ((? ggs) ? 28 b)
       ((? g) ? 28 a)         ((? 28 rel) grandson))

unify-result=failed
apply-a-rule
rule=(rule (list-ending-with-grandson (grandson)))
pattern=((? 28 rel) (? 28 c) (? 28 b))
frame=(((? 110 boy) . Jubal)  ((? 110 woman) . Ada)  ((? 110 man) . Lamech)
       ((? 28 c) ? 110 boy)   ((? 28 a) ? 110 man)   ((? ggs) ? 28 b)
       ((? g) ? 28 a)         ((? 28 rel) grandson))

unify-result=failed
apply-a-rule
rule=(rule ((great ? rel) (? a) (? b))
           (and (son (? a) (? c))
                ((? rel) (? c) (? b))
                (list-ending-with-grandson (? rel))))
pattern=((? 28 rel) (? 28 c) (? 28 b))
frame=(((? 110 boy) . Jabal)  ((? 110 woman) . Ada)  ((? 110 man) . Lamech)
       ((? 28 c) ? 110 boy)   ((? 28 a) ? 110 man)   ((? ggs) ? 28 b)
       ((? g) ? 28 a)         ((? 28 rel) grandson))

unify-result=failed
apply-a-rule
rule=(rule (son (? man) (? boy))
           (and (wife (? man) (? woman)) (son (? woman) (? boy))))
pattern=((? 28 rel) (? 28 c) (? 28 b))
frame=(((? 110 boy) . Jabal)  ((? 110 woman) . Ada)  ((? 110 man) . Lamech)
       ((? 28 c) ? 110 boy)   ((? 28 a) ? 110 man)   ((? ggs) ? 28 b)
       ((? g) ? 28 a)         ((? 28 rel) grandson))

unify-result=failed
apply-a-rule
rule=(rule ((grandson) (? grandpa) (? grandson))
           (and (son (? grandpa) (? dad)) (son (? dad) (? grandson))))
pattern=((? 28 rel) (? 28 c) (? 28 b))
frame=(((? 110 boy) . Jabal)  ((? 110 woman) . Ada)  ((? 110 man) . Lamech)
       ((? 28 c) ? 110 boy)   ((? 28 a) ? 110 man)   ((? ggs) ? 28 b)
       ((? g) ? 28 a)         ((? 28 rel) grandson))

unify-result=(((? 28 b) ? 119 grandson) ((? 119 grandpa) . Jabal)
                                        ((? 110 boy) . Jabal)
                                        ((? 110 woman) . Ada)
                                        ((? 110 man) . Lamech)
                                        ((? 28 c) ? 110 boy)
                                        ((? 28 a) ? 110 man)
                                        ((? ggs) ? 28 b)
                                        ((? g) ? 28 a)
                                        ((? 28 rel) grandson))

debug:simple-query
apply-a-rule
rule=(rule (son (? man) (? boy))
           (and (wife (? man) (? woman)) (son (? woman) (? boy))))
pattern=(son (? 119 grandpa) (? 119 dad))
frame=(((? 28 b) ? 119 grandson) ((? 119 grandpa) . Jabal)
                                 ((? 110 boy) . Jabal)
                                 ((? 110 woman) . Ada)
                                 ((? 110 man) . Lamech)
                                 ((? 28 c) ? 110 boy)
                                 ((? 28 a) ? 110 man)
                                 ((? ggs) ? 28 b)
                                 ((? g) ? 28 a)
                                 ((? 28 rel) grandson))

unify-result=(((? 119 dad) ? 120 boy) ((? 120 man) . Jabal)
                                      ((? 28 b) ? 119 grandson)
                                      ((? 119 grandpa) . Jabal)
                                      ((? 110 boy) . Jabal)
                                      ((? 110 woman) . Ada)
                                      ((? 110 man) . Lamech)
                                      ((? 28 c) ? 110 boy)
                                      ((? 28 a) ? 110 man)
                                      ((? ggs) ? 28 b)
                                      ((? g) ? 28 a)
                                      ((? 28 rel) grandson))

debug:simple-query

debug:simple-query

debug:simple-query
apply-a-rule
rule=(rule (list-ending-with-grandson ((? x) ? y))
           (list-ending-with-grandson (? y)))
pattern=((? 28 rel) (? 28 c) (? 28 b))
frame=(((? 110 boy) . Jabal)  ((? 110 woman) . Ada)  ((? 110 man) . Lamech)
       ((? 28 c) ? 110 boy)   ((? 28 a) ? 110 man)   ((? ggs) ? 28 b)
       ((? g) ? 28 a)         ((? 28 rel) grandson))

unify-result=failed
apply-a-rule
rule=(rule (list-ending-with-grandson (grandson)))
pattern=((? 28 rel) (? 28 c) (? 28 b))
frame=(((? 110 boy) . Jabal)  ((? 110 woman) . Ada)  ((? 110 man) . Lamech)
       ((? 28 c) ? 110 boy)   ((? 28 a) ? 110 man)   ((? ggs) ? 28 b)
       ((? g) ? 28 a)         ((? 28 rel) grandson))

unify-result=failed
apply-a-rule
rule=(rule (son (? man) (? boy))
           (and (wife (? man) (? woman)) (son (? woman) (? boy))))
pattern=(son (? 110 woman) (? 110 boy))
frame=(((? 110 woman) . Ada)  ((? 110 man) . Lamech) ((? 28 c) ? 110 boy)
       ((? 28 a) ? 110 man)   ((? ggs) ? 28 b)       ((? g) ? 28 a)
       ((? 28 rel) grandson))

unify-result=(((? 110 boy) ? 123 boy) ((? 123 man) . Ada)
                                      ((? 110 woman) . Ada)
                                      ((? 110 man) . Lamech)
                                      ((? 28 c) ? 110 boy)
                                      ((? 28 a) ? 110 man)
                                      ((? ggs) ? 28 b)
                                      ((? g) ? 28 a)
                                      ((? 28 rel) grandson))

debug:simple-query

debug:simple-query
apply-a-rule
rule=(rule (list-ending-with-grandson ((? x) ? y))
           (list-ending-with-grandson (? y)))
pattern=((? 28 rel) (? 28 c) (? 28 b))
frame=(((? 28 c) . Cain)     ((? 28 a) . Adam)     ((? ggs) ? 28 b)
       ((? g) ? 28 a)        ((? 28 rel) grandson))

unify-result=failed
apply-a-rule
rule=(rule (list-ending-with-grandson (grandson)))
pattern=((? 28 rel) (? 28 c) (? 28 b))
frame=(((? 28 c) . Cain)     ((? 28 a) . Adam)     ((? ggs) ? 28 b)
       ((? g) ? 28 a)        ((? 28 rel) grandson))

unify-result=failed
apply-a-rule
rule=(rule (son (? man) (? boy))
           (and (wife (? man) (? woman)) (son (? woman) (? boy))))
pattern=(son (? 101 grandpa) (? 101 dad))
frame=(((? 28 b) ? 101 grandson) ((? 101 grandpa) . Cain)
                                 ((? 28 c) . Cain)
                                 ((? 28 a) . Adam)
                                 ((? ggs) ? 28 b)
                                 ((? g) ? 28 a)
                                 ((? 28 rel) grandson))

unify-result=(((? 101 dad) ? 126 boy) ((? 126 man) . Cain)
                                      ((? 28 b) ? 101 grandson)
                                      ((? 101 grandpa) . Cain)
                                      ((? 28 c) . Cain)
                                      ((? 28 a) . Adam)
                                      ((? ggs) ? 28 b)
                                      ((? g) ? 28 a)
                                      ((? 28 rel) grandson))

debug:simple-query

debug:simple-query
apply-a-rule
rule=(rule (son (? man) (? boy))
           (and (wife (? man) (? woman)) (son (? woman) (? boy))))
pattern=(son (? 101 dad) (? 101 grandson))
frame=(((? 101 dad) . Enoch)     ((? 28 b) ? 101 grandson) ((? 101 grandpa) . Cain)
       ((? 28 c) . Cain)         ((? 28 a) . Adam)         ((? ggs) ? 28 b)
       ((? g) ? 28 a)            ((? 28 rel) grandson))

unify-result=(((? 101 grandson) ? 127 boy) ((? 127 man) . Enoch)
                                           ((? 101 dad) . Enoch)
                                           ((? 28 b) ? 101 grandson)
                                           ((? 101 grandpa) . Cain)
                                           ((? 28 c) . Cain)
                                           ((? 28 a) . Adam)
                                           ((? ggs) ? 28 b)
                                           ((? g) ? 28 a)
                                           ((? 28 rel) grandson))

debug:simple-query

debug:simple-query

;;; Query input:
((? relationship) Adam Irad)
;;; Query results:

debug:simple-query
apply-a-rule
rule=(rule ((great ? rel) (? a) (? b))
           (and (son (? a) (? c))
                ((? rel) (? c) (? b))
                (list-ending-with-grandson (? rel))))
pattern=((? relationship) Adam Irad)
frame=()

unify-result=(((? 128 b) . Irad)
              ((? 128 a) . Adam)
              ((? relationship) great ? 128 rel))

debug:simple-query

debug:simple-query
apply-a-rule
rule=(rule ((great ? rel) (? a) (? b))
           (and (son (? a) (? c))
                ((? rel) (? c) (? b))
                (list-ending-with-grandson (? rel))))
pattern=((? 128 rel) (? 128 c) (? 128 b))
frame=(((? 128 c) . Cain)                 ((? 128 b) . Irad)
       ((? 128 a) . Adam)                 ((? relationship) great ? 128 rel))

unify-result=(((? 129 b) . Irad)                 ((? 129 a) . Cain)
              ((? 128 rel) great ? 129 rel)      ((? 128 c) . Cain)
              ((? 128 b) . Irad)                 ((? 128 a) . Adam)
              ((? relationship) great ? 128 rel))

debug:simple-query

debug:simple-query

debug:simple-query
apply-a-rule
rule=(rule (list-ending-with-grandson ((? x) ? y))
           (list-ending-with-grandson (? y)))
pattern=(list-ending-with-grandson (? 129 rel))
frame=(((? 129 rel) . son)                ((? 129 c) . Enoch)
       ((? 129 b) . Irad)                 ((? 129 a) . Cain)
       ((? 128 rel) great ? 129 rel)      ((? 128 c) . Cain)
       ((? 128 b) . Irad)                 ((? 128 a) . Adam)
       ((? relationship) great ? 128 rel))

unify-result=failed
apply-a-rule
rule=(rule (list-ending-with-grandson (grandson)))
pattern=(list-ending-with-grandson (? 129 rel))
frame=(((? 129 rel) . son)                ((? 129 c) . Enoch)
       ((? 129 b) . Irad)                 ((? 129 a) . Cain)
       ((? 128 rel) great ? 129 rel)      ((? 128 c) . Cain)
       ((? 128 b) . Irad)                 ((? 128 a) . Adam)
       ((? relationship) great ? 128 rel))

unify-result=failed
apply-a-rule
rule=(rule (son (? man) (? boy))
           (and (wife (? man) (? woman)) (son (? woman) (? boy))))
pattern=(son (? 129 a) (? 129 c))
frame=(((? 129 b) . Irad)                 ((? 129 a) . Cain)
       ((? 128 rel) great ? 129 rel)      ((? 128 c) . Cain)
       ((? 128 b) . Irad)                 ((? 128 a) . Adam)
       ((? relationship) great ? 128 rel))

unify-result=(((? 129 c) ? 132 boy) ((? 132 man) . Cain)
                                    ((? 129 b) . Irad)
                                    ((? 129 a) . Cain)
                                    ((? 128 rel) great ? 129 rel)
                                    ((? 128 c) . Cain)
                                    ((? 128 b) . Irad)
                                    ((? 128 a) . Adam)
                                    ((? relationship) great ? 128 rel))

debug:simple-query

debug:simple-query
apply-a-rule
rule=(rule ((great ? rel) (? a) (? b))
           (and (son (? a) (? c))
                ((? rel) (? c) (? b))
                (list-ending-with-grandson (? rel))))
pattern=((? 129 rel) (? 129 c) (? 129 b))
frame=(((? 129 c) . Enoch)                ((? 129 b) . Irad)
       ((? 129 a) . Cain)                 ((? 128 rel) great ? 129 rel)
       ((? 128 c) . Cain)                 ((? 128 b) . Irad)
       ((? 128 a) . Adam)                 ((? relationship) great ? 128 rel))

unify-result=(((? 133 b) . Irad)                 ((? 133 a) . Enoch)
              ((? 129 rel) great ? 133 rel)      ((? 129 c) . Enoch)
              ((? 129 b) . Irad)                 ((? 129 a) . Cain)
              ((? 128 rel) great ? 129 rel)      ((? 128 c) . Cain)
              ((? 128 b) . Irad)                 ((? 128 a) . Adam)
              ((? relationship) great ? 128 rel))

debug:simple-query

debug:simple-query
apply-a-rule
rule=(rule ((great ? rel) (? a) (? b))
           (and (son (? a) (? c))
                ((? rel) (? c) (? b))
                (list-ending-with-grandson (? rel))))
pattern=((? 133 rel) (? 133 c) (? 133 b))
frame=(((? 133 c) . Irad)                 ((? 133 b) . Irad)
       ((? 133 a) . Enoch)                ((? 129 rel) great ? 133 rel)
       ((? 129 c) . Enoch)                ((? 129 b) . Irad)
       ((? 129 a) . Cain)                 ((? 128 rel) great ? 129 rel)
       ((? 128 c) . Cain)                 ((? 128 b) . Irad)
       ((? 128 a) . Adam)                 ((? relationship) great ? 128 rel))

unify-result=(((? 134 b) . Irad)                 ((? 134 a) . Irad)
              ((? 133 rel) great ? 134 rel)      ((? 133 c) . Irad)
              ((? 133 b) . Irad)                 ((? 133 a) . Enoch)
              ((? 129 rel) great ? 133 rel)      ((? 129 c) . Enoch)
              ((? 129 b) . Irad)                 ((? 129 a) . Cain)
              ((? 128 rel) great ? 129 rel)      ((? 128 c) . Cain)
              ((? 128 b) . Irad)                 ((? 128 a) . Adam)
              ((? relationship) great ? 128 rel))

debug:simple-query

debug:simple-query
apply-a-rule
rule=(rule ((great ? rel) (? a) (? b))
           (and (son (? a) (? c))
                ((? rel) (? c) (? b))
                (list-ending-with-grandson (? rel))))
pattern=((? 134 rel) (? 134 c) (? 134 b))
frame=(((? 134 c) . Mehujael)             ((? 134 b) . Irad)
       ((? 134 a) . Irad)                 ((? 133 rel) great ? 134 rel)
       ((? 133 c) . Irad)                 ((? 133 b) . Irad)
       ((? 133 a) . Enoch)                ((? 129 rel) great ? 133 rel)
       ((? 129 c) . Enoch)                ((? 129 b) . Irad)
       ((? 129 a) . Cain)                 ((? 128 rel) great ? 129 rel)
       ((? 128 c) . Cain)                 ((? 128 b) . Irad)
       ((? 128 a) . Adam)                 ((? relationship) great ? 128 rel))

unify-result=(((? 135 b) . Irad)                 ((? 135 a) . Mehujael)
              ((? 134 rel) great ? 135 rel)      ((? 134 c) . Mehujael)
              ((? 134 b) . Irad)                 ((? 134 a) . Irad)
              ((? 133 rel) great ? 134 rel)      ((? 133 c) . Irad)
              ((? 133 b) . Irad)                 ((? 133 a) . Enoch)
              ((? 129 rel) great ? 133 rel)      ((? 129 c) . Enoch)
              ((? 129 b) . Irad)                 ((? 129 a) . Cain)
              ((? 128 rel) great ? 129 rel)      ((? 128 c) . Cain)
              ((? 128 b) . Irad)                 ((? 128 a) . Adam)
              ((? relationship) great ? 128 rel))

debug:simple-query

debug:simple-query
apply-a-rule
rule=(rule ((great ? rel) (? a) (? b))
           (and (son (? a) (? c))
                ((? rel) (? c) (? b))
                (list-ending-with-grandson (? rel))))
pattern=((? 135 rel) (? 135 c) (? 135 b))
frame=(((? 135 c) . Methushael)           ((? 135 b) . Irad)
       ((? 135 a) . Mehujael)             ((? 134 rel) great ? 135 rel)
       ((? 134 c) . Mehujael)             ((? 134 b) . Irad)
       ((? 134 a) . Irad)                 ((? 133 rel) great ? 134 rel)
       ((? 133 c) . Irad)                 ((? 133 b) . Irad)
       ((? 133 a) . Enoch)                ((? 129 rel) great ? 133 rel)
       ((? 129 c) . Enoch)                ((? 129 b) . Irad)
       ((? 129 a) . Cain)                 ((? 128 rel) great ? 129 rel)
       ((? 128 c) . Cain)                 ((? 128 b) . Irad)
       ((? 128 a) . Adam)                 ((? relationship) great ? 128 rel))

unify-result=(((? 136 b) . Irad)                 ((? 136 a) . Methushael)
              ((? 135 rel) great ? 136 rel)      ((? 135 c) . Methushael)
              ((? 135 b) . Irad)                 ((? 135 a) . Mehujael)
              ((? 134 rel) great ? 135 rel)      ((? 134 c) . Mehujael)
              ((? 134 b) . Irad)                 ((? 134 a) . Irad)
              ((? 133 rel) great ? 134 rel)      ((? 133 c) . Irad)
              ((? 133 b) . Irad)                 ((? 133 a) . Enoch)
              ((? 129 rel) great ? 133 rel)      ((? 129 c) . Enoch)
              ((? 129 b) . Irad)                 ((? 129 a) . Cain)
              ((? 128 rel) great ? 129 rel)      ((? 128 c) . Cain)
              ((? 128 b) . Irad)                 ((? 128 a) . Adam)
              ((? relationship) great ? 128 rel))

debug:simple-query

debug:simple-query
apply-a-rule
rule=(rule ((great ? rel) (? a) (? b))
           (and (son (? a) (? c))
                ((? rel) (? c) (? b))
                (list-ending-with-grandson (? rel))))
pattern=((? 136 rel) (? 136 c) (? 136 b))
frame=(((? 136 c) . Lamech)               ((? 136 b) . Irad)
       ((? 136 a) . Methushael)           ((? 135 rel) great ? 136 rel)
       ((? 135 c) . Methushael)           ((? 135 b) . Irad)
       ((? 135 a) . Mehujael)             ((? 134 rel) great ? 135 rel)
       ((? 134 c) . Mehujael)             ((? 134 b) . Irad)
       ((? 134 a) . Irad)                 ((? 133 rel) great ? 134 rel)
       ((? 133 c) . Irad)                 ((? 133 b) . Irad)
       ((? 133 a) . Enoch)                ((? 129 rel) great ? 133 rel)
       ((? 129 c) . Enoch)                ((? 129 b) . Irad)
       ((? 129 a) . Cain)                 ((? 128 rel) great ? 129 rel)
       ((? 128 c) . Cain)                 ((? 128 b) . Irad)
       ((? 128 a) . Adam)                 ((? relationship) great ? 128 rel))

unify-result=(((? 137 b) . Irad)                 ((? 137 a) . Lamech)
              ((? 136 rel) great ? 137 rel)      ((? 136 c) . Lamech)
              ((? 136 b) . Irad)                 ((? 136 a) . Methushael)
              ((? 135 rel) great ? 136 rel)      ((? 135 c) . Methushael)
              ((? 135 b) . Irad)                 ((? 135 a) . Mehujael)
              ((? 134 rel) great ? 135 rel)      ((? 134 c) . Mehujael)
              ((? 134 b) . Irad)                 ((? 134 a) . Irad)
              ((? 133 rel) great ? 134 rel)      ((? 133 c) . Irad)
              ((? 133 b) . Irad)                 ((? 133 a) . Enoch)
              ((? 129 rel) great ? 133 rel)      ((? 129 c) . Enoch)
              ((? 129 b) . Irad)                 ((? 129 a) . Cain)
              ((? 128 rel) great ? 129 rel)      ((? 128 c) . Cain)
              ((? 128 b) . Irad)                 ((? 128 a) . Adam)
              ((? relationship) great ? 128 rel))

debug:simple-query
apply-a-rule
rule=(rule (son (? man) (? boy))
           (and (wife (? man) (? woman)) (son (? woman) (? boy))))
pattern=(son (? 137 a) (? 137 c))
frame=(((? 137 b) . Irad)                 ((? 137 a) . Lamech)
       ((? 136 rel) great ? 137 rel)      ((? 136 c) . Lamech)
       ((? 136 b) . Irad)                 ((? 136 a) . Methushael)
       ((? 135 rel) great ? 136 rel)      ((? 135 c) . Methushael)
       ((? 135 b) . Irad)                 ((? 135 a) . Mehujael)
       ((? 134 rel) great ? 135 rel)      ((? 134 c) . Mehujael)
       ((? 134 b) . Irad)                 ((? 134 a) . Irad)
       ((? 133 rel) great ? 134 rel)      ((? 133 c) . Irad)
       ((? 133 b) . Irad)                 ((? 133 a) . Enoch)
       ((? 129 rel) great ? 133 rel)      ((? 129 c) . Enoch)
       ((? 129 b) . Irad)                 ((? 129 a) . Cain)
       ((? 128 rel) great ? 129 rel)      ((? 128 c) . Cain)
       ((? 128 b) . Irad)                 ((? 128 a) . Adam)
       ((? relationship) great ? 128 rel))

unify-result=(((? 137 c) ? 138 boy) ((? 138 man) . Lamech)
                                    ((? 137 b) . Irad)
                                    ((? 137 a) . Lamech)
                                    ((? 136 rel) great ? 137 rel)
                                    ((? 136 c) . Lamech)
                                    ((? 136 b) . Irad)
                                    ((? 136 a) . Methushael)
                                    ((? 135 rel) great ? 136 rel)
                                    ((? 135 c) . Methushael)
                                    ((? 135 b) . Irad)
                                    ((? 135 a) . Mehujael)
                                    ((? 134 rel) great ? 135 rel)
                                    ((? 134 c) . Mehujael)
                                    ((? 134 b) . Irad)
                                    ((? 134 a) . Irad)
                                    ((? 133 rel) great ? 134 rel)
                                    ((? 133 c) . Irad)
                                    ((? 133 b) . Irad)
                                    ((? 133 a) . Enoch)
                                    ((? 129 rel) great ? 133 rel)
                                    ((? 129 c) . Enoch)
                                    ((? 129 b) . Irad)
                                    ((? 129 a) . Cain)
                                    ((? 128 rel) great ? 129 rel)
                                    ((? 128 c) . Cain)
                                    ((? 128 b) . Irad)
                                    ((? 128 a) . Adam)
                                    ((? relationship) great ? 128 rel))

debug:simple-query

debug:simple-query

debug:simple-query
apply-a-rule
rule=(rule ((great ? rel) (? a) (? b))
           (and (son (? a) (? c))
                ((? rel) (? c) (? b))
                (list-ending-with-grandson (? rel))))
pattern=((? 137 rel) (? 137 c) (? 137 b))
frame=(((? 138 boy) . Jubal)              ((? 138 woman) . Ada)
       ((? 137 c) ? 138 boy)              ((? 138 man) . Lamech)
       ((? 137 b) . Irad)                 ((? 137 a) . Lamech)
       ((? 136 rel) great ? 137 rel)      ((? 136 c) . Lamech)
       ((? 136 b) . Irad)                 ((? 136 a) . Methushael)
       ((? 135 rel) great ? 136 rel)      ((? 135 c) . Methushael)
       ((? 135 b) . Irad)                 ((? 135 a) . Mehujael)
       ((? 134 rel) great ? 135 rel)      ((? 134 c) . Mehujael)
       ((? 134 b) . Irad)                 ((? 134 a) . Irad)
       ((? 133 rel) great ? 134 rel)      ((? 133 c) . Irad)
       ((? 133 b) . Irad)                 ((? 133 a) . Enoch)
       ((? 129 rel) great ? 133 rel)      ((? 129 c) . Enoch)
       ((? 129 b) . Irad)                 ((? 129 a) . Cain)
       ((? 128 rel) great ? 129 rel)      ((? 128 c) . Cain)
       ((? 128 b) . Irad)                 ((? 128 a) . Adam)
       ((? relationship) great ? 128 rel))

unify-result=(((? 139 b) . Irad)                 ((? 139 a) . Jubal)
              ((? 137 rel) great ? 139 rel)      ((? 138 boy) . Jubal)
              ((? 138 woman) . Ada)              ((? 137 c) ? 138 boy)
              ((? 138 man) . Lamech)             ((? 137 b) . Irad)
              ((? 137 a) . Lamech)               ((? 136 rel) great ? 137 rel)
              ((? 136 c) . Lamech)               ((? 136 b) . Irad)
              ((? 136 a) . Methushael)           ((? 135 rel) great ? 136 rel)
              ((? 135 c) . Methushael)           ((? 135 b) . Irad)
              ((? 135 a) . Mehujael)             ((? 134 rel) great ? 135 rel)
              ((? 134 c) . Mehujael)             ((? 134 b) . Irad)
              ((? 134 a) . Irad)                 ((? 133 rel) great ? 134 rel)
              ((? 133 c) . Irad)                 ((? 133 b) . Irad)
              ((? 133 a) . Enoch)                ((? 129 rel) great ? 133 rel)
              ((? 129 c) . Enoch)                ((? 129 b) . Irad)
              ((? 129 a) . Cain)                 ((? 128 rel) great ? 129 rel)
              ((? 128 c) . Cain)                 ((? 128 b) . Irad)
              ((? 128 a) . Adam)                 ((? relationship) great ? 128 rel))

debug:simple-query
apply-a-rule
rule=(rule (son (? man) (? boy))
           (and (wife (? man) (? woman)) (son (? woman) (? boy))))
pattern=(son (? 139 a) (? 139 c))
frame=(((? 139 b) . Irad)                 ((? 139 a) . Jubal)
       ((? 137 rel) great ? 139 rel)      ((? 138 boy) . Jubal)
       ((? 138 woman) . Ada)              ((? 137 c) ? 138 boy)
       ((? 138 man) . Lamech)             ((? 137 b) . Irad)
       ((? 137 a) . Lamech)               ((? 136 rel) great ? 137 rel)
       ((? 136 c) . Lamech)               ((? 136 b) . Irad)
       ((? 136 a) . Methushael)           ((? 135 rel) great ? 136 rel)
       ((? 135 c) . Methushael)           ((? 135 b) . Irad)
       ((? 135 a) . Mehujael)             ((? 134 rel) great ? 135 rel)
       ((? 134 c) . Mehujael)             ((? 134 b) . Irad)
       ((? 134 a) . Irad)                 ((? 133 rel) great ? 134 rel)
       ((? 133 c) . Irad)                 ((? 133 b) . Irad)
       ((? 133 a) . Enoch)                ((? 129 rel) great ? 133 rel)
       ((? 129 c) . Enoch)                ((? 129 b) . Irad)
       ((? 129 a) . Cain)                 ((? 128 rel) great ? 129 rel)
       ((? 128 c) . Cain)                 ((? 128 b) . Irad)
       ((? 128 a) . Adam)                 ((? relationship) great ? 128 rel))

unify-result=(((? 139 c) ? 140 boy) ((? 140 man) . Jubal)
                                    ((? 139 b) . Irad)
                                    ((? 139 a) . Jubal)
                                    ((? 137 rel) great ? 139 rel)
                                    ((? 138 boy) . Jubal)
                                    ((? 138 woman) . Ada)
                                    ((? 137 c) ? 138 boy)
                                    ((? 138 man) . Lamech)
                                    ((? 137 b) . Irad)
                                    ((? 137 a) . Lamech)
                                    ((? 136 rel) great ? 137 rel)
                                    ((? 136 c) . Lamech)
                                    ((? 136 b) . Irad)
                                    ((? 136 a) . Methushael)
                                    ((? 135 rel) great ? 136 rel)
                                    ((? 135 c) . Methushael)
                                    ((? 135 b) . Irad)
                                    ((? 135 a) . Mehujael)
                                    ((? 134 rel) great ? 135 rel)
                                    ((? 134 c) . Mehujael)
                                    ((? 134 b) . Irad)
                                    ((? 134 a) . Irad)
                                    ((? 133 rel) great ? 134 rel)
                                    ((? 133 c) . Irad)
                                    ((? 133 b) . Irad)
                                    ((? 133 a) . Enoch)
                                    ((? 129 rel) great ? 133 rel)
                                    ((? 129 c) . Enoch)
                                    ((? 129 b) . Irad)
                                    ((? 129 a) . Cain)
                                    ((? 128 rel) great ? 129 rel)
                                    ((? 128 c) . Cain)
                                    ((? 128 b) . Irad)
                                    ((? 128 a) . Adam)
                                    ((? relationship) great ? 128 rel))

debug:simple-query

debug:simple-query

debug:simple-query

debug:simple-query
apply-a-rule
rule=(rule (son (? man) (? boy))
           (and (wife (? man) (? woman)) (son (? woman) (? boy))))
pattern=((? 137 rel) (? 137 c) (? 137 b))
frame=(((? 138 boy) . Jubal)              ((? 138 woman) . Ada)
       ((? 137 c) ? 138 boy)              ((? 138 man) . Lamech)
       ((? 137 b) . Irad)                 ((? 137 a) . Lamech)
       ((? 136 rel) great ? 137 rel)      ((? 136 c) . Lamech)
       ((? 136 b) . Irad)                 ((? 136 a) . Methushael)
       ((? 135 rel) great ? 136 rel)      ((? 135 c) . Methushael)
       ((? 135 b) . Irad)                 ((? 135 a) . Mehujael)
       ((? 134 rel) great ? 135 rel)      ((? 134 c) . Mehujael)
       ((? 134 b) . Irad)                 ((? 134 a) . Irad)
       ((? 133 rel) great ? 134 rel)      ((? 133 c) . Irad)
       ((? 133 b) . Irad)                 ((? 133 a) . Enoch)
       ((? 129 rel) great ? 133 rel)      ((? 129 c) . Enoch)
       ((? 129 b) . Irad)                 ((? 129 a) . Cain)
       ((? 128 rel) great ? 129 rel)      ((? 128 c) . Cain)
       ((? 128 b) . Irad)                 ((? 128 a) . Adam)
       ((? relationship) great ? 128 rel))

unify-result=(((? 141 boy) . Irad)               ((? 141 man) . Jubal)
              ((? 137 rel) . son)                ((? 138 boy) . Jubal)
              ((? 138 woman) . Ada)              ((? 137 c) ? 138 boy)
              ((? 138 man) . Lamech)             ((? 137 b) . Irad)
              ((? 137 a) . Lamech)               ((? 136 rel) great ? 137 rel)
              ((? 136 c) . Lamech)               ((? 136 b) . Irad)
              ((? 136 a) . Methushael)           ((? 135 rel) great ? 136 rel)
              ((? 135 c) . Methushael)           ((? 135 b) . Irad)
              ((? 135 a) . Mehujael)             ((? 134 rel) great ? 135 rel)
              ((? 134 c) . Mehujael)             ((? 134 b) . Irad)
              ((? 134 a) . Irad)                 ((? 133 rel) great ? 134 rel)
              ((? 133 c) . Irad)                 ((? 133 b) . Irad)
              ((? 133 a) . Enoch)                ((? 129 rel) great ? 133 rel)
              ((? 129 c) . Enoch)                ((? 129 b) . Irad)
              ((? 129 a) . Cain)                 ((? 128 rel) great ? 129 rel)
              ((? 128 c) . Cain)                 ((? 128 b) . Irad)
              ((? 128 a) . Adam)                 ((? relationship) great ? 128 rel))

debug:simple-query

debug:simple-query
apply-a-rule
rule=(rule ((grandson) (? grandpa) (? grandson))
           (and (son (? grandpa) (? dad)) (son (? dad) (? grandson))))
pattern=((? 137 rel) (? 137 c) (? 137 b))
frame=(((? 138 boy) . Jubal)              ((? 138 woman) . Ada)
       ((? 137 c) ? 138 boy)              ((? 138 man) . Lamech)
       ((? 137 b) . Irad)                 ((? 137 a) . Lamech)
       ((? 136 rel) great ? 137 rel)      ((? 136 c) . Lamech)
       ((? 136 b) . Irad)                 ((? 136 a) . Methushael)
       ((? 135 rel) great ? 136 rel)      ((? 135 c) . Methushael)
       ((? 135 b) . Irad)                 ((? 135 a) . Mehujael)
       ((? 134 rel) great ? 135 rel)      ((? 134 c) . Mehujael)
       ((? 134 b) . Irad)                 ((? 134 a) . Irad)
       ((? 133 rel) great ? 134 rel)      ((? 133 c) . Irad)
       ((? 133 b) . Irad)                 ((? 133 a) . Enoch)
       ((? 129 rel) great ? 133 rel)      ((? 129 c) . Enoch)
       ((? 129 b) . Irad)                 ((? 129 a) . Cain)
       ((? 128 rel) great ? 129 rel)      ((? 128 c) . Cain)
       ((? 128 b) . Irad)                 ((? 128 a) . Adam)
       ((? relationship) great ? 128 rel))

unify-result=(((? 142 grandson) . Irad)          ((? 142 grandpa) . Jubal)
              ((? 137 rel) grandson)             ((? 138 boy) . Jubal)
              ((? 138 woman) . Ada)              ((? 137 c) ? 138 boy)
              ((? 138 man) . Lamech)             ((? 137 b) . Irad)
              ((? 137 a) . Lamech)               ((? 136 rel) great ? 137 rel)
              ((? 136 c) . Lamech)               ((? 136 b) . Irad)
              ((? 136 a) . Methushael)           ((? 135 rel) great ? 136 rel)
              ((? 135 c) . Methushael)           ((? 135 b) . Irad)
              ((? 135 a) . Mehujael)             ((? 134 rel) great ? 135 rel)
              ((? 134 c) . Mehujael)             ((? 134 b) . Irad)
              ((? 134 a) . Irad)                 ((? 133 rel) great ? 134 rel)
              ((? 133 c) . Irad)                 ((? 133 b) . Irad)
              ((? 133 a) . Enoch)                ((? 129 rel) great ? 133 rel)
              ((? 129 c) . Enoch)                ((? 129 b) . Irad)
              ((? 129 a) . Cain)                 ((? 128 rel) great ? 129 rel)
              ((? 128 c) . Cain)                 ((? 128 b) . Irad)
              ((? 128 a) . Adam)                 ((? relationship) great ? 128 rel))

debug:simple-query
apply-a-rule
rule=(rule (son (? man) (? boy))
           (and (wife (? man) (? woman)) (son (? woman) (? boy))))
pattern=(son (? 142 grandpa) (? 142 dad))
frame=(((? 142 grandson) . Irad)          ((? 142 grandpa) . Jubal)
       ((? 137 rel) grandson)             ((? 138 boy) . Jubal)
       ((? 138 woman) . Ada)              ((? 137 c) ? 138 boy)
       ((? 138 man) . Lamech)             ((? 137 b) . Irad)
       ((? 137 a) . Lamech)               ((? 136 rel) great ? 137 rel)
       ((? 136 c) . Lamech)               ((? 136 b) . Irad)
       ((? 136 a) . Methushael)           ((? 135 rel) great ? 136 rel)
       ((? 135 c) . Methushael)           ((? 135 b) . Irad)
       ((? 135 a) . Mehujael)             ((? 134 rel) great ? 135 rel)
       ((? 134 c) . Mehujael)             ((? 134 b) . Irad)
       ((? 134 a) . Irad)                 ((? 133 rel) great ? 134 rel)
       ((? 133 c) . Irad)                 ((? 133 b) . Irad)
       ((? 133 a) . Enoch)                ((? 129 rel) great ? 133 rel)
       ((? 129 c) . Enoch)                ((? 129 b) . Irad)
       ((? 129 a) . Cain)                 ((? 128 rel) great ? 129 rel)
       ((? 128 c) . Cain)                 ((? 128 b) . Irad)
       ((? 128 a) . Adam)                 ((? relationship) great ? 128 rel))

unify-result=(((? 142 dad) ? 143 boy) ((? 143 man) . Jubal)
                                      ((? 142 grandson) . Irad)
                                      ((? 142 grandpa) . Jubal)
                                      ((? 137 rel) grandson)
                                      ((? 138 boy) . Jubal)
                                      ((? 138 woman) . Ada)
                                      ((? 137 c) ? 138 boy)
                                      ((? 138 man) . Lamech)
                                      ((? 137 b) . Irad)
                                      ((? 137 a) . Lamech)
                                      ((? 136 rel) great ? 137 rel)
                                      ((? 136 c) . Lamech)
                                      ((? 136 b) . Irad)
                                      ((? 136 a) . Methushael)
                                      ((? 135 rel) great ? 136 rel)
                                      ((? 135 c) . Methushael)
                                      ((? 135 b) . Irad)
                                      ((? 135 a) . Mehujael)
                                      ((? 134 rel) great ? 135 rel)
                                      ((? 134 c) . Mehujael)
                                      ((? 134 b) . Irad)
                                      ((? 134 a) . Irad)
                                      ((? 133 rel) great ? 134 rel)
                                      ((? 133 c) . Irad)
                                      ((? 133 b) . Irad)
                                      ((? 133 a) . Enoch)
                                      ((? 129 rel) great ? 133 rel)
                                      ((? 129 c) . Enoch)
                                      ((? 129 b) . Irad)
                                      ((? 129 a) . Cain)
                                      ((? 128 rel) great ? 129 rel)
                                      ((? 128 c) . Cain)
                                      ((? 128 b) . Irad)
                                      ((? 128 a) . Adam)
                                      ((? relationship) great ? 128 rel))

debug:simple-query

debug:simple-query

debug:simple-query
apply-a-rule
rule=(rule (list-ending-with-grandson ((? x) ? y))
           (list-ending-with-grandson (? y)))
pattern=((? 137 rel) (? 137 c) (? 137 b))
frame=(((? 138 boy) . Jubal)              ((? 138 woman) . Ada)
       ((? 137 c) ? 138 boy)              ((? 138 man) . Lamech)
       ((? 137 b) . Irad)                 ((? 137 a) . Lamech)
       ((? 136 rel) great ? 137 rel)      ((? 136 c) . Lamech)
       ((? 136 b) . Irad)                 ((? 136 a) . Methushael)
       ((? 135 rel) great ? 136 rel)      ((? 135 c) . Methushael)
       ((? 135 b) . Irad)                 ((? 135 a) . Mehujael)
       ((? 134 rel) great ? 135 rel)      ((? 134 c) . Mehujael)
       ((? 134 b) . Irad)                 ((? 134 a) . Irad)
       ((? 133 rel) great ? 134 rel)      ((? 133 c) . Irad)
       ((? 133 b) . Irad)                 ((? 133 a) . Enoch)
       ((? 129 rel) great ? 133 rel)      ((? 129 c) . Enoch)
       ((? 129 b) . Irad)                 ((? 129 a) . Cain)
       ((? 128 rel) great ? 129 rel)      ((? 128 c) . Cain)
       ((? 128 b) . Irad)                 ((? 128 a) . Adam)
       ((? relationship) great ? 128 rel))

unify-result=failed
apply-a-rule
rule=(rule (list-ending-with-grandson (grandson)))
pattern=((? 137 rel) (? 137 c) (? 137 b))
frame=(((? 138 boy) . Jubal)              ((? 138 woman) . Ada)
       ((? 137 c) ? 138 boy)              ((? 138 man) . Lamech)
       ((? 137 b) . Irad)                 ((? 137 a) . Lamech)
       ((? 136 rel) great ? 137 rel)      ((? 136 c) . Lamech)
       ((? 136 b) . Irad)                 ((? 136 a) . Methushael)
       ((? 135 rel) great ? 136 rel)      ((? 135 c) . Methushael)
       ((? 135 b) . Irad)                 ((? 135 a) . Mehujael)
       ((? 134 rel) great ? 135 rel)      ((? 134 c) . Mehujael)
       ((? 134 b) . Irad)                 ((? 134 a) . Irad)
       ((? 133 rel) great ? 134 rel)      ((? 133 c) . Irad)
       ((? 133 b) . Irad)                 ((? 133 a) . Enoch)
       ((? 129 rel) great ? 133 rel)      ((? 129 c) . Enoch)
       ((? 129 b) . Irad)                 ((? 129 a) . Cain)
       ((? 128 rel) great ? 129 rel)      ((? 128 c) . Cain)
       ((? 128 b) . Irad)                 ((? 128 a) . Adam)
       ((? relationship) great ? 128 rel))

unify-result=failed
apply-a-rule
rule=(rule ((great ? rel) (? a) (? b))
           (and (son (? a) (? c))
                ((? rel) (? c) (? b))
                (list-ending-with-grandson (? rel))))
pattern=((? 137 rel) (? 137 c) (? 137 b))
frame=(((? 138 boy) . Jabal)              ((? 138 woman) . Ada)
       ((? 137 c) ? 138 boy)              ((? 138 man) . Lamech)
       ((? 137 b) . Irad)                 ((? 137 a) . Lamech)
       ((? 136 rel) great ? 137 rel)      ((? 136 c) . Lamech)
       ((? 136 b) . Irad)                 ((? 136 a) . Methushael)
       ((? 135 rel) great ? 136 rel)      ((? 135 c) . Methushael)
       ((? 135 b) . Irad)                 ((? 135 a) . Mehujael)
       ((? 134 rel) great ? 135 rel)      ((? 134 c) . Mehujael)
       ((? 134 b) . Irad)                 ((? 134 a) . Irad)
       ((? 133 rel) great ? 134 rel)      ((? 133 c) . Irad)
       ((? 133 b) . Irad)                 ((? 133 a) . Enoch)
       ((? 129 rel) great ? 133 rel)      ((? 129 c) . Enoch)
       ((? 129 b) . Irad)                 ((? 129 a) . Cain)
       ((? 128 rel) great ? 129 rel)      ((? 128 c) . Cain)
       ((? 128 b) . Irad)                 ((? 128 a) . Adam)
       ((? relationship) great ? 128 rel))

unify-result=(((? 146 b) . Irad)                 ((? 146 a) . Jabal)
              ((? 137 rel) great ? 146 rel)      ((? 138 boy) . Jabal)
              ((? 138 woman) . Ada)              ((? 137 c) ? 138 boy)
              ((? 138 man) . Lamech)             ((? 137 b) . Irad)
              ((? 137 a) . Lamech)               ((? 136 rel) great ? 137 rel)
              ((? 136 c) . Lamech)               ((? 136 b) . Irad)
              ((? 136 a) . Methushael)           ((? 135 rel) great ? 136 rel)
              ((? 135 c) . Methushael)           ((? 135 b) . Irad)
              ((? 135 a) . Mehujael)             ((? 134 rel) great ? 135 rel)
              ((? 134 c) . Mehujael)             ((? 134 b) . Irad)
              ((? 134 a) . Irad)                 ((? 133 rel) great ? 134 rel)
              ((? 133 c) . Irad)                 ((? 133 b) . Irad)
              ((? 133 a) . Enoch)                ((? 129 rel) great ? 133 rel)
              ((? 129 c) . Enoch)                ((? 129 b) . Irad)
              ((? 129 a) . Cain)                 ((? 128 rel) great ? 129 rel)
              ((? 128 c) . Cain)                 ((? 128 b) . Irad)
              ((? 128 a) . Adam)                 ((? relationship) great ? 128 rel))

debug:simple-query
apply-a-rule
rule=(rule (son (? man) (? boy))
           (and (wife (? man) (? woman)) (son (? woman) (? boy))))
pattern=(son (? 146 a) (? 146 c))
frame=(((? 146 b) . Irad)                 ((? 146 a) . Jabal)
       ((? 137 rel) great ? 146 rel)      ((? 138 boy) . Jabal)
       ((? 138 woman) . Ada)              ((? 137 c) ? 138 boy)
       ((? 138 man) . Lamech)             ((? 137 b) . Irad)
       ((? 137 a) . Lamech)               ((? 136 rel) great ? 137 rel)
       ((? 136 c) . Lamech)               ((? 136 b) . Irad)
       ((? 136 a) . Methushael)           ((? 135 rel) great ? 136 rel)
       ((? 135 c) . Methushael)           ((? 135 b) . Irad)
       ((? 135 a) . Mehujael)             ((? 134 rel) great ? 135 rel)
       ((? 134 c) . Mehujael)             ((? 134 b) . Irad)
       ((? 134 a) . Irad)                 ((? 133 rel) great ? 134 rel)
       ((? 133 c) . Irad)                 ((? 133 b) . Irad)
       ((? 133 a) . Enoch)                ((? 129 rel) great ? 133 rel)
       ((? 129 c) . Enoch)                ((? 129 b) . Irad)
       ((? 129 a) . Cain)                 ((? 128 rel) great ? 129 rel)
       ((? 128 c) . Cain)                 ((? 128 b) . Irad)
       ((? 128 a) . Adam)                 ((? relationship) great ? 128 rel))

unify-result=(((? 146 c) ? 147 boy) ((? 147 man) . Jabal)
                                    ((? 146 b) . Irad)
                                    ((? 146 a) . Jabal)
                                    ((? 137 rel) great ? 146 rel)
                                    ((? 138 boy) . Jabal)
                                    ((? 138 woman) . Ada)
                                    ((? 137 c) ? 138 boy)
                                    ((? 138 man) . Lamech)
                                    ((? 137 b) . Irad)
                                    ((? 137 a) . Lamech)
                                    ((? 136 rel) great ? 137 rel)
                                    ((? 136 c) . Lamech)
                                    ((? 136 b) . Irad)
                                    ((? 136 a) . Methushael)
                                    ((? 135 rel) great ? 136 rel)
                                    ((? 135 c) . Methushael)
                                    ((? 135 b) . Irad)
                                    ((? 135 a) . Mehujael)
                                    ((? 134 rel) great ? 135 rel)
                                    ((? 134 c) . Mehujael)
                                    ((? 134 b) . Irad)
                                    ((? 134 a) . Irad)
                                    ((? 133 rel) great ? 134 rel)
                                    ((? 133 c) . Irad)
                                    ((? 133 b) . Irad)
                                    ((? 133 a) . Enoch)
                                    ((? 129 rel) great ? 133 rel)
                                    ((? 129 c) . Enoch)
                                    ((? 129 b) . Irad)
                                    ((? 129 a) . Cain)
                                    ((? 128 rel) great ? 129 rel)
                                    ((? 128 c) . Cain)
                                    ((? 128 b) . Irad)
                                    ((? 128 a) . Adam)
                                    ((? relationship) great ? 128 rel))

debug:simple-query

debug:simple-query

debug:simple-query

debug:simple-query
apply-a-rule
rule=(rule (son (? man) (? boy))
           (and (wife (? man) (? woman)) (son (? woman) (? boy))))
pattern=((? 137 rel) (? 137 c) (? 137 b))
frame=(((? 138 boy) . Jabal)              ((? 138 woman) . Ada)
       ((? 137 c) ? 138 boy)              ((? 138 man) . Lamech)
       ((? 137 b) . Irad)                 ((? 137 a) . Lamech)
       ((? 136 rel) great ? 137 rel)      ((? 136 c) . Lamech)
       ((? 136 b) . Irad)                 ((? 136 a) . Methushael)
       ((? 135 rel) great ? 136 rel)      ((? 135 c) . Methushael)
       ((? 135 b) . Irad)                 ((? 135 a) . Mehujael)
       ((? 134 rel) great ? 135 rel)      ((? 134 c) . Mehujael)
       ((? 134 b) . Irad)                 ((? 134 a) . Irad)
       ((? 133 rel) great ? 134 rel)      ((? 133 c) . Irad)
       ((? 133 b) . Irad)                 ((? 133 a) . Enoch)
       ((? 129 rel) great ? 133 rel)      ((? 129 c) . Enoch)
       ((? 129 b) . Irad)                 ((? 129 a) . Cain)
       ((? 128 rel) great ? 129 rel)      ((? 128 c) . Cain)
       ((? 128 b) . Irad)                 ((? 128 a) . Adam)
       ((? relationship) great ? 128 rel))

unify-result=(((? 148 boy) . Irad)               ((? 148 man) . Jabal)
              ((? 137 rel) . son)                ((? 138 boy) . Jabal)
              ((? 138 woman) . Ada)              ((? 137 c) ? 138 boy)
              ((? 138 man) . Lamech)             ((? 137 b) . Irad)
              ((? 137 a) . Lamech)               ((? 136 rel) great ? 137 rel)
              ((? 136 c) . Lamech)               ((? 136 b) . Irad)
              ((? 136 a) . Methushael)           ((? 135 rel) great ? 136 rel)
              ((? 135 c) . Methushael)           ((? 135 b) . Irad)
              ((? 135 a) . Mehujael)             ((? 134 rel) great ? 135 rel)
              ((? 134 c) . Mehujael)             ((? 134 b) . Irad)
              ((? 134 a) . Irad)                 ((? 133 rel) great ? 134 rel)
              ((? 133 c) . Irad)                 ((? 133 b) . Irad)
              ((? 133 a) . Enoch)                ((? 129 rel) great ? 133 rel)
              ((? 129 c) . Enoch)                ((? 129 b) . Irad)
              ((? 129 a) . Cain)                 ((? 128 rel) great ? 129 rel)
              ((? 128 c) . Cain)                 ((? 128 b) . Irad)
              ((? 128 a) . Adam)                 ((? relationship) great ? 128 rel))

debug:simple-query

debug:simple-query
apply-a-rule
rule=(rule ((grandson) (? grandpa) (? grandson))
           (and (son (? grandpa) (? dad)) (son (? dad) (? grandson))))
pattern=((? 137 rel) (? 137 c) (? 137 b))
frame=(((? 138 boy) . Jabal)              ((? 138 woman) . Ada)
       ((? 137 c) ? 138 boy)              ((? 138 man) . Lamech)
       ((? 137 b) . Irad)                 ((? 137 a) . Lamech)
       ((? 136 rel) great ? 137 rel)      ((? 136 c) . Lamech)
       ((? 136 b) . Irad)                 ((? 136 a) . Methushael)
       ((? 135 rel) great ? 136 rel)      ((? 135 c) . Methushael)
       ((? 135 b) . Irad)                 ((? 135 a) . Mehujael)
       ((? 134 rel) great ? 135 rel)      ((? 134 c) . Mehujael)
       ((? 134 b) . Irad)                 ((? 134 a) . Irad)
       ((? 133 rel) great ? 134 rel)      ((? 133 c) . Irad)
       ((? 133 b) . Irad)                 ((? 133 a) . Enoch)
       ((? 129 rel) great ? 133 rel)      ((? 129 c) . Enoch)
       ((? 129 b) . Irad)                 ((? 129 a) . Cain)
       ((? 128 rel) great ? 129 rel)      ((? 128 c) . Cain)
       ((? 128 b) . Irad)                 ((? 128 a) . Adam)
       ((? relationship) great ? 128 rel))

unify-result=(((? 149 grandson) . Irad)          ((? 149 grandpa) . Jabal)
              ((? 137 rel) grandson)             ((? 138 boy) . Jabal)
              ((? 138 woman) . Ada)              ((? 137 c) ? 138 boy)
              ((? 138 man) . Lamech)             ((? 137 b) . Irad)
              ((? 137 a) . Lamech)               ((? 136 rel) great ? 137 rel)
              ((? 136 c) . Lamech)               ((? 136 b) . Irad)
              ((? 136 a) . Methushael)           ((? 135 rel) great ? 136 rel)
              ((? 135 c) . Methushael)           ((? 135 b) . Irad)
              ((? 135 a) . Mehujael)             ((? 134 rel) great ? 135 rel)
              ((? 134 c) . Mehujael)             ((? 134 b) . Irad)
              ((? 134 a) . Irad)                 ((? 133 rel) great ? 134 rel)
              ((? 133 c) . Irad)                 ((? 133 b) . Irad)
              ((? 133 a) . Enoch)                ((? 129 rel) great ? 133 rel)
              ((? 129 c) . Enoch)                ((? 129 b) . Irad)
              ((? 129 a) . Cain)                 ((? 128 rel) great ? 129 rel)
              ((? 128 c) . Cain)                 ((? 128 b) . Irad)
              ((? 128 a) . Adam)                 ((? relationship) great ? 128 rel))

debug:simple-query
apply-a-rule
rule=(rule (son (? man) (? boy))
           (and (wife (? man) (? woman)) (son (? woman) (? boy))))
pattern=(son (? 149 grandpa) (? 149 dad))
frame=(((? 149 grandson) . Irad)          ((? 149 grandpa) . Jabal)
       ((? 137 rel) grandson)             ((? 138 boy) . Jabal)
       ((? 138 woman) . Ada)              ((? 137 c) ? 138 boy)
       ((? 138 man) . Lamech)             ((? 137 b) . Irad)
       ((? 137 a) . Lamech)               ((? 136 rel) great ? 137 rel)
       ((? 136 c) . Lamech)               ((? 136 b) . Irad)
       ((? 136 a) . Methushael)           ((? 135 rel) great ? 136 rel)
       ((? 135 c) . Methushael)           ((? 135 b) . Irad)
       ((? 135 a) . Mehujael)             ((? 134 rel) great ? 135 rel)
       ((? 134 c) . Mehujael)             ((? 134 b) . Irad)
       ((? 134 a) . Irad)                 ((? 133 rel) great ? 134 rel)
       ((? 133 c) . Irad)                 ((? 133 b) . Irad)
       ((? 133 a) . Enoch)                ((? 129 rel) great ? 133 rel)
       ((? 129 c) . Enoch)                ((? 129 b) . Irad)
       ((? 129 a) . Cain)                 ((? 128 rel) great ? 129 rel)
       ((? 128 c) . Cain)                 ((? 128 b) . Irad)
       ((? 128 a) . Adam)                 ((? relationship) great ? 128 rel))

unify-result=(((? 149 dad) ? 150 boy) ((? 150 man) . Jabal)
                                      ((? 149 grandson) . Irad)
                                      ((? 149 grandpa) . Jabal)
                                      ((? 137 rel) grandson)
                                      ((? 138 boy) . Jabal)
                                      ((? 138 woman) . Ada)
                                      ((? 137 c) ? 138 boy)
                                      ((? 138 man) . Lamech)
                                      ((? 137 b) . Irad)
                                      ((? 137 a) . Lamech)
                                      ((? 136 rel) great ? 137 rel)
                                      ((? 136 c) . Lamech)
                                      ((? 136 b) . Irad)
                                      ((? 136 a) . Methushael)
                                      ((? 135 rel) great ? 136 rel)
                                      ((? 135 c) . Methushael)
                                      ((? 135 b) . Irad)
                                      ((? 135 a) . Mehujael)
                                      ((? 134 rel) great ? 135 rel)
                                      ((? 134 c) . Mehujael)
                                      ((? 134 b) . Irad)
                                      ((? 134 a) . Irad)
                                      ((? 133 rel) great ? 134 rel)
                                      ((? 133 c) . Irad)
                                      ((? 133 b) . Irad)
                                      ((? 133 a) . Enoch)
                                      ((? 129 rel) great ? 133 rel)
                                      ((? 129 c) . Enoch)
                                      ((? 129 b) . Irad)
                                      ((? 129 a) . Cain)
                                      ((? 128 rel) great ? 129 rel)
                                      ((? 128 c) . Cain)
                                      ((? 128 b) . Irad)
                                      ((? 128 a) . Adam)
                                      ((? relationship) great ? 128 rel))

debug:simple-query

debug:simple-query

debug:simple-query
apply-a-rule
rule=(rule (list-ending-with-grandson ((? x) ? y))
           (list-ending-with-grandson (? y)))
pattern=((? 137 rel) (? 137 c) (? 137 b))
frame=(((? 138 boy) . Jabal)              ((? 138 woman) . Ada)
       ((? 137 c) ? 138 boy)              ((? 138 man) . Lamech)
       ((? 137 b) . Irad)                 ((? 137 a) . Lamech)
       ((? 136 rel) great ? 137 rel)      ((? 136 c) . Lamech)
       ((? 136 b) . Irad)                 ((? 136 a) . Methushael)
       ((? 135 rel) great ? 136 rel)      ((? 135 c) . Methushael)
       ((? 135 b) . Irad)                 ((? 135 a) . Mehujael)
       ((? 134 rel) great ? 135 rel)      ((? 134 c) . Mehujael)
       ((? 134 b) . Irad)                 ((? 134 a) . Irad)
       ((? 133 rel) great ? 134 rel)      ((? 133 c) . Irad)
       ((? 133 b) . Irad)                 ((? 133 a) . Enoch)
       ((? 129 rel) great ? 133 rel)      ((? 129 c) . Enoch)
       ((? 129 b) . Irad)                 ((? 129 a) . Cain)
       ((? 128 rel) great ? 129 rel)      ((? 128 c) . Cain)
       ((? 128 b) . Irad)                 ((? 128 a) . Adam)
       ((? relationship) great ? 128 rel))

unify-result=failed
apply-a-rule
rule=(rule (list-ending-with-grandson (grandson)))
pattern=((? 137 rel) (? 137 c) (? 137 b))
frame=(((? 138 boy) . Jabal)              ((? 138 woman) . Ada)
       ((? 137 c) ? 138 boy)              ((? 138 man) . Lamech)
       ((? 137 b) . Irad)                 ((? 137 a) . Lamech)
       ((? 136 rel) great ? 137 rel)      ((? 136 c) . Lamech)
       ((? 136 b) . Irad)                 ((? 136 a) . Methushael)
       ((? 135 rel) great ? 136 rel)      ((? 135 c) . Methushael)
       ((? 135 b) . Irad)                 ((? 135 a) . Mehujael)
       ((? 134 rel) great ? 135 rel)      ((? 134 c) . Mehujael)
       ((? 134 b) . Irad)                 ((? 134 a) . Irad)
       ((? 133 rel) great ? 134 rel)      ((? 133 c) . Irad)
       ((? 133 b) . Irad)                 ((? 133 a) . Enoch)
       ((? 129 rel) great ? 133 rel)      ((? 129 c) . Enoch)
       ((? 129 b) . Irad)                 ((? 129 a) . Cain)
       ((? 128 rel) great ? 129 rel)      ((? 128 c) . Cain)
       ((? 128 b) . Irad)                 ((? 128 a) . Adam)
       ((? relationship) great ? 128 rel))

unify-result=failed
apply-a-rule
rule=(rule (son (? man) (? boy))
           (and (wife (? man) (? woman)) (son (? woman) (? boy))))
pattern=(son (? 138 woman) (? 138 boy))
frame=(((? 138 woman) . Ada)              ((? 137 c) ? 138 boy)
       ((? 138 man) . Lamech)             ((? 137 b) . Irad)
       ((? 137 a) . Lamech)               ((? 136 rel) great ? 137 rel)
       ((? 136 c) . Lamech)               ((? 136 b) . Irad)
       ((? 136 a) . Methushael)           ((? 135 rel) great ? 136 rel)
       ((? 135 c) . Methushael)           ((? 135 b) . Irad)
       ((? 135 a) . Mehujael)             ((? 134 rel) great ? 135 rel)
       ((? 134 c) . Mehujael)             ((? 134 b) . Irad)
       ((? 134 a) . Irad)                 ((? 133 rel) great ? 134 rel)
       ((? 133 c) . Irad)                 ((? 133 b) . Irad)
       ((? 133 a) . Enoch)                ((? 129 rel) great ? 133 rel)
       ((? 129 c) . Enoch)                ((? 129 b) . Irad)
       ((? 129 a) . Cain)                 ((? 128 rel) great ? 129 rel)
       ((? 128 c) . Cain)                 ((? 128 b) . Irad)
       ((? 128 a) . Adam)                 ((? relationship) great ? 128 rel))

unify-result=(((? 138 boy) ? 153 boy) ((? 153 man) . Ada)
                                      ((? 138 woman) . Ada)
                                      ((? 137 c) ? 138 boy)
                                      ((? 138 man) . Lamech)
                                      ((? 137 b) . Irad)
                                      ((? 137 a) . Lamech)
                                      ((? 136 rel) great ? 137 rel)
                                      ((? 136 c) . Lamech)
                                      ((? 136 b) . Irad)
                                      ((? 136 a) . Methushael)
                                      ((? 135 rel) great ? 136 rel)
                                      ((? 135 c) . Methushael)
                                      ((? 135 b) . Irad)
                                      ((? 135 a) . Mehujael)
                                      ((? 134 rel) great ? 135 rel)
                                      ((? 134 c) . Mehujael)
                                      ((? 134 b) . Irad)
                                      ((? 134 a) . Irad)
                                      ((? 133 rel) great ? 134 rel)
                                      ((? 133 c) . Irad)
                                      ((? 133 b) . Irad)
                                      ((? 133 a) . Enoch)
                                      ((? 129 rel) great ? 133 rel)
                                      ((? 129 c) . Enoch)
                                      ((? 129 b) . Irad)
                                      ((? 129 a) . Cain)
                                      ((? 128 rel) great ? 129 rel)
                                      ((? 128 c) . Cain)
                                      ((? 128 b) . Irad)
                                      ((? 128 a) . Adam)
                                      ((? relationship) great ? 128 rel))

debug:simple-query

debug:simple-query

debug:simple-query
apply-a-rule
rule=(rule (son (? man) (? boy))
           (and (wife (? man) (? woman)) (son (? woman) (? boy))))
pattern=((? 136 rel) (? 136 c) (? 136 b))
frame=(((? 136 c) . Lamech)               ((? 136 b) . Irad)
       ((? 136 a) . Methushael)           ((? 135 rel) great ? 136 rel)
       ((? 135 c) . Methushael)           ((? 135 b) . Irad)
       ((? 135 a) . Mehujael)             ((? 134 rel) great ? 135 rel)
       ((? 134 c) . Mehujael)             ((? 134 b) . Irad)
       ((? 134 a) . Irad)                 ((? 133 rel) great ? 134 rel)
       ((? 133 c) . Irad)                 ((? 133 b) . Irad)
       ((? 133 a) . Enoch)                ((? 129 rel) great ? 133 rel)
       ((? 129 c) . Enoch)                ((? 129 b) . Irad)
       ((? 129 a) . Cain)                 ((? 128 rel) great ? 129 rel)
       ((? 128 c) . Cain)                 ((? 128 b) . Irad)
       ((? 128 a) . Adam)                 ((? relationship) great ? 128 rel))

unify-result=(((? 154 boy) . Irad)               ((? 154 man) . Lamech)
              ((? 136 rel) . son)                ((? 136 c) . Lamech)
              ((? 136 b) . Irad)                 ((? 136 a) . Methushael)
              ((? 135 rel) great ? 136 rel)      ((? 135 c) . Methushael)
              ((? 135 b) . Irad)                 ((? 135 a) . Mehujael)
              ((? 134 rel) great ? 135 rel)      ((? 134 c) . Mehujael)
              ((? 134 b) . Irad)                 ((? 134 a) . Irad)
              ((? 133 rel) great ? 134 rel)      ((? 133 c) . Irad)
              ((? 133 b) . Irad)                 ((? 133 a) . Enoch)
              ((? 129 rel) great ? 133 rel)      ((? 129 c) . Enoch)
              ((? 129 b) . Irad)                 ((? 129 a) . Cain)
              ((? 128 rel) great ? 129 rel)      ((? 128 c) . Cain)
              ((? 128 b) . Irad)                 ((? 128 a) . Adam)
              ((? relationship) great ? 128 rel))

debug:simple-query

debug:simple-query
apply-a-rule
rule=(rule (son (? man) (? boy))
           (and (wife (? man) (? woman)) (son (? woman) (? boy))))
pattern=(son (? 154 woman) (? 154 boy))
frame=(((? 154 woman) . Ada)              ((? 154 boy) . Irad)
       ((? 154 man) . Lamech)             ((? 136 rel) . son)
       ((? 136 c) . Lamech)               ((? 136 b) . Irad)
       ((? 136 a) . Methushael)           ((? 135 rel) great ? 136 rel)
       ((? 135 c) . Methushael)           ((? 135 b) . Irad)
       ((? 135 a) . Mehujael)             ((? 134 rel) great ? 135 rel)
       ((? 134 c) . Mehujael)             ((? 134 b) . Irad)
       ((? 134 a) . Irad)                 ((? 133 rel) great ? 134 rel)
       ((? 133 c) . Irad)                 ((? 133 b) . Irad)
       ((? 133 a) . Enoch)                ((? 129 rel) great ? 133 rel)
       ((? 129 c) . Enoch)                ((? 129 b) . Irad)
       ((? 129 a) . Cain)                 ((? 128 rel) great ? 129 rel)
       ((? 128 c) . Cain)                 ((? 128 b) . Irad)
       ((? 128 a) . Adam)                 ((? relationship) great ? 128 rel))

unify-result=(((? 155 boy) . Irad)               ((? 155 man) . Ada)
              ((? 154 woman) . Ada)              ((? 154 boy) . Irad)
              ((? 154 man) . Lamech)             ((? 136 rel) . son)
              ((? 136 c) . Lamech)               ((? 136 b) . Irad)
              ((? 136 a) . Methushael)           ((? 135 rel) great ? 136 rel)
              ((? 135 c) . Methushael)           ((? 135 b) . Irad)
              ((? 135 a) . Mehujael)             ((? 134 rel) great ? 135 rel)
              ((? 134 c) . Mehujael)             ((? 134 b) . Irad)
              ((? 134 a) . Irad)                 ((? 133 rel) great ? 134 rel)
              ((? 133 c) . Irad)                 ((? 133 b) . Irad)
              ((? 133 a) . Enoch)                ((? 129 rel) great ? 133 rel)
              ((? 129 c) . Enoch)                ((? 129 b) . Irad)
              ((? 129 a) . Cain)                 ((? 128 rel) great ? 129 rel)
              ((? 128 c) . Cain)                 ((? 128 b) . Irad)
              ((? 128 a) . Adam)                 ((? relationship) great ? 128 rel))

debug:simple-query

debug:simple-query
apply-a-rule
rule=(rule ((grandson) (? grandpa) (? grandson))
           (and (son (? grandpa) (? dad)) (son (? dad) (? grandson))))
pattern=((? 136 rel) (? 136 c) (? 136 b))
frame=(((? 136 c) . Lamech)               ((? 136 b) . Irad)
       ((? 136 a) . Methushael)           ((? 135 rel) great ? 136 rel)
       ((? 135 c) . Methushael)           ((? 135 b) . Irad)
       ((? 135 a) . Mehujael)             ((? 134 rel) great ? 135 rel)
       ((? 134 c) . Mehujael)             ((? 134 b) . Irad)
       ((? 134 a) . Irad)                 ((? 133 rel) great ? 134 rel)
       ((? 133 c) . Irad)                 ((? 133 b) . Irad)
       ((? 133 a) . Enoch)                ((? 129 rel) great ? 133 rel)
       ((? 129 c) . Enoch)                ((? 129 b) . Irad)
       ((? 129 a) . Cain)                 ((? 128 rel) great ? 129 rel)
       ((? 128 c) . Cain)                 ((? 128 b) . Irad)
       ((? 128 a) . Adam)                 ((? relationship) great ? 128 rel))

unify-result=(((? 156 grandson) . Irad)          ((? 156 grandpa) . Lamech)
              ((? 136 rel) grandson)             ((? 136 c) . Lamech)
              ((? 136 b) . Irad)                 ((? 136 a) . Methushael)
              ((? 135 rel) great ? 136 rel)      ((? 135 c) . Methushael)
              ((? 135 b) . Irad)                 ((? 135 a) . Mehujael)
              ((? 134 rel) great ? 135 rel)      ((? 134 c) . Mehujael)
              ((? 134 b) . Irad)                 ((? 134 a) . Irad)
              ((? 133 rel) great ? 134 rel)      ((? 133 c) . Irad)
              ((? 133 b) . Irad)                 ((? 133 a) . Enoch)
              ((? 129 rel) great ? 133 rel)      ((? 129 c) . Enoch)
              ((? 129 b) . Irad)                 ((? 129 a) . Cain)
              ((? 128 rel) great ? 129 rel)      ((? 128 c) . Cain)
              ((? 128 b) . Irad)                 ((? 128 a) . Adam)
              ((? relationship) great ? 128 rel))

debug:simple-query
apply-a-rule
rule=(rule (son (? man) (? boy))
           (and (wife (? man) (? woman)) (son (? woman) (? boy))))
pattern=(son (? 156 grandpa) (? 156 dad))
frame=(((? 156 grandson) . Irad)          ((? 156 grandpa) . Lamech)
       ((? 136 rel) grandson)             ((? 136 c) . Lamech)
       ((? 136 b) . Irad)                 ((? 136 a) . Methushael)
       ((? 135 rel) great ? 136 rel)      ((? 135 c) . Methushael)
       ((? 135 b) . Irad)                 ((? 135 a) . Mehujael)
       ((? 134 rel) great ? 135 rel)      ((? 134 c) . Mehujael)
       ((? 134 b) . Irad)                 ((? 134 a) . Irad)
       ((? 133 rel) great ? 134 rel)      ((? 133 c) . Irad)
       ((? 133 b) . Irad)                 ((? 133 a) . Enoch)
       ((? 129 rel) great ? 133 rel)      ((? 129 c) . Enoch)
       ((? 129 b) . Irad)                 ((? 129 a) . Cain)
       ((? 128 rel) great ? 129 rel)      ((? 128 c) . Cain)
       ((? 128 b) . Irad)                 ((? 128 a) . Adam)
       ((? relationship) great ? 128 rel))

unify-result=(((? 156 dad) ? 157 boy) ((? 157 man) . Lamech)
                                      ((? 156 grandson) . Irad)
                                      ((? 156 grandpa) . Lamech)
                                      ((? 136 rel) grandson)
                                      ((? 136 c) . Lamech)
                                      ((? 136 b) . Irad)
                                      ((? 136 a) . Methushael)
                                      ((? 135 rel) great ? 136 rel)
                                      ((? 135 c) . Methushael)
                                      ((? 135 b) . Irad)
                                      ((? 135 a) . Mehujael)
                                      ((? 134 rel) great ? 135 rel)
                                      ((? 134 c) . Mehujael)
                                      ((? 134 b) . Irad)
                                      ((? 134 a) . Irad)
                                      ((? 133 rel) great ? 134 rel)
                                      ((? 133 c) . Irad)
                                      ((? 133 b) . Irad)
                                      ((? 133 a) . Enoch)
                                      ((? 129 rel) great ? 133 rel)
                                      ((? 129 c) . Enoch)
                                      ((? 129 b) . Irad)
                                      ((? 129 a) . Cain)
                                      ((? 128 rel) great ? 129 rel)
                                      ((? 128 c) . Cain)
                                      ((? 128 b) . Irad)
                                      ((? 128 a) . Adam)
                                      ((? relationship) great ? 128 rel))

debug:simple-query

debug:simple-query

debug:simple-query
apply-a-rule
rule=(rule (son (? man) (? boy))
           (and (wife (? man) (? woman)) (son (? woman) (? boy))))
pattern=(son (? 156 dad) (? 156 grandson))
frame=(((? 157 boy) . Jubal)              ((? 157 woman) . Ada)
       ((? 156 dad) ? 157 boy)            ((? 157 man) . Lamech)
       ((? 156 grandson) . Irad)          ((? 156 grandpa) . Lamech)
       ((? 136 rel) grandson)             ((? 136 c) . Lamech)
       ((? 136 b) . Irad)                 ((? 136 a) . Methushael)
       ((? 135 rel) great ? 136 rel)      ((? 135 c) . Methushael)
       ((? 135 b) . Irad)                 ((? 135 a) . Mehujael)
       ((? 134 rel) great ? 135 rel)      ((? 134 c) . Mehujael)
       ((? 134 b) . Irad)                 ((? 134 a) . Irad)
       ((? 133 rel) great ? 134 rel)      ((? 133 c) . Irad)
       ((? 133 b) . Irad)                 ((? 133 a) . Enoch)
       ((? 129 rel) great ? 133 rel)      ((? 129 c) . Enoch)
       ((? 129 b) . Irad)                 ((? 129 a) . Cain)
       ((? 128 rel) great ? 129 rel)      ((? 128 c) . Cain)
       ((? 128 b) . Irad)                 ((? 128 a) . Adam)
       ((? relationship) great ? 128 rel))

unify-result=(((? 158 boy) . Irad)               ((? 158 man) . Jubal)
              ((? 157 boy) . Jubal)              ((? 157 woman) . Ada)
              ((? 156 dad) ? 157 boy)            ((? 157 man) . Lamech)
              ((? 156 grandson) . Irad)          ((? 156 grandpa) . Lamech)
              ((? 136 rel) grandson)             ((? 136 c) . Lamech)
              ((? 136 b) . Irad)                 ((? 136 a) . Methushael)
              ((? 135 rel) great ? 136 rel)      ((? 135 c) . Methushael)
              ((? 135 b) . Irad)                 ((? 135 a) . Mehujael)
              ((? 134 rel) great ? 135 rel)      ((? 134 c) . Mehujael)
              ((? 134 b) . Irad)                 ((? 134 a) . Irad)
              ((? 133 rel) great ? 134 rel)      ((? 133 c) . Irad)
              ((? 133 b) . Irad)                 ((? 133 a) . Enoch)
              ((? 129 rel) great ? 133 rel)      ((? 129 c) . Enoch)
              ((? 129 b) . Irad)                 ((? 129 a) . Cain)
              ((? 128 rel) great ? 129 rel)      ((? 128 c) . Cain)
              ((? 128 b) . Irad)                 ((? 128 a) . Adam)
              ((? relationship) great ? 128 rel))

debug:simple-query

debug:simple-query
apply-a-rule
rule=(rule (son (? man) (? boy))
           (and (wife (? man) (? woman)) (son (? woman) (? boy))))
pattern=(son (? 156 dad) (? 156 grandson))
frame=(((? 157 boy) . Jabal)              ((? 157 woman) . Ada)
       ((? 156 dad) ? 157 boy)            ((? 157 man) . Lamech)
       ((? 156 grandson) . Irad)          ((? 156 grandpa) . Lamech)
       ((? 136 rel) grandson)             ((? 136 c) . Lamech)
       ((? 136 b) . Irad)                 ((? 136 a) . Methushael)
       ((? 135 rel) great ? 136 rel)      ((? 135 c) . Methushael)
       ((? 135 b) . Irad)                 ((? 135 a) . Mehujael)
       ((? 134 rel) great ? 135 rel)      ((? 134 c) . Mehujael)
       ((? 134 b) . Irad)                 ((? 134 a) . Irad)
       ((? 133 rel) great ? 134 rel)      ((? 133 c) . Irad)
       ((? 133 b) . Irad)                 ((? 133 a) . Enoch)
       ((? 129 rel) great ? 133 rel)      ((? 129 c) . Enoch)
       ((? 129 b) . Irad)                 ((? 129 a) . Cain)
       ((? 128 rel) great ? 129 rel)      ((? 128 c) . Cain)
       ((? 128 b) . Irad)                 ((? 128 a) . Adam)
       ((? relationship) great ? 128 rel))

unify-result=(((? 159 boy) . Irad)               ((? 159 man) . Jabal)
              ((? 157 boy) . Jabal)              ((? 157 woman) . Ada)
              ((? 156 dad) ? 157 boy)            ((? 157 man) . Lamech)
              ((? 156 grandson) . Irad)          ((? 156 grandpa) . Lamech)
              ((? 136 rel) grandson)             ((? 136 c) . Lamech)
              ((? 136 b) . Irad)                 ((? 136 a) . Methushael)
              ((? 135 rel) great ? 136 rel)      ((? 135 c) . Methushael)
              ((? 135 b) . Irad)                 ((? 135 a) . Mehujael)
              ((? 134 rel) great ? 135 rel)      ((? 134 c) . Mehujael)
              ((? 134 b) . Irad)                 ((? 134 a) . Irad)
              ((? 133 rel) great ? 134 rel)      ((? 133 c) . Irad)
              ((? 133 b) . Irad)                 ((? 133 a) . Enoch)
              ((? 129 rel) great ? 133 rel)      ((? 129 c) . Enoch)
              ((? 129 b) . Irad)                 ((? 129 a) . Cain)
              ((? 128 rel) great ? 129 rel)      ((? 128 c) . Cain)
              ((? 128 b) . Irad)                 ((? 128 a) . Adam)
              ((? relationship) great ? 128 rel))

debug:simple-query

debug:simple-query
apply-a-rule
rule=(rule (son (? man) (? boy))
           (and (wife (? man) (? woman)) (son (? woman) (? boy))))
pattern=(son (? 157 woman) (? 157 boy))
frame=(((? 157 woman) . Ada)              ((? 156 dad) ? 157 boy)
       ((? 157 man) . Lamech)             ((? 156 grandson) . Irad)
       ((? 156 grandpa) . Lamech)         ((? 136 rel) grandson)
       ((? 136 c) . Lamech)               ((? 136 b) . Irad)
       ((? 136 a) . Methushael)           ((? 135 rel) great ? 136 rel)
       ((? 135 c) . Methushael)           ((? 135 b) . Irad)
       ((? 135 a) . Mehujael)             ((? 134 rel) great ? 135 rel)
       ((? 134 c) . Mehujael)             ((? 134 b) . Irad)
       ((? 134 a) . Irad)                 ((? 133 rel) great ? 134 rel)
       ((? 133 c) . Irad)                 ((? 133 b) . Irad)
       ((? 133 a) . Enoch)                ((? 129 rel) great ? 133 rel)
       ((? 129 c) . Enoch)                ((? 129 b) . Irad)
       ((? 129 a) . Cain)                 ((? 128 rel) great ? 129 rel)
       ((? 128 c) . Cain)                 ((? 128 b) . Irad)
       ((? 128 a) . Adam)                 ((? relationship) great ? 128 rel))

unify-result=(((? 157 boy) ? 160 boy) ((? 160 man) . Ada)
                                      ((? 157 woman) . Ada)
                                      ((? 156 dad) ? 157 boy)
                                      ((? 157 man) . Lamech)
                                      ((? 156 grandson) . Irad)
                                      ((? 156 grandpa) . Lamech)
                                      ((? 136 rel) grandson)
                                      ((? 136 c) . Lamech)
                                      ((? 136 b) . Irad)
                                      ((? 136 a) . Methushael)
                                      ((? 135 rel) great ? 136 rel)
                                      ((? 135 c) . Methushael)
                                      ((? 135 b) . Irad)
                                      ((? 135 a) . Mehujael)
                                      ((? 134 rel) great ? 135 rel)
                                      ((? 134 c) . Mehujael)
                                      ((? 134 b) . Irad)
                                      ((? 134 a) . Irad)
                                      ((? 133 rel) great ? 134 rel)
                                      ((? 133 c) . Irad)
                                      ((? 133 b) . Irad)
                                      ((? 133 a) . Enoch)
                                      ((? 129 rel) great ? 133 rel)
                                      ((? 129 c) . Enoch)
                                      ((? 129 b) . Irad)
                                      ((? 129 a) . Cain)
                                      ((? 128 rel) great ? 129 rel)
                                      ((? 128 c) . Cain)
                                      ((? 128 b) . Irad)
                                      ((? 128 a) . Adam)
                                      ((? relationship) great ? 128 rel))

debug:simple-query

debug:simple-query
apply-a-rule
rule=(rule (list-ending-with-grandson ((? x) ? y))
           (list-ending-with-grandson (? y)))
pattern=((? 136 rel) (? 136 c) (? 136 b))
frame=(((? 136 c) . Lamech)               ((? 136 b) . Irad)
       ((? 136 a) . Methushael)           ((? 135 rel) great ? 136 rel)
       ((? 135 c) . Methushael)           ((? 135 b) . Irad)
       ((? 135 a) . Mehujael)             ((? 134 rel) great ? 135 rel)
       ((? 134 c) . Mehujael)             ((? 134 b) . Irad)
       ((? 134 a) . Irad)                 ((? 133 rel) great ? 134 rel)
       ((? 133 c) . Irad)                 ((? 133 b) . Irad)
       ((? 133 a) . Enoch)                ((? 129 rel) great ? 133 rel)
       ((? 129 c) . Enoch)                ((? 129 b) . Irad)
       ((? 129 a) . Cain)                 ((? 128 rel) great ? 129 rel)
       ((? 128 c) . Cain)                 ((? 128 b) . Irad)
       ((? 128 a) . Adam)                 ((? relationship) great ? 128 rel))

unify-result=failed
apply-a-rule
rule=(rule (list-ending-with-grandson (grandson)))
pattern=((? 136 rel) (? 136 c) (? 136 b))
frame=(((? 136 c) . Lamech)               ((? 136 b) . Irad)
       ((? 136 a) . Methushael)           ((? 135 rel) great ? 136 rel)
       ((? 135 c) . Methushael)           ((? 135 b) . Irad)
       ((? 135 a) . Mehujael)             ((? 134 rel) great ? 135 rel)
       ((? 134 c) . Mehujael)             ((? 134 b) . Irad)
       ((? 134 a) . Irad)                 ((? 133 rel) great ? 134 rel)
       ((? 133 c) . Irad)                 ((? 133 b) . Irad)
       ((? 133 a) . Enoch)                ((? 129 rel) great ? 133 rel)
       ((? 129 c) . Enoch)                ((? 129 b) . Irad)
       ((? 129 a) . Cain)                 ((? 128 rel) great ? 129 rel)
       ((? 128 c) . Cain)                 ((? 128 b) . Irad)
       ((? 128 a) . Adam)                 ((? relationship) great ? 128 rel))

unify-result=failed
apply-a-rule
rule=(rule (son (? man) (? boy))
           (and (wife (? man) (? woman)) (son (? woman) (? boy))))
pattern=(son (? 136 a) (? 136 c))
frame=(((? 136 b) . Irad)                 ((? 136 a) . Methushael)
       ((? 135 rel) great ? 136 rel)      ((? 135 c) . Methushael)
       ((? 135 b) . Irad)                 ((? 135 a) . Mehujael)
       ((? 134 rel) great ? 135 rel)      ((? 134 c) . Mehujael)
       ((? 134 b) . Irad)                 ((? 134 a) . Irad)
       ((? 133 rel) great ? 134 rel)      ((? 133 c) . Irad)
       ((? 133 b) . Irad)                 ((? 133 a) . Enoch)
       ((? 129 rel) great ? 133 rel)      ((? 129 c) . Enoch)
       ((? 129 b) . Irad)                 ((? 129 a) . Cain)
       ((? 128 rel) great ? 129 rel)      ((? 128 c) . Cain)
       ((? 128 b) . Irad)                 ((? 128 a) . Adam)
       ((? relationship) great ? 128 rel))

unify-result=(((? 136 c) ? 163 boy) ((? 163 man) . Methushael)
                                    ((? 136 b) . Irad)
                                    ((? 136 a) . Methushael)
                                    ((? 135 rel) great ? 136 rel)
                                    ((? 135 c) . Methushael)
                                    ((? 135 b) . Irad)
                                    ((? 135 a) . Mehujael)
                                    ((? 134 rel) great ? 135 rel)
                                    ((? 134 c) . Mehujael)
                                    ((? 134 b) . Irad)
                                    ((? 134 a) . Irad)
                                    ((? 133 rel) great ? 134 rel)
                                    ((? 133 c) . Irad)
                                    ((? 133 b) . Irad)
                                    ((? 133 a) . Enoch)
                                    ((? 129 rel) great ? 133 rel)
                                    ((? 129 c) . Enoch)
                                    ((? 129 b) . Irad)
                                    ((? 129 a) . Cain)
                                    ((? 128 rel) great ? 129 rel)
                                    ((? 128 c) . Cain)
                                    ((? 128 b) . Irad)
                                    ((? 128 a) . Adam)
                                    ((? relationship) great ? 128 rel))

debug:simple-query

debug:simple-query

debug:simple-query
apply-a-rule
rule=(rule (son (? man) (? boy))
           (and (wife (? man) (? woman)) (son (? woman) (? boy))))
pattern=((? 135 rel) (? 135 c) (? 135 b))
frame=(((? 135 c) . Methushael)           ((? 135 b) . Irad)
       ((? 135 a) . Mehujael)             ((? 134 rel) great ? 135 rel)
       ((? 134 c) . Mehujael)             ((? 134 b) . Irad)
       ((? 134 a) . Irad)                 ((? 133 rel) great ? 134 rel)
       ((? 133 c) . Irad)                 ((? 133 b) . Irad)
       ((? 133 a) . Enoch)                ((? 129 rel) great ? 133 rel)
       ((? 129 c) . Enoch)                ((? 129 b) . Irad)
       ((? 129 a) . Cain)                 ((? 128 rel) great ? 129 rel)
       ((? 128 c) . Cain)                 ((? 128 b) . Irad)
       ((? 128 a) . Adam)                 ((? relationship) great ? 128 rel))

unify-result=(((? 164 boy) . Irad)               ((? 164 man) . Methushael)
              ((? 135 rel) . son)                ((? 135 c) . Methushael)
              ((? 135 b) . Irad)                 ((? 135 a) . Mehujael)
              ((? 134 rel) great ? 135 rel)      ((? 134 c) . Mehujael)
              ((? 134 b) . Irad)                 ((? 134 a) . Irad)
              ((? 133 rel) great ? 134 rel)      ((? 133 c) . Irad)
              ((? 133 b) . Irad)                 ((? 133 a) . Enoch)
              ((? 129 rel) great ? 133 rel)      ((? 129 c) . Enoch)
              ((? 129 b) . Irad)                 ((? 129 a) . Cain)
              ((? 128 rel) great ? 129 rel)      ((? 128 c) . Cain)
              ((? 128 b) . Irad)                 ((? 128 a) . Adam)
              ((? relationship) great ? 128 rel))

debug:simple-query

debug:simple-query
apply-a-rule
rule=(rule ((grandson) (? grandpa) (? grandson))
           (and (son (? grandpa) (? dad)) (son (? dad) (? grandson))))
pattern=((? 135 rel) (? 135 c) (? 135 b))
frame=(((? 135 c) . Methushael)           ((? 135 b) . Irad)
       ((? 135 a) . Mehujael)             ((? 134 rel) great ? 135 rel)
       ((? 134 c) . Mehujael)             ((? 134 b) . Irad)
       ((? 134 a) . Irad)                 ((? 133 rel) great ? 134 rel)
       ((? 133 c) . Irad)                 ((? 133 b) . Irad)
       ((? 133 a) . Enoch)                ((? 129 rel) great ? 133 rel)
       ((? 129 c) . Enoch)                ((? 129 b) . Irad)
       ((? 129 a) . Cain)                 ((? 128 rel) great ? 129 rel)
       ((? 128 c) . Cain)                 ((? 128 b) . Irad)
       ((? 128 a) . Adam)                 ((? relationship) great ? 128 rel))

unify-result=(((? 165 grandson) . Irad)          ((? 165 grandpa) . Methushael)
              ((? 135 rel) grandson)             ((? 135 c) . Methushael)
              ((? 135 b) . Irad)                 ((? 135 a) . Mehujael)
              ((? 134 rel) great ? 135 rel)      ((? 134 c) . Mehujael)
              ((? 134 b) . Irad)                 ((? 134 a) . Irad)
              ((? 133 rel) great ? 134 rel)      ((? 133 c) . Irad)
              ((? 133 b) . Irad)                 ((? 133 a) . Enoch)
              ((? 129 rel) great ? 133 rel)      ((? 129 c) . Enoch)
              ((? 129 b) . Irad)                 ((? 129 a) . Cain)
              ((? 128 rel) great ? 129 rel)      ((? 128 c) . Cain)
              ((? 128 b) . Irad)                 ((? 128 a) . Adam)
              ((? relationship) great ? 128 rel))

debug:simple-query

debug:simple-query
apply-a-rule
rule=(rule (son (? man) (? boy))
           (and (wife (? man) (? woman)) (son (? woman) (? boy))))
pattern=(son (? 165 dad) (? 165 grandson))
frame=(((? 165 dad) . Lamech)             ((? 165 grandson) . Irad)
       ((? 165 grandpa) . Methushael)     ((? 135 rel) grandson)
       ((? 135 c) . Methushael)           ((? 135 b) . Irad)
       ((? 135 a) . Mehujael)             ((? 134 rel) great ? 135 rel)
       ((? 134 c) . Mehujael)             ((? 134 b) . Irad)
       ((? 134 a) . Irad)                 ((? 133 rel) great ? 134 rel)
       ((? 133 c) . Irad)                 ((? 133 b) . Irad)
       ((? 133 a) . Enoch)                ((? 129 rel) great ? 133 rel)
       ((? 129 c) . Enoch)                ((? 129 b) . Irad)
       ((? 129 a) . Cain)                 ((? 128 rel) great ? 129 rel)
       ((? 128 c) . Cain)                 ((? 128 b) . Irad)
       ((? 128 a) . Adam)                 ((? relationship) great ? 128 rel))

unify-result=(((? 166 boy) . Irad)               ((? 166 man) . Lamech)
              ((? 165 dad) . Lamech)             ((? 165 grandson) . Irad)
              ((? 165 grandpa) . Methushael)     ((? 135 rel) grandson)
              ((? 135 c) . Methushael)           ((? 135 b) . Irad)
              ((? 135 a) . Mehujael)             ((? 134 rel) great ? 135 rel)
              ((? 134 c) . Mehujael)             ((? 134 b) . Irad)
              ((? 134 a) . Irad)                 ((? 133 rel) great ? 134 rel)
              ((? 133 c) . Irad)                 ((? 133 b) . Irad)
              ((? 133 a) . Enoch)                ((? 129 rel) great ? 133 rel)
              ((? 129 c) . Enoch)                ((? 129 b) . Irad)
              ((? 129 a) . Cain)                 ((? 128 rel) great ? 129 rel)
              ((? 128 c) . Cain)                 ((? 128 b) . Irad)
              ((? 128 a) . Adam)                 ((? relationship) great ? 128 rel))

debug:simple-query

debug:simple-query
apply-a-rule
rule=(rule (son (? man) (? boy))
           (and (wife (? man) (? woman)) (son (? woman) (? boy))))
pattern=(son (? 166 woman) (? 166 boy))
frame=(((? 166 woman) . Ada)              ((? 166 boy) . Irad)
       ((? 166 man) . Lamech)             ((? 165 dad) . Lamech)
       ((? 165 grandson) . Irad)          ((? 165 grandpa) . Methushael)
       ((? 135 rel) grandson)             ((? 135 c) . Methushael)
       ((? 135 b) . Irad)                 ((? 135 a) . Mehujael)
       ((? 134 rel) great ? 135 rel)      ((? 134 c) . Mehujael)
       ((? 134 b) . Irad)                 ((? 134 a) . Irad)
       ((? 133 rel) great ? 134 rel)      ((? 133 c) . Irad)
       ((? 133 b) . Irad)                 ((? 133 a) . Enoch)
       ((? 129 rel) great ? 133 rel)      ((? 129 c) . Enoch)
       ((? 129 b) . Irad)                 ((? 129 a) . Cain)
       ((? 128 rel) great ? 129 rel)      ((? 128 c) . Cain)
       ((? 128 b) . Irad)                 ((? 128 a) . Adam)
       ((? relationship) great ? 128 rel))

unify-result=(((? 167 boy) . Irad)               ((? 167 man) . Ada)
              ((? 166 woman) . Ada)              ((? 166 boy) . Irad)
              ((? 166 man) . Lamech)             ((? 165 dad) . Lamech)
              ((? 165 grandson) . Irad)          ((? 165 grandpa) . Methushael)
              ((? 135 rel) grandson)             ((? 135 c) . Methushael)
              ((? 135 b) . Irad)                 ((? 135 a) . Mehujael)
              ((? 134 rel) great ? 135 rel)      ((? 134 c) . Mehujael)
              ((? 134 b) . Irad)                 ((? 134 a) . Irad)
              ((? 133 rel) great ? 134 rel)      ((? 133 c) . Irad)
              ((? 133 b) . Irad)                 ((? 133 a) . Enoch)
              ((? 129 rel) great ? 133 rel)      ((? 129 c) . Enoch)
              ((? 129 b) . Irad)                 ((? 129 a) . Cain)
              ((? 128 rel) great ? 129 rel)      ((? 128 c) . Cain)
              ((? 128 b) . Irad)                 ((? 128 a) . Adam)
              ((? relationship) great ? 128 rel))

debug:simple-query

debug:simple-query
apply-a-rule
rule=(rule (son (? man) (? boy))
           (and (wife (? man) (? woman)) (son (? woman) (? boy))))
pattern=(son (? 165 grandpa) (? 165 dad))
frame=(((? 165 grandson) . Irad)          ((? 165 grandpa) . Methushael)
       ((? 135 rel) grandson)             ((? 135 c) . Methushael)
       ((? 135 b) . Irad)                 ((? 135 a) . Mehujael)
       ((? 134 rel) great ? 135 rel)      ((? 134 c) . Mehujael)
       ((? 134 b) . Irad)                 ((? 134 a) . Irad)
       ((? 133 rel) great ? 134 rel)      ((? 133 c) . Irad)
       ((? 133 b) . Irad)                 ((? 133 a) . Enoch)
       ((? 129 rel) great ? 133 rel)      ((? 129 c) . Enoch)
       ((? 129 b) . Irad)                 ((? 129 a) . Cain)
       ((? 128 rel) great ? 129 rel)      ((? 128 c) . Cain)
       ((? 128 b) . Irad)                 ((? 128 a) . Adam)
       ((? relationship) great ? 128 rel))

unify-result=(((? 165 dad) ? 168 boy) ((? 168 man) . Methushael)
                                      ((? 165 grandson) . Irad)
                                      ((? 165 grandpa) . Methushael)
                                      ((? 135 rel) grandson)
                                      ((? 135 c) . Methushael)
                                      ((? 135 b) . Irad)
                                      ((? 135 a) . Mehujael)
                                      ((? 134 rel) great ? 135 rel)
                                      ((? 134 c) . Mehujael)
                                      ((? 134 b) . Irad)
                                      ((? 134 a) . Irad)
                                      ((? 133 rel) great ? 134 rel)
                                      ((? 133 c) . Irad)
                                      ((? 133 b) . Irad)
                                      ((? 133 a) . Enoch)
                                      ((? 129 rel) great ? 133 rel)
                                      ((? 129 c) . Enoch)
                                      ((? 129 b) . Irad)
                                      ((? 129 a) . Cain)
                                      ((? 128 rel) great ? 129 rel)
                                      ((? 128 c) . Cain)
                                      ((? 128 b) . Irad)
                                      ((? 128 a) . Adam)
                                      ((? relationship) great ? 128 rel))

debug:simple-query

debug:simple-query
apply-a-rule
rule=(rule (list-ending-with-grandson ((? x) ? y))
           (list-ending-with-grandson (? y)))
pattern=((? 135 rel) (? 135 c) (? 135 b))
frame=(((? 135 c) . Methushael)           ((? 135 b) . Irad)
       ((? 135 a) . Mehujael)             ((? 134 rel) great ? 135 rel)
       ((? 134 c) . Mehujael)             ((? 134 b) . Irad)
       ((? 134 a) . Irad)                 ((? 133 rel) great ? 134 rel)
       ((? 133 c) . Irad)                 ((? 133 b) . Irad)
       ((? 133 a) . Enoch)                ((? 129 rel) great ? 133 rel)
       ((? 129 c) . Enoch)                ((? 129 b) . Irad)
       ((? 129 a) . Cain)                 ((? 128 rel) great ? 129 rel)
       ((? 128 c) . Cain)                 ((? 128 b) . Irad)
       ((? 128 a) . Adam)                 ((? relationship) great ? 128 rel))

unify-result=failed
apply-a-rule
rule=(rule (list-ending-with-grandson (grandson)))
pattern=((? 135 rel) (? 135 c) (? 135 b))
frame=(((? 135 c) . Methushael)           ((? 135 b) . Irad)
       ((? 135 a) . Mehujael)             ((? 134 rel) great ? 135 rel)
       ((? 134 c) . Mehujael)             ((? 134 b) . Irad)
       ((? 134 a) . Irad)                 ((? 133 rel) great ? 134 rel)
       ((? 133 c) . Irad)                 ((? 133 b) . Irad)
       ((? 133 a) . Enoch)                ((? 129 rel) great ? 133 rel)
       ((? 129 c) . Enoch)                ((? 129 b) . Irad)
       ((? 129 a) . Cain)                 ((? 128 rel) great ? 129 rel)
       ((? 128 c) . Cain)                 ((? 128 b) . Irad)
       ((? 128 a) . Adam)                 ((? relationship) great ? 128 rel))

unify-result=failed
apply-a-rule
rule=(rule (son (? man) (? boy))
           (and (wife (? man) (? woman)) (son (? woman) (? boy))))
pattern=(son (? 135 a) (? 135 c))
frame=(((? 135 b) . Irad)                 ((? 135 a) . Mehujael)
       ((? 134 rel) great ? 135 rel)      ((? 134 c) . Mehujael)
       ((? 134 b) . Irad)                 ((? 134 a) . Irad)
       ((? 133 rel) great ? 134 rel)      ((? 133 c) . Irad)
       ((? 133 b) . Irad)                 ((? 133 a) . Enoch)
       ((? 129 rel) great ? 133 rel)      ((? 129 c) . Enoch)
       ((? 129 b) . Irad)                 ((? 129 a) . Cain)
       ((? 128 rel) great ? 129 rel)      ((? 128 c) . Cain)
       ((? 128 b) . Irad)                 ((? 128 a) . Adam)
       ((? relationship) great ? 128 rel))

unify-result=(((? 135 c) ? 171 boy) ((? 171 man) . Mehujael)
                                    ((? 135 b) . Irad)
                                    ((? 135 a) . Mehujael)
                                    ((? 134 rel) great ? 135 rel)
                                    ((? 134 c) . Mehujael)
                                    ((? 134 b) . Irad)
                                    ((? 134 a) . Irad)
                                    ((? 133 rel) great ? 134 rel)
                                    ((? 133 c) . Irad)
                                    ((? 133 b) . Irad)
                                    ((? 133 a) . Enoch)
                                    ((? 129 rel) great ? 133 rel)
                                    ((? 129 c) . Enoch)
                                    ((? 129 b) . Irad)
                                    ((? 129 a) . Cain)
                                    ((? 128 rel) great ? 129 rel)
                                    ((? 128 c) . Cain)
                                    ((? 128 b) . Irad)
                                    ((? 128 a) . Adam)
                                    ((? relationship) great ? 128 rel))

debug:simple-query

debug:simple-query

debug:simple-query
apply-a-rule
rule=(rule (son (? man) (? boy))
           (and (wife (? man) (? woman)) (son (? woman) (? boy))))
pattern=((? 134 rel) (? 134 c) (? 134 b))
frame=(((? 134 c) . Mehujael)             ((? 134 b) . Irad)
       ((? 134 a) . Irad)                 ((? 133 rel) great ? 134 rel)
       ((? 133 c) . Irad)                 ((? 133 b) . Irad)
       ((? 133 a) . Enoch)                ((? 129 rel) great ? 133 rel)
       ((? 129 c) . Enoch)                ((? 129 b) . Irad)
       ((? 129 a) . Cain)                 ((? 128 rel) great ? 129 rel)
       ((? 128 c) . Cain)                 ((? 128 b) . Irad)
       ((? 128 a) . Adam)                 ((? relationship) great ? 128 rel))

unify-result=(((? 172 boy) . Irad)               ((? 172 man) . Mehujael)
              ((? 134 rel) . son)                ((? 134 c) . Mehujael)
              ((? 134 b) . Irad)                 ((? 134 a) . Irad)
              ((? 133 rel) great ? 134 rel)      ((? 133 c) . Irad)
              ((? 133 b) . Irad)                 ((? 133 a) . Enoch)
              ((? 129 rel) great ? 133 rel)      ((? 129 c) . Enoch)
              ((? 129 b) . Irad)                 ((? 129 a) . Cain)
              ((? 128 rel) great ? 129 rel)      ((? 128 c) . Cain)
              ((? 128 b) . Irad)                 ((? 128 a) . Adam)
              ((? relationship) great ? 128 rel))

debug:simple-query

debug:simple-query
apply-a-rule
rule=(rule ((grandson) (? grandpa) (? grandson))
           (and (son (? grandpa) (? dad)) (son (? dad) (? grandson))))
pattern=((? 134 rel) (? 134 c) (? 134 b))
frame=(((? 134 c) . Mehujael)             ((? 134 b) . Irad)
       ((? 134 a) . Irad)                 ((? 133 rel) great ? 134 rel)
       ((? 133 c) . Irad)                 ((? 133 b) . Irad)
       ((? 133 a) . Enoch)                ((? 129 rel) great ? 133 rel)
       ((? 129 c) . Enoch)                ((? 129 b) . Irad)
       ((? 129 a) . Cain)                 ((? 128 rel) great ? 129 rel)
       ((? 128 c) . Cain)                 ((? 128 b) . Irad)
       ((? 128 a) . Adam)                 ((? relationship) great ? 128 rel))

unify-result=(((? 173 grandson) . Irad)          ((? 173 grandpa) . Mehujael)
              ((? 134 rel) grandson)             ((? 134 c) . Mehujael)
              ((? 134 b) . Irad)                 ((? 134 a) . Irad)
              ((? 133 rel) great ? 134 rel)      ((? 133 c) . Irad)
              ((? 133 b) . Irad)                 ((? 133 a) . Enoch)
              ((? 129 rel) great ? 133 rel)      ((? 129 c) . Enoch)
              ((? 129 b) . Irad)                 ((? 129 a) . Cain)
              ((? 128 rel) great ? 129 rel)      ((? 128 c) . Cain)
              ((? 128 b) . Irad)                 ((? 128 a) . Adam)
              ((? relationship) great ? 128 rel))

debug:simple-query

debug:simple-query
apply-a-rule
rule=(rule (son (? man) (? boy))
           (and (wife (? man) (? woman)) (son (? woman) (? boy))))
pattern=(son (? 173 dad) (? 173 grandson))
frame=(((? 173 dad) . Methushael)         ((? 173 grandson) . Irad)
       ((? 173 grandpa) . Mehujael)       ((? 134 rel) grandson)
       ((? 134 c) . Mehujael)             ((? 134 b) . Irad)
       ((? 134 a) . Irad)                 ((? 133 rel) great ? 134 rel)
       ((? 133 c) . Irad)                 ((? 133 b) . Irad)
       ((? 133 a) . Enoch)                ((? 129 rel) great ? 133 rel)
       ((? 129 c) . Enoch)                ((? 129 b) . Irad)
       ((? 129 a) . Cain)                 ((? 128 rel) great ? 129 rel)
       ((? 128 c) . Cain)                 ((? 128 b) . Irad)
       ((? 128 a) . Adam)                 ((? relationship) great ? 128 rel))

unify-result=(((? 174 boy) . Irad)               ((? 174 man) . Methushael)
              ((? 173 dad) . Methushael)         ((? 173 grandson) . Irad)
              ((? 173 grandpa) . Mehujael)       ((? 134 rel) grandson)
              ((? 134 c) . Mehujael)             ((? 134 b) . Irad)
              ((? 134 a) . Irad)                 ((? 133 rel) great ? 134 rel)
              ((? 133 c) . Irad)                 ((? 133 b) . Irad)
              ((? 133 a) . Enoch)                ((? 129 rel) great ? 133 rel)
              ((? 129 c) . Enoch)                ((? 129 b) . Irad)
              ((? 129 a) . Cain)                 ((? 128 rel) great ? 129 rel)
              ((? 128 c) . Cain)                 ((? 128 b) . Irad)
              ((? 128 a) . Adam)                 ((? relationship) great ? 128 rel))

debug:simple-query

debug:simple-query
apply-a-rule
rule=(rule (son (? man) (? boy))
           (and (wife (? man) (? woman)) (son (? woman) (? boy))))
pattern=(son (? 173 grandpa) (? 173 dad))
frame=(((? 173 grandson) . Irad)          ((? 173 grandpa) . Mehujael)
       ((? 134 rel) grandson)             ((? 134 c) . Mehujael)
       ((? 134 b) . Irad)                 ((? 134 a) . Irad)
       ((? 133 rel) great ? 134 rel)      ((? 133 c) . Irad)
       ((? 133 b) . Irad)                 ((? 133 a) . Enoch)
       ((? 129 rel) great ? 133 rel)      ((? 129 c) . Enoch)
       ((? 129 b) . Irad)                 ((? 129 a) . Cain)
       ((? 128 rel) great ? 129 rel)      ((? 128 c) . Cain)
       ((? 128 b) . Irad)                 ((? 128 a) . Adam)
       ((? relationship) great ? 128 rel))

unify-result=(((? 173 dad) ? 175 boy) ((? 175 man) . Mehujael)
                                      ((? 173 grandson) . Irad)
                                      ((? 173 grandpa) . Mehujael)
                                      ((? 134 rel) grandson)
                                      ((? 134 c) . Mehujael)
                                      ((? 134 b) . Irad)
                                      ((? 134 a) . Irad)
                                      ((? 133 rel) great ? 134 rel)
                                      ((? 133 c) . Irad)
                                      ((? 133 b) . Irad)
                                      ((? 133 a) . Enoch)
                                      ((? 129 rel) great ? 133 rel)
                                      ((? 129 c) . Enoch)
                                      ((? 129 b) . Irad)
                                      ((? 129 a) . Cain)
                                      ((? 128 rel) great ? 129 rel)
                                      ((? 128 c) . Cain)
                                      ((? 128 b) . Irad)
                                      ((? 128 a) . Adam)
                                      ((? relationship) great ? 128 rel))

debug:simple-query

debug:simple-query
apply-a-rule
rule=(rule (list-ending-with-grandson ((? x) ? y))
           (list-ending-with-grandson (? y)))
pattern=((? 134 rel) (? 134 c) (? 134 b))
frame=(((? 134 c) . Mehujael)             ((? 134 b) . Irad)
       ((? 134 a) . Irad)                 ((? 133 rel) great ? 134 rel)
       ((? 133 c) . Irad)                 ((? 133 b) . Irad)
       ((? 133 a) . Enoch)                ((? 129 rel) great ? 133 rel)
       ((? 129 c) . Enoch)                ((? 129 b) . Irad)
       ((? 129 a) . Cain)                 ((? 128 rel) great ? 129 rel)
       ((? 128 c) . Cain)                 ((? 128 b) . Irad)
       ((? 128 a) . Adam)                 ((? relationship) great ? 128 rel))

unify-result=failed
apply-a-rule
rule=(rule (list-ending-with-grandson (grandson)))
pattern=((? 134 rel) (? 134 c) (? 134 b))
frame=(((? 134 c) . Mehujael)             ((? 134 b) . Irad)
       ((? 134 a) . Irad)                 ((? 133 rel) great ? 134 rel)
       ((? 133 c) . Irad)                 ((? 133 b) . Irad)
       ((? 133 a) . Enoch)                ((? 129 rel) great ? 133 rel)
       ((? 129 c) . Enoch)                ((? 129 b) . Irad)
       ((? 129 a) . Cain)                 ((? 128 rel) great ? 129 rel)
       ((? 128 c) . Cain)                 ((? 128 b) . Irad)
       ((? 128 a) . Adam)                 ((? relationship) great ? 128 rel))

unify-result=failed
apply-a-rule
rule=(rule (son (? man) (? boy))
           (and (wife (? man) (? woman)) (son (? woman) (? boy))))
pattern=(son (? 134 a) (? 134 c))
frame=(((? 134 b) . Irad)                 ((? 134 a) . Irad)
       ((? 133 rel) great ? 134 rel)      ((? 133 c) . Irad)
       ((? 133 b) . Irad)                 ((? 133 a) . Enoch)
       ((? 129 rel) great ? 133 rel)      ((? 129 c) . Enoch)
       ((? 129 b) . Irad)                 ((? 129 a) . Cain)
       ((? 128 rel) great ? 129 rel)      ((? 128 c) . Cain)
       ((? 128 b) . Irad)                 ((? 128 a) . Adam)
       ((? relationship) great ? 128 rel))

unify-result=(((? 134 c) ? 178 boy) ((? 178 man) . Irad)
                                    ((? 134 b) . Irad)
                                    ((? 134 a) . Irad)
                                    ((? 133 rel) great ? 134 rel)
                                    ((? 133 c) . Irad)
                                    ((? 133 b) . Irad)
                                    ((? 133 a) . Enoch)
                                    ((? 129 rel) great ? 133 rel)
                                    ((? 129 c) . Enoch)
                                    ((? 129 b) . Irad)
                                    ((? 129 a) . Cain)
                                    ((? 128 rel) great ? 129 rel)
                                    ((? 128 c) . Cain)
                                    ((? 128 b) . Irad)
                                    ((? 128 a) . Adam)
                                    ((? relationship) great ? 128 rel))

debug:simple-query

debug:simple-query

debug:simple-query
apply-a-rule
rule=(rule (son (? man) (? boy))
           (and (wife (? man) (? woman)) (son (? woman) (? boy))))
pattern=((? 133 rel) (? 133 c) (? 133 b))
frame=(((? 133 c) . Irad)                 ((? 133 b) . Irad)
       ((? 133 a) . Enoch)                ((? 129 rel) great ? 133 rel)
       ((? 129 c) . Enoch)                ((? 129 b) . Irad)
       ((? 129 a) . Cain)                 ((? 128 rel) great ? 129 rel)
       ((? 128 c) . Cain)                 ((? 128 b) . Irad)
       ((? 128 a) . Adam)                 ((? relationship) great ? 128 rel))

unify-result=(((? 179 boy) . Irad)               ((? 179 man) . Irad)
              ((? 133 rel) . son)                ((? 133 c) . Irad)
              ((? 133 b) . Irad)                 ((? 133 a) . Enoch)
              ((? 129 rel) great ? 133 rel)      ((? 129 c) . Enoch)
              ((? 129 b) . Irad)                 ((? 129 a) . Cain)
              ((? 128 rel) great ? 129 rel)      ((? 128 c) . Cain)
              ((? 128 b) . Irad)                 ((? 128 a) . Adam)
              ((? relationship) great ? 128 rel))

debug:simple-query

debug:simple-query
apply-a-rule
rule=(rule ((grandson) (? grandpa) (? grandson))
           (and (son (? grandpa) (? dad)) (son (? dad) (? grandson))))
pattern=((? 133 rel) (? 133 c) (? 133 b))
frame=(((? 133 c) . Irad)                 ((? 133 b) . Irad)
       ((? 133 a) . Enoch)                ((? 129 rel) great ? 133 rel)
       ((? 129 c) . Enoch)                ((? 129 b) . Irad)
       ((? 129 a) . Cain)                 ((? 128 rel) great ? 129 rel)
       ((? 128 c) . Cain)                 ((? 128 b) . Irad)
       ((? 128 a) . Adam)                 ((? relationship) great ? 128 rel))

unify-result=(((? 180 grandson) . Irad)          ((? 180 grandpa) . Irad)
              ((? 133 rel) grandson)             ((? 133 c) . Irad)
              ((? 133 b) . Irad)                 ((? 133 a) . Enoch)
              ((? 129 rel) great ? 133 rel)      ((? 129 c) . Enoch)
              ((? 129 b) . Irad)                 ((? 129 a) . Cain)
              ((? 128 rel) great ? 129 rel)      ((? 128 c) . Cain)
              ((? 128 b) . Irad)                 ((? 128 a) . Adam)
              ((? relationship) great ? 128 rel))

debug:simple-query

debug:simple-query
apply-a-rule
rule=(rule (son (? man) (? boy))
           (and (wife (? man) (? woman)) (son (? woman) (? boy))))
pattern=(son (? 180 dad) (? 180 grandson))
frame=(((? 180 dad) . Mehujael)           ((? 180 grandson) . Irad)
       ((? 180 grandpa) . Irad)           ((? 133 rel) grandson)
       ((? 133 c) . Irad)                 ((? 133 b) . Irad)
       ((? 133 a) . Enoch)                ((? 129 rel) great ? 133 rel)
       ((? 129 c) . Enoch)                ((? 129 b) . Irad)
       ((? 129 a) . Cain)                 ((? 128 rel) great ? 129 rel)
       ((? 128 c) . Cain)                 ((? 128 b) . Irad)
       ((? 128 a) . Adam)                 ((? relationship) great ? 128 rel))

unify-result=(((? 181 boy) . Irad)               ((? 181 man) . Mehujael)
              ((? 180 dad) . Mehujael)           ((? 180 grandson) . Irad)
              ((? 180 grandpa) . Irad)           ((? 133 rel) grandson)
              ((? 133 c) . Irad)                 ((? 133 b) . Irad)
              ((? 133 a) . Enoch)                ((? 129 rel) great ? 133 rel)
              ((? 129 c) . Enoch)                ((? 129 b) . Irad)
              ((? 129 a) . Cain)                 ((? 128 rel) great ? 129 rel)
              ((? 128 c) . Cain)                 ((? 128 b) . Irad)
              ((? 128 a) . Adam)                 ((? relationship) great ? 128 rel))

debug:simple-query

debug:simple-query
apply-a-rule
rule=(rule (son (? man) (? boy))
           (and (wife (? man) (? woman)) (son (? woman) (? boy))))
pattern=(son (? 180 grandpa) (? 180 dad))
frame=(((? 180 grandson) . Irad)          ((? 180 grandpa) . Irad)
       ((? 133 rel) grandson)             ((? 133 c) . Irad)
       ((? 133 b) . Irad)                 ((? 133 a) . Enoch)
       ((? 129 rel) great ? 133 rel)      ((? 129 c) . Enoch)
       ((? 129 b) . Irad)                 ((? 129 a) . Cain)
       ((? 128 rel) great ? 129 rel)      ((? 128 c) . Cain)
       ((? 128 b) . Irad)                 ((? 128 a) . Adam)
       ((? relationship) great ? 128 rel))

unify-result=(((? 180 dad) ? 182 boy) ((? 182 man) . Irad)
                                      ((? 180 grandson) . Irad)
                                      ((? 180 grandpa) . Irad)
                                      ((? 133 rel) grandson)
                                      ((? 133 c) . Irad)
                                      ((? 133 b) . Irad)
                                      ((? 133 a) . Enoch)
                                      ((? 129 rel) great ? 133 rel)
                                      ((? 129 c) . Enoch)
                                      ((? 129 b) . Irad)
                                      ((? 129 a) . Cain)
                                      ((? 128 rel) great ? 129 rel)
                                      ((? 128 c) . Cain)
                                      ((? 128 b) . Irad)
                                      ((? 128 a) . Adam)
                                      ((? relationship) great ? 128 rel))

debug:simple-query

debug:simple-query
apply-a-rule
rule=(rule (list-ending-with-grandson ((? x) ? y))
           (list-ending-with-grandson (? y)))
pattern=((? 133 rel) (? 133 c) (? 133 b))
frame=(((? 133 c) . Irad)                 ((? 133 b) . Irad)
       ((? 133 a) . Enoch)                ((? 129 rel) great ? 133 rel)
       ((? 129 c) . Enoch)                ((? 129 b) . Irad)
       ((? 129 a) . Cain)                 ((? 128 rel) great ? 129 rel)
       ((? 128 c) . Cain)                 ((? 128 b) . Irad)
       ((? 128 a) . Adam)                 ((? relationship) great ? 128 rel))

unify-result=failed
apply-a-rule
rule=(rule (list-ending-with-grandson (grandson)))
pattern=((? 133 rel) (? 133 c) (? 133 b))
frame=(((? 133 c) . Irad)                 ((? 133 b) . Irad)
       ((? 133 a) . Enoch)                ((? 129 rel) great ? 133 rel)
       ((? 129 c) . Enoch)                ((? 129 b) . Irad)
       ((? 129 a) . Cain)                 ((? 128 rel) great ? 129 rel)
       ((? 128 c) . Cain)                 ((? 128 b) . Irad)
       ((? 128 a) . Adam)                 ((? relationship) great ? 128 rel))

unify-result=failed
apply-a-rule
rule=(rule (son (? man) (? boy))
           (and (wife (? man) (? woman)) (son (? woman) (? boy))))
pattern=(son (? 133 a) (? 133 c))
frame=(((? 133 b) . Irad)                 ((? 133 a) . Enoch)
       ((? 129 rel) great ? 133 rel)      ((? 129 c) . Enoch)
       ((? 129 b) . Irad)                 ((? 129 a) . Cain)
       ((? 128 rel) great ? 129 rel)      ((? 128 c) . Cain)
       ((? 128 b) . Irad)                 ((? 128 a) . Adam)
       ((? relationship) great ? 128 rel))

unify-result=(((? 133 c) ? 185 boy) ((? 185 man) . Enoch)
                                    ((? 133 b) . Irad)
                                    ((? 133 a) . Enoch)
                                    ((? 129 rel) great ? 133 rel)
                                    ((? 129 c) . Enoch)
                                    ((? 129 b) . Irad)
                                    ((? 129 a) . Cain)
                                    ((? 128 rel) great ? 129 rel)
                                    ((? 128 c) . Cain)
                                    ((? 128 b) . Irad)
                                    ((? 128 a) . Adam)
                                    ((? relationship) great ? 128 rel))

debug:simple-query

debug:simple-query

debug:simple-query
apply-a-rule
rule=(rule (son (? man) (? boy))
           (and (wife (? man) (? woman)) (son (? woman) (? boy))))
pattern=((? 129 rel) (? 129 c) (? 129 b))
frame=(((? 129 c) . Enoch)                ((? 129 b) . Irad)
       ((? 129 a) . Cain)                 ((? 128 rel) great ? 129 rel)
       ((? 128 c) . Cain)                 ((? 128 b) . Irad)
       ((? 128 a) . Adam)                 ((? relationship) great ? 128 rel))

unify-result=(((? 186 boy) . Irad)               ((? 186 man) . Enoch)
              ((? 129 rel) . son)                ((? 129 c) . Enoch)
              ((? 129 b) . Irad)                 ((? 129 a) . Cain)
              ((? 128 rel) great ? 129 rel)      ((? 128 c) . Cain)
              ((? 128 b) . Irad)                 ((? 128 a) . Adam)
              ((? relationship) great ? 128 rel))

debug:simple-query

debug:simple-query
apply-a-rule
rule=(rule ((grandson) (? grandpa) (? grandson))
           (and (son (? grandpa) (? dad)) (son (? dad) (? grandson))))
pattern=((? 129 rel) (? 129 c) (? 129 b))
frame=(((? 129 c) . Enoch)                ((? 129 b) . Irad)
       ((? 129 a) . Cain)                 ((? 128 rel) great ? 129 rel)
       ((? 128 c) . Cain)                 ((? 128 b) . Irad)
       ((? 128 a) . Adam)                 ((? relationship) great ? 128 rel))

unify-result=(((? 187 grandson) . Irad)          ((? 187 grandpa) . Enoch)
              ((? 129 rel) grandson)             ((? 129 c) . Enoch)
              ((? 129 b) . Irad)                 ((? 129 a) . Cain)
              ((? 128 rel) great ? 129 rel)      ((? 128 c) . Cain)
              ((? 128 b) . Irad)                 ((? 128 a) . Adam)
              ((? relationship) great ? 128 rel))

debug:simple-query

debug:simple-query
apply-a-rule
rule=(rule (son (? man) (? boy))
           (and (wife (? man) (? woman)) (son (? woman) (? boy))))
pattern=(son (? 187 dad) (? 187 grandson))
frame=(((? 187 dad) . Irad)               ((? 187 grandson) . Irad)
       ((? 187 grandpa) . Enoch)          ((? 129 rel) grandson)
       ((? 129 c) . Enoch)                ((? 129 b) . Irad)
       ((? 129 a) . Cain)                 ((? 128 rel) great ? 129 rel)
       ((? 128 c) . Cain)                 ((? 128 b) . Irad)
       ((? 128 a) . Adam)                 ((? relationship) great ? 128 rel))

unify-result=(((? 188 boy) . Irad)               ((? 188 man) . Irad)
              ((? 187 dad) . Irad)               ((? 187 grandson) . Irad)
              ((? 187 grandpa) . Enoch)          ((? 129 rel) grandson)
              ((? 129 c) . Enoch)                ((? 129 b) . Irad)
              ((? 129 a) . Cain)                 ((? 128 rel) great ? 129 rel)
              ((? 128 c) . Cain)                 ((? 128 b) . Irad)
              ((? 128 a) . Adam)                 ((? relationship) great ? 128 rel))

debug:simple-query

debug:simple-query
apply-a-rule
rule=(rule (son (? man) (? boy))
           (and (wife (? man) (? woman)) (son (? woman) (? boy))))
pattern=(son (? 187 grandpa) (? 187 dad))
frame=(((? 187 grandson) . Irad)          ((? 187 grandpa) . Enoch)
       ((? 129 rel) grandson)             ((? 129 c) . Enoch)
       ((? 129 b) . Irad)                 ((? 129 a) . Cain)
       ((? 128 rel) great ? 129 rel)      ((? 128 c) . Cain)
       ((? 128 b) . Irad)                 ((? 128 a) . Adam)
       ((? relationship) great ? 128 rel))

unify-result=(((? 187 dad) ? 189 boy) ((? 189 man) . Enoch)
                                      ((? 187 grandson) . Irad)
                                      ((? 187 grandpa) . Enoch)
                                      ((? 129 rel) grandson)
                                      ((? 129 c) . Enoch)
                                      ((? 129 b) . Irad)
                                      ((? 129 a) . Cain)
                                      ((? 128 rel) great ? 129 rel)
                                      ((? 128 c) . Cain)
                                      ((? 128 b) . Irad)
                                      ((? 128 a) . Adam)
                                      ((? relationship) great ? 128 rel))

debug:simple-query

debug:simple-query
apply-a-rule
rule=(rule (list-ending-with-grandson ((? x) ? y))
           (list-ending-with-grandson (? y)))
pattern=((? 129 rel) (? 129 c) (? 129 b))
frame=(((? 129 c) . Enoch)                ((? 129 b) . Irad)
       ((? 129 a) . Cain)                 ((? 128 rel) great ? 129 rel)
       ((? 128 c) . Cain)                 ((? 128 b) . Irad)
       ((? 128 a) . Adam)                 ((? relationship) great ? 128 rel))

unify-result=failed
apply-a-rule
rule=(rule (list-ending-with-grandson (grandson)))
pattern=((? 129 rel) (? 129 c) (? 129 b))
frame=(((? 129 c) . Enoch)                ((? 129 b) . Irad)
       ((? 129 a) . Cain)                 ((? 128 rel) great ? 129 rel)
       ((? 128 c) . Cain)                 ((? 128 b) . Irad)
       ((? 128 a) . Adam)                 ((? relationship) great ? 128 rel))

unify-result=failed
apply-a-rule
rule=(rule (son (? man) (? boy))
           (and (wife (? man) (? woman)) (son (? woman) (? boy))))
pattern=((? 128 rel) (? 128 c) (? 128 b))
frame=(((? 128 c) . Cain)                 ((? 128 b) . Irad)
       ((? 128 a) . Adam)                 ((? relationship) great ? 128 rel))

unify-result=(((? 192 boy) . Irad)               ((? 192 man) . Cain)
              ((? 128 rel) . son)                ((? 128 c) . Cain)
              ((? 128 b) . Irad)                 ((? 128 a) . Adam)
              ((? relationship) great ? 128 rel))

debug:simple-query

debug:simple-query
apply-a-rule
rule=(rule ((grandson) (? grandpa) (? grandson))
           (and (son (? grandpa) (? dad)) (son (? dad) (? grandson))))
pattern=((? 128 rel) (? 128 c) (? 128 b))
frame=(((? 128 c) . Cain)                 ((? 128 b) . Irad)
       ((? 128 a) . Adam)                 ((? relationship) great ? 128 rel))

unify-result=(((? 193 grandson) . Irad)          ((? 193 grandpa) . Cain)
              ((? 128 rel) grandson)             ((? 128 c) . Cain)
              ((? 128 b) . Irad)                 ((? 128 a) . Adam)
              ((? relationship) great ? 128 rel))

debug:simple-query

debug:simple-query

debug:simple-query
apply-a-rule
rule=(rule (list-ending-with-grandson ((? x) ? y))
           (list-ending-with-grandson (? y)))
pattern=(list-ending-with-grandson (? 128 rel))
frame=(((? 193 dad) . Enoch)              ((? 193 grandson) . Irad)
       ((? 193 grandpa) . Cain)           ((? 128 rel) grandson)
       ((? 128 c) . Cain)                 ((? 128 b) . Irad)
       ((? 128 a) . Adam)                 ((? relationship) great ? 128 rel))

unify-result=(((? 194 y)) ((? 194 x) . grandson)
                          ((? 193 dad) . Enoch)
                          ((? 193 grandson) . Irad)
                          ((? 193 grandpa) . Cain)
                          ((? 128 rel) grandson)
                          ((? 128 c) . Cain)
                          ((? 128 b) . Irad)
                          ((? 128 a) . Adam)
                          ((? relationship) great ? 128 rel))

debug:simple-query
apply-a-rule
rule=(rule (list-ending-with-grandson ((? x) ? y))
           (list-ending-with-grandson (? y)))
pattern=(list-ending-with-grandson (? 194 y))
frame=(((? 194 y)) ((? 194 x) . grandson)
                   ((? 193 dad) . Enoch)
                   ((? 193 grandson) . Irad)
                   ((? 193 grandpa) . Cain)
                   ((? 128 rel) grandson)
                   ((? 128 c) . Cain)
                   ((? 128 b) . Irad)
                   ((? 128 a) . Adam)
                   ((? relationship) great ? 128 rel))

unify-result=failed
apply-a-rule
rule=(rule (list-ending-with-grandson (grandson)))
pattern=(list-ending-with-grandson (? 194 y))
frame=(((? 194 y)) ((? 194 x) . grandson)
                   ((? 193 dad) . Enoch)
                   ((? 193 grandson) . Irad)
                   ((? 193 grandpa) . Cain)
                   ((? 128 rel) grandson)
                   ((? 128 c) . Cain)
                   ((? 128 b) . Irad)
                   ((? 128 a) . Adam)
                   ((? relationship) great ? 128 rel))

unify-result=failed
apply-a-rule
rule=(rule (list-ending-with-grandson (grandson)))
pattern=(list-ending-with-grandson (? 128 rel))
frame=(((? 193 dad) . Enoch)              ((? 193 grandson) . Irad)
       ((? 193 grandpa) . Cain)           ((? 128 rel) grandson)
       ((? 128 c) . Cain)                 ((? 128 b) . Irad)
       ((? 128 a) . Adam)                 ((? relationship) great ? 128 rel))

unify-result=(((? 193 dad) . Enoch)              ((? 193 grandson) . Irad)
              ((? 193 grandpa) . Cain)           ((? 128 rel) grandson)
              ((? 128 c) . Cain)                 ((? 128 b) . Irad)
              ((? 128 a) . Adam)                 ((? relationship) great ? 128 rel))
((great grandson) Adam Irad)
apply-a-rule
rule=(rule (son (? man) (? boy))
           (and (wife (? man) (? woman)) (son (? woman) (? boy))))
pattern=((? relationship) Adam Irad)
frame=()

unify-result=(((? 198 boy) . Irad)
              ((? 198 man) . Adam)
              ((? relationship) . son))

debug:simple-query

debug:simple-query
apply-a-rule
rule=(rule ((grandson) (? grandpa) (? grandson))
           (and (son (? grandpa) (? dad)) (son (? dad) (? grandson))))
pattern=((? relationship) Adam Irad)
frame=()

unify-result=(((? 199 grandson) . Irad)
              ((? 199 grandpa) . Adam)
              ((? relationship) grandson))

debug:simple-query

debug:simple-query
apply-a-rule
rule=(rule (son (? man) (? boy))
           (and (wife (? man) (? woman)) (son (? woman) (? boy))))
pattern=(son (? 199 dad) (? 199 grandson))
frame=(((? 199 dad) . Cain)        ((? 199 grandson) . Irad)
       ((? 199 grandpa) . Adam)    ((? relationship) grandson))

unify-result=(((? 200 boy) . Irad)        ((? 200 man) . Cain)
              ((? 199 dad) . Cain)        ((? 199 grandson) . Irad)
              ((? 199 grandpa) . Adam)    ((? relationship) grandson))

debug:simple-query

debug:simple-query
apply-a-rule
rule=(rule (son (? man) (? boy))
           (and (wife (? man) (? woman)) (son (? woman) (? boy))))
pattern=(son (? 199 grandpa) (? 199 dad))
frame=(((? 199 grandson) . Irad)
       ((? 199 grandpa) . Adam)
       ((? relationship) grandson))

unify-result=(((? 199 dad) ? 201 boy) ((? 201 man) . Adam)
                                      ((? 199 grandson) . Irad)
                                      ((? 199 grandpa) . Adam)
                                      ((? relationship) grandson))

debug:simple-query

debug:simple-query
apply-a-rule
rule=(rule (list-ending-with-grandson ((? x) ? y))
           (list-ending-with-grandson (? y)))
pattern=((? relationship) Adam Irad)
frame=()

unify-result=failed
apply-a-rule
rule=(rule (list-ending-with-grandson (grandson)))
pattern=((? relationship) Adam Irad)
frame=()

unify-result=failed
apply-a-rule
rule=(rule (son (? man) (? boy))
           (and (wife (? man) (? woman)) (son (? woman) (? boy))))
pattern=(son (? 128 a) (? 128 c))
frame=(((? 128 b) . Irad)
       ((? 128 a) . Adam)
       ((? relationship) great ? 128 rel))

unify-result=(((? 128 c) ? 204 boy) ((? 204 man) . Adam)
                                    ((? 128 b) . Irad)
                                    ((? 128 a) . Adam)
                                    ((? relationship) great ? 128 rel))

debug:simple-query

debug:simple-query
apply-a-rule
rule=(rule (list-ending-with-grandson ((? x) ? y))
           (list-ending-with-grandson (? y)))
pattern=((? 128 rel) (? 128 c) (? 128 b))
frame=(((? 128 c) . Cain)                 ((? 128 b) . Irad)
       ((? 128 a) . Adam)                 ((? relationship) great ? 128 rel))

unify-result=failed
apply-a-rule
rule=(rule (list-ending-with-grandson (grandson)))
pattern=((? 128 rel) (? 128 c) (? 128 b))
frame=(((? 128 c) . Cain)                 ((? 128 b) . Irad)
       ((? 128 a) . Adam)                 ((? relationship) great ? 128 rel))

unify-result=failed
apply-a-rule
rule=(rule (son (? man) (? boy))
           (and (wife (? man) (? woman)) (son (? woman) (? boy))))
pattern=(son (? 193 grandpa) (? 193 dad))
frame=(((? 193 grandson) . Irad)          ((? 193 grandpa) . Cain)
       ((? 128 rel) grandson)             ((? 128 c) . Cain)
       ((? 128 b) . Irad)                 ((? 128 a) . Adam)
       ((? relationship) great ? 128 rel))

unify-result=(((? 193 dad) ? 207 boy) ((? 207 man) . Cain)
                                      ((? 193 grandson) . Irad)
                                      ((? 193 grandpa) . Cain)
                                      ((? 128 rel) grandson)
                                      ((? 128 c) . Cain)
                                      ((? 128 b) . Irad)
                                      ((? 128 a) . Adam)
                                      ((? relationship) great ? 128 rel))

debug:simple-query

debug:simple-query
apply-a-rule
rule=(rule (son (? man) (? boy))
           (and (wife (? man) (? woman)) (son (? woman) (? boy))))
pattern=(son (? 193 dad) (? 193 grandson))
frame=(((? 193 dad) . Enoch)              ((? 193 grandson) . Irad)
       ((? 193 grandpa) . Cain)           ((? 128 rel) grandson)
       ((? 128 c) . Cain)                 ((? 128 b) . Irad)
       ((? 128 a) . Adam)                 ((? relationship) great ? 128 rel))

unify-result=(((? 208 boy) . Irad)               ((? 208 man) . Enoch)
              ((? 193 dad) . Enoch)              ((? 193 grandson) . Irad)
              ((? 193 grandpa) . Cain)           ((? 128 rel) grandson)
              ((? 128 c) . Cain)                 ((? 128 b) . Irad)
              ((? 128 a) . Adam)                 ((? relationship) great ? 128 rel))

debug:simple-query

debug:simple-query

;;; Query input:
exit
#+end_src


**** 4.4.4 Implementing the Query System [10/10]
***** Common code

The following snippet has ~(display q)~ added to display the input
queries, because we are using the literate programming
style. ~prompt-for-input~ and ~tagged-list~ were also implemented by me.

#+name: prolog-debugging-help
#+begin_src scheme :exports code :results none
  (define debug #t)
  (define current-qeval-depth 0)
  (define (print-frame frame)
    (define (print-binding b)
        (display "(")
        (display (instantiate
		     (binding-variable b)
		     '()
		   (lambda (v f)
		     (contract-question-mark v))))
        (display " . ")
        (display (instantiate
		     (binding-value b)
		     '()
		   (lambda (v f)
		     (contract-question-mark v))))
        (display ") ")
        (newline))
     (display "( ")
     (map print-binding frame)
     (display ")")
      'print-finished)
#+end_src

#+name: prolog-glue
#+begin_src scheme :exports both :results none
  (import (scheme small))
  (import (scheme list))
  (import (chibi ast))
  (import (srfi 159))
  (define true #t)
  (define false #f)
  (define debug #f)
  (define (prompt-for-input string)
     (newline) (display string) (newline))
  (define (tagged-list? exp tag)
            (if (pair? exp)
                (eq? (car exp) tag)
                false))
  (define user-initial-environment (interaction-environment))
#+end_src

#+name: prolog-driver-loop
#+begin_src scheme :exports code :results none
  (define input-prompt  ";;; Query input:")
  (define output-prompt ";;; Query results:")

  (define (query-driver-loop)
    (prompt-for-input input-prompt)
    (let* ((i (read))
           (q (query-syntax-process i)))
      (show #t (pretty q))
      (cond  ((eq? q 'exit) (exit))
             ((assertion-to-be-added? q)
	     (add-rule-or-assertion! (add-assertion-body q))
	     #;(newline)
	     (display "Assertion added to data base.")
	     (query-driver-loop))
	    (else
	     ;;(newline)
	     (display output-prompt)
             (newline)
	     (display-stream
	      (stream-map
	       (lambda (frame)
		 (instantiate
		     q
		     frame
		   (lambda (v f)
		     (contract-question-mark v))))
	       (qeval q (singleton-stream '()))))
	     (query-driver-loop)))))
#+end_src

#+name: prolog-instantiate
#+begin_src scheme :exports code :results none
  (define (instantiate exp frame unbound-var-handler)
    (define (copy exp)
      (cond ((var? exp)
	     (let ((binding (binding-in-frame exp frame)))
	       (if binding
		   (copy (binding-value binding))
		   (unbound-var-handler exp frame))))
	    ((pair? exp)
	     (cons (copy (car exp)) (copy (cdr exp))))
	    (else exp)))
    (copy exp))

#+end_src

#+name: prolog-qeval
#+begin_src scheme :exports code :results none
  (define (qeval query frame-stream)
    (if debug
	(begin
	  (set! current-qeval-depth (+ 1 current-qeval-depth))
	  (display "\n\nqeval:depth=") (display current-qeval-depth)
	  (display "\n\ query=") (show #t (pretty query))
	  #;(display "\n instantiations=")
	  #;(map (lambda (frame) (display (instantiate
	  query
	  frame
	  (lambda (v f)
	  (contract-question-mark v))))) frame-stream)
	  (display "\n frame-stream=")
	  (stream-map print-frame frame-stream)))
    (let ((qproc (get (type query) 'qeval)))
      (if debug
	  (if (> current-qeval-depth 20)
	      (begin
		(display "\nMaximum depth reached.")
		(set! current-qeval-depth (- current-qeval-depth 1))
		the-empty-stream)
	      (let ((retval (if qproc
				(qproc (contents query) frame-stream)
				(simple-query query frame-stream))))
		(display "\n retval=")
		(stream-map print-frame retval)
		retval))
	  (if qproc
	      (qproc (contents query) frame-stream)
	      (simple-query query frame-stream)))))
#+end_src

The next block is a bit funny, because although ~stream-append~ was defined in the
chapter 3, it was not used, since ~interleave~ was used.

#+name: stream-append
#+begin_src scheme :exports code :results none
  (define (stream-append s1 s2)
    (if (stream-null? s1)
	s2
	(cons-stream (stream-car s1)
		     (stream-append (stream-cdr s1) s2))))
#+end_src

#+name: prolog-simple-queries
#+begin_src scheme :exports code :results none
  (define (simple-query query-pattern frame-stream)
   #;(show #t "\ndebug:simple-query\n")
    (stream-flatmap
     (lambda (frame)
       (stream-append-delayed
	(find-assertions query-pattern frame)
	(delay (apply-rules query-pattern frame))))
     frame-stream))
#+end_src

#+name: prolog-conjoin
#+begin_src scheme :exports code :results none
  (define (conjoin conjuncts frame-stream)
    (if (empty-conjunction? conjuncts)
	frame-stream
	(conjoin (rest-conjuncts conjuncts)
		 (qeval (first-conjunct conjuncts) frame-stream))))
#+end_src

#+name: prolog-conjoin-installation
#+begin_src scheme :exports code :results none
(put 'and 'qeval conjoin)
#+end_src

#+name: prolog-disjoin
#+begin_src scheme :exports code :results none
  (define (disjoin disjuncts frame-stream)
    (if (empty-disjunction? disjuncts)
	the-empty-stream
	(interleave-delayed
	 (qeval (first-disjunct disjuncts) frame-stream)
	 (delay (disjoin (rest-disjuncts disjuncts) frame-stream)))))

#+end_src

#+name: prolog-disjoin-installation
#+begin_src scheme :exports code :results none
  (put 'or 'qeval disjoin)
#+end_src

#+name: prolog-negate
#+begin_src scheme :exports code :results none
  (define (negate operands frame-stream)
    (stream-flatmap
     (lambda (frame)
       (if (stream-null?
	    (qeval (negated-query operands)
		   (singleton-stream frame)))
	   (singleton-stream frame)
	   the-empty-stream))
     frame-stream))

#+end_src

#+name: prolog-negate-installation
#+begin_src scheme :exports code :results none
  (put 'not 'qeval negate)
#+end_src

#+name: prolog-lisp-filter
#+begin_src scheme :exports code :results none
  (define (lisp-value call frame-stream)
    (stream-flatmap
     (lambda (frame)
       (if (execute
	    (instantiate
		call
		frame
	      (lambda (v f)
		(error "Unknown pat var: LISP-VALUE" v))))
	   (singleton-stream frame)
	   the-empty-stream))
     frame-stream))
  (define (execute exp)
    (apply (eval (predicate exp) user-initial-environment)
	   (args exp)))
#+end_src

#+name: prolog-lisp-filter-installation
#+begin_src scheme :exports code :results none
  (put 'lisp-value 'qeval lisp-value)
#+end_src

#+name: prolog-always-true
#+begin_src scheme :exports code :results none
  (define (always-true ignore frame-stream) frame-stream)
  (put 'always-true 'qeval always-true)
#+end_src

#+name: prolog-pattern-matching
#+begin_src scheme :exports code :results none

  (define (find-assertions pattern frame)
    (stream-flatmap
     (lambda (datum) (check-an-assertion datum pattern frame))
     (fetch-assertions pattern frame)))
  (define (check-an-assertion assertion query-pat query-frame)
    (let ((match-result
	   (pattern-match query-pat assertion query-frame)))
      (if (eq? match-result 'failed)
	  the-empty-stream
	  (singleton-stream match-result))))
  (define (pattern-match pat dat frame)
    (cond ((eq? frame 'failed) 'failed)
	  ((equal? pat dat) frame)
	  ((var? pat) (extend-if-consistent pat dat frame))
	  ((and (pair? pat) (pair? dat))
	   (pattern-match
	    (cdr pat)
	    (cdr dat)
	    (pattern-match (car pat) (car dat) frame)))
	  (else 'failed)))
  (define (extend-if-consistent var dat frame)
    (let ((binding (binding-in-frame var frame)))
      (if binding
	  (pattern-match (binding-value binding) dat frame)
	  (extend var dat frame))))
#+end_src

#+name: prolog-rules-and-unification
#+begin_src scheme :exports code :results none

  (define (apply-rules pattern frame)
    (stream-flatmap (lambda (rule)
		      (apply-a-rule rule pattern frame))
		    (fetch-rules pattern frame)))

  (define (apply-a-rule rule query-pattern query-frame)
(show #t "apply-a-rule\n"  "rule=" (pretty rule) "pattern=" (pretty query-pattern)
                                       "frame=" (pretty query-frame))
    (let ((clean-rule (rename-variables-in rule)))
      (let ((unify-result (unify-match query-pattern
				       (conclusion clean-rule)
				       query-frame)))
(show #t "\nunify-result=" (pretty unify-result))
	(if (eq? unify-result 'failed)
	    the-empty-stream
	    (qeval (rule-body clean-rule)
		   (singleton-stream unify-result))))))

  (define (rename-variables-in rule)
    (let ((rule-application-id (new-rule-application-id)))
      (define (tree-walk exp)
	(cond ((var? exp)
	       (make-new-variable exp rule-application-id))
	      ((pair? exp)
	       (cons (tree-walk (car exp))
		     (tree-walk (cdr exp))))
	      (else exp)))
      (tree-walk rule)))

  (define (unify-match p1 p2 frame)
    (cond ((eq? frame 'failed) 'failed)
	  ((equal? p1 p2) frame)
	  ((var? p1) (extend-if-possible p1 p2 frame))
	  ((var? p2) (extend-if-possible p2 p1 frame))
					  ; ***
	  ((and (pair? p1) (pair? p2))
	   (unify-match (cdr p1)
			(cdr p2)
			(unify-match (car p1)
				     (car p2)
				     frame)))
	  (else 'failed)))

  (define (extend-if-possible var val frame)
    (let ((binding (binding-in-frame var frame)))
      (cond (binding
	     (unify-match (binding-value binding) val frame))
					  ; ***
	    ((var? val)
	     (let ((binding (binding-in-frame val frame)))
	       (if binding
		   (unify-match
		    var (binding-value binding) frame)
		   (extend var val frame))))
	    ((depends-on? val var frame)
					  ; ***
	     'failed)
	    (else (extend var val frame)))))

  (define (depends-on? exp var frame)
    (define (tree-walk e)
      (cond ((var? e)
	     (if (equal? var e)
		 true
		 (let ((b (binding-in-frame e frame)))
		   (if b
		       (tree-walk (binding-value b))
		       false))))
	    ((pair? e)
	     (or (tree-walk (car e))
		 (tree-walk (cdr e))))
	    (else false)))
    (tree-walk exp))
#+end_src

#+name: prolog-database
#+begin_src scheme :exports code :results none
  (define THE-ASSERTIONS the-empty-stream)
  (define (fetch-assertions pattern frame)
    (if (use-index? pattern)
	(get-indexed-assertions pattern)
	(get-all-assertions)))
  (define (get-all-assertions) THE-ASSERTIONS)
  (define (get-indexed-assertions pattern)
    (get-stream (index-key-of pattern) 'assertion-stream))
  (define (get-stream key1 key2)
    (let ((s (get key1 key2)))
      (if s s the-empty-stream)))

  (define THE-RULES the-empty-stream)
  (define (fetch-rules pattern frame)
    (if (use-index? pattern)
	(get-indexed-rules pattern)
	(get-all-rules)))
  (define (get-all-rules) THE-RULES)
  (define (get-indexed-rules pattern)
    (stream-append
     (get-stream (index-key-of pattern) 'rule-stream)
     (get-stream '? 'rule-stream)))
#+end_src

#+name: prolog-database-add-assertion-original
#+begin_src scheme :exports code :results none
  (define (add-rule-or-assertion! assertion)
    (if (rule? assertion)
	(add-rule! assertion)
	(add-assertion! assertion)))
  (define (add-assertion! assertion)
    (store-assertion-in-index assertion)
    (let ((old-assertions THE-ASSERTIONS))
      (set! THE-ASSERTIONS
	(cons-stream assertion old-assertions))
      'ok))
  (define (add-rule! rule)
    (store-rule-in-index rule)
    (let ((old-rules THE-RULES))
      (set! THE-RULES (cons-stream rule old-rules))
      'ok))
#+end_src

#+name: prolog-database-store-assertion-in-index
#+begin_src scheme :exports code :results none
  (define (store-assertion-in-index assertion)
    (if (indexable? assertion)
	(let ((key (index-key-of assertion)))
	  (let ((current-assertion-stream
		 (get-stream key 'assertion-stream)))
	    (put key
		 'assertion-stream
		 (cons-stream
		  assertion
		  current-assertion-stream))))))
  (define (store-rule-in-index rule)
    (let ((pattern (conclusion rule)))
      (if (indexable? pattern)
	  (let ((key (index-key-of pattern)))
	    (let ((current-rule-stream
		   (get-stream key 'rule-stream)))
	      (put key
		   'rule-stream
		   (cons-stream rule
				current-rule-stream)))))))
  (define (indexable? pat)
    (or (constant-symbol? (car pat))
	(var? (car pat))))
  (define (index-key-of pat)
    (let ((key (car pat)))
      (if (var? key) '? key)))
  (define (use-index? pat) (constant-symbol? (car pat)))
#+end_src

#+name: prolog-stream-operations
#+begin_src scheme :exports code :results none
  (define (stream-append-delayed s1 delayed-s2)
    (if (stream-null? s1)
	(force delayed-s2)
	(cons-stream
	 (stream-car s1)
	 (stream-append-delayed
	  (stream-cdr s1)
	  delayed-s2))))
  (define (interleave-delayed s1 delayed-s2)
    (if (stream-null? s1)
	(force delayed-s2)
	(cons-stream
	 (stream-car s1)
	 (interleave-delayed
	  (force delayed-s2)
	  (delay (stream-cdr s1))))))
#+end_src

#+name: prolog-stream-flatmap
#+begin_src scheme :exports code :results none
  (define (stream-flatmap proc s)
    (flatten-stream (stream-map proc s)))
#+end_src

#+name: prolog-flatten-stream
#+begin_src scheme :exports code :results none
  (define (flatten-stream stream)
    (if (stream-null? stream)
	the-empty-stream
	(interleave-delayed
	 (stream-car stream)
	 (delay (flatten-stream (stream-cdr stream))))))
#+end_src

#+name: streams-singleton
#+begin_src scheme :exports code :results none
(define (singleton-stream x)
  (cons-stream x the-empty-stream))
#+end_src

#+name: prolog-query
#+begin_src scheme :exports code :results none
  (define (type exp)
    (if (pair? exp)
	(car exp)
	(error "Unknown expression TYPE" exp)))
  (define (contents exp)
    (if (pair? exp)
	(cdr exp)
	(error "Unknown expression CONTENTS" exp)))
  (define (assertion-to-be-added? exp)
    (eq? (type exp) 'assert!))
  (define (add-assertion-body exp) (car (contents exp)))
  (define (empty-conjunction? exps) (null? exps))
  (define (first-conjunct exps) (car exps))
  (define (rest-conjuncts exps) (cdr exps))
  (define (empty-disjunction? exps) (null? exps))
  (define (first-disjunct exps) (car exps))
  (define (rest-disjuncts exps) (cdr exps))
  (define (negated-query exps) (car exps))
  (define (predicate exps) (car exps))
  (define (args exps) (cdr exps))
  (define (rule? statement)
    (tagged-list? statement 'rule))
  (define (conclusion rule) (cadr rule))
  (define (rule-body rule)
    (if (null? (cddr rule)) '(always-true) (caddr rule)))
  (define (query-syntax-process exp)
    (map-over-symbols expand-question-mark exp))
  (define (map-over-symbols proc exp)
    (cond ((pair? exp)
	   (cons (map-over-symbols proc (car exp))
		 (map-over-symbols proc (cdr exp))))
	  ((symbol? exp) (proc exp))
	  (else exp)))
  (define (expand-question-mark symbol)
    (let ((chars (symbol->string symbol)))
      (if (string=? (substring chars 0 1) "?")
	  (list '?
		(string->symbol
		 (substring chars 1 (string-length chars))))
	  symbol)))
  (define (var? exp) (tagged-list? exp '?))
  (define (constant-symbol? exp) (symbol? exp))
  (define rule-counter 0)
  (define (new-rule-application-id)
    (set! rule-counter (+ 1 rule-counter))
    rule-counter)
  (define (make-new-variable var rule-application-id)
    (cons '? (cons rule-application-id (cdr var))))
  (define (contract-question-mark variable)
    (string->symbol
     (string-append "?"
		    (if (number? (cadr variable))
			(string-append (symbol->string (caddr variable))
				       "-"
				       (number->string (cadr variable)))
			(symbol->string (cadr variable))))))
#+end_src

#+name: prolog-frames-and-bindings
#+begin_src scheme :exports code :results none
  (define (make-binding variable value)
  (if #f
     (begin
        (display "\nvariable=") (display (contract-question-mark variable))
        (display "\nvalue=") (display value)))
    (cons variable value))
  (define (binding-variable binding) (car binding))
  (define (binding-value binding) (cdr binding))
  (define (binding-in-frame variable frame)
    (assoc variable frame))
  (define (extend variable value frame)
    (cons (make-binding variable value) frame))
#+end_src

#+name: prolog-input-test-assert
#+begin_example scheme :exports code :results output
  (assert! (job (Bitdiddle Ben)
		(computer wizard)))
  (assert! (rule (wheel ?person)
		 (and (supervisor ?middle-manager ?person)
		      (supervisor ?x ?middle-manager))))
  (missing-fact)
  exit
#+end_example


#+header: :stdin prolog-input-test-assert
#+begin_src shell :shebang "#! /usr/bin/chibi-scheme" :exports both :results output scalar code :exports both
  <<prolog-glue>>
  <<put-and-get>>
  <<streams-common>>
  <<streams-2>>
  <<stream-append>>
  <<prolog-driver-loop>>
  <<prolog-instantiate>>
  <<prolog-qeval>>
  <<prolog-simple-queries>>
  <<prolog-conjoin>>
  <<prolog-conjoin-installation>>
  <<prolog-disjoin>>
  <<prolog-disjoin-installation>>
  <<prolog-negate>>
  <<prolog-negate-installation>>
  <<prolog-lisp-filter>>
  <<prolog-lisp-filter-installation>>
  <<prolog-always-true>>
  <<prolog-pattern-matching>>
  <<prolog-rules-and-unification>>
  <<prolog-database>>
  <<prolog-database-add-assertion-original>>
  <<prolog-database-store-assertion-in-index>>
  <<prolog-stream-operations>>
  <<prolog-stream-flatmap>>
  <<prolog-flatten-stream>>
  <<streams-singleton>>
  <<prolog-query>>
  <<prolog-frames-and-bindings>>
  (query-driver-loop)
#+end_src

#+RESULTS[cfe2df064215dc9b3a1c4981e31e45cb17f1be15]:
#+begin_src shell

;;; Query input:
(assert! (job (Bitdiddle Ben) (computer wizard)))
Assertion added to data base.
;;; Query input:
(assert!
 (rule (wheel (? person))
       (and (supervisor (? middle-manager) (? person))
            (supervisor (? x) (? middle-manager)))))
Assertion added to data base.
;;; Query input:
(missing-fact)
;;; Query results:

debug:simple-query

;;; Query input:
exit
#+end_src

#+name: prolog-input-sample-database
#+begin_src scheme :exports code
  (assert! (address (Bitdiddle Ben) (Slumerville (Ridge Road) 10)))
  (assert! (job (Bitdiddle Ben) (computer wizard)))
  (assert! (salary (Bitdiddle Ben) 60000))

  (assert! (address (Hacker Alyssa P) (Cambridge (Mass Ave) 78)))
  (assert! (job (Hacker Alyssa P) (computer programmer)))
  (assert! (salary (Hacker Alyssa P) 40000))
  (assert! (supervisor (Hacker Alyssa P) (Bitdiddle Ben)))

  (assert! (address (Fect Cy D) (Cambridge (Ames Street) 3)))
  (assert! (job (Fect Cy D) (computer programmer)))
  (assert! (salary (Fect Cy D) 35000))
  (assert! (supervisor (Fect Cy D) (Bitdiddle Ben)))

  (assert! (address (Tweakit Lem E) (Boston (Bay State Road) 22)))
  (assert! (job (Tweakit Lem E) (computer technician)))
  (assert! (salary (Tweakit Lem E) 25000))
  (assert! (supervisor (Tweakit Lem E) (Bitdiddle Ben)))

  (assert! (address (Reasoner Louis) (Slumerville (Pine Tree Road) 80)))
  (assert! (job (Reasoner Louis) (computer programmer trainee)))
  (assert! (salary (Reasoner Louis) 30000))
  (assert! (supervisor (Reasoner Louis) (Hacker Alyssa P)))

  (assert! (supervisor (Bitdiddle Ben) (Warbucks Oliver)))
  (assert! (address (Warbucks Oliver) (Swellesley (Top Heap Road))))
  (assert! (job (Warbucks Oliver) (administration big wheel)))
  (assert! (salary (Warbucks Oliver) 150000))
  (assert! (address (Scrooge Eben) (Weston (Shady Lane) 10)))
  (assert! (job (Scrooge Eben) (accounting chief accountant)))
  (assert! (salary (Scrooge Eben) 75000))
  (assert! (supervisor (Scrooge Eben) (Warbucks Oliver)))
  (assert! (address (Cratchet Robert) (Allston (N Harvard Street) 16)))
  (assert! (job (Cratchet Robert) (accounting scrivener)))
  (assert! (salary (Cratchet Robert) 18000))
  (assert! (supervisor (Cratchet Robert) (Scrooge Eben)))
  (assert! (address (Aull DeWitt) (Slumerville (Onion Square) 5)))
  (assert! (job (Aull DeWitt) (administration secretary)))
  (assert! (salary (Aull DeWitt) 25000))
  (assert! (supervisor (Aull DeWitt) (Warbucks Oliver)))
  (assert! (can-do-job (computer wizard) (computer programmer)))
  (assert! (can-do-job (computer wizard) (computer technician)))
  (assert! (can-do-job (computer programmer) (computer programmer trainee)))
  (assert! (can-do-job (administration secretary) (administration big wheel)))
#+end_src

#+name: prolog-input-database-test
#+begin_src shell :exports code :results output scalar code
  cat <<EOF
  <<prolog-input-sample-database>>
  exit
  EOF
#+end_src

#+header: :stdin prolog-input-database-test
#+begin_src shell :shebang "#! /usr/bin/chibi-scheme" :exports both :results output scalar code :exports both
  <<prolog-glue>>
  <<put-and-get>>
  <<streams-common>>
  <<streams-2>>
  <<stream-append>>
  <<prolog-driver-loop>>
  <<prolog-instantiate>>
  <<prolog-qeval>>
  <<prolog-simple-queries>>
  <<prolog-conjoin>>
  <<prolog-conjoin-installation>>
  <<prolog-disjoin>>
  <<prolog-disjoin-installation>>
  <<prolog-negate>>
  <<prolog-negate-installation>>
  <<prolog-lisp-filter>>
  <<prolog-lisp-filter-installation>>
  <<prolog-always-true>>
  <<prolog-pattern-matching>>
  <<prolog-rules-and-unification>>
  <<prolog-database>>
  <<prolog-database-add-assertion-original>>
  <<prolog-database-store-assertion-in-index>>
  <<prolog-stream-operations>>
  <<prolog-stream-flatmap>>
  <<prolog-flatten-stream>>
  <<streams-singleton>>
  <<prolog-query>>
  <<prolog-frames-and-bindings>>
  (query-driver-loop)
#+end_src

#+RESULTS[c2285be47146c910d66efb1858976b521307c6f2]:
#+begin_src shell

;;; Query input:
(assert! (address (Bitdiddle Ben) (Slumerville (Ridge Road) 10)))
Assertion added to data base.
;;; Query input:
(assert! (job (Bitdiddle Ben) (computer wizard)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Bitdiddle Ben) 60000))
Assertion added to data base.
;;; Query input:
(assert! (address (Hacker Alyssa P) (Cambridge (Mass Ave) 78)))
Assertion added to data base.
;;; Query input:
(assert! (job (Hacker Alyssa P) (computer programmer)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Hacker Alyssa P) 40000))
Assertion added to data base.
;;; Query input:
(assert! (supervisor (Hacker Alyssa P) (Bitdiddle Ben)))
Assertion added to data base.
;;; Query input:
(assert! (address (Fect Cy D) (Cambridge (Ames Street) 3)))
Assertion added to data base.
;;; Query input:
(assert! (job (Fect Cy D) (computer programmer)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Fect Cy D) 35000))
Assertion added to data base.
;;; Query input:
(assert! (supervisor (Fect Cy D) (Bitdiddle Ben)))
Assertion added to data base.
;;; Query input:
(assert! (address (Tweakit Lem E) (Boston (Bay State Road) 22)))
Assertion added to data base.
;;; Query input:
(assert! (job (Tweakit Lem E) (computer technician)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Tweakit Lem E) 25000))
Assertion added to data base.
;;; Query input:
(assert! (supervisor (Tweakit Lem E) (Bitdiddle Ben)))
Assertion added to data base.
;;; Query input:
(assert! (address (Reasoner Louis) (Slumerville (Pine Tree Road) 80)))
Assertion added to data base.
;;; Query input:
(assert! (job (Reasoner Louis) (computer programmer trainee)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Reasoner Louis) 30000))
Assertion added to data base.
;;; Query input:
(assert! (supervisor (Reasoner Louis) (Hacker Alyssa P)))
Assertion added to data base.
;;; Query input:
(assert! (supervisor (Bitdiddle Ben) (Warbucks Oliver)))
Assertion added to data base.
;;; Query input:
(assert! (address (Warbucks Oliver) (Swellesley (Top Heap Road))))
Assertion added to data base.
;;; Query input:
(assert! (job (Warbucks Oliver) (administration big wheel)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Warbucks Oliver) 150000))
Assertion added to data base.
;;; Query input:
(assert! (address (Scrooge Eben) (Weston (Shady Lane) 10)))
Assertion added to data base.
;;; Query input:
(assert! (job (Scrooge Eben) (accounting chief accountant)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Scrooge Eben) 75000))
Assertion added to data base.
;;; Query input:
(assert! (supervisor (Scrooge Eben) (Warbucks Oliver)))
Assertion added to data base.
;;; Query input:
(assert! (address (Cratchet Robert) (Allston (N Harvard Street) 16)))
Assertion added to data base.
;;; Query input:
(assert! (job (Cratchet Robert) (accounting scrivener)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Cratchet Robert) 18000))
Assertion added to data base.
;;; Query input:
(assert! (supervisor (Cratchet Robert) (Scrooge Eben)))
Assertion added to data base.
;;; Query input:
(assert! (address (Aull DeWitt) (Slumerville (Onion Square) 5)))
Assertion added to data base.
;;; Query input:
(assert! (job (Aull DeWitt) (administration secretary)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Aull DeWitt) 25000))
Assertion added to data base.
;;; Query input:
(assert! (supervisor (Aull DeWitt) (Warbucks Oliver)))
Assertion added to data base.
;;; Query input:
(assert! (can-do-job (computer wizard) (computer programmer)))
Assertion added to data base.
;;; Query input:
(assert! (can-do-job (computer wizard) (computer technician)))
Assertion added to data base.
;;; Query input:
(assert! (can-do-job (computer programmer) (computer programmer trainee)))
Assertion added to data base.
;;; Query input:
(assert! (can-do-job (administration secretary) (administration big wheel)))
Assertion added to data base.
;;; Query input:
exit
#+end_src

***** DONE Exercise 4.70 Cons-stream delays its second argument
      CLOSED: [2020-02-20 Thu 17:08]

We cannot set ~THE-ASSERTIONS~ directly, because ~cons-stream~ delays
its second argument. Therefore, if we don't store a pointer to
~THE-ASSERTIONS~ beforehand, the cons part would always evaluate to
the evaluation-time value of ~THE-ASSERTIONS~.

***** DONE Exercise 4.71 Louis' simple queries
      CLOSED: [2020-02-21 Fri 20:56]

The original ~simple-query~ was like this:

#+begin_src scheme :exports code :results none
(define (simple-query query-pattern frame-stream)
    (stream-flatmap
     (lambda (frame)
       (stream-append-delayed
	(find-assertions query-pattern frame)
	(delay (apply-rules query-pattern frame))))
     frame-stream))
#+end_src

#+name: prolog-simple-queries-broken
#+begin_src scheme :exports code :results none
  (define (simple-query query-pattern frame-stream)
    (stream-flatmap
     (lambda (frame)
       (stream-append
	(find-assertions query-pattern frame)
	(apply-rules query-pattern frame)))
     frame-stream))
#+end_src

The original ~disjoin~ was.

#+begin_src scheme :exports code :results none
  (define (disjoin disjuncts frame-stream)
    (if (empty-disjunction? disjuncts)
	the-empty-stream
	(interleave-delayed
	 (qeval (first-disjunct disjuncts) frame-stream)
	 (delay (disjoin (rest-disjuncts disjuncts) frame-stream)))))
#+end_src


#+name: prolog-disjoin-broken
#+begin_src scheme :exports code :results none
  (define (disjoin disjuncts frame-stream)
    (if (empty-disjunction? disjuncts)
	the-empty-stream
	(interleave
	 (qeval (first-disjunct disjuncts)
		frame-stream)
	 (disjoin (rest-disjuncts disjuncts)
		  frame-stream))))
#+end_src

Let's assemble a "broken" interpreter.

#+name: prolog-input-broken-simple-query-and-disjoin
#+begin_src shell :exports code :results verbatim output
  printf "%s" '

  (assert! (dummy a))
  (assert! (dummy b))
  (assert! (dummy c))
  (assert! (rule (dummy ?x) (dummy ?x)))
  (dummy ?who)
  exit'
#+end_src

This is one of the cases which is hard to illustrate with chibi+org,
because this combination will print the results only after they are
delivered. Therefore I install a debugging snap-in.

#+header: :stdin prolog-input-broken-simple-query-and-disjoin
#+begin_src shell :shebang "#! /usr/bin/chibi-scheme" :exports code :results output scalar code :exports both

  <<prolog-glue>>
  <<prolog-debugging-help>>
  <<put-and-get>>
  <<streams-common>>
  <<streams-2>>
  <<stream-append>>
  <<streams-interleave>>
  <<prolog-driver-loop>>
  <<prolog-instantiate>>
  <<prolog-qeval>>
  <<prolog-simple-queries-broken>>

  <<prolog-conjoin>>
  <<prolog-conjoin-installation>>
  <<prolog-disjoin-broken>>

  <<prolog-disjoin-installation>>
  <<prolog-negate>>
  <<prolog-negate-installation>>
  <<prolog-lisp-filter>>
  <<prolog-lisp-filter-installation>>
  <<prolog-always-true>>
  <<prolog-pattern-matching>>
  <<prolog-rules-and-unification>>
  <<prolog-database>>
  <<prolog-database-add-assertion-original>>
  <<prolog-database-store-assertion-in-index>>
  <<prolog-stream-operations>>
  <<prolog-stream-flatmap>>
  <<prolog-flatten-stream>>
  <<streams-singleton>>
  <<prolog-query>>
  <<prolog-frames-and-bindings>>

  (query-driver-loop)
#+end_src

#+RESULTS[7680415fa64064e0d14cbe56ffb0193f6a295101]:
#+begin_src shell

;;; Query input:
(assert! (dummy a))
Assertion added to data base.
;;; Query input:
(assert! (dummy b))
Assertion added to data base.
;;; Query input:
(assert! (dummy c))
Assertion added to data base.
;;; Query input:
(assert! (rule (dummy (? x)) (dummy (? x))))
Assertion added to data base.
;;; Query input:
(dummy (? who))
;;; Query results:


qeval:depth=1
query=(dummy (? who))

 frame-stream=( )apply-a-rule
rule=(rule (dummy (? x)) (dummy (? x)))
pattern=(dummy (? who))
frame=()

unify-result=(((? who) ? 1 x))


qeval:depth=2
query=(dummy (? 1 x))

 frame-stream=( (?who . ?x-1) 
)apply-a-rule
rule=(rule (dummy (? x)) (dummy (? x)))
pattern=(dummy (? 1 x))
frame=(((? who) ? 1 x))

unify-result=(((? 1 x) ? 2 x) ((? who) ? 1 x))


qeval:depth=3
query=(dummy (? 2 x))

 frame-stream=( (?x-1 . ?x-2) 
(?who . ?x-1) 
)apply-a-rule
rule=(rule (dummy (? x)) (dummy (? x)))
pattern=(dummy (? 2 x))
frame=(((? 1 x) ? 2 x) ((? who) ? 1 x))

unify-result=(((? 2 x) ? 3 x) ((? 1 x) ? 2 x) ((? who) ? 1 x))


qeval:depth=4
query=(dummy (? 3 x))

 frame-stream=( (?x-2 . ?x-3) 
(?x-1 . ?x-2) 
(?who . ?x-1) 
)apply-a-rule
rule=(rule (dummy (? x)) (dummy (? x)))
pattern=(dummy (? 3 x))
frame=(((? 2 x) ? 3 x) ((? 1 x) ? 2 x) ((? who) ? 1 x))

unify-result=(((? 3 x) ? 4 x) ((? 2 x) ? 3 x) ((? 1 x) ? 2 x) ((? who) ? 1 x))


qeval:depth=5
query=(dummy (? 4 x))

 frame-stream=( (?x-3 . ?x-4) 
(?x-2 . ?x-3) 
(?x-1 . ?x-2) 
(?who . ?x-1) 
)apply-a-rule
rule=(rule (dummy (? x)) (dummy (? x)))
pattern=(dummy (? 4 x))
frame=(((? 3 x) ? 4 x) ((? 2 x) ? 3 x) ((? 1 x) ? 2 x) ((? who) ? 1 x))

unify-result=(((? 4 x) ? 5 x) ((? 3 x) ? 4 x)
                              ((? 2 x) ? 3 x)
                              ((? 1 x) ? 2 x)
                              ((? who) ? 1 x))


qeval:depth=6
query=(dummy (? 5 x))

 frame-stream=( (?x-4 . ?x-5) 
(?x-3 . ?x-4) 
(?x-2 . ?x-3) 
(?x-1 . ?x-2) 
(?who . ?x-1) 
)apply-a-rule
rule=(rule (dummy (? x)) (dummy (? x)))
pattern=(dummy (? 5 x))
frame=(((? 4 x) ? 5 x) ((? 3 x) ? 4 x)
                       ((? 2 x) ? 3 x)
                       ((? 1 x) ? 2 x)
                       ((? who) ? 1 x))

unify-result=(((? 5 x) ? 6 x) ((? 4 x) ? 5 x)
                              ((? 3 x) ? 4 x)
                              ((? 2 x) ? 3 x)
                              ((? 1 x) ? 2 x)
                              ((? who) ? 1 x))


qeval:depth=7
query=(dummy (? 6 x))

 frame-stream=( (?x-5 . ?x-6) 
(?x-4 . ?x-5) 
(?x-3 . ?x-4) 
(?x-2 . ?x-3) 
(?x-1 . ?x-2) 
(?who . ?x-1) 
)apply-a-rule
rule=(rule (dummy (? x)) (dummy (? x)))
pattern=(dummy (? 6 x))
frame=(((? 5 x) ? 6 x) ((? 4 x) ? 5 x)
                       ((? 3 x) ? 4 x)
                       ((? 2 x) ? 3 x)
                       ((? 1 x) ? 2 x)
                       ((? who) ? 1 x))

unify-result=(((? 6 x) ? 7 x) ((? 5 x) ? 6 x)
                              ((? 4 x) ? 5 x)
                              ((? 3 x) ? 4 x)
                              ((? 2 x) ? 3 x)
                              ((? 1 x) ? 2 x)
                              ((? who) ? 1 x))


qeval:depth=8
query=(dummy (? 7 x))

 frame-stream=( (?x-6 . ?x-7) 
(?x-5 . ?x-6) 
(?x-4 . ?x-5) 
(?x-3 . ?x-4) 
(?x-2 . ?x-3) 
(?x-1 . ?x-2) 
(?who . ?x-1) 
)apply-a-rule
rule=(rule (dummy (? x)) (dummy (? x)))
pattern=(dummy (? 7 x))
frame=(((? 6 x) ? 7 x) ((? 5 x) ? 6 x)
                       ((? 4 x) ? 5 x)
                       ((? 3 x) ? 4 x)
                       ((? 2 x) ? 3 x)
                       ((? 1 x) ? 2 x)
                       ((? who) ? 1 x))

unify-result=(((? 7 x) ? 8 x) ((? 6 x) ? 7 x)
                              ((? 5 x) ? 6 x)
                              ((? 4 x) ? 5 x)
                              ((? 3 x) ? 4 x)
                              ((? 2 x) ? 3 x)
                              ((? 1 x) ? 2 x)
                              ((? who) ? 1 x))


qeval:depth=9
query=(dummy (? 8 x))

 frame-stream=( (?x-7 . ?x-8) 
(?x-6 . ?x-7) 
(?x-5 . ?x-6) 
(?x-4 . ?x-5) 
(?x-3 . ?x-4) 
(?x-2 . ?x-3) 
(?x-1 . ?x-2) 
(?who . ?x-1) 
)apply-a-rule
rule=(rule (dummy (? x)) (dummy (? x)))
pattern=(dummy (? 8 x))
frame=(((? 7 x) ? 8 x) ((? 6 x) ? 7 x)
                       ((? 5 x) ? 6 x)
                       ((? 4 x) ? 5 x)
                       ((? 3 x) ? 4 x)
                       ((? 2 x) ? 3 x)
                       ((? 1 x) ? 2 x)
                       ((? who) ? 1 x))

unify-result=(((? 8 x) ? 9 x) ((? 7 x) ? 8 x)
                              ((? 6 x) ? 7 x)
                              ((? 5 x) ? 6 x)
                              ((? 4 x) ? 5 x)
                              ((? 3 x) ? 4 x)
                              ((? 2 x) ? 3 x)
                              ((? 1 x) ? 2 x)
                              ((? who) ? 1 x))


qeval:depth=10
query=(dummy (? 9 x))

 frame-stream=( (?x-8 . ?x-9) 
(?x-7 . ?x-8) 
(?x-6 . ?x-7) 
(?x-5 . ?x-6) 
(?x-4 . ?x-5) 
(?x-3 . ?x-4) 
(?x-2 . ?x-3) 
(?x-1 . ?x-2) 
(?who . ?x-1) 
)apply-a-rule
rule=(rule (dummy (? x)) (dummy (? x)))
pattern=(dummy (? 9 x))
frame=(((? 8 x) ? 9 x) ((? 7 x) ? 8 x)
                       ((? 6 x) ? 7 x)
                       ((? 5 x) ? 6 x)
                       ((? 4 x) ? 5 x)
                       ((? 3 x) ? 4 x)
                       ((? 2 x) ? 3 x)
                       ((? 1 x) ? 2 x)
                       ((? who) ? 1 x))

unify-result=(((? 9 x) ? 10 x) ((? 8 x) ? 9 x)
                               ((? 7 x) ? 8 x)
                               ((? 6 x) ? 7 x)
                               ((? 5 x) ? 6 x)
                               ((? 4 x) ? 5 x)
                               ((? 3 x) ? 4 x)
                               ((? 2 x) ? 3 x)
                               ((? 1 x) ? 2 x)
                               ((? who) ? 1 x))


qeval:depth=11
query=(dummy (? 10 x))

 frame-stream=( (?x-9 . ?x-10) 
(?x-8 . ?x-9) 
(?x-7 . ?x-8) 
(?x-6 . ?x-7) 
(?x-5 . ?x-6) 
(?x-4 . ?x-5) 
(?x-3 . ?x-4) 
(?x-2 . ?x-3) 
(?x-1 . ?x-2) 
(?who . ?x-1) 
)apply-a-rule
rule=(rule (dummy (? x)) (dummy (? x)))
pattern=(dummy (? 10 x))
frame=(((? 9 x) ? 10 x) ((? 8 x) ? 9 x)
                        ((? 7 x) ? 8 x)
                        ((? 6 x) ? 7 x)
                        ((? 5 x) ? 6 x)
                        ((? 4 x) ? 5 x)
                        ((? 3 x) ? 4 x)
                        ((? 2 x) ? 3 x)
                        ((? 1 x) ? 2 x)
                        ((? who) ? 1 x))

unify-result=(((? 10 x) ? 11 x) ((? 9 x) ? 10 x)
                                ((? 8 x) ? 9 x)
                                ((? 7 x) ? 8 x)
                                ((? 6 x) ? 7 x)
                                ((? 5 x) ? 6 x)
                                ((? 4 x) ? 5 x)
                                ((? 3 x) ? 4 x)
                                ((? 2 x) ? 3 x)
                                ((? 1 x) ? 2 x)
                                ((? who) ? 1 x))


qeval:depth=12
query=(dummy (? 11 x))

 frame-stream=( (?x-10 . ?x-11) 
(?x-9 . ?x-10) 
(?x-8 . ?x-9) 
(?x-7 . ?x-8) 
(?x-6 . ?x-7) 
(?x-5 . ?x-6) 
(?x-4 . ?x-5) 
(?x-3 . ?x-4) 
(?x-2 . ?x-3) 
(?x-1 . ?x-2) 
(?who . ?x-1) 
)apply-a-rule
rule=(rule (dummy (? x)) (dummy (? x)))
pattern=(dummy (? 11 x))
frame=(((? 10 x) ? 11 x) ((? 9 x) ? 10 x)
                         ((? 8 x) ? 9 x)
                         ((? 7 x) ? 8 x)
                         ((? 6 x) ? 7 x)
                         ((? 5 x) ? 6 x)
                         ((? 4 x) ? 5 x)
                         ((? 3 x) ? 4 x)
                         ((? 2 x) ? 3 x)
                         ((? 1 x) ? 2 x)
                         ((? who) ? 1 x))

unify-result=(((? 11 x) ? 12 x) ((? 10 x) ? 11 x)
                                ((? 9 x) ? 10 x)
                                ((? 8 x) ? 9 x)
                                ((? 7 x) ? 8 x)
                                ((? 6 x) ? 7 x)
                                ((? 5 x) ? 6 x)
                                ((? 4 x) ? 5 x)
                                ((? 3 x) ? 4 x)
                                ((? 2 x) ? 3 x)
                                ((? 1 x) ? 2 x)
                                ((? who) ? 1 x))


qeval:depth=13
query=(dummy (? 12 x))

 frame-stream=( (?x-11 . ?x-12) 
(?x-10 . ?x-11) 
(?x-9 . ?x-10) 
(?x-8 . ?x-9) 
(?x-7 . ?x-8) 
(?x-6 . ?x-7) 
(?x-5 . ?x-6) 
(?x-4 . ?x-5) 
(?x-3 . ?x-4) 
(?x-2 . ?x-3) 
(?x-1 . ?x-2) 
(?who . ?x-1) 
)apply-a-rule
rule=(rule (dummy (? x)) (dummy (? x)))
pattern=(dummy (? 12 x))
frame=(((? 11 x) ? 12 x) ((? 10 x) ? 11 x)
                         ((? 9 x) ? 10 x)
                         ((? 8 x) ? 9 x)
                         ((? 7 x) ? 8 x)
                         ((? 6 x) ? 7 x)
                         ((? 5 x) ? 6 x)
                         ((? 4 x) ? 5 x)
                         ((? 3 x) ? 4 x)
                         ((? 2 x) ? 3 x)
                         ((? 1 x) ? 2 x)
                         ((? who) ? 1 x))

unify-result=(((? 12 x) ? 13 x) ((? 11 x) ? 12 x)
                                ((? 10 x) ? 11 x)
                                ((? 9 x) ? 10 x)
                                ((? 8 x) ? 9 x)
                                ((? 7 x) ? 8 x)
                                ((? 6 x) ? 7 x)
                                ((? 5 x) ? 6 x)
                                ((? 4 x) ? 5 x)
                                ((? 3 x) ? 4 x)
                                ((? 2 x) ? 3 x)
                                ((? 1 x) ? 2 x)
                                ((? who) ? 1 x))


qeval:depth=14
query=(dummy (? 13 x))

 frame-stream=( (?x-12 . ?x-13) 
(?x-11 . ?x-12) 
(?x-10 . ?x-11) 
(?x-9 . ?x-10) 
(?x-8 . ?x-9) 
(?x-7 . ?x-8) 
(?x-6 . ?x-7) 
(?x-5 . ?x-6) 
(?x-4 . ?x-5) 
(?x-3 . ?x-4) 
(?x-2 . ?x-3) 
(?x-1 . ?x-2) 
(?who . ?x-1) 
)apply-a-rule
rule=(rule (dummy (? x)) (dummy (? x)))
pattern=(dummy (? 13 x))
frame=(((? 12 x) ? 13 x) ((? 11 x) ? 12 x)
                         ((? 10 x) ? 11 x)
                         ((? 9 x) ? 10 x)
                         ((? 8 x) ? 9 x)
                         ((? 7 x) ? 8 x)
                         ((? 6 x) ? 7 x)
                         ((? 5 x) ? 6 x)
                         ((? 4 x) ? 5 x)
                         ((? 3 x) ? 4 x)
                         ((? 2 x) ? 3 x)
                         ((? 1 x) ? 2 x)
                         ((? who) ? 1 x))

unify-result=(((? 13 x) ? 14 x) ((? 12 x) ? 13 x)
                                ((? 11 x) ? 12 x)
                                ((? 10 x) ? 11 x)
                                ((? 9 x) ? 10 x)
                                ((? 8 x) ? 9 x)
                                ((? 7 x) ? 8 x)
                                ((? 6 x) ? 7 x)
                                ((? 5 x) ? 6 x)
                                ((? 4 x) ? 5 x)
                                ((? 3 x) ? 4 x)
                                ((? 2 x) ? 3 x)
                                ((? 1 x) ? 2 x)
                                ((? who) ? 1 x))


qeval:depth=15
query=(dummy (? 14 x))

 frame-stream=( (?x-13 . ?x-14) 
(?x-12 . ?x-13) 
(?x-11 . ?x-12) 
(?x-10 . ?x-11) 
(?x-9 . ?x-10) 
(?x-8 . ?x-9) 
(?x-7 . ?x-8) 
(?x-6 . ?x-7) 
(?x-5 . ?x-6) 
(?x-4 . ?x-5) 
(?x-3 . ?x-4) 
(?x-2 . ?x-3) 
(?x-1 . ?x-2) 
(?who . ?x-1) 
)apply-a-rule
rule=(rule (dummy (? x)) (dummy (? x)))
pattern=(dummy (? 14 x))
frame=(((? 13 x) ? 14 x) ((? 12 x) ? 13 x)
                         ((? 11 x) ? 12 x)
                         ((? 10 x) ? 11 x)
                         ((? 9 x) ? 10 x)
                         ((? 8 x) ? 9 x)
                         ((? 7 x) ? 8 x)
                         ((? 6 x) ? 7 x)
                         ((? 5 x) ? 6 x)
                         ((? 4 x) ? 5 x)
                         ((? 3 x) ? 4 x)
                         ((? 2 x) ? 3 x)
                         ((? 1 x) ? 2 x)
                         ((? who) ? 1 x))

unify-result=(((? 14 x) ? 15 x) ((? 13 x) ? 14 x)
                                ((? 12 x) ? 13 x)
                                ((? 11 x) ? 12 x)
                                ((? 10 x) ? 11 x)
                                ((? 9 x) ? 10 x)
                                ((? 8 x) ? 9 x)
                                ((? 7 x) ? 8 x)
                                ((? 6 x) ? 7 x)
                                ((? 5 x) ? 6 x)
                                ((? 4 x) ? 5 x)
                                ((? 3 x) ? 4 x)
                                ((? 2 x) ? 3 x)
                                ((? 1 x) ? 2 x)
                                ((? who) ? 1 x))


qeval:depth=16
query=(dummy (? 15 x))

 frame-stream=( (?x-14 . ?x-15) 
(?x-13 . ?x-14) 
(?x-12 . ?x-13) 
(?x-11 . ?x-12) 
(?x-10 . ?x-11) 
(?x-9 . ?x-10) 
(?x-8 . ?x-9) 
(?x-7 . ?x-8) 
(?x-6 . ?x-7) 
(?x-5 . ?x-6) 
(?x-4 . ?x-5) 
(?x-3 . ?x-4) 
(?x-2 . ?x-3) 
(?x-1 . ?x-2) 
(?who . ?x-1) 
)apply-a-rule
rule=(rule (dummy (? x)) (dummy (? x)))
pattern=(dummy (? 15 x))
frame=(((? 14 x) ? 15 x) ((? 13 x) ? 14 x)
                         ((? 12 x) ? 13 x)
                         ((? 11 x) ? 12 x)
                         ((? 10 x) ? 11 x)
                         ((? 9 x) ? 10 x)
                         ((? 8 x) ? 9 x)
                         ((? 7 x) ? 8 x)
                         ((? 6 x) ? 7 x)
                         ((? 5 x) ? 6 x)
                         ((? 4 x) ? 5 x)
                         ((? 3 x) ? 4 x)
                         ((? 2 x) ? 3 x)
                         ((? 1 x) ? 2 x)
                         ((? who) ? 1 x))

unify-result=(((? 15 x) ? 16 x) ((? 14 x) ? 15 x)
                                ((? 13 x) ? 14 x)
                                ((? 12 x) ? 13 x)
                                ((? 11 x) ? 12 x)
                                ((? 10 x) ? 11 x)
                                ((? 9 x) ? 10 x)
                                ((? 8 x) ? 9 x)
                                ((? 7 x) ? 8 x)
                                ((? 6 x) ? 7 x)
                                ((? 5 x) ? 6 x)
                                ((? 4 x) ? 5 x)
                                ((? 3 x) ? 4 x)
                                ((? 2 x) ? 3 x)
                                ((? 1 x) ? 2 x)
                                ((? who) ? 1 x))


qeval:depth=17
query=(dummy (? 16 x))

 frame-stream=( (?x-15 . ?x-16) 
(?x-14 . ?x-15) 
(?x-13 . ?x-14) 
(?x-12 . ?x-13) 
(?x-11 . ?x-12) 
(?x-10 . ?x-11) 
(?x-9 . ?x-10) 
(?x-8 . ?x-9) 
(?x-7 . ?x-8) 
(?x-6 . ?x-7) 
(?x-5 . ?x-6) 
(?x-4 . ?x-5) 
(?x-3 . ?x-4) 
(?x-2 . ?x-3) 
(?x-1 . ?x-2) 
(?who . ?x-1) 
)apply-a-rule
rule=(rule (dummy (? x)) (dummy (? x)))
pattern=(dummy (? 16 x))
frame=(((? 15 x) ? 16 x) ((? 14 x) ? 15 x)
                         ((? 13 x) ? 14 x)
                         ((? 12 x) ? 13 x)
                         ((? 11 x) ? 12 x)
                         ((? 10 x) ? 11 x)
                         ((? 9 x) ? 10 x)
                         ((? 8 x) ? 9 x)
                         ((? 7 x) ? 8 x)
                         ((? 6 x) ? 7 x)
                         ((? 5 x) ? 6 x)
                         ((? 4 x) ? 5 x)
                         ((? 3 x) ? 4 x)
                         ((? 2 x) ? 3 x)
                         ((? 1 x) ? 2 x)
                         ((? who) ? 1 x))

unify-result=(((? 16 x) ? 17 x) ((? 15 x) ? 16 x)
                                ((? 14 x) ? 15 x)
                                ((? 13 x) ? 14 x)
                                ((? 12 x) ? 13 x)
                                ((? 11 x) ? 12 x)
                                ((? 10 x) ? 11 x)
                                ((? 9 x) ? 10 x)
                                ((? 8 x) ? 9 x)
                                ((? 7 x) ? 8 x)
                                ((? 6 x) ? 7 x)
                                ((? 5 x) ? 6 x)
                                ((? 4 x) ? 5 x)
                                ((? 3 x) ? 4 x)
                                ((? 2 x) ? 3 x)
                                ((? 1 x) ? 2 x)
                                ((? who) ? 1 x))


qeval:depth=18
query=(dummy (? 17 x))

 frame-stream=( (?x-16 . ?x-17) 
(?x-15 . ?x-16) 
(?x-14 . ?x-15) 
(?x-13 . ?x-14) 
(?x-12 . ?x-13) 
(?x-11 . ?x-12) 
(?x-10 . ?x-11) 
(?x-9 . ?x-10) 
(?x-8 . ?x-9) 
(?x-7 . ?x-8) 
(?x-6 . ?x-7) 
(?x-5 . ?x-6) 
(?x-4 . ?x-5) 
(?x-3 . ?x-4) 
(?x-2 . ?x-3) 
(?x-1 . ?x-2) 
(?who . ?x-1) 
)apply-a-rule
rule=(rule (dummy (? x)) (dummy (? x)))
pattern=(dummy (? 17 x))
frame=(((? 16 x) ? 17 x) ((? 15 x) ? 16 x)
                         ((? 14 x) ? 15 x)
                         ((? 13 x) ? 14 x)
                         ((? 12 x) ? 13 x)
                         ((? 11 x) ? 12 x)
                         ((? 10 x) ? 11 x)
                         ((? 9 x) ? 10 x)
                         ((? 8 x) ? 9 x)
                         ((? 7 x) ? 8 x)
                         ((? 6 x) ? 7 x)
                         ((? 5 x) ? 6 x)
                         ((? 4 x) ? 5 x)
                         ((? 3 x) ? 4 x)
                         ((? 2 x) ? 3 x)
                         ((? 1 x) ? 2 x)
                         ((? who) ? 1 x))

unify-result=(((? 17 x) ? 18 x) ((? 16 x) ? 17 x)
                                ((? 15 x) ? 16 x)
                                ((? 14 x) ? 15 x)
                                ((? 13 x) ? 14 x)
                                ((? 12 x) ? 13 x)
                                ((? 11 x) ? 12 x)
                                ((? 10 x) ? 11 x)
                                ((? 9 x) ? 10 x)
                                ((? 8 x) ? 9 x)
                                ((? 7 x) ? 8 x)
                                ((? 6 x) ? 7 x)
                                ((? 5 x) ? 6 x)
                                ((? 4 x) ? 5 x)
                                ((? 3 x) ? 4 x)
                                ((? 2 x) ? 3 x)
                                ((? 1 x) ? 2 x)
                                ((? who) ? 1 x))


qeval:depth=19
query=(dummy (? 18 x))

 frame-stream=( (?x-17 . ?x-18) 
(?x-16 . ?x-17) 
(?x-15 . ?x-16) 
(?x-14 . ?x-15) 
(?x-13 . ?x-14) 
(?x-12 . ?x-13) 
(?x-11 . ?x-12) 
(?x-10 . ?x-11) 
(?x-9 . ?x-10) 
(?x-8 . ?x-9) 
(?x-7 . ?x-8) 
(?x-6 . ?x-7) 
(?x-5 . ?x-6) 
(?x-4 . ?x-5) 
(?x-3 . ?x-4) 
(?x-2 . ?x-3) 
(?x-1 . ?x-2) 
(?who . ?x-1) 
)apply-a-rule
rule=(rule (dummy (? x)) (dummy (? x)))
pattern=(dummy (? 18 x))
frame=(((? 17 x) ? 18 x) ((? 16 x) ? 17 x)
                         ((? 15 x) ? 16 x)
                         ((? 14 x) ? 15 x)
                         ((? 13 x) ? 14 x)
                         ((? 12 x) ? 13 x)
                         ((? 11 x) ? 12 x)
                         ((? 10 x) ? 11 x)
                         ((? 9 x) ? 10 x)
                         ((? 8 x) ? 9 x)
                         ((? 7 x) ? 8 x)
                         ((? 6 x) ? 7 x)
                         ((? 5 x) ? 6 x)
                         ((? 4 x) ? 5 x)
                         ((? 3 x) ? 4 x)
                         ((? 2 x) ? 3 x)
                         ((? 1 x) ? 2 x)
                         ((? who) ? 1 x))

unify-result=(((? 18 x) ? 19 x) ((? 17 x) ? 18 x)
                                ((? 16 x) ? 17 x)
                                ((? 15 x) ? 16 x)
                                ((? 14 x) ? 15 x)
                                ((? 13 x) ? 14 x)
                                ((? 12 x) ? 13 x)
                                ((? 11 x) ? 12 x)
                                ((? 10 x) ? 11 x)
                                ((? 9 x) ? 10 x)
                                ((? 8 x) ? 9 x)
                                ((? 7 x) ? 8 x)
                                ((? 6 x) ? 7 x)
                                ((? 5 x) ? 6 x)
                                ((? 4 x) ? 5 x)
                                ((? 3 x) ? 4 x)
                                ((? 2 x) ? 3 x)
                                ((? 1 x) ? 2 x)
                                ((? who) ? 1 x))


qeval:depth=20
query=(dummy (? 19 x))

 frame-stream=( (?x-18 . ?x-19) 
(?x-17 . ?x-18) 
(?x-16 . ?x-17) 
(?x-15 . ?x-16) 
(?x-14 . ?x-15) 
(?x-13 . ?x-14) 
(?x-12 . ?x-13) 
(?x-11 . ?x-12) 
(?x-10 . ?x-11) 
(?x-9 . ?x-10) 
(?x-8 . ?x-9) 
(?x-7 . ?x-8) 
(?x-6 . ?x-7) 
(?x-5 . ?x-6) 
(?x-4 . ?x-5) 
(?x-3 . ?x-4) 
(?x-2 . ?x-3) 
(?x-1 . ?x-2) 
(?who . ?x-1) 
)apply-a-rule
rule=(rule (dummy (? x)) (dummy (? x)))
pattern=(dummy (? 19 x))
frame=(((? 18 x) ? 19 x) ((? 17 x) ? 18 x)
                         ((? 16 x) ? 17 x)
                         ((? 15 x) ? 16 x)
                         ((? 14 x) ? 15 x)
                         ((? 13 x) ? 14 x)
                         ((? 12 x) ? 13 x)
                         ((? 11 x) ? 12 x)
                         ((? 10 x) ? 11 x)
                         ((? 9 x) ? 10 x)
                         ((? 8 x) ? 9 x)
                         ((? 7 x) ? 8 x)
                         ((? 6 x) ? 7 x)
                         ((? 5 x) ? 6 x)
                         ((? 4 x) ? 5 x)
                         ((? 3 x) ? 4 x)
                         ((? 2 x) ? 3 x)
                         ((? 1 x) ? 2 x)
                         ((? who) ? 1 x))

unify-result=(((? 19 x) ? 20 x) ((? 18 x) ? 19 x)
                                ((? 17 x) ? 18 x)
                                ((? 16 x) ? 17 x)
                                ((? 15 x) ? 16 x)
                                ((? 14 x) ? 15 x)
                                ((? 13 x) ? 14 x)
                                ((? 12 x) ? 13 x)
                                ((? 11 x) ? 12 x)
                                ((? 10 x) ? 11 x)
                                ((? 9 x) ? 10 x)
                                ((? 8 x) ? 9 x)
                                ((? 7 x) ? 8 x)
                                ((? 6 x) ? 7 x)
                                ((? 5 x) ? 6 x)
                                ((? 4 x) ? 5 x)
                                ((? 3 x) ? 4 x)
                                ((? 2 x) ? 3 x)
                                ((? 1 x) ? 2 x)
                                ((? who) ? 1 x))


qeval:depth=21
query=(dummy (? 20 x))

 frame-stream=( (?x-19 . ?x-20) 
(?x-18 . ?x-19) 
(?x-17 . ?x-18) 
(?x-16 . ?x-17) 
(?x-15 . ?x-16) 
(?x-14 . ?x-15) 
(?x-13 . ?x-14) 
(?x-12 . ?x-13) 
(?x-11 . ?x-12) 
(?x-10 . ?x-11) 
(?x-9 . ?x-10) 
(?x-8 . ?x-9) 
(?x-7 . ?x-8) 
(?x-6 . ?x-7) 
(?x-5 . ?x-6) 
(?x-4 . ?x-5) 
(?x-3 . ?x-4) 
(?x-2 . ?x-3) 
(?x-1 . ?x-2) 
(?who . ?x-1) 
)
Maximum depth reached.
 retval=( (?x-19 . c) 
(?x-18 . ?x-19) 
(?x-17 . ?x-18) 
(?x-16 . ?x-17) 
(?x-15 . ?x-16) 
(?x-14 . ?x-15) 
(?x-13 . ?x-14) 
(?x-12 . ?x-13) 
(?x-11 . ?x-12) 
(?x-10 . ?x-11) 
(?x-9 . ?x-10) 
(?x-8 . ?x-9) 
(?x-7 . ?x-8) 
(?x-6 . ?x-7) 
(?x-5 . ?x-6) 
(?x-4 . ?x-5) 
(?x-3 . ?x-4) 
(?x-2 . ?x-3) 
(?x-1 . ?x-2) 
(?who . ?x-1) 
)
 retval=( (?x-18 . c) 
(?x-17 . ?x-18) 
(?x-16 . ?x-17) 
(?x-15 . ?x-16) 
(?x-14 . ?x-15) 
(?x-13 . ?x-14) 
(?x-12 . ?x-13) 
(?x-11 . ?x-12) 
(?x-10 . ?x-11) 
(?x-9 . ?x-10) 
(?x-8 . ?x-9) 
(?x-7 . ?x-8) 
(?x-6 . ?x-7) 
(?x-5 . ?x-6) 
(?x-4 . ?x-5) 
(?x-3 . ?x-4) 
(?x-2 . ?x-3) 
(?x-1 . ?x-2) 
(?who . ?x-1) 
)
 retval=( (?x-17 . c) 
(?x-16 . ?x-17) 
(?x-15 . ?x-16) 
(?x-14 . ?x-15) 
(?x-13 . ?x-14) 
(?x-12 . ?x-13) 
(?x-11 . ?x-12) 
(?x-10 . ?x-11) 
(?x-9 . ?x-10) 
(?x-8 . ?x-9) 
(?x-7 . ?x-8) 
(?x-6 . ?x-7) 
(?x-5 . ?x-6) 
(?x-4 . ?x-5) 
(?x-3 . ?x-4) 
(?x-2 . ?x-3) 
(?x-1 . ?x-2) 
(?who . ?x-1) 
)
 retval=( (?x-16 . c) 
(?x-15 . ?x-16) 
(?x-14 . ?x-15) 
(?x-13 . ?x-14) 
(?x-12 . ?x-13) 
(?x-11 . ?x-12) 
(?x-10 . ?x-11) 
(?x-9 . ?x-10) 
(?x-8 . ?x-9) 
(?x-7 . ?x-8) 
(?x-6 . ?x-7) 
(?x-5 . ?x-6) 
(?x-4 . ?x-5) 
(?x-3 . ?x-4) 
(?x-2 . ?x-3) 
(?x-1 . ?x-2) 
(?who . ?x-1) 
)
 retval=( (?x-15 . c) 
(?x-14 . ?x-15) 
(?x-13 . ?x-14) 
(?x-12 . ?x-13) 
(?x-11 . ?x-12) 
(?x-10 . ?x-11) 
(?x-9 . ?x-10) 
(?x-8 . ?x-9) 
(?x-7 . ?x-8) 
(?x-6 . ?x-7) 
(?x-5 . ?x-6) 
(?x-4 . ?x-5) 
(?x-3 . ?x-4) 
(?x-2 . ?x-3) 
(?x-1 . ?x-2) 
(?who . ?x-1) 
)
 retval=( (?x-14 . c) 
(?x-13 . ?x-14) 
(?x-12 . ?x-13) 
(?x-11 . ?x-12) 
(?x-10 . ?x-11) 
(?x-9 . ?x-10) 
(?x-8 . ?x-9) 
(?x-7 . ?x-8) 
(?x-6 . ?x-7) 
(?x-5 . ?x-6) 
(?x-4 . ?x-5) 
(?x-3 . ?x-4) 
(?x-2 . ?x-3) 
(?x-1 . ?x-2) 
(?who . ?x-1) 
)
 retval=( (?x-13 . c) 
(?x-12 . ?x-13) 
(?x-11 . ?x-12) 
(?x-10 . ?x-11) 
(?x-9 . ?x-10) 
(?x-8 . ?x-9) 
(?x-7 . ?x-8) 
(?x-6 . ?x-7) 
(?x-5 . ?x-6) 
(?x-4 . ?x-5) 
(?x-3 . ?x-4) 
(?x-2 . ?x-3) 
(?x-1 . ?x-2) 
(?who . ?x-1) 
)
 retval=( (?x-12 . c) 
(?x-11 . ?x-12) 
(?x-10 . ?x-11) 
(?x-9 . ?x-10) 
(?x-8 . ?x-9) 
(?x-7 . ?x-8) 
(?x-6 . ?x-7) 
(?x-5 . ?x-6) 
(?x-4 . ?x-5) 
(?x-3 . ?x-4) 
(?x-2 . ?x-3) 
(?x-1 . ?x-2) 
(?who . ?x-1) 
)
 retval=( (?x-11 . c) 
(?x-10 . ?x-11) 
(?x-9 . ?x-10) 
(?x-8 . ?x-9) 
(?x-7 . ?x-8) 
(?x-6 . ?x-7) 
(?x-5 . ?x-6) 
(?x-4 . ?x-5) 
(?x-3 . ?x-4) 
(?x-2 . ?x-3) 
(?x-1 . ?x-2) 
(?who . ?x-1) 
)
 retval=( (?x-10 . c) 
(?x-9 . ?x-10) 
(?x-8 . ?x-9) 
(?x-7 . ?x-8) 
(?x-6 . ?x-7) 
(?x-5 . ?x-6) 
(?x-4 . ?x-5) 
(?x-3 . ?x-4) 
(?x-2 . ?x-3) 
(?x-1 . ?x-2) 
(?who . ?x-1) 
)
 retval=( (?x-9 . c) 
(?x-8 . ?x-9) 
(?x-7 . ?x-8) 
(?x-6 . ?x-7) 
(?x-5 . ?x-6) 
(?x-4 . ?x-5) 
(?x-3 . ?x-4) 
(?x-2 . ?x-3) 
(?x-1 . ?x-2) 
(?who . ?x-1) 
)
 retval=( (?x-8 . c) 
(?x-7 . ?x-8) 
(?x-6 . ?x-7) 
(?x-5 . ?x-6) 
(?x-4 . ?x-5) 
(?x-3 . ?x-4) 
(?x-2 . ?x-3) 
(?x-1 . ?x-2) 
(?who . ?x-1) 
)
 retval=( (?x-7 . c) 
(?x-6 . ?x-7) 
(?x-5 . ?x-6) 
(?x-4 . ?x-5) 
(?x-3 . ?x-4) 
(?x-2 . ?x-3) 
(?x-1 . ?x-2) 
(?who . ?x-1) 
)
 retval=( (?x-6 . c) 
(?x-5 . ?x-6) 
(?x-4 . ?x-5) 
(?x-3 . ?x-4) 
(?x-2 . ?x-3) 
(?x-1 . ?x-2) 
(?who . ?x-1) 
)
 retval=( (?x-5 . c) 
(?x-4 . ?x-5) 
(?x-3 . ?x-4) 
(?x-2 . ?x-3) 
(?x-1 . ?x-2) 
(?who . ?x-1) 
)
 retval=( (?x-4 . c) 
(?x-3 . ?x-4) 
(?x-2 . ?x-3) 
(?x-1 . ?x-2) 
(?who . ?x-1) 
)
 retval=( (?x-3 . c) 
(?x-2 . ?x-3) 
(?x-1 . ?x-2) 
(?who . ?x-1) 
)
 retval=( (?x-2 . c) 
(?x-1 . ?x-2) 
(?who . ?x-1) 
)
 retval=( (?x-1 . c) 
(?who . ?x-1) 
)
 retval=( (?who . c) 
)(dummy c)
(dummy b)
(dummy a)
(dummy c)
(dummy b)
(dummy a)
(dummy c)
(dummy b)
(dummy a)
(dummy c)
(dummy b)
(dummy a)
(dummy c)
(dummy b)
(dummy a)
(dummy c)
(dummy b)
(dummy a)
(dummy c)
(dummy b)
(dummy a)
(dummy c)
(dummy b)
(dummy a)
(dummy c)
(dummy b)
(dummy a)
(dummy c)
(dummy b)
(dummy a)
(dummy c)
(dummy b)
(dummy a)
(dummy c)
(dummy b)
(dummy a)
(dummy c)
(dummy b)
(dummy a)
(dummy c)
(dummy b)
(dummy a)
(dummy c)
(dummy b)
(dummy a)
(dummy c)
(dummy b)
(dummy a)
(dummy c)
(dummy b)
(dummy a)
(dummy c)
(dummy b)
(dummy a)
(dummy c)
(dummy b)
(dummy a)
(dummy c)
(dummy b)
(dummy a)

;;; Query input:
exit
#+end_src


#+header: :stdin prolog-input-broken-simple-query-and-disjoin
#+begin_src shell :shebang "#! /usr/bin/chibi-scheme" :exports code :results output scalar code :exports both

  <<prolog-glue>>
  <<prolog-debugging-help>>
  <<put-and-get>>
  <<streams-common>>
  <<streams-2>>
  <<stream-append>>
  <<streams-interleave>>
  <<prolog-driver-loop>>
  <<prolog-instantiate>>
  <<prolog-qeval>>
  <<prolog-simple-queries>>

  <<prolog-conjoin>>
  <<prolog-conjoin-installation>>
  <<prolog-disjoin>>

  <<prolog-disjoin-installation>>
  <<prolog-negate>>
  <<prolog-negate-installation>>
  <<prolog-lisp-filter>>
  <<prolog-lisp-filter-installation>>
  <<prolog-always-true>>
  <<prolog-pattern-matching>>
  <<prolog-rules-and-unification>>
  <<prolog-database>>
  <<prolog-database-add-assertion-original>>
  <<prolog-database-store-assertion-in-index>>
  <<prolog-stream-operations>>
  <<prolog-stream-flatmap>>
  <<prolog-flatten-stream>>
  <<streams-singleton>>
  <<prolog-query>>
  <<prolog-frames-and-bindings>>

  (query-driver-loop)
#+end_src

#+RESULTS[e0ad9dc339d9e25dc285742bc8656dbb9fa078cf]:
#+begin_src shell

;;; Query input:
(assert! (dummy a))
Assertion added to data base.
;;; Query input:
(assert! (dummy b))
Assertion added to data base.
;;; Query input:
(assert! (dummy c))
Assertion added to data base.
;;; Query input:
(assert! (rule (dummy (? x)) (dummy (? x))))
Assertion added to data base.
;;; Query input:
(dummy (? who))
;;; Query results:


qeval:depth=1
query=(dummy (? who))

 frame-stream=( )
debug:simple-query

 retval=( (?who . c) 
)(dummy c)
(dummy b)
(dummy a)
apply-a-rule
rule=(rule (dummy (? x)) (dummy (? x)))
pattern=(dummy (? who))
frame=()

unify-result=(((? who) ? 1 x))


qeval:depth=2
query=(dummy (? 1 x))

 frame-stream=( (?who . ?x-1) 
)
debug:simple-query

 retval=( (?x-1 . c) 
(?who . ?x-1) 
)(dummy c)
(dummy b)
(dummy a)
apply-a-rule
rule=(rule (dummy (? x)) (dummy (? x)))
pattern=(dummy (? 1 x))
frame=(((? who) ? 1 x))

unify-result=(((? 1 x) ? 2 x) ((? who) ? 1 x))


qeval:depth=3
query=(dummy (? 2 x))

 frame-stream=( (?x-1 . ?x-2) 
(?who . ?x-1) 
)
debug:simple-query

 retval=( (?x-2 . c) 
(?x-1 . ?x-2) 
(?who . ?x-1) 
)(dummy c)
(dummy b)
(dummy a)
apply-a-rule
rule=(rule (dummy (? x)) (dummy (? x)))
pattern=(dummy (? 2 x))
frame=(((? 1 x) ? 2 x) ((? who) ? 1 x))

unify-result=(((? 2 x) ? 3 x) ((? 1 x) ? 2 x) ((? who) ? 1 x))


qeval:depth=4
query=(dummy (? 3 x))

 frame-stream=( (?x-2 . ?x-3) 
(?x-1 . ?x-2) 
(?who . ?x-1) 
)
debug:simple-query

 retval=( (?x-3 . c) 
(?x-2 . ?x-3) 
(?x-1 . ?x-2) 
(?who . ?x-1) 
)(dummy c)
(dummy b)
(dummy a)
apply-a-rule
rule=(rule (dummy (? x)) (dummy (? x)))
pattern=(dummy (? 3 x))
frame=(((? 2 x) ? 3 x) ((? 1 x) ? 2 x) ((? who) ? 1 x))

unify-result=(((? 3 x) ? 4 x) ((? 2 x) ? 3 x) ((? 1 x) ? 2 x) ((? who) ? 1 x))


qeval:depth=5
query=(dummy (? 4 x))

 frame-stream=( (?x-3 . ?x-4) 
(?x-2 . ?x-3) 
(?x-1 . ?x-2) 
(?who . ?x-1) 
)
debug:simple-query

 retval=( (?x-4 . c) 
(?x-3 . ?x-4) 
(?x-2 . ?x-3) 
(?x-1 . ?x-2) 
(?who . ?x-1) 
)(dummy c)
(dummy b)
(dummy a)
apply-a-rule
rule=(rule (dummy (? x)) (dummy (? x)))
pattern=(dummy (? 4 x))
frame=(((? 3 x) ? 4 x) ((? 2 x) ? 3 x) ((? 1 x) ? 2 x) ((? who) ? 1 x))

unify-result=(((? 4 x) ? 5 x) ((? 3 x) ? 4 x)
                              ((? 2 x) ? 3 x)
                              ((? 1 x) ? 2 x)
                              ((? who) ? 1 x))


qeval:depth=6
query=(dummy (? 5 x))

 frame-stream=( (?x-4 . ?x-5) 
(?x-3 . ?x-4) 
(?x-2 . ?x-3) 
(?x-1 . ?x-2) 
(?who . ?x-1) 
)
debug:simple-query

 retval=( (?x-5 . c) 
(?x-4 . ?x-5) 
(?x-3 . ?x-4) 
(?x-2 . ?x-3) 
(?x-1 . ?x-2) 
(?who . ?x-1) 
)(dummy c)
(dummy b)
(dummy a)
apply-a-rule
rule=(rule (dummy (? x)) (dummy (? x)))
pattern=(dummy (? 5 x))
frame=(((? 4 x) ? 5 x) ((? 3 x) ? 4 x)
                       ((? 2 x) ? 3 x)
                       ((? 1 x) ? 2 x)
                       ((? who) ? 1 x))

unify-result=(((? 5 x) ? 6 x) ((? 4 x) ? 5 x)
                              ((? 3 x) ? 4 x)
                              ((? 2 x) ? 3 x)
                              ((? 1 x) ? 2 x)
                              ((? who) ? 1 x))


qeval:depth=7
query=(dummy (? 6 x))

 frame-stream=( (?x-5 . ?x-6) 
(?x-4 . ?x-5) 
(?x-3 . ?x-4) 
(?x-2 . ?x-3) 
(?x-1 . ?x-2) 
(?who . ?x-1) 
)
debug:simple-query

 retval=( (?x-6 . c) 
(?x-5 . ?x-6) 
(?x-4 . ?x-5) 
(?x-3 . ?x-4) 
(?x-2 . ?x-3) 
(?x-1 . ?x-2) 
(?who . ?x-1) 
)(dummy c)
(dummy b)
(dummy a)
apply-a-rule
rule=(rule (dummy (? x)) (dummy (? x)))
pattern=(dummy (? 6 x))
frame=(((? 5 x) ? 6 x) ((? 4 x) ? 5 x)
                       ((? 3 x) ? 4 x)
                       ((? 2 x) ? 3 x)
                       ((? 1 x) ? 2 x)
                       ((? who) ? 1 x))

unify-result=(((? 6 x) ? 7 x) ((? 5 x) ? 6 x)
                              ((? 4 x) ? 5 x)
                              ((? 3 x) ? 4 x)
                              ((? 2 x) ? 3 x)
                              ((? 1 x) ? 2 x)
                              ((? who) ? 1 x))


qeval:depth=8
query=(dummy (? 7 x))

 frame-stream=( (?x-6 . ?x-7) 
(?x-5 . ?x-6) 
(?x-4 . ?x-5) 
(?x-3 . ?x-4) 
(?x-2 . ?x-3) 
(?x-1 . ?x-2) 
(?who . ?x-1) 
)
debug:simple-query

 retval=( (?x-7 . c) 
(?x-6 . ?x-7) 
(?x-5 . ?x-6) 
(?x-4 . ?x-5) 
(?x-3 . ?x-4) 
(?x-2 . ?x-3) 
(?x-1 . ?x-2) 
(?who . ?x-1) 
)(dummy c)
(dummy b)
(dummy a)
apply-a-rule
rule=(rule (dummy (? x)) (dummy (? x)))
pattern=(dummy (? 7 x))
frame=(((? 6 x) ? 7 x) ((? 5 x) ? 6 x)
                       ((? 4 x) ? 5 x)
                       ((? 3 x) ? 4 x)
                       ((? 2 x) ? 3 x)
                       ((? 1 x) ? 2 x)
                       ((? who) ? 1 x))

unify-result=(((? 7 x) ? 8 x) ((? 6 x) ? 7 x)
                              ((? 5 x) ? 6 x)
                              ((? 4 x) ? 5 x)
                              ((? 3 x) ? 4 x)
                              ((? 2 x) ? 3 x)
                              ((? 1 x) ? 2 x)
                              ((? who) ? 1 x))


qeval:depth=9
query=(dummy (? 8 x))

 frame-stream=( (?x-7 . ?x-8) 
(?x-6 . ?x-7) 
(?x-5 . ?x-6) 
(?x-4 . ?x-5) 
(?x-3 . ?x-4) 
(?x-2 . ?x-3) 
(?x-1 . ?x-2) 
(?who . ?x-1) 
)
debug:simple-query

 retval=( (?x-8 . c) 
(?x-7 . ?x-8) 
(?x-6 . ?x-7) 
(?x-5 . ?x-6) 
(?x-4 . ?x-5) 
(?x-3 . ?x-4) 
(?x-2 . ?x-3) 
(?x-1 . ?x-2) 
(?who . ?x-1) 
)(dummy c)
(dummy b)
(dummy a)
apply-a-rule
rule=(rule (dummy (? x)) (dummy (? x)))
pattern=(dummy (? 8 x))
frame=(((? 7 x) ? 8 x) ((? 6 x) ? 7 x)
                       ((? 5 x) ? 6 x)
                       ((? 4 x) ? 5 x)
                       ((? 3 x) ? 4 x)
                       ((? 2 x) ? 3 x)
                       ((? 1 x) ? 2 x)
                       ((? who) ? 1 x))

unify-result=(((? 8 x) ? 9 x) ((? 7 x) ? 8 x)
                              ((? 6 x) ? 7 x)
                              ((? 5 x) ? 6 x)
                              ((? 4 x) ? 5 x)
                              ((? 3 x) ? 4 x)
                              ((? 2 x) ? 3 x)
                              ((? 1 x) ? 2 x)
                              ((? who) ? 1 x))


qeval:depth=10
query=(dummy (? 9 x))

 frame-stream=( (?x-8 . ?x-9) 
(?x-7 . ?x-8) 
(?x-6 . ?x-7) 
(?x-5 . ?x-6) 
(?x-4 . ?x-5) 
(?x-3 . ?x-4) 
(?x-2 . ?x-3) 
(?x-1 . ?x-2) 
(?who . ?x-1) 
)
debug:simple-query

 retval=( (?x-9 . c) 
(?x-8 . ?x-9) 
(?x-7 . ?x-8) 
(?x-6 . ?x-7) 
(?x-5 . ?x-6) 
(?x-4 . ?x-5) 
(?x-3 . ?x-4) 
(?x-2 . ?x-3) 
(?x-1 . ?x-2) 
(?who . ?x-1) 
)(dummy c)
(dummy b)
(dummy a)
apply-a-rule
rule=(rule (dummy (? x)) (dummy (? x)))
pattern=(dummy (? 9 x))
frame=(((? 8 x) ? 9 x) ((? 7 x) ? 8 x)
                       ((? 6 x) ? 7 x)
                       ((? 5 x) ? 6 x)
                       ((? 4 x) ? 5 x)
                       ((? 3 x) ? 4 x)
                       ((? 2 x) ? 3 x)
                       ((? 1 x) ? 2 x)
                       ((? who) ? 1 x))

unify-result=(((? 9 x) ? 10 x) ((? 8 x) ? 9 x)
                               ((? 7 x) ? 8 x)
                               ((? 6 x) ? 7 x)
                               ((? 5 x) ? 6 x)
                               ((? 4 x) ? 5 x)
                               ((? 3 x) ? 4 x)
                               ((? 2 x) ? 3 x)
                               ((? 1 x) ? 2 x)
                               ((? who) ? 1 x))


qeval:depth=11
query=(dummy (? 10 x))

 frame-stream=( (?x-9 . ?x-10) 
(?x-8 . ?x-9) 
(?x-7 . ?x-8) 
(?x-6 . ?x-7) 
(?x-5 . ?x-6) 
(?x-4 . ?x-5) 
(?x-3 . ?x-4) 
(?x-2 . ?x-3) 
(?x-1 . ?x-2) 
(?who . ?x-1) 
)
debug:simple-query

 retval=( (?x-10 . c) 
(?x-9 . ?x-10) 
(?x-8 . ?x-9) 
(?x-7 . ?x-8) 
(?x-6 . ?x-7) 
(?x-5 . ?x-6) 
(?x-4 . ?x-5) 
(?x-3 . ?x-4) 
(?x-2 . ?x-3) 
(?x-1 . ?x-2) 
(?who . ?x-1) 
)(dummy c)
(dummy b)
(dummy a)
apply-a-rule
rule=(rule (dummy (? x)) (dummy (? x)))
pattern=(dummy (? 10 x))
frame=(((? 9 x) ? 10 x) ((? 8 x) ? 9 x)
                        ((? 7 x) ? 8 x)
                        ((? 6 x) ? 7 x)
                        ((? 5 x) ? 6 x)
                        ((? 4 x) ? 5 x)
                        ((? 3 x) ? 4 x)
                        ((? 2 x) ? 3 x)
                        ((? 1 x) ? 2 x)
                        ((? who) ? 1 x))

unify-result=(((? 10 x) ? 11 x) ((? 9 x) ? 10 x)
                                ((? 8 x) ? 9 x)
                                ((? 7 x) ? 8 x)
                                ((? 6 x) ? 7 x)
                                ((? 5 x) ? 6 x)
                                ((? 4 x) ? 5 x)
                                ((? 3 x) ? 4 x)
                                ((? 2 x) ? 3 x)
                                ((? 1 x) ? 2 x)
                                ((? who) ? 1 x))


qeval:depth=12
query=(dummy (? 11 x))

 frame-stream=( (?x-10 . ?x-11) 
(?x-9 . ?x-10) 
(?x-8 . ?x-9) 
(?x-7 . ?x-8) 
(?x-6 . ?x-7) 
(?x-5 . ?x-6) 
(?x-4 . ?x-5) 
(?x-3 . ?x-4) 
(?x-2 . ?x-3) 
(?x-1 . ?x-2) 
(?who . ?x-1) 
)
debug:simple-query

 retval=( (?x-11 . c) 
(?x-10 . ?x-11) 
(?x-9 . ?x-10) 
(?x-8 . ?x-9) 
(?x-7 . ?x-8) 
(?x-6 . ?x-7) 
(?x-5 . ?x-6) 
(?x-4 . ?x-5) 
(?x-3 . ?x-4) 
(?x-2 . ?x-3) 
(?x-1 . ?x-2) 
(?who . ?x-1) 
)(dummy c)
(dummy b)
(dummy a)
apply-a-rule
rule=(rule (dummy (? x)) (dummy (? x)))
pattern=(dummy (? 11 x))
frame=(((? 10 x) ? 11 x) ((? 9 x) ? 10 x)
                         ((? 8 x) ? 9 x)
                         ((? 7 x) ? 8 x)
                         ((? 6 x) ? 7 x)
                         ((? 5 x) ? 6 x)
                         ((? 4 x) ? 5 x)
                         ((? 3 x) ? 4 x)
                         ((? 2 x) ? 3 x)
                         ((? 1 x) ? 2 x)
                         ((? who) ? 1 x))

unify-result=(((? 11 x) ? 12 x) ((? 10 x) ? 11 x)
                                ((? 9 x) ? 10 x)
                                ((? 8 x) ? 9 x)
                                ((? 7 x) ? 8 x)
                                ((? 6 x) ? 7 x)
                                ((? 5 x) ? 6 x)
                                ((? 4 x) ? 5 x)
                                ((? 3 x) ? 4 x)
                                ((? 2 x) ? 3 x)
                                ((? 1 x) ? 2 x)
                                ((? who) ? 1 x))


qeval:depth=13
query=(dummy (? 12 x))

 frame-stream=( (?x-11 . ?x-12) 
(?x-10 . ?x-11) 
(?x-9 . ?x-10) 
(?x-8 . ?x-9) 
(?x-7 . ?x-8) 
(?x-6 . ?x-7) 
(?x-5 . ?x-6) 
(?x-4 . ?x-5) 
(?x-3 . ?x-4) 
(?x-2 . ?x-3) 
(?x-1 . ?x-2) 
(?who . ?x-1) 
)
debug:simple-query

 retval=( (?x-12 . c) 
(?x-11 . ?x-12) 
(?x-10 . ?x-11) 
(?x-9 . ?x-10) 
(?x-8 . ?x-9) 
(?x-7 . ?x-8) 
(?x-6 . ?x-7) 
(?x-5 . ?x-6) 
(?x-4 . ?x-5) 
(?x-3 . ?x-4) 
(?x-2 . ?x-3) 
(?x-1 . ?x-2) 
(?who . ?x-1) 
)(dummy c)
(dummy b)
(dummy a)
apply-a-rule
rule=(rule (dummy (? x)) (dummy (? x)))
pattern=(dummy (? 12 x))
frame=(((? 11 x) ? 12 x) ((? 10 x) ? 11 x)
                         ((? 9 x) ? 10 x)
                         ((? 8 x) ? 9 x)
                         ((? 7 x) ? 8 x)
                         ((? 6 x) ? 7 x)
                         ((? 5 x) ? 6 x)
                         ((? 4 x) ? 5 x)
                         ((? 3 x) ? 4 x)
                         ((? 2 x) ? 3 x)
                         ((? 1 x) ? 2 x)
                         ((? who) ? 1 x))

unify-result=(((? 12 x) ? 13 x) ((? 11 x) ? 12 x)
                                ((? 10 x) ? 11 x)
                                ((? 9 x) ? 10 x)
                                ((? 8 x) ? 9 x)
                                ((? 7 x) ? 8 x)
                                ((? 6 x) ? 7 x)
                                ((? 5 x) ? 6 x)
                                ((? 4 x) ? 5 x)
                                ((? 3 x) ? 4 x)
                                ((? 2 x) ? 3 x)
                                ((? 1 x) ? 2 x)
                                ((? who) ? 1 x))


qeval:depth=14
query=(dummy (? 13 x))

 frame-stream=( (?x-12 . ?x-13) 
(?x-11 . ?x-12) 
(?x-10 . ?x-11) 
(?x-9 . ?x-10) 
(?x-8 . ?x-9) 
(?x-7 . ?x-8) 
(?x-6 . ?x-7) 
(?x-5 . ?x-6) 
(?x-4 . ?x-5) 
(?x-3 . ?x-4) 
(?x-2 . ?x-3) 
(?x-1 . ?x-2) 
(?who . ?x-1) 
)
debug:simple-query

 retval=( (?x-13 . c) 
(?x-12 . ?x-13) 
(?x-11 . ?x-12) 
(?x-10 . ?x-11) 
(?x-9 . ?x-10) 
(?x-8 . ?x-9) 
(?x-7 . ?x-8) 
(?x-6 . ?x-7) 
(?x-5 . ?x-6) 
(?x-4 . ?x-5) 
(?x-3 . ?x-4) 
(?x-2 . ?x-3) 
(?x-1 . ?x-2) 
(?who . ?x-1) 
)(dummy c)
(dummy b)
(dummy a)
apply-a-rule
rule=(rule (dummy (? x)) (dummy (? x)))
pattern=(dummy (? 13 x))
frame=(((? 12 x) ? 13 x) ((? 11 x) ? 12 x)
                         ((? 10 x) ? 11 x)
                         ((? 9 x) ? 10 x)
                         ((? 8 x) ? 9 x)
                         ((? 7 x) ? 8 x)
                         ((? 6 x) ? 7 x)
                         ((? 5 x) ? 6 x)
                         ((? 4 x) ? 5 x)
                         ((? 3 x) ? 4 x)
                         ((? 2 x) ? 3 x)
                         ((? 1 x) ? 2 x)
                         ((? who) ? 1 x))

unify-result=(((? 13 x) ? 14 x) ((? 12 x) ? 13 x)
                                ((? 11 x) ? 12 x)
                                ((? 10 x) ? 11 x)
                                ((? 9 x) ? 10 x)
                                ((? 8 x) ? 9 x)
                                ((? 7 x) ? 8 x)
                                ((? 6 x) ? 7 x)
                                ((? 5 x) ? 6 x)
                                ((? 4 x) ? 5 x)
                                ((? 3 x) ? 4 x)
                                ((? 2 x) ? 3 x)
                                ((? 1 x) ? 2 x)
                                ((? who) ? 1 x))


qeval:depth=15
query=(dummy (? 14 x))

 frame-stream=( (?x-13 . ?x-14) 
(?x-12 . ?x-13) 
(?x-11 . ?x-12) 
(?x-10 . ?x-11) 
(?x-9 . ?x-10) 
(?x-8 . ?x-9) 
(?x-7 . ?x-8) 
(?x-6 . ?x-7) 
(?x-5 . ?x-6) 
(?x-4 . ?x-5) 
(?x-3 . ?x-4) 
(?x-2 . ?x-3) 
(?x-1 . ?x-2) 
(?who . ?x-1) 
)
debug:simple-query

 retval=( (?x-14 . c) 
(?x-13 . ?x-14) 
(?x-12 . ?x-13) 
(?x-11 . ?x-12) 
(?x-10 . ?x-11) 
(?x-9 . ?x-10) 
(?x-8 . ?x-9) 
(?x-7 . ?x-8) 
(?x-6 . ?x-7) 
(?x-5 . ?x-6) 
(?x-4 . ?x-5) 
(?x-3 . ?x-4) 
(?x-2 . ?x-3) 
(?x-1 . ?x-2) 
(?who . ?x-1) 
)(dummy c)
(dummy b)
(dummy a)
apply-a-rule
rule=(rule (dummy (? x)) (dummy (? x)))
pattern=(dummy (? 14 x))
frame=(((? 13 x) ? 14 x) ((? 12 x) ? 13 x)
                         ((? 11 x) ? 12 x)
                         ((? 10 x) ? 11 x)
                         ((? 9 x) ? 10 x)
                         ((? 8 x) ? 9 x)
                         ((? 7 x) ? 8 x)
                         ((? 6 x) ? 7 x)
                         ((? 5 x) ? 6 x)
                         ((? 4 x) ? 5 x)
                         ((? 3 x) ? 4 x)
                         ((? 2 x) ? 3 x)
                         ((? 1 x) ? 2 x)
                         ((? who) ? 1 x))

unify-result=(((? 14 x) ? 15 x) ((? 13 x) ? 14 x)
                                ((? 12 x) ? 13 x)
                                ((? 11 x) ? 12 x)
                                ((? 10 x) ? 11 x)
                                ((? 9 x) ? 10 x)
                                ((? 8 x) ? 9 x)
                                ((? 7 x) ? 8 x)
                                ((? 6 x) ? 7 x)
                                ((? 5 x) ? 6 x)
                                ((? 4 x) ? 5 x)
                                ((? 3 x) ? 4 x)
                                ((? 2 x) ? 3 x)
                                ((? 1 x) ? 2 x)
                                ((? who) ? 1 x))


qeval:depth=16
query=(dummy (? 15 x))

 frame-stream=( (?x-14 . ?x-15) 
(?x-13 . ?x-14) 
(?x-12 . ?x-13) 
(?x-11 . ?x-12) 
(?x-10 . ?x-11) 
(?x-9 . ?x-10) 
(?x-8 . ?x-9) 
(?x-7 . ?x-8) 
(?x-6 . ?x-7) 
(?x-5 . ?x-6) 
(?x-4 . ?x-5) 
(?x-3 . ?x-4) 
(?x-2 . ?x-3) 
(?x-1 . ?x-2) 
(?who . ?x-1) 
)
debug:simple-query

 retval=( (?x-15 . c) 
(?x-14 . ?x-15) 
(?x-13 . ?x-14) 
(?x-12 . ?x-13) 
(?x-11 . ?x-12) 
(?x-10 . ?x-11) 
(?x-9 . ?x-10) 
(?x-8 . ?x-9) 
(?x-7 . ?x-8) 
(?x-6 . ?x-7) 
(?x-5 . ?x-6) 
(?x-4 . ?x-5) 
(?x-3 . ?x-4) 
(?x-2 . ?x-3) 
(?x-1 . ?x-2) 
(?who . ?x-1) 
)(dummy c)
(dummy b)
(dummy a)
apply-a-rule
rule=(rule (dummy (? x)) (dummy (? x)))
pattern=(dummy (? 15 x))
frame=(((? 14 x) ? 15 x) ((? 13 x) ? 14 x)
                         ((? 12 x) ? 13 x)
                         ((? 11 x) ? 12 x)
                         ((? 10 x) ? 11 x)
                         ((? 9 x) ? 10 x)
                         ((? 8 x) ? 9 x)
                         ((? 7 x) ? 8 x)
                         ((? 6 x) ? 7 x)
                         ((? 5 x) ? 6 x)
                         ((? 4 x) ? 5 x)
                         ((? 3 x) ? 4 x)
                         ((? 2 x) ? 3 x)
                         ((? 1 x) ? 2 x)
                         ((? who) ? 1 x))

unify-result=(((? 15 x) ? 16 x) ((? 14 x) ? 15 x)
                                ((? 13 x) ? 14 x)
                                ((? 12 x) ? 13 x)
                                ((? 11 x) ? 12 x)
                                ((? 10 x) ? 11 x)
                                ((? 9 x) ? 10 x)
                                ((? 8 x) ? 9 x)
                                ((? 7 x) ? 8 x)
                                ((? 6 x) ? 7 x)
                                ((? 5 x) ? 6 x)
                                ((? 4 x) ? 5 x)
                                ((? 3 x) ? 4 x)
                                ((? 2 x) ? 3 x)
                                ((? 1 x) ? 2 x)
                                ((? who) ? 1 x))


qeval:depth=17
query=(dummy (? 16 x))

 frame-stream=( (?x-15 . ?x-16) 
(?x-14 . ?x-15) 
(?x-13 . ?x-14) 
(?x-12 . ?x-13) 
(?x-11 . ?x-12) 
(?x-10 . ?x-11) 
(?x-9 . ?x-10) 
(?x-8 . ?x-9) 
(?x-7 . ?x-8) 
(?x-6 . ?x-7) 
(?x-5 . ?x-6) 
(?x-4 . ?x-5) 
(?x-3 . ?x-4) 
(?x-2 . ?x-3) 
(?x-1 . ?x-2) 
(?who . ?x-1) 
)
debug:simple-query

 retval=( (?x-16 . c) 
(?x-15 . ?x-16) 
(?x-14 . ?x-15) 
(?x-13 . ?x-14) 
(?x-12 . ?x-13) 
(?x-11 . ?x-12) 
(?x-10 . ?x-11) 
(?x-9 . ?x-10) 
(?x-8 . ?x-9) 
(?x-7 . ?x-8) 
(?x-6 . ?x-7) 
(?x-5 . ?x-6) 
(?x-4 . ?x-5) 
(?x-3 . ?x-4) 
(?x-2 . ?x-3) 
(?x-1 . ?x-2) 
(?who . ?x-1) 
)(dummy c)
(dummy b)
(dummy a)
apply-a-rule
rule=(rule (dummy (? x)) (dummy (? x)))
pattern=(dummy (? 16 x))
frame=(((? 15 x) ? 16 x) ((? 14 x) ? 15 x)
                         ((? 13 x) ? 14 x)
                         ((? 12 x) ? 13 x)
                         ((? 11 x) ? 12 x)
                         ((? 10 x) ? 11 x)
                         ((? 9 x) ? 10 x)
                         ((? 8 x) ? 9 x)
                         ((? 7 x) ? 8 x)
                         ((? 6 x) ? 7 x)
                         ((? 5 x) ? 6 x)
                         ((? 4 x) ? 5 x)
                         ((? 3 x) ? 4 x)
                         ((? 2 x) ? 3 x)
                         ((? 1 x) ? 2 x)
                         ((? who) ? 1 x))

unify-result=(((? 16 x) ? 17 x) ((? 15 x) ? 16 x)
                                ((? 14 x) ? 15 x)
                                ((? 13 x) ? 14 x)
                                ((? 12 x) ? 13 x)
                                ((? 11 x) ? 12 x)
                                ((? 10 x) ? 11 x)
                                ((? 9 x) ? 10 x)
                                ((? 8 x) ? 9 x)
                                ((? 7 x) ? 8 x)
                                ((? 6 x) ? 7 x)
                                ((? 5 x) ? 6 x)
                                ((? 4 x) ? 5 x)
                                ((? 3 x) ? 4 x)
                                ((? 2 x) ? 3 x)
                                ((? 1 x) ? 2 x)
                                ((? who) ? 1 x))


qeval:depth=18
query=(dummy (? 17 x))

 frame-stream=( (?x-16 . ?x-17) 
(?x-15 . ?x-16) 
(?x-14 . ?x-15) 
(?x-13 . ?x-14) 
(?x-12 . ?x-13) 
(?x-11 . ?x-12) 
(?x-10 . ?x-11) 
(?x-9 . ?x-10) 
(?x-8 . ?x-9) 
(?x-7 . ?x-8) 
(?x-6 . ?x-7) 
(?x-5 . ?x-6) 
(?x-4 . ?x-5) 
(?x-3 . ?x-4) 
(?x-2 . ?x-3) 
(?x-1 . ?x-2) 
(?who . ?x-1) 
)
debug:simple-query

 retval=( (?x-17 . c) 
(?x-16 . ?x-17) 
(?x-15 . ?x-16) 
(?x-14 . ?x-15) 
(?x-13 . ?x-14) 
(?x-12 . ?x-13) 
(?x-11 . ?x-12) 
(?x-10 . ?x-11) 
(?x-9 . ?x-10) 
(?x-8 . ?x-9) 
(?x-7 . ?x-8) 
(?x-6 . ?x-7) 
(?x-5 . ?x-6) 
(?x-4 . ?x-5) 
(?x-3 . ?x-4) 
(?x-2 . ?x-3) 
(?x-1 . ?x-2) 
(?who . ?x-1) 
)(dummy c)
(dummy b)
(dummy a)
apply-a-rule
rule=(rule (dummy (? x)) (dummy (? x)))
pattern=(dummy (? 17 x))
frame=(((? 16 x) ? 17 x) ((? 15 x) ? 16 x)
                         ((? 14 x) ? 15 x)
                         ((? 13 x) ? 14 x)
                         ((? 12 x) ? 13 x)
                         ((? 11 x) ? 12 x)
                         ((? 10 x) ? 11 x)
                         ((? 9 x) ? 10 x)
                         ((? 8 x) ? 9 x)
                         ((? 7 x) ? 8 x)
                         ((? 6 x) ? 7 x)
                         ((? 5 x) ? 6 x)
                         ((? 4 x) ? 5 x)
                         ((? 3 x) ? 4 x)
                         ((? 2 x) ? 3 x)
                         ((? 1 x) ? 2 x)
                         ((? who) ? 1 x))

unify-result=(((? 17 x) ? 18 x) ((? 16 x) ? 17 x)
                                ((? 15 x) ? 16 x)
                                ((? 14 x) ? 15 x)
                                ((? 13 x) ? 14 x)
                                ((? 12 x) ? 13 x)
                                ((? 11 x) ? 12 x)
                                ((? 10 x) ? 11 x)
                                ((? 9 x) ? 10 x)
                                ((? 8 x) ? 9 x)
                                ((? 7 x) ? 8 x)
                                ((? 6 x) ? 7 x)
                                ((? 5 x) ? 6 x)
                                ((? 4 x) ? 5 x)
                                ((? 3 x) ? 4 x)
                                ((? 2 x) ? 3 x)
                                ((? 1 x) ? 2 x)
                                ((? who) ? 1 x))


qeval:depth=19
query=(dummy (? 18 x))

 frame-stream=( (?x-17 . ?x-18) 
(?x-16 . ?x-17) 
(?x-15 . ?x-16) 
(?x-14 . ?x-15) 
(?x-13 . ?x-14) 
(?x-12 . ?x-13) 
(?x-11 . ?x-12) 
(?x-10 . ?x-11) 
(?x-9 . ?x-10) 
(?x-8 . ?x-9) 
(?x-7 . ?x-8) 
(?x-6 . ?x-7) 
(?x-5 . ?x-6) 
(?x-4 . ?x-5) 
(?x-3 . ?x-4) 
(?x-2 . ?x-3) 
(?x-1 . ?x-2) 
(?who . ?x-1) 
)
debug:simple-query

 retval=( (?x-18 . c) 
(?x-17 . ?x-18) 
(?x-16 . ?x-17) 
(?x-15 . ?x-16) 
(?x-14 . ?x-15) 
(?x-13 . ?x-14) 
(?x-12 . ?x-13) 
(?x-11 . ?x-12) 
(?x-10 . ?x-11) 
(?x-9 . ?x-10) 
(?x-8 . ?x-9) 
(?x-7 . ?x-8) 
(?x-6 . ?x-7) 
(?x-5 . ?x-6) 
(?x-4 . ?x-5) 
(?x-3 . ?x-4) 
(?x-2 . ?x-3) 
(?x-1 . ?x-2) 
(?who . ?x-1) 
)(dummy c)
(dummy b)
(dummy a)
apply-a-rule
rule=(rule (dummy (? x)) (dummy (? x)))
pattern=(dummy (? 18 x))
frame=(((? 17 x) ? 18 x) ((? 16 x) ? 17 x)
                         ((? 15 x) ? 16 x)
                         ((? 14 x) ? 15 x)
                         ((? 13 x) ? 14 x)
                         ((? 12 x) ? 13 x)
                         ((? 11 x) ? 12 x)
                         ((? 10 x) ? 11 x)
                         ((? 9 x) ? 10 x)
                         ((? 8 x) ? 9 x)
                         ((? 7 x) ? 8 x)
                         ((? 6 x) ? 7 x)
                         ((? 5 x) ? 6 x)
                         ((? 4 x) ? 5 x)
                         ((? 3 x) ? 4 x)
                         ((? 2 x) ? 3 x)
                         ((? 1 x) ? 2 x)
                         ((? who) ? 1 x))

unify-result=(((? 18 x) ? 19 x) ((? 17 x) ? 18 x)
                                ((? 16 x) ? 17 x)
                                ((? 15 x) ? 16 x)
                                ((? 14 x) ? 15 x)
                                ((? 13 x) ? 14 x)
                                ((? 12 x) ? 13 x)
                                ((? 11 x) ? 12 x)
                                ((? 10 x) ? 11 x)
                                ((? 9 x) ? 10 x)
                                ((? 8 x) ? 9 x)
                                ((? 7 x) ? 8 x)
                                ((? 6 x) ? 7 x)
                                ((? 5 x) ? 6 x)
                                ((? 4 x) ? 5 x)
                                ((? 3 x) ? 4 x)
                                ((? 2 x) ? 3 x)
                                ((? 1 x) ? 2 x)
                                ((? who) ? 1 x))


qeval:depth=20
query=(dummy (? 19 x))

 frame-stream=( (?x-18 . ?x-19) 
(?x-17 . ?x-18) 
(?x-16 . ?x-17) 
(?x-15 . ?x-16) 
(?x-14 . ?x-15) 
(?x-13 . ?x-14) 
(?x-12 . ?x-13) 
(?x-11 . ?x-12) 
(?x-10 . ?x-11) 
(?x-9 . ?x-10) 
(?x-8 . ?x-9) 
(?x-7 . ?x-8) 
(?x-6 . ?x-7) 
(?x-5 . ?x-6) 
(?x-4 . ?x-5) 
(?x-3 . ?x-4) 
(?x-2 . ?x-3) 
(?x-1 . ?x-2) 
(?who . ?x-1) 
)
debug:simple-query

 retval=( (?x-19 . c) 
(?x-18 . ?x-19) 
(?x-17 . ?x-18) 
(?x-16 . ?x-17) 
(?x-15 . ?x-16) 
(?x-14 . ?x-15) 
(?x-13 . ?x-14) 
(?x-12 . ?x-13) 
(?x-11 . ?x-12) 
(?x-10 . ?x-11) 
(?x-9 . ?x-10) 
(?x-8 . ?x-9) 
(?x-7 . ?x-8) 
(?x-6 . ?x-7) 
(?x-5 . ?x-6) 
(?x-4 . ?x-5) 
(?x-3 . ?x-4) 
(?x-2 . ?x-3) 
(?x-1 . ?x-2) 
(?who . ?x-1) 
)(dummy c)
(dummy b)
(dummy a)
apply-a-rule
rule=(rule (dummy (? x)) (dummy (? x)))
pattern=(dummy (? 19 x))
frame=(((? 18 x) ? 19 x) ((? 17 x) ? 18 x)
                         ((? 16 x) ? 17 x)
                         ((? 15 x) ? 16 x)
                         ((? 14 x) ? 15 x)
                         ((? 13 x) ? 14 x)
                         ((? 12 x) ? 13 x)
                         ((? 11 x) ? 12 x)
                         ((? 10 x) ? 11 x)
                         ((? 9 x) ? 10 x)
                         ((? 8 x) ? 9 x)
                         ((? 7 x) ? 8 x)
                         ((? 6 x) ? 7 x)
                         ((? 5 x) ? 6 x)
                         ((? 4 x) ? 5 x)
                         ((? 3 x) ? 4 x)
                         ((? 2 x) ? 3 x)
                         ((? 1 x) ? 2 x)
                         ((? who) ? 1 x))

unify-result=(((? 19 x) ? 20 x) ((? 18 x) ? 19 x)
                                ((? 17 x) ? 18 x)
                                ((? 16 x) ? 17 x)
                                ((? 15 x) ? 16 x)
                                ((? 14 x) ? 15 x)
                                ((? 13 x) ? 14 x)
                                ((? 12 x) ? 13 x)
                                ((? 11 x) ? 12 x)
                                ((? 10 x) ? 11 x)
                                ((? 9 x) ? 10 x)
                                ((? 8 x) ? 9 x)
                                ((? 7 x) ? 8 x)
                                ((? 6 x) ? 7 x)
                                ((? 5 x) ? 6 x)
                                ((? 4 x) ? 5 x)
                                ((? 3 x) ? 4 x)
                                ((? 2 x) ? 3 x)
                                ((? 1 x) ? 2 x)
                                ((? who) ? 1 x))


qeval:depth=21
query=(dummy (? 20 x))

 frame-stream=( (?x-19 . ?x-20) 
(?x-18 . ?x-19) 
(?x-17 . ?x-18) 
(?x-16 . ?x-17) 
(?x-15 . ?x-16) 
(?x-14 . ?x-15) 
(?x-13 . ?x-14) 
(?x-12 . ?x-13) 
(?x-11 . ?x-12) 
(?x-10 . ?x-11) 
(?x-9 . ?x-10) 
(?x-8 . ?x-9) 
(?x-7 . ?x-8) 
(?x-6 . ?x-7) 
(?x-5 . ?x-6) 
(?x-4 . ?x-5) 
(?x-3 . ?x-4) 
(?x-2 . ?x-3) 
(?x-1 . ?x-2) 
(?who . ?x-1) 
)
Maximum depth reached.
;;; Query input:
exit
#+end_src

We can see that although the system stack still overflows, it can
print some queries interleaved with computing the rest. Should help
with debugging, I guess.

This solution is due to Eli Bendersky and Flavio Cruz.

***** DONE Exercise 4.72 interleave-stream
      CLOSED: [2020-02-20 Thu 17:11]

We interleave the streams because they may happen to be
infinite. Therefore, if the first stream to get appended is infinite,
it would effectively replace the other one. ~interleave~ guarantees
that the elements of the other stream will also get into the resulting
stream.

***** DONE Exercise 4.73 flatten-stream delays
      CLOSED: [2020-02-20 Thu 17:19]

~flatten-stream~ calls itself. Again, it would work with finite
streams (although would require a large memory), but with infinite
streams it would _have to_ call itself before handing in control into
~interleave~. But if the argument is an infinite stream, it would
never finish.

***** DONE Exercise 4.74 Alyssa's streams
      CLOSED: [2020-02-21 Fri 22:00]

#+name: prolog-alyssas-streams
#+begin_src scheme :exports code :results none
  (define (simple-stream-flatmap proc s)
    (simple-flatten (stream-map proc s)))
  (define (simple-flatten stream)
    (stream-map
     stream-car
     (stream-filter
      (lambda (x) (not (stream-null? x))) stream)))
#+end_src

The behaviour should not change, since empty elements are ignored, and
singleton appendage and interleaving is the same thing.

***** DONE Exercise 4.75 ~unique~ special form
      CLOSED: [2020-02-21 Fri 23:19]

#+name: prolog-unique
#+begin_src scheme :exports code :results none
  (define (unique-query exp) (car exp))

  (define (uniquely-asserted operands frame-stream)
    (stream-flatmap
     (lambda (frame)
       (let ((retval (qeval (unique-query operands)
		   (singleton-stream frame))))
            (if (null? (stream-cdr retval))
                retval
                the-empty-stream)))
     frame-stream))

  (put 'unique 'qeval uniquely-asserted)
#+end_src

#+name: prolog-input-unique
#+begin_src shell :exports code :results verbatim output scalar code
  printf "%s" '
  <<prolog-input-sample-database>>
  (unique (job ?x (computer wizard)))
  (unique (job ?x (computer programmer)))
  (and (job ?x ?j) (unique (job ?anyone ?j)))
  (and (supervisor ?supervisee ?supervisor) (unique (supervisor ?anyone ?supervisor)))
  exit'
#+end_src

#+header: :stdin prolog-input-unique
#+begin_src shell :shebang "#! /usr/bin/chibi-scheme" :exports code :results output scalar code :exports both
  <<prolog-glue>>
  <<put-and-get>>
  <<streams-common>>
  <<streams-2>>
  <<stream-append>>
  <<prolog-driver-loop>>
  <<prolog-instantiate>>
  <<prolog-qeval>>
  <<prolog-simple-queries>>
  <<prolog-conjoin>>
  <<prolog-conjoin-installation>>
  <<prolog-disjoin>>
  <<prolog-disjoin-installation>>
  <<prolog-negate>>
  <<prolog-negate-installation>>
  <<prolog-lisp-filter>>
  <<prolog-lisp-filter-installation>>
  <<prolog-unique>>
  <<prolog-always-true>>
  <<prolog-pattern-matching>>
  <<prolog-rules-and-unification>>
  <<prolog-database>>
  <<prolog-database-add-assertion-original>>
  <<prolog-database-store-assertion-in-index>>
  <<prolog-stream-operations>>
  <<prolog-stream-flatmap>>
  <<prolog-flatten-stream>>
  <<streams-singleton>>
  <<prolog-query>>
  <<prolog-frames-and-bindings>>

  (query-driver-loop)
#+end_src

#+RESULTS[8f9caf7f421ec6b894a30634aa1c05a7966ecb94]:
#+begin_src shell

;;; Query input:
(assert! (address (Bitdiddle Ben) (Slumerville (Ridge Road) 10)))
Assertion added to data base.
;;; Query input:
(assert! (job (Bitdiddle Ben) (computer wizard)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Bitdiddle Ben) 60000))
Assertion added to data base.
;;; Query input:
(assert! (address (Hacker Alyssa P) (Cambridge (Mass Ave) 78)))
Assertion added to data base.
;;; Query input:
(assert! (job (Hacker Alyssa P) (computer programmer)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Hacker Alyssa P) 40000))
Assertion added to data base.
;;; Query input:
(assert! (supervisor (Hacker Alyssa P) (Bitdiddle Ben)))
Assertion added to data base.
;;; Query input:
(assert! (address (Fect Cy D) (Cambridge (Ames Street) 3)))
Assertion added to data base.
;;; Query input:
(assert! (job (Fect Cy D) (computer programmer)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Fect Cy D) 35000))
Assertion added to data base.
;;; Query input:
(assert! (supervisor (Fect Cy D) (Bitdiddle Ben)))
Assertion added to data base.
;;; Query input:
(assert! (address (Tweakit Lem E) (Boston (Bay State Road) 22)))
Assertion added to data base.
;;; Query input:
(assert! (job (Tweakit Lem E) (computer technician)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Tweakit Lem E) 25000))
Assertion added to data base.
;;; Query input:
(assert! (supervisor (Tweakit Lem E) (Bitdiddle Ben)))
Assertion added to data base.
;;; Query input:
(assert! (address (Reasoner Louis) (Slumerville (Pine Tree Road) 80)))
Assertion added to data base.
;;; Query input:
(assert! (job (Reasoner Louis) (computer programmer trainee)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Reasoner Louis) 30000))
Assertion added to data base.
;;; Query input:
(assert! (supervisor (Reasoner Louis) (Hacker Alyssa P)))
Assertion added to data base.
;;; Query input:
(assert! (supervisor (Bitdiddle Ben) (Warbucks Oliver)))
Assertion added to data base.
;;; Query input:
(assert! (address (Warbucks Oliver) (Swellesley (Top Heap Road))))
Assertion added to data base.
;;; Query input:
(assert! (job (Warbucks Oliver) (administration big wheel)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Warbucks Oliver) 150000))
Assertion added to data base.
;;; Query input:
(assert! (address (Scrooge Eben) (Weston (Shady Lane) 10)))
Assertion added to data base.
;;; Query input:
(assert! (job (Scrooge Eben) (accounting chief accountant)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Scrooge Eben) 75000))
Assertion added to data base.
;;; Query input:
(assert! (supervisor (Scrooge Eben) (Warbucks Oliver)))
Assertion added to data base.
;;; Query input:
(assert! (address (Cratchet Robert) (Allston (N Harvard Street) 16)))
Assertion added to data base.
;;; Query input:
(assert! (job (Cratchet Robert) (accounting scrivener)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Cratchet Robert) 18000))
Assertion added to data base.
;;; Query input:
(assert! (supervisor (Cratchet Robert) (Scrooge Eben)))
Assertion added to data base.
;;; Query input:
(assert! (address (Aull DeWitt) (Slumerville (Onion Square) 5)))
Assertion added to data base.
;;; Query input:
(assert! (job (Aull DeWitt) (administration secretary)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Aull DeWitt) 25000))
Assertion added to data base.
;;; Query input:
(assert! (supervisor (Aull DeWitt) (Warbucks Oliver)))
Assertion added to data base.
;;; Query input:
(assert! (can-do-job (computer wizard) (computer programmer)))
Assertion added to data base.
;;; Query input:
(assert! (can-do-job (computer wizard) (computer technician)))
Assertion added to data base.
;;; Query input:
(assert! (can-do-job (computer programmer) (computer programmer trainee)))
Assertion added to data base.
;;; Query input:
(assert! (can-do-job (administration secretary) (administration big wheel)))
Assertion added to data base.
;;; Query input:
(unique (job (? x) (computer wizard)))
;;; Query results:
(unique (job (Bitdiddle Ben) (computer wizard)))

;;; Query input:
(unique (job (? x) (computer programmer)))
;;; Query results:

;;; Query input:
(and (job (? x) (? j)) (unique (job (? anyone) (? j))))
;;; Query results:
(and (job (Aull DeWitt) (administration secretary))
     (unique (job (Aull DeWitt) (administration secretary))))
(and (job (Cratchet Robert) (accounting scrivener))
     (unique (job (Cratchet Robert) (accounting scrivener))))
(and (job (Scrooge Eben) (accounting chief accountant))
     (unique (job (Scrooge Eben) (accounting chief accountant))))
(and (job (Warbucks Oliver) (administration big wheel))
     (unique (job (Warbucks Oliver) (administration big wheel))))
(and (job (Reasoner Louis) (computer programmer trainee))
     (unique (job (Reasoner Louis) (computer programmer trainee))))
(and (job (Tweakit Lem E) (computer technician))
     (unique (job (Tweakit Lem E) (computer technician))))
(and (job (Bitdiddle Ben) (computer wizard))
     (unique (job (Bitdiddle Ben) (computer wizard))))

;;; Query input:
(and (supervisor (? supervisee) (? supervisor))
     (unique (supervisor (? anyone) (? supervisor))))
;;; Query results:
(and (supervisor (Cratchet Robert) (Scrooge Eben))
     (unique (supervisor (Cratchet Robert) (Scrooge Eben))))
(and (supervisor (Reasoner Louis) (Hacker Alyssa P))
     (unique (supervisor (Reasoner Louis) (Hacker Alyssa P))))

;;; Query input:
exit
#+end_src


Turned out (surprisingly) to be much easier than I thought.

***** DONE Exercise 4.76 improving ~and~
      CLOSED: [2020-02-22 Sat 18:27]

#+name: prolog-better-conjoin-and-installation
#+begin_src scheme :exports code :results none
  #;(define (select-compatible-frames frame-stream-1 frame-stream-2)
  (define (compatible-with-frame-stream-1 frame-from-stream-2)
  (accumulate (lambda (x y) (and x y))
  #t
  (stream-map
  (lambda (frame)
  (compatible-frames? frame frame-from-stream-2))
  frame-stream-1)))
  (stream-filter compatible-with-frame-stream-1 frame-stream-2))

  ;;two frames as
  ;;inputs, checks whether the bindings in the frames are com-
  ;;patible, and, if so, produces a frame that merges the two
  ;;sets of bindings. is operation is similar to unification.

  (define (compatible-pair frame-pair)
    (let* ((frame-1 (reverse (car frame-pair)))
	   (frame-2 (reverse (cadr frame-pair)))
           (names-1 (map binding-variable frame-1))
           (names-2 (map binding-variable frame-2))
	   (bindings-names (lset-union eq? names-1 names-2)))
      (define (extend-or-fail frame name)
	(if (eq? frame 'failed)
	    'failed
	    (cond ((and (binding-in-frame name frame-1)
			(not (binding-in-frame name frame-2)))
		   (extend name (binding-value (binding-in-frame name frame-1)) frame))
		  ((and (binding-in-frame name frame-2)
			(not (binding-in-frame name frame-1)))
		   (extend name (binding-value (binding-in-frame name frame-2)) frame))
		  ((and (binding-in-frame name frame-2)
			(binding-in-frame name frame-1))
		   (unify-match (binding-value (binding-in-frame name frame-1))
				name
				(extend name
                                        (binding-value (binding-in-frame name frame-2))
                                         frame)))
                  #;(else (error "LWF:Strange binding" name))
                  (else 'failed)
                   )))
;      (display "\ncompatible-pair:\n")
;      (display "frame-pair=") (display frame-pair) (newline)
;      (display "frame-1=") (display frame-1)  (newline)
;      (display "frame-2=") (display frame-2)  (newline)
;      (display "names-1=") (display names-1)  (newline)
;      (display "names-2=") (display names-2)  (newline)

;      (display "bindings-names(lset-union)=")
;      (display bindings-names) (newline)
      (accumulate extend-or-fail '() bindings-names) ;; => makes _one_ frame
      ))
  (define (frame-streams->compatible fs1 fs2)
;    (display "\nframe-streams:\n")
;    (display "fs1=")  (stream-print-n fs1 10) (newline)
;    (display "fs2=")  (stream-print-n fs2 10) (newline)
;    (display "pairs=") (stream-print-n (pairs fs1 fs2) 10) (newline)
    (let ((retval (stream-filter (lambda (frame) (not (eq? frame 'failed)))
                                 (stream-map compatible-pair (pairs fs1 fs2)))))
;         (display "retval=") (stream-print-n retval 5) (newline)
         retval))

  (define (conjoin-better conjuncts frame-stream)
    (if (empty-conjunction? conjuncts)
	frame-stream
	(let ((resulting-frame-stream-list
	       (map (lambda (conjunct)
		      (qeval conjunct frame-stream))
		    conjuncts)))
	  (accumulate frame-streams->compatible
		      (singleton-stream '())
		      resulting-frame-stream-list))))

  (put 'and-better 'qeval conjoin-better)
#+end_src

#+name: prolog-input-better-and
#+begin_src shell :exports code :results verbatim output scalar code
  printf "%s" '
    <<prolog-input-sample-database>>
;    (unique (job ?x (computer wizard)))
;    (unique (job ?x (computer programmer)))
    (and (job ?x ?j) (unique (job ?anyone ?j)))
    (and-better (job ?x ?j) (unique (job ?anyone ?j)))
;    (and (supervisor ?supervisee ?supervisor) (unique (supervisor ?anyone ?supervisor)))
    (and (can-do-job ?x (computer programmer trainee))
         (job ?person ?x))
;    (and (can-do-job  . ?x)
;         (supervisor . ?y))
;     (assert! (job programmer))
;     (assert! (job clerk))
;     (assert! (hobby reading))
;     (assert! (hobby writing))
;     (and-better (job ?x) (hobby ?y))
    (and-better (can-do-job ?x (computer programmer trainee))
         (job ?person ?x))
    exit'
#+end_src


#+header: :stdin prolog-input-better-and
#+begin_src shell :shebang "#! /usr/bin/chibi-scheme" :exports code :results output scalar code
  <<prolog-glue>>
  <<accumulate>>
  <<put-and-get>>
  <<streams-common>>
  <<streams-2>>
  <<streams-interleave>>
  <<stream-append>>
  <<streams-pairs-full>>
  <<streams-print-n>>

  <<prolog-driver-loop>>
  <<prolog-instantiate>>
  <<prolog-qeval>>
  <<prolog-simple-queries>>

  <<prolog-conjoin>>
  <<prolog-conjoin-installation>>

  <<prolog-better-conjoin-and-installation>>
  <<prolog-disjoin>>
  <<prolog-disjoin-installation>>
  <<prolog-negate>>
  <<prolog-negate-installation>>
  <<prolog-lisp-filter>>
  <<prolog-lisp-filter-installation>>
  <<prolog-unique>>
  <<prolog-always-true>>
  <<prolog-pattern-matching>>
  <<prolog-rules-and-unification>>
  <<prolog-database>>
  <<prolog-database-add-assertion-original>>
  <<prolog-database-store-assertion-in-index>>
  <<prolog-stream-operations>>
  <<prolog-stream-flatmap>>
  <<prolog-flatten-stream>>
  <<streams-singleton>>
  <<prolog-query>>
  <<prolog-frames-and-bindings>>

  (query-driver-loop)
#+end_src

#+RESULTS[9dc9e0febbd3837f0a361b0702d293ab6afa8586]:
#+begin_src shell

;;; Query input:
(assert! (address (Bitdiddle Ben) (Slumerville (Ridge Road) 10)))
Assertion added to data base.
;;; Query input:
(assert! (job (Bitdiddle Ben) (computer wizard)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Bitdiddle Ben) 60000))
Assertion added to data base.
;;; Query input:
(assert! (address (Hacker Alyssa P) (Cambridge (Mass Ave) 78)))
Assertion added to data base.
;;; Query input:
(assert! (job (Hacker Alyssa P) (computer programmer)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Hacker Alyssa P) 40000))
Assertion added to data base.
;;; Query input:
(assert! (supervisor (Hacker Alyssa P) (Bitdiddle Ben)))
Assertion added to data base.
;;; Query input:
(assert! (address (Fect Cy D) (Cambridge (Ames Street) 3)))
Assertion added to data base.
;;; Query input:
(assert! (job (Fect Cy D) (computer programmer)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Fect Cy D) 35000))
Assertion added to data base.
;;; Query input:
(assert! (supervisor (Fect Cy D) (Bitdiddle Ben)))
Assertion added to data base.
;;; Query input:
(assert! (address (Tweakit Lem E) (Boston (Bay State Road) 22)))
Assertion added to data base.
;;; Query input:
(assert! (job (Tweakit Lem E) (computer technician)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Tweakit Lem E) 25000))
Assertion added to data base.
;;; Query input:
(assert! (supervisor (Tweakit Lem E) (Bitdiddle Ben)))
Assertion added to data base.
;;; Query input:
(assert! (address (Reasoner Louis) (Slumerville (Pine Tree Road) 80)))
Assertion added to data base.
;;; Query input:
(assert! (job (Reasoner Louis) (computer programmer trainee)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Reasoner Louis) 30000))
Assertion added to data base.
;;; Query input:
(assert! (supervisor (Reasoner Louis) (Hacker Alyssa P)))
Assertion added to data base.
;;; Query input:
(assert! (supervisor (Bitdiddle Ben) (Warbucks Oliver)))
Assertion added to data base.
;;; Query input:
(assert! (address (Warbucks Oliver) (Swellesley (Top Heap Road))))
Assertion added to data base.
;;; Query input:
(assert! (job (Warbucks Oliver) (administration big wheel)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Warbucks Oliver) 150000))
Assertion added to data base.
;;; Query input:
(assert! (address (Scrooge Eben) (Weston (Shady Lane) 10)))
Assertion added to data base.
;;; Query input:
(assert! (job (Scrooge Eben) (accounting chief accountant)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Scrooge Eben) 75000))
Assertion added to data base.
;;; Query input:
(assert! (supervisor (Scrooge Eben) (Warbucks Oliver)))
Assertion added to data base.
;;; Query input:
(assert! (address (Cratchet Robert) (Allston (N Harvard Street) 16)))
Assertion added to data base.
;;; Query input:
(assert! (job (Cratchet Robert) (accounting scrivener)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Cratchet Robert) 18000))
Assertion added to data base.
;;; Query input:
(assert! (supervisor (Cratchet Robert) (Scrooge Eben)))
Assertion added to data base.
;;; Query input:
(assert! (address (Aull DeWitt) (Slumerville (Onion Square) 5)))
Assertion added to data base.
;;; Query input:
(assert! (job (Aull DeWitt) (administration secretary)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Aull DeWitt) 25000))
Assertion added to data base.
;;; Query input:
(assert! (supervisor (Aull DeWitt) (Warbucks Oliver)))
Assertion added to data base.
;;; Query input:
(assert! (can-do-job (computer wizard) (computer programmer)))
Assertion added to data base.
;;; Query input:
(assert! (can-do-job (computer wizard) (computer technician)))
Assertion added to data base.
;;; Query input:
(assert! (can-do-job (computer programmer) (computer programmer trainee)))
Assertion added to data base.
;;; Query input:
(assert! (can-do-job (administration secretary) (administration big wheel)))
Assertion added to data base.
;;; Query input:
(and (job (? x) (? j)) (unique (job (? anyone) (? j))))
;;; Query results:
(and (job (Aull DeWitt) (administration secretary))
     (unique (job (Aull DeWitt) (administration secretary))))
(and (job (Cratchet Robert) (accounting scrivener))
     (unique (job (Cratchet Robert) (accounting scrivener))))
(and (job (Scrooge Eben) (accounting chief accountant))
     (unique (job (Scrooge Eben) (accounting chief accountant))))
(and (job (Warbucks Oliver) (administration big wheel))
     (unique (job (Warbucks Oliver) (administration big wheel))))
(and (job (Reasoner Louis) (computer programmer trainee))
     (unique (job (Reasoner Louis) (computer programmer trainee))))
(and (job (Tweakit Lem E) (computer technician))
     (unique (job (Tweakit Lem E) (computer technician))))
(and (job (Bitdiddle Ben) (computer wizard))
     (unique (job (Bitdiddle Ben) (computer wizard))))

;;; Query input:
(and-better (job (? x) (? j)) (unique (job (? anyone) (? j))))
;;; Query results:

;;; Query input:
(and (can-do-job (? x) (computer programmer trainee)) (job (? person) (? x)))
;;; Query results:
(and (can-do-job (computer programmer) (computer programmer trainee))
     (job (Fect Cy D) (computer programmer)))
(and (can-do-job (computer programmer) (computer programmer trainee))
     (job (Hacker Alyssa P) (computer programmer)))

;;; Query input:
(and-better (can-do-job (? x) (computer programmer trainee))
            (job (? person) (? x)))
;;; Query results:

;;; Query input:
exit
#+end_src

It seems that this implementation is working, but the two ~and~'s are
not equivalent. This is illustrated by the following query:

~(and (job (? x) (? j)) (unique (job (? anyone) (? j))))~

The example above shows that there is indeed a difference in
processing the query. Why? Let us think, what would the query
~(unique (job (? anyone) (? j)))~ produce in general?
Well, it would produce a list of people who can do something. Clearly
this list won't have just a single entry, hence ~unique~ will fail.
Applying ~and~ will make the whole query fail.

The ordinary ~and~ does not behave this way, it pre-filters ~(job (?
anyone) (? j))~ with the results of the previous query, and _then_
there will be unique values.

***** DONE Exercise 4.77 lazy queries
      CLOSED: [2020-03-14 Sat 15:42]

Turned out to be surprisingly easy. I consulted inchmeal's solution
before looking into my own one, the one at scheme community wiki, and
the one of skanev. The scheme wiki one has one ingenious solution
based on purely syntactic rewriting. However, I think that mine is
better, as it allows the propagation of promises above the second
level. I only implemented it for negation, but the implementation for
the lisp-value should be trivial now. This solution also has a
potential for extension in that it could be easily enhanced to return
extended frames if needed.

#+name: prolog-frames-and-bindings-with-promises
#+begin_src scheme :exports code :results none
  (define (frame-promises frame)
      (if (null? frame)
          '()
          (cadr frame)))
  (define (frame-bindings frame)
    (if (null? frame)
      '()
      (car frame)))
  (define (make-binding variable value)
    (cons variable value))
  (define (binding-variable binding) (car binding))
  (define (binding-value binding) (cdr binding))
  (define (binding-in-frame variable frame)
    (assoc variable (frame-bindings frame)))
  (define (extend variable value frame)
    (make-frame-prolog (cons (make-binding variable value) (frame-bindings frame))
          (frame-promises frame)))
  (define (frame-add-promise frame promise)
    (make-frame-prolog (frame-bindings frame) (cons promise (frame-promises frame))))
  (define (make-frame-prolog bindings promises)
     (list bindings promises))
#+end_src

#+name: prolog-negate-with-promise
#+begin_src scheme :exports code :results none
  (define (negate operands frame-stream)
    (let ((promise (lambda (frame)
                      (if (has-not-bound?  (negated-query operands) frame)
                        'has-not-bound
                        (if (stream-null? (qeval (negated-query operands)
                              (singleton-stream frame)))
                  	   'let-it-stay ; let it stay
                           'kill-it)))))
    (stream-flatmap
     (lambda (frame)
      (if (has-not-bound? (negated-query operands) frame)
        (singleton-stream (frame-add-promise frame promise))
        (if (stream-null? (qeval (negated-query operands)
                              (singleton-stream frame)))
	   (singleton-stream frame) ; let it stay
           the-empty-stream)))      ; remove
     frame-stream)))

(define (has-not-bound? query frame)
  (cond ((null? query) #f)
        ((var? query) (if (binding-in-frame query frame)
                          (has-not-bound?
                               (binding-value (binding-in-frame query frame))
                               frame)
                          #t))
        ((pair? query) (or (has-not-bound? (car query) frame)
                            (has-not-bound? (cdr query) frame)))
        (else #f)))

#+end_src


#+name: prolog-input-lazy-negate
#+begin_src shell :exports code :results verbatim output code
  printf "%s" '
  <<prolog-input-sample-database>>
  <<prolog-input-canned-rules>>

  (and (supervisor ?x ?y)
       (not (job ?x (computer programmer))))

  (and (not (job ?x (computer programmer)))
       (supervisor ?x ?y))
  (same a ?x)
  exit'
#+end_src

#+name: prolog-qeval-promises
#+begin_src scheme :exports code :results none

(define (process-promises frame-stream)
  (define (processor frame)
    (let loop ((bindings (frame-bindings frame))
               (promises (frame-promises frame))
               (retval (make-frame-prolog (frame-bindings frame) '())))
         (cond ((null? promises) (singleton-stream retval)) ;; a normal frame
               ((eq? ((car promises) retval) 'kill-it) the-empty-stream) ;; frame to be killed
               ((eq? ((car promises) retval) 'let-it-stay) (loop bindings (cdr promises) retval)) ;; this promise can't kill this frame
               ((eq? ((car promises) retval) 'has-not-bound) (loop bindings (cdr promises) (frame-add-promise retval (car promises)))) ;; we don't have enough variables so far
               (else (error "process-promises -- unknown promise protocol")))))
  (stream-flatmap processor frame-stream))

  (define (qeval query frame-stream)
    #;(show #t "qeval\n")
    (process-promises
      (let ((qproc (get (type query) 'qeval)))
        (if qproc
           (begin #;(show #t  "qproc branch qproc=" (pretty qproc))
                  (qproc (contents query) frame-stream))
           (begin $;(display "simplebranch")
                  (simple-query query frame-stream))))))
#+end_src


#+header: :stdin prolog-input-lazy-negate
#+begin_src shell :shebang "#! /usr/bin/chibi-scheme" :exports code :results output scalar code :exports both
  <<prolog-glue>>
  <<put-and-get>>
  <<streams-common>>
  <<streams-2>>
  <<stream-append>>
  <<prolog-driver-loop>>
  <<prolog-instantiate>>
  <<prolog-qeval-promises>>
  <<prolog-simple-queries>>
  <<prolog-conjoin>>
  <<prolog-conjoin-installation>>
  <<prolog-disjoin>>
  <<prolog-disjoin-installation>>
  <<prolog-negate-with-promise>>
  <<prolog-negate-installation>>
  <<prolog-lisp-filter>>
  <<prolog-lisp-filter-installation>>
  <<prolog-always-true>>
  <<prolog-pattern-matching>>
  <<prolog-rules-and-unification>>
  <<prolog-database>>
  <<prolog-database-add-assertion-original>>
  <<prolog-database-store-assertion-in-index>>
  <<prolog-stream-operations>>
  <<prolog-stream-flatmap>>
  <<prolog-flatten-stream>>
  <<streams-singleton>>
  <<prolog-query>>
  <<prolog-frames-and-bindings-with-promises>>
  (query-driver-loop)
#+end_src

#+RESULTS[1a5d8048b84515bb96cb9351cccd33fdfb7396d8]:
#+begin_src shell

;;; Query input:
(assert! (address (Bitdiddle Ben) (Slumerville (Ridge Road) 10)))
Assertion added to data base.
;;; Query input:
(assert! (job (Bitdiddle Ben) (computer wizard)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Bitdiddle Ben) 60000))
Assertion added to data base.
;;; Query input:
(assert! (address (Hacker Alyssa P) (Cambridge (Mass Ave) 78)))
Assertion added to data base.
;;; Query input:
(assert! (job (Hacker Alyssa P) (computer programmer)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Hacker Alyssa P) 40000))
Assertion added to data base.
;;; Query input:
(assert! (supervisor (Hacker Alyssa P) (Bitdiddle Ben)))
Assertion added to data base.
;;; Query input:
(assert! (address (Fect Cy D) (Cambridge (Ames Street) 3)))
Assertion added to data base.
;;; Query input:
(assert! (job (Fect Cy D) (computer programmer)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Fect Cy D) 35000))
Assertion added to data base.
;;; Query input:
(assert! (supervisor (Fect Cy D) (Bitdiddle Ben)))
Assertion added to data base.
;;; Query input:
(assert! (address (Tweakit Lem E) (Boston (Bay State Road) 22)))
Assertion added to data base.
;;; Query input:
(assert! (job (Tweakit Lem E) (computer technician)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Tweakit Lem E) 25000))
Assertion added to data base.
;;; Query input:
(assert! (supervisor (Tweakit Lem E) (Bitdiddle Ben)))
Assertion added to data base.
;;; Query input:
(assert! (address (Reasoner Louis) (Slumerville (Pine Tree Road) 80)))
Assertion added to data base.
;;; Query input:
(assert! (job (Reasoner Louis) (computer programmer trainee)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Reasoner Louis) 30000))
Assertion added to data base.
;;; Query input:
(assert! (supervisor (Reasoner Louis) (Hacker Alyssa P)))
Assertion added to data base.
;;; Query input:
(assert! (supervisor (Bitdiddle Ben) (Warbucks Oliver)))
Assertion added to data base.
;;; Query input:
(assert! (address (Warbucks Oliver) (Swellesley (Top Heap Road))))
Assertion added to data base.
;;; Query input:
(assert! (job (Warbucks Oliver) (administration big wheel)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Warbucks Oliver) 150000))
Assertion added to data base.
;;; Query input:
(assert! (address (Scrooge Eben) (Weston (Shady Lane) 10)))
Assertion added to data base.
;;; Query input:
(assert! (job (Scrooge Eben) (accounting chief accountant)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Scrooge Eben) 75000))
Assertion added to data base.
;;; Query input:
(assert! (supervisor (Scrooge Eben) (Warbucks Oliver)))
Assertion added to data base.
;;; Query input:
(assert! (address (Cratchet Robert) (Allston (N Harvard Street) 16)))
Assertion added to data base.
;;; Query input:
(assert! (job (Cratchet Robert) (accounting scrivener)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Cratchet Robert) 18000))
Assertion added to data base.
;;; Query input:
(assert! (supervisor (Cratchet Robert) (Scrooge Eben)))
Assertion added to data base.
;;; Query input:
(assert! (address (Aull DeWitt) (Slumerville (Onion Square) 5)))
Assertion added to data base.
;;; Query input:
(assert! (job (Aull DeWitt) (administration secretary)))
Assertion added to data base.
;;; Query input:
(assert! (salary (Aull DeWitt) 25000))
Assertion added to data base.
;;; Query input:
(assert! (supervisor (Aull DeWitt) (Warbucks Oliver)))
Assertion added to data base.
;;; Query input:
(assert! (can-do-job (computer wizard) (computer programmer)))
Assertion added to data base.
;;; Query input:
(assert! (can-do-job (computer wizard) (computer technician)))
Assertion added to data base.
;;; Query input:
(assert! (can-do-job (computer programmer) (computer programmer trainee)))
Assertion added to data base.
;;; Query input:
(assert! (can-do-job (administration secretary) (administration big wheel)))
Assertion added to data base.
;;; Query input:
(assert!
 (rule (lives-near (? person-1) (? person-2))
       (and (address (? person-1) ((? town) ? rest-1))
            (address (? person-2) ((? town) ? rest-2))
            (not (same (? person-1) (? person-2))))))
Assertion added to data base.
;;; Query input:
(assert! (rule (same (? x) (? x))))
Assertion added to data base.
;;; Query input:
(assert!
 (rule (wheel (? person))
       (and (supervisor (? middle-manager) (? person))
            (supervisor (? x) (? middle-manager)))))
Assertion added to data base.
;;; Query input:
(assert!
 (rule (outranked-by (? staff-person) (? boss))
       (or (supervisor (? staff-person) (? boss))
           (and (supervisor (? staff-person) (? middle-manager))
                (outranked-by (? middle-manager) (? boss))))))
Assertion added to data base.
;;; Query input:
(assert! (rule (append-to-form () (? y) (? y))))
Assertion added to data base.
;;; Query input:
(assert!
 (rule (append-to-form ((? u) ? v) (? y) ((? u) ? z))
       (append-to-form (? v) (? y) (? z))))
Assertion added to data base.
;;; Query input:
(and (supervisor (? x) (? y)) (not (job (? x) (computer programmer))))
;;; Query results:
(and (supervisor (Aull DeWitt) (Warbucks Oliver))
     (not (job (Aull DeWitt) (computer programmer))))
(and (supervisor (Cratchet Robert) (Scrooge Eben))
     (not (job (Cratchet Robert) (computer programmer))))
(and (supervisor (Scrooge Eben) (Warbucks Oliver))
     (not (job (Scrooge Eben) (computer programmer))))
(and (supervisor (Bitdiddle Ben) (Warbucks Oliver))
     (not (job (Bitdiddle Ben) (computer programmer))))
(and (supervisor (Reasoner Louis) (Hacker Alyssa P))
     (not (job (Reasoner Louis) (computer programmer))))
(and (supervisor (Tweakit Lem E) (Bitdiddle Ben))
     (not (job (Tweakit Lem E) (computer programmer))))

;;; Query input:
(and (not (job (? x) (computer programmer))) (supervisor (? x) (? y)))
;;; Query results:
(and (not (job (Aull DeWitt) (computer programmer)))
     (supervisor (Aull DeWitt) (Warbucks Oliver)))
(and (not (job (Cratchet Robert) (computer programmer)))
     (supervisor (Cratchet Robert) (Scrooge Eben)))
(and (not (job (Scrooge Eben) (computer programmer)))
     (supervisor (Scrooge Eben) (Warbucks Oliver)))
(and (not (job (Bitdiddle Ben) (computer programmer)))
     (supervisor (Bitdiddle Ben) (Warbucks Oliver)))
(and (not (job (Reasoner Louis) (computer programmer)))
     (supervisor (Reasoner Louis) (Hacker Alyssa P)))
(and (not (job (Tweakit Lem E) (computer programmer)))
     (supervisor (Tweakit Lem E) (Bitdiddle Ben)))

;;; Query input:
(same a (? x))
;;; Query results:
apply-a-rule
rule=(rule (same (? x) (? x)))
pattern=(same a (? x))
frame=()

unify-result=((((? x) . a) ((? 1 x) . a)) ())
(same a a)

;;; Query input:
exit
#+end_src

***** DONE Exercise 4.78 non-deterministic queries
      CLOSED: [2020-03-15 Sun 12:40]

#+name: prolog-in-amb-database
#+begin_src scheme :exports code
  (lq '(assert! (address (Bitdiddle Ben) (Slumerville (Ridge Road) 10))))
  (lq '(assert! (job (Bitdiddle Ben) (computer wizard))))
  (lq '(assert! (salary (Bitdiddle Ben) 60000)))
  (lq '(assert! (address (Hacker Alyssa P) (Cambridge (Mass Ave) 78))))
  (lq '(assert! (job (Hacker Alyssa P) (computer programmer))))
  (lq '(assert! (salary (Hacker Alyssa P) 40000)))
  (lq '(assert! (supervisor (Hacker Alyssa P) (Bitdiddle Ben))))
  (lq '(assert! (address (Fect Cy D) (Cambridge (Ames Street) 3))))
  (lq '(assert! (job (Fect Cy D) (computer programmer))))
  (lq '(assert! (salary (Fect Cy D) 35000)))
  (lq '(assert! (supervisor (Fect Cy D) (Bitdiddle Ben))))
  (lq '(assert! (address (Tweakit Lem E) (Boston (Bay State Road) 22))))
  (lq '(assert! (job (Tweakit Lem E) (computer technician))))
  (lq '(assert! (salary (Tweakit Lem E) 25000)))
  (lq '(assert! (supervisor (Tweakit Lem E) (Bitdiddle Ben))))
  (lq '(assert! (address (Reasoner Louis) (Slumerville (Pine Tree Road) 80))))
  (lq '(assert! (job (Reasoner Louis) (computer programmer trainee))))
  (lq '(assert! (salary (Reasoner Louis) 30000)))
  (lq '(assert! (supervisor (Reasoner Louis) (Hacker Alyssa P))))
  (lq '(assert! (supervisor (Bitdiddle Ben) (Warbucks Oliver))))
  (lq '(assert! (address (Warbucks Oliver) (Swellesley (Top Heap Road)))))
  (lq '(assert! (job (Warbucks Oliver) (administration big wheel))))
  (lq '(assert! (salary (Warbucks Oliver) 150000)))
  (lq '(assert! (address (Scrooge Eben) (Weston (Shady Lane) 10))))
  (lq '(assert! (job (Scrooge Eben) (accounting chief accountant))))
  (lq '(assert! (salary (Scrooge Eben) 75000)))
  (lq '(assert! (supervisor (Scrooge Eben) (Warbucks Oliver))))
  (lq '(assert! (address (Cratchet Robert) (Allston (N Harvard Street) 16))))
  (lq '(assert! (job (Cratchet Robert) (accounting scrivener))))
  (lq '(assert! (salary (Cratchet Robert) 18000)))
  (lq '(assert! (supervisor (Cratchet Robert) (Scrooge Eben))))
  (lq '(assert! (address (Aull DeWitt) (Slumerville (Onion Square) 5))))
  (lq '(assert! (job (Aull DeWitt) (administration secretary))))
  (lq '(assert! (salary (Aull DeWitt) 25000)))
  (lq '(assert! (supervisor (Aull DeWitt) (Warbucks Oliver))))
  (lq '(assert! (can-do-job (computer wizard) (computer programmer))))
  (lq '(assert! (can-do-job (computer wizard) (computer technician))))
  (lq '(assert! (can-do-job (computer programmer) (computer programmer trainee))))
  (lq '(assert! (can-do-job (administration secretary) (administration big wheel))))
  (lq '(assert! (rule (lives-near ?person-1 ?person-2)
		 (and (address ?person-1 (?town . ?rest-1))
		      (address ?person-2 (?town . ?rest-2))
		      (not (same ?person-1 ?person-2))))))
  (lq '(assert! (rule (same ?x ?x))))
  (lq '(assert! (rule (wheel ?person)
	    (and (supervisor ?middle-manager ?person)
	         (supervisor ?x ?middle-manager)))))
  (lq '(assert! (rule (outranked-by ?staff-person ?boss)
	            (or (supervisor ?staff-person ?boss)
	                (and (supervisor ?staff-person ?middle-manager)
		             (outranked-by ?middle-manager ?boss))))))
  (lq '(assert! (rule (append-to-form () ?y ?y))))
  (lq '(assert! (rule (append-to-form (?u . ?v) ?y (?u . ?z))
                 (append-to-form ?v ?y ?z))))

#+end_src

#+name: primitive-procedures-prolog-in-amb
#+begin_src scheme :exports code
(set! primitive-procedures
        (append (list
(list 'symbol->string symbol->string)
(list 'string? string?)
(list 'string=? string=?)
(list 'substring substring)
(list 'tagged-list? tagged-list?)
(list 'string->symbol string->symbol)
(list 'string-length string-length)
(list 'append append)
(list 'written written)
(list 'displayed displayed)
(list 'nl nl)
(list 'apply-in-underlying-scheme apply-in-underlying-scheme)
(list 'eval eval)
(list 'assq assq)
(list 'string-append string-append)
(list 'interaction-environment interaction-environment)
) primitive-procedures))
#+end_src

#+name: prolog-in-amb
#+begin_src scheme :exports code :results verbatim code
  (define THE-ASSERTIONS '())
  (define THE-RULES '())

  (define (add-rule-or-assertion! assertion)
    (if (rule? assertion)
	(add-rule! assertion)
	(add-assertion! assertion)))

  (define (add-assertion! assertion)
    (set! THE-ASSERTIONS  (cons assertion THE-ASSERTIONS))
    'ok)
  (define (add-rule! rule)
    (set! THE-RULES (cons rule THE-RULES))
    'ok)
  (define (rule? statement)
    (tagged-list? statement 'rule))
  (define (conclusion rule) (cadr rule))
  (define (rule-body rule)
    (if (null? (cddr rule)) '(always-true) (caddr rule)))

  (define (lq i)
    (let ((q (query-syntax-process i)))
      (cond  ((assertion-to-be-added? q)
	      (add-rule-or-assertion! (add-assertion-body q))
	      'added)
	     (else
	      (instantiate
		  q
		  (try-qeval (qeval q (make-frame-prolog '() '())))
		(lambda (v f)
		  (contract-question-mark v)))))))
  (define (query-syntax-process exp)
    (map-over-symbols expand-question-mark exp))
  (define (map-over-symbols proc exp)
    (cond ((pair? exp)
	   (cons (map-over-symbols proc (car exp))
		 (map-over-symbols proc (cdr exp))))
	  ((symbol? exp) (proc exp))
	  (else exp)))

  <<prolog-query>>
  <<prolog-frames-and-bindings-with-promises>>
  <<prolog-instantiate>>
  <<put-and-get>>
  (define (try-qeval result)
    (if (eq? result 'no-more-answers)
	(amb)
	result))
  (define (qeval query frame)
    (amb (processor
	  (let ((qproc (get (type query) 'qeval)))
	    (if qproc
		(qproc (contents query) frame)
		(simple-query query frame))))
	 'no-more-answers))
  (define (processor frame)
    (define (loop bindings promises retval)
      (cond ((null? promises) retval)
	    ((eq? ((car promises) retval) 'kill-it)
	     (amb))
	    ((eq? ((car promises) retval) 'let-it-stay)
	     (loop bindings
		   (cdr promises)
		   retval)) ;; this promise can't kill this frame
	    ((eq? ((car promises) retval) 'has-not-bound)
	     (loop bindings
		   (cdr promises)
		   (frame-add-promise retval (car promises)))) ;; we don't have enough variables so far
	    (else (error "process-promises -- unknown promise protocol"))))
    (loop (frame-bindings frame)
	  (frame-promises frame)
	  (make-frame-prolog (frame-bindings frame) '())))
  (define (simple-query query-pattern frame)
    (amb
     (find-assertions query-pattern frame)
     (apply-rules query-pattern frame)))
  (define (find-assertions query-pattern frame)
    (let ((a (an-element-of THE-ASSERTIONS)))
      (check-an-assertion a query-pattern frame)))
  (define (check-an-assertion assertion query-pat query-frame)
    (let ((match-result
	   (pattern-match query-pat assertion query-frame)))
      (if (eq? match-result 'failed)
	  (amb)
	  match-result)))
  (define (apply-rules pattern frame)
    (let ((r (an-element-of THE-RULES)))
      (apply-a-rule r pattern frame)))

  (define (apply-a-rule rule query-pattern query-frame)
    (let ((clean-rule (rename-variables-in rule)))
      (let ((unify-result (unify-match query-pattern
				       (conclusion clean-rule)
				       query-frame)))
	(if (eq? unify-result 'failed)
	    (amb)
	    (try-qeval (qeval (rule-body clean-rule) unify-result))))))

  (define (rename-variables-in rule)
    (let ((rule-application-id (new-rule-application-id)))
      (define (tree-walk exp)
	(cond ((var? exp)
	       (make-new-variable exp rule-application-id))
	      ((pair? exp)
	       (cons (tree-walk (car exp))
		     (tree-walk (cdr exp))))
	      (else exp)))
      (tree-walk rule)))

  (define (unify-match p1 p2 frame)
    (cond ((eq? frame 'failed) 'failed)
	  ((equal? p1 p2) frame)
	  ((var? p1) (extend-if-possible p1 p2 frame))
	  ((var? p2) (extend-if-possible p2 p1 frame))
					  ; ***
	  ((and (pair? p1) (pair? p2))
	   (unify-match (cdr p1)
			(cdr p2)
			(unify-match (car p1)
				     (car p2)
				     frame)))
	  (else 'failed)))

  (define (extend-if-possible var val frame)
    (let ((binding (binding-in-frame var frame)))
      (cond (binding
	     (unify-match (binding-value binding) val frame))
					  ; ***
	    ((var? val)
	     (let ((binding (binding-in-frame val frame)))
	       (if binding
		   (unify-match
		    var (binding-value binding) frame)
		   (extend var val frame))))
	    ((depends-on? val var frame)
					  ; ***
	     'failed)
	    (else (extend var val frame)))))

  (define (depends-on? exp var frame)
    (define (tree-walk e)
      (cond ((var? e)
	     (if (equal? var e)
		 true
		 (let ((b (binding-in-frame e frame)))
		   (if b
		       (tree-walk (binding-value b))
		       false))))
	    ((pair? e)
	     (or (tree-walk (car e))
		 (tree-walk (cdr e))))
	    (else false)))
    (tree-walk exp))


  (define (and a b)
    (if a
	(if b true false)
	false))

  (define (or a b)
    (if a
	true
	(if b true false)))

  (define (not e)
    (if e false true))

  (define (pattern-match pat dat frame)
    (cond ((eq? frame 'failed) 'failed)
	  ((equal? pat dat) frame)
	  ((var? pat) (extend-if-consistent pat dat frame))
	  ((and (pair? pat) (pair? dat))
	   (pattern-match
	    (cdr pat)
	    (cdr dat)
	    (pattern-match (car pat) (car dat) frame)))
	  (else 'failed)))
  (define (extend-if-consistent var dat frame)
    (let ((binding (binding-in-frame var frame)))
      (if binding
	  (pattern-match (binding-value binding) dat frame)
	  (extend var dat frame))))
  <<prolog-always-true>>
  (define (conjoin conjuncts frame)
    (if (empty-conjunction? conjuncts)
	frame
	(conjoin (rest-conjuncts conjuncts)
		 (try-qeval (qeval (first-conjunct conjuncts) frame)))))
  <<prolog-conjoin-installation>>
  ;; This place has a subtle bug in case the stream happens to be infinite.
  (define (disjoin disjuncts frame)
    (if (empty-disjunction? disjuncts)
	(amb)
	(amb
	 (try-qeval (qeval (first-disjunct disjuncts) frame))
	 (disjoin (rest-disjuncts disjuncts) frame))))
  <<prolog-disjoin-installation>>

  (define (negate operands frame1)
    (let ((promise (lambda (frame)
		     (if (has-not-bound?  (negated-query operands) frame)
			 'has-not-bound
			 (if (eq? 'no-more-values (let ((retval (qeval
								  (negated-query operands)
								  frame)))
						    #;(display "testing negation: ")
						    ;(display retval) (newline)
						    retval))
			     'let-it-stay ; let it stay
			     'kill-it)))))
      (frame-add-promise frame1 promise)))


  (define (has-not-bound? query frame)
    (cond ((null? query) #f)
	  ((var? query) (if (binding-in-frame query frame)
			    (has-not-bound?
			     (binding-value (binding-in-frame query frame))
			     frame)
			    #t))
	  ((pair? query) (or (has-not-bound? (car query) frame)
			     (has-not-bound? (cdr query) frame)))
	  (else #f)))
  <<prolog-negate-installation>>
  (define (lisp-value call frame1)
    (let ((promise (lambda (frame) (if (has-not-bound? call frame)
				  'has-not-bound
				  (if (execute
				       (instantiate
					   call
					   frame
					 (lambda (v f)
					   (error "Unknown pat var: LISP-VALUE" v))))
				      'let-it-stay
				      'kill-it)))))
      (frame-add-promise frame1 promise)
      ))
  (define (execute exp)
    (let ((pred (eval
		  (predicate exp)
		  (interaction-environment))))
   (apply-in-underlying-scheme pred  (args exp))))

  <<prolog-lisp-filter-installation>>

#+end_src


#+name: s-amb-prolog-implementing-prolog-in-amb
#+begin_src shell :exports code :results verbatim output
  cat << EOF
  <<s-amb-input-require>>
  <<s-amb-input-an-element-of>>
  <<s-amb-distinct>>
  <<prolog-in-amb>>
  <<prolog-in-amb-database>>
  (lq '(job ?x (computer programmer)))
  try-again
  (lq '(same a ?x))
  (lq '(and (job ?x (computer programmer)) (salary ?x 40000)))
  (lq '(or (job ?x (computer programmer)) (salary ?x 18000)))
  (lq '(and (job ?x (computer programmer)) (not (salary ?x 40000))))
  (lq '(and (job ?x (computer programmer))
            (salary ?x ?y)
            ))
  (lq '(and (salary ?x ?y) (lisp-value < ?y 50000)))
  try-again
  try-again
  try-again
  (lq '(outranked-by ?w1 ?w2))
  try-again
  (lq '(lives-near ?w1 ?w2))
  (exit)
  EOF
#+end_src

#+header: :stdin s-amb-prolog-implementing-prolog-in-amb
#+begin_src shell :shebang "#! /usr/bin/chibi-scheme" :results output scalar code :exports both
<<s-glue1>>
<<s-amb-amb-implementation>>
<<s-amb-analyze-eval-with-let-amb-ramb-pset-iffail>>

<<s-amb-analyze-permanent-assignment>>
<<s-let-implementation>>
<<s-amb-simple-expressions>>
<<s-amb-analyze-if>>
<<s-amb-analyze-sequence>>
<<s-amb-analyze-definition>>
<<s-amb-analyze-assignment>>
<<s-amb-analyze-application>>
<<s-amb-get-args>>
<<s-amb-execute-application>>
<<s-amb-analyze-amb>>
<<s-amb-ramb>>
<<s-amb-analyze-if-fail>>
<<s-syntax>>
<<s-application>>
<<s-cond-with-arrow>>
<<s-truefalse>>
<<s-compound-procedures>>
<<s-environments-list-of-bindings-better-abstractions>>
<<s-primitive-procedures>>
<<primitive-procedures-prolog-in-amb>>
<<s-amb-driver-loop>>
<<s-user-prompt-print>>
<<s-glue2>>
(driver-loop)

#+end_src

#+RESULTS[c4fe95e085bb192267fbfbf1384d661f67154a68]:
#+begin_src shell

;;; Amb-Eval input:
(define (require p) (if (not p) (amb)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (an-element-of items) (require (not (null? items))) (amb (car items) (an-element-of (cdr items))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (an-integer-starting-from n) (amb n (an-integer-starting-from (+ n 1))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (distinct? items) (cond ((null? items) true) ((null? (cdr items)) true) ((member (car items) (cdr items)) false) (else (distinct? (cdr items)))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define THE-ASSERTIONS (quote ()))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define THE-RULES (quote ()))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (add-rule-or-assertion! assertion) (if (rule? assertion) (add-rule! assertion) (add-assertion! assertion)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (add-assertion! assertion) (set! THE-ASSERTIONS (cons assertion THE-ASSERTIONS)) (quote ok))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (add-rule! rule) (set! THE-RULES (cons rule THE-RULES)) (quote ok))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (rule? statement) (tagged-list? statement (quote rule)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (conclusion rule) (cadr rule))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (rule-body rule) (if (null? (cddr rule)) (quote (always-true)) (caddr rule)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (lq i) (let ((q (query-syntax-process i))) (cond ((assertion-to-be-added? q) (add-rule-or-assertion! (add-assertion-body q)) (quote added)) (else (instantiate q (try-qeval (qeval q (make-frame-prolog (quote ()) (quote ())))) (lambda (v f) (contract-question-mark v)))))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (query-syntax-process exp) (map-over-symbols expand-question-mark exp))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (map-over-symbols proc exp) (cond ((pair? exp) (cons (map-over-symbols proc (car exp)) (map-over-symbols proc (cdr exp)))) ((symbol? exp) (proc exp)) (else exp)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (type exp) (if (pair? exp) (car exp) (error "Unknown expression TYPE" exp)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (contents exp) (if (pair? exp) (cdr exp) (error "Unknown expression CONTENTS" exp)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (assertion-to-be-added? exp) (eq? (type exp) (quote assert!)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (add-assertion-body exp) (car (contents exp)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (empty-conjunction? exps) (null? exps))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (first-conjunct exps) (car exps))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (rest-conjuncts exps) (cdr exps))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (empty-disjunction? exps) (null? exps))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (first-disjunct exps) (car exps))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (rest-disjuncts exps) (cdr exps))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (negated-query exps) (car exps))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (predicate exps) (car exps))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (args exps) (cdr exps))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (rule? statement) (tagged-list? statement (quote rule)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (conclusion rule) (cadr rule))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (rule-body rule) (if (null? (cddr rule)) (quote (always-true)) (caddr rule)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (query-syntax-process exp) (map-over-symbols expand-question-mark exp))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (map-over-symbols proc exp) (cond ((pair? exp) (cons (map-over-symbols proc (car exp)) (map-over-symbols proc (cdr exp)))) ((symbol? exp) (proc exp)) (else exp)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (expand-question-mark symbol) (let ((chars (symbol->string symbol))) (if (string=? (substring chars 0 1) "?") (list (quote ?) (string->symbol (substring chars 1 (string-length chars)))) symbol)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (var? exp) (tagged-list? exp (quote ?)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (constant-symbol? exp) (symbol? exp))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define rule-counter 0)
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (new-rule-application-id) (set! rule-counter (+ 1 rule-counter)) rule-counter)
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (make-new-variable var rule-application-id) (cons (quote ?) (cons rule-application-id (cdr var))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (contract-question-mark variable) (string->symbol (string-append "?" (if (number? (cadr variable)) (string-append (symbol->string (caddr variable)) "-" (number->string (cadr variable))) (symbol->string (cadr variable))))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (frame-promises frame) (if (null? frame) (quote ()) (cadr frame)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (frame-bindings frame) (if (null? frame) (quote ()) (car frame)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (make-binding variable value) (cons variable value))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (binding-variable binding) (car binding))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (binding-value binding) (cdr binding))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (binding-in-frame variable frame) (assoc variable (frame-bindings frame)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (extend variable value frame) (make-frame-prolog (cons (make-binding variable value) (frame-bindings frame)) (frame-promises frame)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (frame-add-promise frame promise) (make-frame-prolog (frame-bindings frame) (cons promise (frame-promises frame))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (make-frame-prolog bindings promises) (list bindings promises))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (instantiate exp frame unbound-var-handler) (define (copy exp) (cond ((var? exp) (let ((binding (binding-in-frame exp frame))) (if binding (copy (binding-value binding)) (unbound-var-handler exp frame)))) ((pair? exp) (cons (copy (car exp)) (copy (cdr exp)))) (else exp))) (copy exp))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (make-table) (let ((local-table (list (quote *table*)))) (define (lookup key-1 key-2) (let ((subtable (assoc key-1 (cdr local-table)))) (if subtable (let ((record (assoc key-2 (cdr subtable)))) (if record (cdr record) false)) false))) (define (insert! key-1 key-2 value) (let ((subtable (assoc key-1 (cdr local-table)))) (if subtable (let ((record (assoc key-2 (cdr subtable)))) (if record (set-cdr! record value) (set-cdr! subtable (cons (cons key-2 value) (cdr subtable))))) (set-cdr! local-table (cons (list key-1 (cons key-2 value)) (cdr local-table))))) (quote ok)) (define (dispatch m) (cond ((eq? m (quote lookup-proc)) lookup) ((eq? m (quote insert-proc!)) insert!) (else (error "Unknown operation -- TABLE" m)))) dispatch))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define operation-table (make-table))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define get (operation-table (quote lookup-proc)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define put (operation-table (quote insert-proc!)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define coercion-table (make-table))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define get-coercion (coercion-table (quote lookup-proc)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define put-coercion (coercion-table (quote insert-proc!)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (try-qeval result) (if (eq? result (quote no-more-answers)) (amb) result))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (qeval query frame) (amb (processor (let ((qproc (get (type query) (quote qeval)))) (if qproc (qproc (contents query) frame) (simple-query query frame)))) (quote no-more-answers)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (processor frame) (define (loop bindings promises retval) (cond ((null? promises) retval) ((eq? ((car promises) retval) (quote kill-it)) (amb)) ((eq? ((car promises) retval) (quote let-it-stay)) (loop bindings (cdr promises) retval)) ((eq? ((car promises) retval) (quote has-not-bound)) (loop bindings (cdr promises) (frame-add-promise retval (car promises)))) (else (error "process-promises -- unknown promise protocol")))) (loop (frame-bindings frame) (frame-promises frame) (make-frame-prolog (frame-bindings frame) (quote ()))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (simple-query query-pattern frame) (amb (find-assertions query-pattern frame) (apply-rules query-pattern frame)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (find-assertions query-pattern frame) (let ((a (an-element-of THE-ASSERTIONS))) (check-an-assertion a query-pattern frame)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (check-an-assertion assertion query-pat query-frame) (let ((match-result (pattern-match query-pat assertion query-frame))) (if (eq? match-result (quote failed)) (amb) match-result)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (apply-rules pattern frame) (let ((r (an-element-of THE-RULES))) (apply-a-rule r pattern frame)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (apply-a-rule rule query-pattern query-frame) (let ((clean-rule (rename-variables-in rule))) (let ((unify-result (unify-match query-pattern (conclusion clean-rule) query-frame))) (if (eq? unify-result (quote failed)) (amb) (try-qeval (qeval (rule-body clean-rule) unify-result))))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (rename-variables-in rule) (let ((rule-application-id (new-rule-application-id))) (define (tree-walk exp) (cond ((var? exp) (make-new-variable exp rule-application-id)) ((pair? exp) (cons (tree-walk (car exp)) (tree-walk (cdr exp)))) (else exp))) (tree-walk rule)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (unify-match p1 p2 frame) (cond ((eq? frame (quote failed)) (quote failed)) ((equal? p1 p2) frame) ((var? p1) (extend-if-possible p1 p2 frame)) ((var? p2) (extend-if-possible p2 p1 frame)) ((and (pair? p1) (pair? p2)) (unify-match (cdr p1) (cdr p2) (unify-match (car p1) (car p2) frame))) (else (quote failed))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (extend-if-possible var val frame) (let ((binding (binding-in-frame var frame))) (cond (binding (unify-match (binding-value binding) val frame)) ((var? val) (let ((binding (binding-in-frame val frame))) (if binding (unify-match var (binding-value binding) frame) (extend var val frame)))) ((depends-on? val var frame) (quote failed)) (else (extend var val frame)))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (depends-on? exp var frame) (define (tree-walk e) (cond ((var? e) (if (equal? var e) true (let ((b (binding-in-frame e frame))) (if b (tree-walk (binding-value b)) false)))) ((pair? e) (or (tree-walk (car e)) (tree-walk (cdr e)))) (else false))) (tree-walk exp))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (and a b) (if a (if b true false) false))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (or a b) (if a true (if b true false)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (not e) (if e false true))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (pattern-match pat dat frame) (cond ((eq? frame (quote failed)) (quote failed)) ((equal? pat dat) frame) ((var? pat) (extend-if-consistent pat dat frame)) ((and (pair? pat) (pair? dat)) (pattern-match (cdr pat) (cdr dat) (pattern-match (car pat) (car dat) frame))) (else (quote failed))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (extend-if-consistent var dat frame) (let ((binding (binding-in-frame var frame))) (if binding (pattern-match (binding-value binding) dat frame) (extend var dat frame))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (always-true ignore frame-stream) frame-stream)
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(put (quote always-true) (quote qeval) always-true)
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (conjoin conjuncts frame) (if (empty-conjunction? conjuncts) frame (conjoin (rest-conjuncts conjuncts) (try-qeval (qeval (first-conjunct conjuncts) frame)))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(put (quote and) (quote qeval) conjoin)
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (disjoin disjuncts frame) (if (empty-disjunction? disjuncts) (amb) (amb (try-qeval (qeval (first-disjunct disjuncts) frame)) (disjoin (rest-disjuncts disjuncts) frame))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(put (quote or) (quote qeval) disjoin)
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (negate operands frame1) (let ((promise (lambda (frame) (if (has-not-bound? (negated-query operands) frame) (quote has-not-bound) (if (eq? (quote no-more-values) (let ((retval (qeval (negated-query operands) frame))) retval)) (quote let-it-stay) (quote kill-it)))))) (frame-add-promise frame1 promise)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (has-not-bound? query frame) (cond ((null? query) #f) ((var? query) (if (binding-in-frame query frame) (has-not-bound? (binding-value (binding-in-frame query frame)) frame) #t)) ((pair? query) (or (has-not-bound? (car query) frame) (has-not-bound? (cdr query) frame))) (else #f)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(put (quote not) (quote qeval) negate)
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (lisp-value call frame1) (let ((promise (lambda (frame) (if (has-not-bound? call frame) (quote has-not-bound) (if (execute (instantiate call frame (lambda (v f) (error "Unknown pat var: LISP-VALUE" v)))) (quote let-it-stay) (quote kill-it)))))) (frame-add-promise frame1 promise)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (execute exp) (let ((pred (eval (predicate exp) (interaction-environment)))) (apply-in-underlying-scheme pred (args exp))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(put (quote lisp-value) (quote qeval) lisp-value)
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(lq (quote (assert! (address (Bitdiddle Ben) (Slumerville (Ridge Road) 10)))))
;;; Starting a new problem 
;;; Amb-Eval value:
added
;;; Amb-Eval input:
(lq (quote (assert! (job (Bitdiddle Ben) (computer wizard)))))
;;; Starting a new problem 
;;; Amb-Eval value:
added
;;; Amb-Eval input:
(lq (quote (assert! (salary (Bitdiddle Ben) 60000))))
;;; Starting a new problem 
;;; Amb-Eval value:
added
;;; Amb-Eval input:
(lq (quote (assert! (address (Hacker Alyssa P) (Cambridge (Mass Ave) 78)))))
;;; Starting a new problem 
;;; Amb-Eval value:
added
;;; Amb-Eval input:
(lq (quote (assert! (job (Hacker Alyssa P) (computer programmer)))))
;;; Starting a new problem 
;;; Amb-Eval value:
added
;;; Amb-Eval input:
(lq (quote (assert! (salary (Hacker Alyssa P) 40000))))
;;; Starting a new problem 
;;; Amb-Eval value:
added
;;; Amb-Eval input:
(lq (quote (assert! (supervisor (Hacker Alyssa P) (Bitdiddle Ben)))))
;;; Starting a new problem 
;;; Amb-Eval value:
added
;;; Amb-Eval input:
(lq (quote (assert! (address (Fect Cy D) (Cambridge (Ames Street) 3)))))
;;; Starting a new problem 
;;; Amb-Eval value:
added
;;; Amb-Eval input:
(lq (quote (assert! (job (Fect Cy D) (computer programmer)))))
;;; Starting a new problem 
;;; Amb-Eval value:
added
;;; Amb-Eval input:
(lq (quote (assert! (salary (Fect Cy D) 35000))))
;;; Starting a new problem 
;;; Amb-Eval value:
added
;;; Amb-Eval input:
(lq (quote (assert! (supervisor (Fect Cy D) (Bitdiddle Ben)))))
;;; Starting a new problem 
;;; Amb-Eval value:
added
;;; Amb-Eval input:
(lq (quote (assert! (address (Tweakit Lem E) (Boston (Bay State Road) 22)))))
;;; Starting a new problem 
;;; Amb-Eval value:
added
;;; Amb-Eval input:
(lq (quote (assert! (job (Tweakit Lem E) (computer technician)))))
;;; Starting a new problem 
;;; Amb-Eval value:
added
;;; Amb-Eval input:
(lq (quote (assert! (salary (Tweakit Lem E) 25000))))
;;; Starting a new problem 
;;; Amb-Eval value:
added
;;; Amb-Eval input:
(lq (quote (assert! (supervisor (Tweakit Lem E) (Bitdiddle Ben)))))
;;; Starting a new problem 
;;; Amb-Eval value:
added
;;; Amb-Eval input:
(lq (quote (assert! (address (Reasoner Louis) (Slumerville (Pine Tree Road) 80)))))
;;; Starting a new problem 
;;; Amb-Eval value:
added
;;; Amb-Eval input:
(lq (quote (assert! (job (Reasoner Louis) (computer programmer trainee)))))
;;; Starting a new problem 
;;; Amb-Eval value:
added
;;; Amb-Eval input:
(lq (quote (assert! (salary (Reasoner Louis) 30000))))
;;; Starting a new problem 
;;; Amb-Eval value:
added
;;; Amb-Eval input:
(lq (quote (assert! (supervisor (Reasoner Louis) (Hacker Alyssa P)))))
;;; Starting a new problem 
;;; Amb-Eval value:
added
;;; Amb-Eval input:
(lq (quote (assert! (supervisor (Bitdiddle Ben) (Warbucks Oliver)))))
;;; Starting a new problem 
;;; Amb-Eval value:
added
;;; Amb-Eval input:
(lq (quote (assert! (address (Warbucks Oliver) (Swellesley (Top Heap Road))))))
;;; Starting a new problem 
;;; Amb-Eval value:
added
;;; Amb-Eval input:
(lq (quote (assert! (job (Warbucks Oliver) (administration big wheel)))))
;;; Starting a new problem 
;;; Amb-Eval value:
added
;;; Amb-Eval input:
(lq (quote (assert! (salary (Warbucks Oliver) 150000))))
;;; Starting a new problem 
;;; Amb-Eval value:
added
;;; Amb-Eval input:
(lq (quote (assert! (address (Scrooge Eben) (Weston (Shady Lane) 10)))))
;;; Starting a new problem 
;;; Amb-Eval value:
added
;;; Amb-Eval input:
(lq (quote (assert! (job (Scrooge Eben) (accounting chief accountant)))))
;;; Starting a new problem 
;;; Amb-Eval value:
added
;;; Amb-Eval input:
(lq (quote (assert! (salary (Scrooge Eben) 75000))))
;;; Starting a new problem 
;;; Amb-Eval value:
added
;;; Amb-Eval input:
(lq (quote (assert! (supervisor (Scrooge Eben) (Warbucks Oliver)))))
;;; Starting a new problem 
;;; Amb-Eval value:
added
;;; Amb-Eval input:
(lq (quote (assert! (address (Cratchet Robert) (Allston (N Harvard Street) 16)))))
;;; Starting a new problem 
;;; Amb-Eval value:
added
;;; Amb-Eval input:
(lq (quote (assert! (job (Cratchet Robert) (accounting scrivener)))))
;;; Starting a new problem 
;;; Amb-Eval value:
added
;;; Amb-Eval input:
(lq (quote (assert! (salary (Cratchet Robert) 18000))))
;;; Starting a new problem 
;;; Amb-Eval value:
added
;;; Amb-Eval input:
(lq (quote (assert! (supervisor (Cratchet Robert) (Scrooge Eben)))))
;;; Starting a new problem 
;;; Amb-Eval value:
added
;;; Amb-Eval input:
(lq (quote (assert! (address (Aull DeWitt) (Slumerville (Onion Square) 5)))))
;;; Starting a new problem 
;;; Amb-Eval value:
added
;;; Amb-Eval input:
(lq (quote (assert! (job (Aull DeWitt) (administration secretary)))))
;;; Starting a new problem 
;;; Amb-Eval value:
added
;;; Amb-Eval input:
(lq (quote (assert! (salary (Aull DeWitt) 25000))))
;;; Starting a new problem 
;;; Amb-Eval value:
added
;;; Amb-Eval input:
(lq (quote (assert! (supervisor (Aull DeWitt) (Warbucks Oliver)))))
;;; Starting a new problem 
;;; Amb-Eval value:
added
;;; Amb-Eval input:
(lq (quote (assert! (can-do-job (computer wizard) (computer programmer)))))
;;; Starting a new problem 
;;; Amb-Eval value:
added
;;; Amb-Eval input:
(lq (quote (assert! (can-do-job (computer wizard) (computer technician)))))
;;; Starting a new problem 
;;; Amb-Eval value:
added
;;; Amb-Eval input:
(lq (quote (assert! (can-do-job (computer programmer) (computer programmer trainee)))))
;;; Starting a new problem 
;;; Amb-Eval value:
added
;;; Amb-Eval input:
(lq (quote (assert! (can-do-job (administration secretary) (administration big wheel)))))
;;; Starting a new problem 
;;; Amb-Eval value:
added
;;; Amb-Eval input:
(lq (quote (assert! (rule (lives-near ?person-1 ?person-2) (and (address ?person-1 (?town . ?rest-1)) (address ?person-2 (?town . ?rest-2)) (not (same ?person-1 ?person-2)))))))
;;; Starting a new problem 
;;; Amb-Eval value:
added
;;; Amb-Eval input:
(lq (quote (assert! (rule (same ?x ?x)))))
;;; Starting a new problem 
;;; Amb-Eval value:
added
;;; Amb-Eval input:
(lq (quote (assert! (rule (wheel ?person) (and (supervisor ?middle-manager ?person) (supervisor ?x ?middle-manager))))))
;;; Starting a new problem 
;;; Amb-Eval value:
added
;;; Amb-Eval input:
(lq (quote (assert! (rule (outranked-by ?staff-person ?boss) (or (supervisor ?staff-person ?boss) (and (supervisor ?staff-person ?middle-manager) (outranked-by ?middle-manager ?boss)))))))
;;; Starting a new problem 
;;; Amb-Eval value:
added
;;; Amb-Eval input:
(lq (quote (assert! (rule (append-to-form () ?y ?y)))))
;;; Starting a new problem 
;;; Amb-Eval value:
added
;;; Amb-Eval input:
(lq (quote (assert! (rule (append-to-form (?u . ?v) ?y (?u . ?z)) (append-to-form ?v ?y ?z)))))
;;; Starting a new problem 
;;; Amb-Eval value:
added
;;; Amb-Eval input:
(lq (quote (job ?x (computer programmer))))
;;; Starting a new problem 
;;; Amb-Eval value:
(job (Fect Cy D) (computer programmer))
;;; Amb-Eval input:
try-again
;;; Amb-Eval value:
(job (Hacker Alyssa P) (computer programmer))
;;; Amb-Eval input:
(lq (quote (same a ?x)))
;;; Starting a new problem 
;;; Amb-Eval value:
(same a a)
;;; Amb-Eval input:
(lq (quote (and (job ?x (computer programmer)) (salary ?x 40000))))
;;; Starting a new problem 
;;; Amb-Eval value:
(and (job (Hacker Alyssa P) (computer programmer)) (salary (Hacker Alyssa P) 40000))
;;; Amb-Eval input:
(lq (quote (or (job ?x (computer programmer)) (salary ?x 18000))))
;;; Starting a new problem 
;;; Amb-Eval value:
(or (job (Fect Cy D) (computer programmer)) (salary (Fect Cy D) 18000))
;;; Amb-Eval input:
(lq (quote (and (job ?x (computer programmer)) (not (salary ?x 40000)))))
;;; Starting a new problem 
;;; There are no more values of

(lq (quote (and (job ?x (computer programmer)) (not (salary ?x 40000)))))
;;; Amb-Eval input:
(lq (quote (and (job ?x (computer programmer)) (salary ?x ?y))))
;;; Starting a new problem 
;;; Amb-Eval value:
(and (job (Fect Cy D) (computer programmer)) (salary (Fect Cy D) 35000))
;;; Amb-Eval input:
(lq (quote (and (salary ?x ?y) (lisp-value < ?y 50000))))
;;; Starting a new problem 
;;; Amb-Eval value:
(and (salary (Aull DeWitt) 25000) (lisp-value < 25000 50000))
;;; Amb-Eval input:
try-again
;;; Amb-Eval value:
(and (salary (Cratchet Robert) 18000) (lisp-value < 18000 50000))
;;; Amb-Eval input:
try-again
;;; Amb-Eval value:
(and (salary (Reasoner Louis) 30000) (lisp-value < 30000 50000))
;;; Amb-Eval input:
try-again
;;; Amb-Eval value:
(and (salary (Tweakit Lem E) 25000) (lisp-value < 25000 50000))
;;; Amb-Eval input:
(lq (quote (outranked-by ?w1 ?w2)))
;;; Starting a new problem 
;;; Amb-Eval value:
(outranked-by (Aull DeWitt) (Warbucks Oliver))
;;; Amb-Eval input:
try-again
;;; Amb-Eval value:
(outranked-by (Cratchet Robert) (Scrooge Eben))
;;; Amb-Eval input:
(lq (quote (lives-near ?w1 ?w2)))
;;; Starting a new problem 
;;; There are no more values of

(lq (quote (lives-near ?w1 ?w2)))
;;; Amb-Eval input:
(exit)
;;; Starting a new problem 
#+end_src

~lisp-value~ is implemented in the "underlying scheme", but in
principle you can forward it to the ~ambeval~ primitive.

***** DONE Exercise 4.79 prolog environments
      CLOSED: [2020-05-10 Sun 17:59]


I expect this work to require some heavy modifications, so I will
copy the source.

Okay, I still don't entirely understand what is going on, but there is
a hint. I probably should just get rid of ~unify-match~ entirely, and
deal with ~pattern-match~ to create one-sided bindings in rule application.

 2020-03-21 Sat:
Frames should only have values for "external" variables.
Logical variables should originally contain references to themselves.
After applying, a rule is getting values in the value cells.
This way we are _applying a rule with a frame, but getting a return
value inside the query.

 1. Bind logical variables to themselves in the query.
 2. Instantiate a copy of a rule head with variables bound to
    themselves. That means that all instances of ?x in the query
    should match to the same cell.
 3. Make a "frame" by unifying the query pattern and rule head. The
    unification should not just assign variables same values, but
    actually assign make them point to the same cell, and the cell
    should contain the shared structure.
 4. Instantiate the body. This way the variables will propagate to the
    body, including the logical subvariables.
 5. Get the nested assertions and append them to the environment.
 6. Evaluate the body of the rule.
 7. Failures happen by non-matching queries or encountering
    contradictory matches for variables.
 8. The important bit that happens at the end is the merge of
    two frames, which happens if the rule-head and the fule-body give
    different (although possible not contradictory) results.


#+name: prolog-environments
#+begin_src shell :exports code :results verbatim output
    cat <<'EOF'
    (define (require p) (if (not p) (amb)))
    (define (an-element-of items)
      (require (not (null? items)))
      (amb (car items) (an-element-of (cdr items))))
    (define (an-integer-starting-from n)
      (amb n (an-integer-starting-from (+ n 1))))
    (define (distinct? items)
      (cond ((null? items) true)
	    ((null? (cdr items)) true)
	    ((member (car items) (cdr items)) false)
	    (else (distinct? (cdr items)))))
    (define THE-ASSERTIONS '())
    (define THE-RULES '())

    (define (add-rule-or-assertion! assertion)
      (if (rule? assertion)
	  (add-rule! assertion)
	  (add-assertion! assertion)))

    (define (add-assertion! assertion)
      (set! THE-ASSERTIONS  (cons assertion THE-ASSERTIONS))
      'ok)
    (define (add-rule! rule)
      (set! THE-RULES (cons rule THE-RULES))
      'ok)
    (define (rule? statement)
      (tagged-list? statement 'rule))
    (define (conclusion rule) (cadr rule))
    (define (rule-body rule)
      (if (null? (cddr rule)) '(always-true) (caddr rule)))

    (define (identity-var v f)
	v)

    (define (lq i)
      (let ((q (query-syntax-process i)))
	(cond  ((assertion-to-be-added? q)
		(add-rule-or-assertion! (add-assertion-body q))
		'added)
	       (else
		(instantiate
		    q
		    (try-qeval (qeval q THE-ASSERTIONS THE-RULES))
		  (lambda (v f)
		    (contract-question-mark v)))))))
    (define (query-syntax-process exp)
      (map-over-symbols expand-question-mark exp))
    (define (map-over-symbols proc exp)
      (cond ((pair? exp)
	     (cons (map-over-symbols proc (car exp))
		   (map-over-symbols proc (cdr exp))))
	    ((symbol? exp) (proc exp))
	    (else exp)))

    (define (type exp)
      (if (pair? exp)
	  (car exp)
	  (error "Unknown expression TYPE" exp)))
    (define (contents exp)
      (if (pair? exp)
	  (cdr exp)
	  (error "Unknown expression CONTENTS" exp)))
    (define (assertion-to-be-added? exp)
      (eq? (type exp) 'assert!))
    (define (add-assertion-body exp) (car (contents exp)))
    (define (empty-conjunction? exps) (null? exps))
    (define (first-conjunct exps) (car exps))
    (define (rest-conjuncts exps) (cdr exps))
    (define (empty-disjunction? exps) (null? exps))
    (define (first-disjunct exps) (car exps))
    (define (rest-disjuncts exps) (cdr exps))
    (define (negated-query exps) (car exps))
    (define (predicate exps) (car exps))
    (define (args exps) (cdr exps))
    (define (rule? statement)
      (tagged-list? statement 'rule))
    (define (conclusion rule) (cadr rule))
    (define (rule-body rule)
      (if (null? (cddr rule)) '(always-true) (caddr rule)))

    (define (rule-inner-rules-and-assertions rule2)
      (if (equal? '(always-true) (rule-body rule2))
	  (list '() '())
	  (cdddr rule2)))

    (define (rule-subfeatures-assertions subfeatures)
	(assq 'assertions subfeatures))

    (define (rule-subfeatures-rules subfeatures)
	(assq 'rules subfeatures))

    (define (rule-subrules r)
      (cdr (rule-subfeatures-rules (rule-inner-rules-and-assertions r))))

    (define (rule-subassertions r)
      (cdr (rule-subfeatures-assertions (rule-inner-rules-and-assertions r))))

    (define (query-syntax-process exp)
      (map-over-symbols expand-question-mark exp))
    (define (map-over-symbols proc exp)
      (cond ((pair? exp)
	     (cons (map-over-symbols proc (car exp))
		   (map-over-symbols proc (cdr exp))))
	    ((symbol? exp) (proc exp))
	    (else exp)))
    (define (expand-question-mark symbol)
      (let ((chars (symbol->string symbol)))
	(if (string=? (substring chars 0 1) "?")
	    (list '?
		  (string->symbol
		   (substring chars 1 (string-length chars))))
	    symbol)))
    (define (var? exp) (tagged-list? exp '?))
    (define (constant-symbol? exp) (symbol? exp))
    (define rule-counter 0)
    (define (new-rule-application-id)
      (set! rule-counter (+ 1 rule-counter))
      rule-counter)
    (define (make-new-variable var rule-application-id)
      (cons '? (cons rule-application-id (cdr var))))
    (define (contract-question-mark variable)
      (string->symbol
       (string-append "?"
		      (if (number? (cadr variable))
			  (string-append (symbol->string (caddr variable))
					 "-"
					 (number->string (cadr variable)))
			  (symbol->string (cadr variable))))))
    (define (frame-promises frame)
	(if (null? frame)
	    '()
	    (cadr frame)))
    (define (frame-bindings frame)
      (if (null? frame)
	'()
	(car frame)))
    (define (make-binding variable value)
      (cons variable value))
    (define (binding-variable binding) (car binding))
    (define (binding-value binding) (cdr binding))
    (define (binding-in-frame variable frame)
      (assoc variable (frame-bindings frame)))
    (define (extend variable value frame)
      (make-frame-prolog (cons (make-binding variable value) (frame-bindings frame))
	    (frame-promises frame)))
    (define (frame-add-promise frame promise)
      (make-frame-prolog (frame-bindings frame) (cons promise (frame-promises frame))))
    (define (make-frame-prolog bindings promises)
       (list bindings promises))
    (define (instantiate exp frame unbound-var-handler)
      (define (copy exp)
	(cond ((var? exp)
	       (let ((binding (binding-in-frame exp frame)))
		 (if binding
		     (copy (binding-value binding))
		     (unbound-var-handler exp frame))))
	      ((pair? exp)
	       (cons (copy (car exp)) (copy (cdr exp))))
	      (else exp)))
      (copy exp))

    (define (make-table)
      (let ((local-table (list '*table*)))
	(define (lookup key-1 key-2)
	  (let ((subtable (assoc key-1 (cdr local-table))))
	    (if subtable
		(let ((record (assoc key-2 (cdr subtable))))
		  (if record
		      (cdr record)
		      false))
		false)))
	(define (insert! key-1 key-2 value)
	  (let ((subtable (assoc key-1 (cdr local-table))))
	    (if subtable
		(let ((record (assoc key-2 (cdr subtable))))
		  (if record
		      (set-cdr! record value)
		      (set-cdr! subtable
				(cons (cons key-2 value)
				      (cdr subtable)))))
		(set-cdr! local-table
			  (cons (list key-1
				      (cons key-2 value))
				(cdr local-table)))))
	  'ok)
	(define (dispatch m)
	  (cond ((eq? m 'lookup-proc) lookup)
		((eq? m 'insert-proc!) insert!)
		(else (error "Unknown operation -- TABLE" m))))
	dispatch))

    (define operation-table (make-table))
    (define get (operation-table 'lookup-proc))
    (define put (operation-table 'insert-proc!))
    (define coercion-table (make-table))
    (define get-coercion (coercion-table 'lookup-proc))
    (define put-coercion (coercion-table 'insert-proc!))

    (define (try-qeval result)
      (if (eq? result 'no-more-answers)
	  (amb)
	  result))
    (define (qeval query assertions-env rules-env)
      ;(newline) (display "debug:") (display query) (newline)
      ;(newline) (display "debug:contents:") (display (contents query)) (newline)
      (amb (processor
	    (let ((qproc (get (type query) 'qeval)))
	      (if qproc
		  (qproc (contents query) assertions-env rules-env)
		  (simple-query query assertions-env rules-env))))
	   'no-more-answers))
    (define (processor frame)
      (define (loop bindings promises retval)
	(cond ((null? promises) retval)
	      ((eq? ((car promises) retval) 'kill-it)
	       (amb))
	      ((eq? ((car promises) retval) 'let-it-stay)
	       (loop bindings
		     (cdr promises)
		     retval)) ;; this promise can't kill this frame
	      ((eq? ((car promises) retval) 'has-not-bound)
	       (loop bindings
		     (cdr promises)
		     (frame-add-promise retval (car promises)))) ;; we don't have enough variables so far
	      (else (error "process-promises -- unknown promise protocol"))))
      (loop (frame-bindings frame)
	    (frame-promises frame)
	    (make-frame-prolog (frame-bindings frame) '())))
    (define (simple-query query-pattern assertions-env rules-env)
      (amb
       (find-assertions query-pattern assertions-env)
       (apply-rules query-pattern assertions-env rules-env)))

    (define (find-assertions query-pattern assertions-env) ; -> frame
      (let ((a (an-element-of assertions-env)))
	(check-an-assertion a query-pattern (make-frame-prolog '() '()) )))

    (define (check-an-assertion assertion query-pat query-frame)
      (let ((match-result
	     (pattern-match query-pat assertion query-frame)))
	(if (eq? match-result 'failed)
	    (amb)
	    match-result)))

    (define (apply-rules pattern assertions-env rules-env)
      (let ((r (an-element-of rules-env)))
	(apply-a-rule r pattern assertions-env rules-env)))

    (define (prolog-extend-env lst env)
       (append lst env))

    (define (extend-if-unifies var pat1 pat2 frame)
;        (newline) (display "entering extend-if-unifies")
;        (newline) (display "var=") (display var)
;        (newline) (display "pat1=") (display pat1)
;        (newline) (display "pat2=") (display pat2)
      (let ((match-frame (unify-match pat1 pat2 frame)))
	 (if (eq? 'failed match-frame)
	   'failed
	   (extend var (instantiate pat1 match-frame identity-var) frame))))
    <<accumulate>>
    <<map-append-length>>
    (define (union-set set1 set2)
       (if (null? set2)
          set1
          (if (member (car set2) set1)
              (union-set set1 (cdr set2))
              (union-set (cons (car set2) set1) (cdr set2)))))
    (define (unify-two-frames f1 f2 iframe)
     ; We have at most two bindings for each variable. The final binding is a unification of those.
       (cond ((eq? 'failed f1) 'failed)
             ((eq? 'failed f2) 'failed)
             (else   (let ((f1-vars (map car (frame-bindings f1)))
	                   (f2-vars (map car (frame-bindings f2))))
                 	  (let ((ret-vars (union-set f1-vars f2-vars)))
;(newline) (display "unify-two-frames-variable-list:") (display ret-vars)
	                     (accumulate  (lambda (var iframe)
                    (if (eq? 'failed iframe)
                         'failed
			 (let ((binding-f1 (binding-in-frame var f1))
			       (binding-f2 (binding-in-frame var f2)))
			   (cond ((and binding-f1 (not binding-f2))
                                    (extend-if-possible var (binding-value binding-f1) iframe))
				 ((and binding-f2 (not binding-f1))
                                    (begin ;(display "running extend-if--f2")
                                           (extend-if-possible var (binding-value binding-f2) iframe)))
				 ((and binding-f1 binding-f2)
                                    (begin ;(newline) (display "running extend-if-unifies")  (newline)
                                           (extend-if-unifies  var
                                                               (binding-value binding-f1)
                                                               (binding-value binding-f2)
                                                                iframe)))
				 (else (error "Impossible case"))))))
		    (make-frame-prolog '() '())
		    ret-vars)
)))))

    (define (apply-a-rule rule query-pattern assertions-env rules-env)
;      (newline) (display "entered apply-a-rule")
      (let ((doubleframe-result (two-sided-match query-pattern
						   (conclusion rule))))
 ;         (newline) (display "doubleframe-result=") (display doubleframe-result)
	  (if (or (eq? (doubleframe-downframe-get doubleframe-result) 'failed)
                  (eq? (doubleframe-upframe-get doubleframe-result) 'failed))
	      (amb)
	      (let ((df-u (doubleframe-upframe-get doubleframe-result))
		    (t-q-r (begin (newline) (display "- propagating down")
                                  (try-qeval (qeval (instantiate
					             (rule-body rule)
					             (doubleframe-downframe-get doubleframe-result)
					             identity-var)
				                  (prolog-extend-env (rule-subassertions rule) assertions-env)
				                  (prolog-extend-env (rule-subrules rule) rules-env)  )))))
                     (let ((retval  (begin ;(newline) (display "- propagating up")
                                           ;(newline) (display "upward frame=") (display df-u)
                                           ;(newline) (display "rule returns frame=") (display t-q-r)

                                    (unify-two-frames ; fail if conflict
                                     df-u
                                     t-q-r
                                     (make-frame-prolog '() '())))))
                           (if (eq? 'failed retval)
                                (amb)
                                 retval))))))

    (define (unify-match p1 p2 frame)
;      (newline)
;      (display "p1=") (display p1)
;      (display "p2=") (display p2)
;      (display "frame=") (display frame)
;      (newline)
      (cond ((eq? frame 'failed) 'failed)
	    ((equal? p1 p2) frame)
	    ((var? p1) (extend-if-possible p1 p2 frame))
	    ((var? p2) (extend-if-possible p2 p1 frame))
					    ; ***
	    ((and (pair? p1) (pair? p2))
	     (unify-match (cdr p1)
			  (cdr p2)
			  (unify-match (car p1)
				       (car p2)
				       frame)))
	    (else 'failed)))



    (define (extend-if-possible var val frame)
;    (newline) (display "entering extend-if-possible")
;    (newline) (display "var=") (display var)
;    (newline) (display "val=") (display val)
;    (newline) (display "frame=") (display frame)
;    (newline)
      (let ((binding (binding-in-frame var frame)))
	(cond (binding
	       (unify-match (binding-value binding) val frame))
					    ; ***
	      ((var? val)
	       (let ((binding (binding-in-frame val frame)))
		 (if binding
		     (unify-match
		      var (binding-value binding) frame)
		     (extend var val frame))))
	      ((depends-on? val var frame)
					    ; ***
	       'failed)
	      (else (extend var val frame)))))

    (define (depends-on? exp var frame)
      (define (tree-walk e)
	(cond ((var? e)
	       (if (equal? var e)
		   true
		   (let ((b (binding-in-frame e frame)))
		     (if b
			 (tree-walk (binding-value b))
			 false))))
	      ((pair? e)
	       (or (tree-walk (car e))
		   (tree-walk (cdr e))))
	      (else false)))
      (tree-walk exp))


    (define (and a b)
      (if a
	  (if b true false)
	  false))

    (define (or a b)
      (if a
	  true
	  (if b true false)))

    (define (not e)
      (if e false true))

    (define (pattern-match-weak pat dat frame)
      (cond ((eq? frame 'failed) 'failed)
	    ((equal? pat dat) frame)
	    ((var? pat) (extend-if-consistent pat dat frame))
	    ((and (pair? pat) (pair? dat))
	     (pattern-match-weak
	      (cdr pat)
	      (cdr dat)
	      (pattern-match-weak (car pat) (car dat) frame)))
	    ((var? dat) frame) ; This is the difference
	    (else 'failed)))

    (define (two-sided-match p1 p2)
      (make-doubleframe (pattern-match-weak p1 p2 (make-frame-prolog '() '()))
	    (pattern-match-weak p2 p1 (make-frame-prolog '() '()))
	      ))
    (define (make-doubleframe upward-frame downward-frame)
       (list upward-frame downward-frame))
    (define (doubleframe-upframe-get doubleframe)
       (car doubleframe))
    (define (doubleframe-downframe-get doubleframe)
       (cadr doubleframe))

    (define (pattern-match pat dat frame)
      (cond ((eq? frame 'failed) 'failed)
	    ((equal? pat dat) frame)
	    ((var? pat) (extend-if-consistent pat dat frame))
	    ((and (pair? pat) (pair? dat))
	     (pattern-match
	      (cdr pat)
	      (cdr dat)
	      (pattern-match (car pat) (car dat) frame)))
	    (else 'failed)))
    (define (extend-if-consistent var dat frame)
      (let ((binding (binding-in-frame var frame)))
	(if binding
	    (pattern-match (binding-value binding) dat frame)
	    (extend var dat frame))))
    (define (always-true pat assertions rules) (make-frame-prolog '() '()))
    (put 'always-true 'qeval always-true)
    (define (conjoin conjuncts assertions rules)
;      (newline) (display "entered conjoin")
      (if (empty-conjunction? conjuncts)
	  (make-frame-prolog '() '())
          (let ((rest-frame (conjoin (rest-conjuncts conjuncts) assertions rules))
                (this-frame (try-qeval (qeval (first-conjunct conjuncts) assertions rules))))
;          (newline) (display "conjoin unifying: rest-frame: ") (display rest-frame)
;          (newline) (display "conjoin unifying: this-frame: ") (display this-frame)
          (let ((retval	  (unify-two-frames
                              rest-frame
                    	      this-frame
                              (make-frame-prolog '() '()))))
;            (newline) (display "conjoining two clauses result:") (display retval)
retval))))
    (put 'and 'qeval conjoin)
    ;; This place has a subtle bug in case the stream happens to be infinite.
    (define (disjoin disjuncts assertions rules)
      (if (empty-disjunction? disjuncts)
	  (amb)
	  (amb
	   (try-qeval (qeval (first-disjunct disjuncts) assertions rules))
	   (disjoin (rest-disjuncts disjuncts) assertions rules))))
    (put 'or 'qeval disjoin)

    (define (negate operands assertions rules)
      (let ((promise (lambda (frame)
		       (if (has-not-bound?  (negated-query operands) frame)
			   'has-not-bound
			   (if (eq? 'no-more-values (qeval (negated-query operands) assertions rules))
			       'let-it-stay ; let it stay
			       'kill-it)))))
	(frame-add-promise frame1 promise)))


    (define (has-not-bound? query frame)
      (cond ((null? query) #f)
	    ((var? query) (if (binding-in-frame query frame)
			      (has-not-bound?
			       (binding-value (binding-in-frame query frame))
			       frame)
			      #t))
	    ((pair? query) (or (has-not-bound? (car query) frame)
			       (has-not-bound? (cdr query) frame)))
	    (else #f)))
    (put 'not 'qeval negate)
    (define (lisp-value call ignore ignore)
      (let ((promise (lambda (frame) (if (has-not-bound? call frame)
				    'has-not-bound
				    (if (execute
					 (instantiate
					     call
					     frame
					   (lambda (v f)
					     (error "Unknown pat var: LISP-VALUE" v))))
					'let-it-stay
					'kill-it)))))
	(frame-add-promise frame1 promise)
	))
    (define (execute exp)
      (let ((pred (eval
		    (predicate exp)
		    (interaction-environment))))
     (apply-in-underlying-scheme pred  (args exp))))

    (put 'lisp-value 'qeval lisp-value)

    (unify-match
	 (query-syntax-process '(can-do-job (computer programmer) (computer ?x trainee)))
	 (query-syntax-process '(can-do-job (computer ?x) (computer programmer trainee)))
	 (make-frame-prolog '() '()))

    (two-sided-match
	 (query-syntax-process '(can-do-job (computer programmer) (computer ?x trainee)))
	 (query-syntax-process '(can-do-job (computer programmer) (computer programmer ?x))))

    (two-sided-match
	 (query-syntax-process '(can-do-job (computer programmer) (computer ?x trainee)))
	 (query-syntax-process '(can-do-job (computer programmer) (computer programmer ?x assistant))))

    (two-sided-match
	 (query-syntax-process '(can-do-job (computer programmer) (computer ?x trainee)))
	 (query-syntax-process '(can-do-job (computer programmer) (computer ?y trainee))))

    (rule-subfeatures-assertions
	   (rule-inner-rules-and-assertions
      '(rule (lives-near ?person-1 ?person-2)
		      (and (address ?person-1 (?town . ?rest-1))
			   (address ?person-2 (?town . ?rest-2)))
		      (assertions ((homefull world) (peopleful world)))
		      (rules ((same ?x ?x))) )))

  (rule-subfeatures-rules
	   (rule-inner-rules-and-assertions
      '(rule (lives-near ?person-1 ?person-2)
		      (and (address ?person-1 (?town . ?rest-1))
			   (address ?person-2 (?town . ?rest-2)))
		      (assertions ((homefull world) (peopleful world)))
		      (rules ((same ?x ?x))) )))
    (lq '(assert! (rule (lives-near ?person-1 ?person-2)
			(and (address ?person-1 (?town . ?rest-1))
			     (address ?person-2 (?town . ?rest-2)))
		      (assertions ((homefull world) (peopleful world)))
		      (rules ((same ?x ?x))) )))
    (lq '(assert! (address (Hacker Alyssa P) (Cambridge (Mass Ave) 78))))
    (lq '(assert! (address (Schemer The Little) (Cambridge (Mass Ave) 78))))
    (lq '(lives-near ?x ?y))
    try-again
    (exit)
    try-again
    try-again
    try-again
    (exit)
    (lq '(assert! (address (Tweakit Lem E) (Boston (Bay State Road) 22))))
    (lq '(assert! (job (Tweakit Lem E) (computer technician))))
    (lq '(assert! (salary (Tweakit Lem E) 25000)))
    (lq '(assert! (supervisor (Tweakit Lem E) (Bitdiddle Ben))))
    (lq '(assert! (address (Reasoner Louis) (Slumerville (Pine Tree Road) 80))))
    (lq '(assert! (job (Reasoner Louis) (computer programmer trainee))))
    (lq '(assert! (salary (Reasoner Louis) 30000)))
    (lq '(assert! (supervisor (Reasoner Louis) (Hacker Alyssa P))))
    (lq '(assert! (supervisor (Bitdiddle Ben) (Warbucks Oliver))))
    (lq '(assert! (address (Warbucks Oliver) (Swellesley (Top Heap Road)))))
    (lq '(assert! (job (Warbucks Oliver) (administration big wheel))))
    (lq '(assert! (salary (Warbucks Oliver) 150000)))
    (lq '(assert! (address (Scrooge Eben) (Weston (Shady Lane) 10))))
    (lq '(assert! (job (Scrooge Eben) (accounting chief accountant))))
    (lq '(assert! (salary (Scrooge Eben) 75000)))
    (lq '(assert! (supervisor (Scrooge Eben) (Warbucks Oliver))))
    (lq '(assert! (address (Cratchet Robert) (Allston (N Harvard Street) 16))))
    (lq '(assert! (job (Cratchet Robert) (accounting scrivener))))
    (lq '(assert! (salary (Cratchet Robert) 18000)))
    (lq '(assert! (supervisor (Cratchet Robert) (Scrooge Eben))))
    (lq '(assert! (address (Aull DeWitt) (Slumerville (Onion Square) 5))))
    (lq '(assert! (job (Aull DeWitt) (administration secretary))))
    (lq '(assert! (salary (Aull DeWitt) 25000)))
    (lq '(assert! (supervisor (Aull DeWitt) (Warbucks Oliver))))
    (lq '(assert! (can-do-job (computer wizard) (computer programmer))))
    (lq '(assert! (can-do-job (computer wizard) (computer technician))))
    (lq '(assert! (can-do-job (computer programmer) (computer programmer trainee))))
    (lq '(assert! (can-do-job (administration secretary) (administration big wheel))))
    (lq '(assert! (rule (lives-near ?person-1 ?person-2)
		   (and (address ?person-1 (?town . ?rest-1))
			(address ?person-2 (?town . ?rest-2))
			(not (same ?person-1 ?person-2))))))

    (lq '(assert! (rule (wheel ?person)
	      (and (supervisor ?middle-manager ?person)
		   (supervisor ?x ?middle-manager)))))
    (lq '(assert! (rule (outranked-by ?staff-person ?boss)
		      (or (supervisor ?staff-person ?boss)
			  (and (supervisor ?staff-person ?middle-manager)
			       (outranked-by ?middle-manager ?boss))))))
    (lq '(assert! (rule (append-to-form () ?y ?y))))
    (lq '(assert! (rule (append-to-form (?u . ?v) ?y (?u . ?z))
		   (append-to-form ?v ?y ?z))))

    (lq '(job ?x (computer programmer)))
    try-again
    (lq '(same a ?x))
    (lq '(and (job ?x (computer programmer)) (salary ?x 40000)))
    (lq '(or (job ?x (computer programmer)) (salary ?x 18000)))
    (lq '(and (job ?x (computer programmer)) (not (salary ?x 40000))))
    (lq '(and (job ?x (computer programmer))
	      (salary ?x ?y)
	      ))
    (lq '(and (salary ?x ?y) (lisp-value < ?y 50000)))
    try-again
    try-again
    try-again
    (exit)
  EOF
#+end_src


#+header: :stdin prolog-environments
#+begin_src shell :shebang "#! /usr/bin/chibi-scheme" :results output scalar code :exports both
<<s-glue1>>
<<s-amb-amb-implementation>>
<<s-amb-analyze-eval-with-let-amb-ramb-pset-iffail>>
<<s-amb-analyze-permanent-assignment>>
<<s-let-implementation>>
<<s-amb-simple-expressions>>
<<s-amb-analyze-if>>
<<s-amb-analyze-sequence>>
<<s-amb-analyze-definition>>
<<s-amb-analyze-assignment>>
<<s-amb-analyze-application>>
<<s-amb-get-args>>
<<s-amb-execute-application>>
<<s-amb-analyze-amb>>
<<s-amb-ramb>>
<<s-amb-analyze-if-fail>>
<<s-syntax>>
<<s-application>>
<<s-cond-with-arrow>>
<<s-truefalse>>
<<s-compound-procedures>>
<<s-environments-list-of-bindings-better-abstractions>>
<<s-primitive-procedures>>
<<primitive-procedures-prolog-in-amb>>
<<s-amb-driver-loop>>
<<s-user-prompt-print>>
<<s-glue2>>
(driver-loop)

#+end_src

#+RESULTS[22468ff82ee995b57b32f14431a84d918a86cb20]:
#+begin_src shell

;;; Amb-Eval input:
(define (require p) (if (not p) (amb)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (an-element-of items) (require (not (null? items))) (amb (car items) (an-element-of (cdr items))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (an-integer-starting-from n) (amb n (an-integer-starting-from (+ n 1))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (distinct? items) (cond ((null? items) true) ((null? (cdr items)) true) ((member (car items) (cdr items)) false) (else (distinct? (cdr items)))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define THE-ASSERTIONS (quote ()))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define THE-RULES (quote ()))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (add-rule-or-assertion! assertion) (if (rule? assertion) (add-rule! assertion) (add-assertion! assertion)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (add-assertion! assertion) (set! THE-ASSERTIONS (cons assertion THE-ASSERTIONS)) (quote ok))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (add-rule! rule) (set! THE-RULES (cons rule THE-RULES)) (quote ok))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (rule? statement) (tagged-list? statement (quote rule)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (conclusion rule) (cadr rule))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (rule-body rule) (if (null? (cddr rule)) (quote (always-true)) (caddr rule)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (identity-var v f) v)
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (lq i) (let ((q (query-syntax-process i))) (cond ((assertion-to-be-added? q) (add-rule-or-assertion! (add-assertion-body q)) (quote added)) (else (instantiate q (try-qeval (qeval q THE-ASSERTIONS THE-RULES)) (lambda (v f) (contract-question-mark v)))))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (query-syntax-process exp) (map-over-symbols expand-question-mark exp))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (map-over-symbols proc exp) (cond ((pair? exp) (cons (map-over-symbols proc (car exp)) (map-over-symbols proc (cdr exp)))) ((symbol? exp) (proc exp)) (else exp)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (type exp) (if (pair? exp) (car exp) (error "Unknown expression TYPE" exp)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (contents exp) (if (pair? exp) (cdr exp) (error "Unknown expression CONTENTS" exp)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (assertion-to-be-added? exp) (eq? (type exp) (quote assert!)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (add-assertion-body exp) (car (contents exp)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (empty-conjunction? exps) (null? exps))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (first-conjunct exps) (car exps))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (rest-conjuncts exps) (cdr exps))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (empty-disjunction? exps) (null? exps))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (first-disjunct exps) (car exps))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (rest-disjuncts exps) (cdr exps))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (negated-query exps) (car exps))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (predicate exps) (car exps))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (args exps) (cdr exps))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (rule? statement) (tagged-list? statement (quote rule)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (conclusion rule) (cadr rule))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (rule-body rule) (if (null? (cddr rule)) (quote (always-true)) (caddr rule)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (rule-inner-rules-and-assertions rule2) (if (equal? (quote (always-true)) (rule-body rule2)) (list (quote ()) (quote ())) (cdddr rule2)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (rule-subfeatures-assertions subfeatures) (assq (quote assertions) subfeatures))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (rule-subfeatures-rules subfeatures) (assq (quote rules) subfeatures))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (rule-subrules r) (cdr (rule-subfeatures-rules (rule-inner-rules-and-assertions r))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (rule-subassertions r) (cdr (rule-subfeatures-assertions (rule-inner-rules-and-assertions r))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (query-syntax-process exp) (map-over-symbols expand-question-mark exp))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (map-over-symbols proc exp) (cond ((pair? exp) (cons (map-over-symbols proc (car exp)) (map-over-symbols proc (cdr exp)))) ((symbol? exp) (proc exp)) (else exp)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (expand-question-mark symbol) (let ((chars (symbol->string symbol))) (if (string=? (substring chars 0 1) "?") (list (quote ?) (string->symbol (substring chars 1 (string-length chars)))) symbol)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (var? exp) (tagged-list? exp (quote ?)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (constant-symbol? exp) (symbol? exp))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define rule-counter 0)
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (new-rule-application-id) (set! rule-counter (+ 1 rule-counter)) rule-counter)
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (make-new-variable var rule-application-id) (cons (quote ?) (cons rule-application-id (cdr var))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (contract-question-mark variable) (string->symbol (string-append "?" (if (number? (cadr variable)) (string-append (symbol->string (caddr variable)) "-" (number->string (cadr variable))) (symbol->string (cadr variable))))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (frame-promises frame) (if (null? frame) (quote ()) (cadr frame)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (frame-bindings frame) (if (null? frame) (quote ()) (car frame)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (make-binding variable value) (cons variable value))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (binding-variable binding) (car binding))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (binding-value binding) (cdr binding))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (binding-in-frame variable frame) (assoc variable (frame-bindings frame)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (extend variable value frame) (make-frame-prolog (cons (make-binding variable value) (frame-bindings frame)) (frame-promises frame)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (frame-add-promise frame promise) (make-frame-prolog (frame-bindings frame) (cons promise (frame-promises frame))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (make-frame-prolog bindings promises) (list bindings promises))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (instantiate exp frame unbound-var-handler) (define (copy exp) (cond ((var? exp) (let ((binding (binding-in-frame exp frame))) (if binding (copy (binding-value binding)) (unbound-var-handler exp frame)))) ((pair? exp) (cons (copy (car exp)) (copy (cdr exp)))) (else exp))) (copy exp))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (make-table) (let ((local-table (list (quote *table*)))) (define (lookup key-1 key-2) (let ((subtable (assoc key-1 (cdr local-table)))) (if subtable (let ((record (assoc key-2 (cdr subtable)))) (if record (cdr record) false)) false))) (define (insert! key-1 key-2 value) (let ((subtable (assoc key-1 (cdr local-table)))) (if subtable (let ((record (assoc key-2 (cdr subtable)))) (if record (set-cdr! record value) (set-cdr! subtable (cons (cons key-2 value) (cdr subtable))))) (set-cdr! local-table (cons (list key-1 (cons key-2 value)) (cdr local-table))))) (quote ok)) (define (dispatch m) (cond ((eq? m (quote lookup-proc)) lookup) ((eq? m (quote insert-proc!)) insert!) (else (error "Unknown operation -- TABLE" m)))) dispatch))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define operation-table (make-table))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define get (operation-table (quote lookup-proc)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define put (operation-table (quote insert-proc!)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define coercion-table (make-table))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define get-coercion (coercion-table (quote lookup-proc)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define put-coercion (coercion-table (quote insert-proc!)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (try-qeval result) (if (eq? result (quote no-more-answers)) (amb) result))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (qeval query assertions-env rules-env) (amb (processor (let ((qproc (get (type query) (quote qeval)))) (if qproc (qproc (contents query) assertions-env rules-env) (simple-query query assertions-env rules-env)))) (quote no-more-answers)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (processor frame) (define (loop bindings promises retval) (cond ((null? promises) retval) ((eq? ((car promises) retval) (quote kill-it)) (amb)) ((eq? ((car promises) retval) (quote let-it-stay)) (loop bindings (cdr promises) retval)) ((eq? ((car promises) retval) (quote has-not-bound)) (loop bindings (cdr promises) (frame-add-promise retval (car promises)))) (else (error "process-promises -- unknown promise protocol")))) (loop (frame-bindings frame) (frame-promises frame) (make-frame-prolog (frame-bindings frame) (quote ()))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (simple-query query-pattern assertions-env rules-env) (amb (find-assertions query-pattern assertions-env) (apply-rules query-pattern assertions-env rules-env)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (find-assertions query-pattern assertions-env) (let ((a (an-element-of assertions-env))) (check-an-assertion a query-pattern (make-frame-prolog (quote ()) (quote ())))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (check-an-assertion assertion query-pat query-frame) (let ((match-result (pattern-match query-pat assertion query-frame))) (if (eq? match-result (quote failed)) (amb) match-result)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (apply-rules pattern assertions-env rules-env) (let ((r (an-element-of rules-env))) (apply-a-rule r pattern assertions-env rules-env)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (prolog-extend-env lst env) (append lst env))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (extend-if-unifies var pat1 pat2 frame) (let ((match-frame (unify-match pat1 pat2 frame))) (if (eq? (quote failed) match-frame) (quote failed) (extend var (instantiate pat1 match-frame identity-var) frame))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (accumulate op initial sequence) (if (null? sequence) initial (op (car sequence) (accumulate op initial (cdr sequence)))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (map p sequence) (accumulate (lambda (x y) (cons (p x) y)) (quote ()) sequence))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (append seq1 seq2) (accumulate cons seq2 seq1))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (length sequence) (accumulate (lambda (x y) (+ 1 y)) 0 sequence))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (union-set set1 set2) (if (null? set2) set1 (if (member (car set2) set1) (union-set set1 (cdr set2)) (union-set (cons (car set2) set1) (cdr set2)))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (unify-two-frames f1 f2 iframe) (cond ((eq? (quote failed) f1) (quote failed)) ((eq? (quote failed) f2) (quote failed)) (else (let ((f1-vars (map car (frame-bindings f1))) (f2-vars (map car (frame-bindings f2)))) (let ((ret-vars (union-set f1-vars f2-vars))) (accumulate (lambda (var iframe) (if (eq? (quote failed) iframe) (quote failed) (let ((binding-f1 (binding-in-frame var f1)) (binding-f2 (binding-in-frame var f2))) (cond ((and binding-f1 (not binding-f2)) (extend-if-possible var (binding-value binding-f1) iframe)) ((and binding-f2 (not binding-f1)) (begin (extend-if-possible var (binding-value binding-f2) iframe))) ((and binding-f1 binding-f2) (begin (extend-if-unifies var (binding-value binding-f1) (binding-value binding-f2) iframe))) (else (error "Impossible case")))))) (make-frame-prolog (quote ()) (quote ())) ret-vars))))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (apply-a-rule rule query-pattern assertions-env rules-env) (let ((doubleframe-result (two-sided-match query-pattern (conclusion rule)))) (if (or (eq? (doubleframe-downframe-get doubleframe-result) (quote failed)) (eq? (doubleframe-upframe-get doubleframe-result) (quote failed))) (amb) (let ((df-u (doubleframe-upframe-get doubleframe-result)) (t-q-r (begin (newline) (display "- propagating down") (try-qeval (qeval (instantiate (rule-body rule) (doubleframe-downframe-get doubleframe-result) identity-var) (prolog-extend-env (rule-subassertions rule) assertions-env) (prolog-extend-env (rule-subrules rule) rules-env)))))) (let ((retval (begin (unify-two-frames df-u t-q-r (make-frame-prolog (quote ()) (quote ())))))) (if (eq? (quote failed) retval) (amb) retval))))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (unify-match p1 p2 frame) (cond ((eq? frame (quote failed)) (quote failed)) ((equal? p1 p2) frame) ((var? p1) (extend-if-possible p1 p2 frame)) ((var? p2) (extend-if-possible p2 p1 frame)) ((and (pair? p1) (pair? p2)) (unify-match (cdr p1) (cdr p2) (unify-match (car p1) (car p2) frame))) (else (quote failed))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (extend-if-possible var val frame) (let ((binding (binding-in-frame var frame))) (cond (binding (unify-match (binding-value binding) val frame)) ((var? val) (let ((binding (binding-in-frame val frame))) (if binding (unify-match var (binding-value binding) frame) (extend var val frame)))) ((depends-on? val var frame) (quote failed)) (else (extend var val frame)))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (depends-on? exp var frame) (define (tree-walk e) (cond ((var? e) (if (equal? var e) true (let ((b (binding-in-frame e frame))) (if b (tree-walk (binding-value b)) false)))) ((pair? e) (or (tree-walk (car e)) (tree-walk (cdr e)))) (else false))) (tree-walk exp))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (and a b) (if a (if b true false) false))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (or a b) (if a true (if b true false)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (not e) (if e false true))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (pattern-match-weak pat dat frame) (cond ((eq? frame (quote failed)) (quote failed)) ((equal? pat dat) frame) ((var? pat) (extend-if-consistent pat dat frame)) ((and (pair? pat) (pair? dat)) (pattern-match-weak (cdr pat) (cdr dat) (pattern-match-weak (car pat) (car dat) frame))) ((var? dat) frame) (else (quote failed))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (two-sided-match p1 p2) (make-doubleframe (pattern-match-weak p1 p2 (make-frame-prolog (quote ()) (quote ()))) (pattern-match-weak p2 p1 (make-frame-prolog (quote ()) (quote ())))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (make-doubleframe upward-frame downward-frame) (list upward-frame downward-frame))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (doubleframe-upframe-get doubleframe) (car doubleframe))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (doubleframe-downframe-get doubleframe) (cadr doubleframe))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (pattern-match pat dat frame) (cond ((eq? frame (quote failed)) (quote failed)) ((equal? pat dat) frame) ((var? pat) (extend-if-consistent pat dat frame)) ((and (pair? pat) (pair? dat)) (pattern-match (cdr pat) (cdr dat) (pattern-match (car pat) (car dat) frame))) (else (quote failed))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (extend-if-consistent var dat frame) (let ((binding (binding-in-frame var frame))) (if binding (pattern-match (binding-value binding) dat frame) (extend var dat frame))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (always-true pat assertions rules) (make-frame-prolog (quote ()) (quote ())))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(put (quote always-true) (quote qeval) always-true)
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (conjoin conjuncts assertions rules) (if (empty-conjunction? conjuncts) (make-frame-prolog (quote ()) (quote ())) (let ((rest-frame (conjoin (rest-conjuncts conjuncts) assertions rules)) (this-frame (try-qeval (qeval (first-conjunct conjuncts) assertions rules)))) (let ((retval (unify-two-frames rest-frame this-frame (make-frame-prolog (quote ()) (quote ()))))) retval))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(put (quote and) (quote qeval) conjoin)
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (disjoin disjuncts assertions rules) (if (empty-disjunction? disjuncts) (amb) (amb (try-qeval (qeval (first-disjunct disjuncts) assertions rules)) (disjoin (rest-disjuncts disjuncts) assertions rules))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(put (quote or) (quote qeval) disjoin)
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (negate operands assertions rules) (let ((promise (lambda (frame) (if (has-not-bound? (negated-query operands) frame) (quote has-not-bound) (if (eq? (quote no-more-values) (qeval (negated-query operands) assertions rules)) (quote let-it-stay) (quote kill-it)))))) (frame-add-promise frame1 promise)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (has-not-bound? query frame) (cond ((null? query) #f) ((var? query) (if (binding-in-frame query frame) (has-not-bound? (binding-value (binding-in-frame query frame)) frame) #t)) ((pair? query) (or (has-not-bound? (car query) frame) (has-not-bound? (cdr query) frame))) (else #f)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(put (quote not) (quote qeval) negate)
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (lisp-value call ignore ignore) (let ((promise (lambda (frame) (if (has-not-bound? call frame) (quote has-not-bound) (if (execute (instantiate call frame (lambda (v f) (error "Unknown pat var: LISP-VALUE" v)))) (quote let-it-stay) (quote kill-it)))))) (frame-add-promise frame1 promise)))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(define (execute exp) (let ((pred (eval (predicate exp) (interaction-environment)))) (apply-in-underlying-scheme pred (args exp))))
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(put (quote lisp-value) (quote qeval) lisp-value)
;;; Starting a new problem 
;;; Amb-Eval value:
ok
;;; Amb-Eval input:
(unify-match (query-syntax-process (quote (can-do-job (computer programmer) (computer ?x trainee)))) (query-syntax-process (quote (can-do-job (computer ?x) (computer programmer trainee)))) (make-frame-prolog (quote ()) (quote ())))
;;; Starting a new problem 
;;; Amb-Eval value:
((((? x) . programmer)) ())
;;; Amb-Eval input:
(two-sided-match (query-syntax-process (quote (can-do-job (computer programmer) (computer ?x trainee)))) (query-syntax-process (quote (can-do-job (computer programmer) (computer programmer ?x)))))
;;; Starting a new problem 
;;; Amb-Eval value:
(((((? x) . programmer)) ()) ((((? x) . trainee)) ()))
;;; Amb-Eval input:
(two-sided-match (query-syntax-process (quote (can-do-job (computer programmer) (computer ?x trainee)))) (query-syntax-process (quote (can-do-job (computer programmer) (computer programmer ?x assistant)))))
;;; Starting a new problem 
;;; Amb-Eval value:
(failed failed)
;;; Amb-Eval input:
(two-sided-match (query-syntax-process (quote (can-do-job (computer programmer) (computer ?x trainee)))) (query-syntax-process (quote (can-do-job (computer programmer) (computer ?y trainee)))))
;;; Starting a new problem 
;;; Amb-Eval value:
(((((? x) ? y)) ()) ((((? y) ? x)) ()))
;;; Amb-Eval input:
(rule-subfeatures-assertions (rule-inner-rules-and-assertions (quote (rule (lives-near ?person-1 ?person-2) (and (address ?person-1 (?town . ?rest-1)) (address ?person-2 (?town . ?rest-2))) (assertions ((homefull world) (peopleful world))) (rules ((same ?x ?x)))))))
;;; Starting a new problem 
;;; Amb-Eval value:
(assertions ((homefull world) (peopleful world)))
;;; Amb-Eval input:
(rule-subfeatures-rules (rule-inner-rules-and-assertions (quote (rule (lives-near ?person-1 ?person-2) (and (address ?person-1 (?town . ?rest-1)) (address ?person-2 (?town . ?rest-2))) (assertions ((homefull world) (peopleful world))) (rules ((same ?x ?x)))))))
;;; Starting a new problem 
;;; Amb-Eval value:
(rules ((same ?x ?x)))
;;; Amb-Eval input:
(lq (quote (assert! (rule (lives-near ?person-1 ?person-2) (and (address ?person-1 (?town . ?rest-1)) (address ?person-2 (?town . ?rest-2))) (assertions ((homefull world) (peopleful world))) (rules ((same ?x ?x)))))))
;;; Starting a new problem 
;;; Amb-Eval value:
added
;;; Amb-Eval input:
(lq (quote (assert! (address (Hacker Alyssa P) (Cambridge (Mass Ave) 78)))))
;;; Starting a new problem 
;;; Amb-Eval value:
added
;;; Amb-Eval input:
(lq (quote (assert! (address (Schemer The Little) (Cambridge (Mass Ave) 78)))))
;;; Starting a new problem 
;;; Amb-Eval value:
added
;;; Amb-Eval input:
(lq (quote (lives-near ?x ?y)))
;;; Starting a new problem 
- propagating down
;;; Amb-Eval value:
(lives-near (Schemer The Little) (Schemer The Little))
;;; Amb-Eval input:
try-again
;;; Amb-Eval value:
(lives-near (Hacker Alyssa P) (Schemer The Little))
;;; Amb-Eval input:
(exit)
;;; Starting a new problem 
#+end_src


** Chapter 5: Computing with Register Machines [54/54]
*** 5.1 Designing Register Machines [8/8]
**** DONE Figure 5.1 Data paths for a Register Machine
     CLOSED: [2020-02-23 Sun 13:18]

#+name: figure-5-1.png
#+begin_src plantuml :exports both :file figure-5-1.png
@startuml
skinparam monochrome true
skinparam componentStyle uml2
top to bottom direction

component "a" as a
component "b" as b
component "rem" as rem
component "t" as t
component "=" as eq
component "0" as zero

interface "a←b" as ab
interface "t←r" as tr
interface "b←t" as bt

b -left- ab
ab -left-> a
a -down-> rem
b -down-> rem
rem -down- tr
tr -down-> t
t -up- bt
bt -up-> b
b -right-> eq
zero -up-> eq

@enduml
#+end_src

#+RESULTS[77cef1b5c276bf4ea324a73b1c46c775db9c9c2a]: figure-5-1.png
[[file:figure-5-1.png]]



**** DONE Figure 5.2 Controller for a GCD Machine
     CLOSED: [2020-02-22 Sat 22:27]

#+name: figure-5-2.png
#+begin_src plantuml :exports both :file figure-5-2.png
@startuml
skinparam monochrome true
skinparam componentStyle uml2

start
while (=) is (no)
 :t->r;
 :a->b;
 :b->t;
endwhile (yes)
stop

@enduml
#+end_src

#+RESULTS[c6011a06f21a14c37cdbfccd0e53ff0c3aafd4d8]: figure-5-2.png
[[file:figure-5-2.png]]


 Ugly, but working.

**** DONE Exercise 5.1 Register machine plot
     CLOSED: [2020-02-22 Sat 22:56]

#+name: exercise-5-1-dataflow.png
#+begin_src plantuml :exports both :file exercise-5-1-dataflow.png
@startuml
skinparam monochrome true
skinparam componentStyle uml2

component n as n
component product as product
component counter as counter

component 1 as one
component "+" as plus
component "*" as mul
component ">" as gt

n --> gt
counter -left-> gt

counter -> mul
product -> mul
interface "*→p" as mp

mul -down- mp
mp -down-> product

one -left-> plus
counter -up-> plus
interface "+→c" as pc
plus -down- pc
pc -down-> counter

@enduml
#+end_src

#+RESULTS[7668d5c0cbc3eb70c90ec6d95ba02181b2a6d6cb]: exercise-5-1-dataflow.png
[[file:exercise-5-1-dataflow.png]]


 The controller is approximately the following:
  1. put the argument into ~n~
  2. put 1 in ~counter~
  3. put 1 in ~product~
  4. if >
  5. *→p
  6. +→c

#+name: figure-5-2-controller.png
#+begin_src plantuml :exports both :file figure-5-2-controller.png
@startuml
skinparam monochrome true
skinparam componentStyle uml2

start
while (>) is (no)
   :∗→p;
   :+→c;
endwhile (yes)
stop

@enduml
#+end_src

#+RESULTS[ec0331b27f87508fc8dd75242144852e46cc120c]: figure-5-2-controller.png
[[file:figure-5-2-controller.png]]


 Ugly, but seems correct.

**** DONE Exercise 5.2 Register machine language description of Exercise 5.1
     CLOSED: [2020-02-23 Sun 13:26]

#+begin_src scheme :exports code
(controller
test-b
(test (op >) (reg counter) (reg n))
(branch (label factorial-done))
(assign product (op *) (reg product) (reg counter))
(assign counter (op +) (reg counter) (const 1))
(goto (label test-b))
factorial-done)
#+end_src

**** DONE Exercise 5.3 Machine for ~sqrt~ using Newton Method
     CLOSED: [2020-02-23 Sun 20:47]
As usual with PlantUML, it's a big ugly, but good enough.

***** Simple version

#+name: exercise-5-3-dataflow-simple.png
#+begin_src plantuml :exports both :file exercise-5-3-dataflow-simple.png
@startuml
skinparam monochrome true
skinparam componentStyle uml2

component 1 as one
component guess as guess
interface "1→guess" as og
one -down- og
og  -down-> guess

package "good-enough?" as goodenough {
}
guess -right-> goodenough

package "improve " as improve {
}

guess -left-> improve
interface "i→g" as itog
improve -right- itog
itog -right-> guess

component x as x
x -down-> goodenough

@enduml
#+end_src

#+RESULTS[759957b2ef2f359bb5ef85c55038f80bd26db71b]: exercise-5-3-dataflow-simple.png
[[file:exercise-5-3-dataflow-simple.png]]


#+begin_src scheme :exports code
(controller
  test-guess
    (test (op good-enough?) (reg x) (reg guess))
    (branch (label sqrt-done))
    (assign guess (op improve) (reg guess))
    (goto (label test-guess))
  sqrt-done)
#+end_src

***** Expanding ~good-enough?~

#+name: exercise-5-3-dataflow-good-enough.png
#+begin_src plantuml :exports both :file exercise-5-3-dataflow-good-enough.png :noweb false
@startuml
skinparam monochrome true
skinparam componentStyle uml2

component 1 <<const>> as one
component guess <<reg>> as guess
interface "1→guess" <<assign>> as og
one -down- og
og  -down-> guess

package "good-enough?" as goodenough_package {
component square <<op>> as goodenough
component abs <<op>> as abs
component "−" <<op>> as minus
component ">" <<op>> as gt
component "0.001" <<const>> as thresh
component "square-result" <<reg>> as sqres
interface "s→sr" <<assign>> as runsquare
goodenough -right- runsquare
runsquare -right-> sqres
sqres -up-> minus
component "minus-result" <<reg>> as minres
interface "m→mr" <<assign>> as runminus
minus -up- runminus
runminus -up-> minres
minres -left-> abs
interface "a→absres" <<assign>> as runabs
abs -down- runabs
component "abs-result" <<reg>> as absres
runabs -down->absres
absres -left-> gt
thresh -down- gt
'  goodenough -[hidden]up- thresh
}
guess -right-> goodenough

package "improve " <<op>> as improve {
}

guess -left-> improve
interface "i→g" <<assign>> as itog
improve -right- itog
itog -right-> guess

component x <<reg>> as x
x -left-> minus

@enduml
#+end_src

#+RESULTS[d4c4737310daccd08fdf7677db5f9f4cce503530]: exercise-5-3-dataflow-good-enough.png
[[file:exercise-5-3-dataflow-good-enough.png]]


#+begin_src scheme :exports code
(controller
    (assign guess (const 1))
  test-guess
    (assign square-result (op square) (reg guess))
    (assign minus-result  (op -) (reg x) (reg square-result))
    (assign abs-result (op abs) (reg minus-result))
    (test (op >) (reg abs-result) (const 0.001))
    (branch (label sqrt-done))
    (assign guess (op improve) (reg guess))
    (goto (label test-guess))
  sqrt-done)
#+end_src

***** Expanding ~improve~

#+name: exercise-5-3-dataflow-good-enough-improve.png
#+begin_src plantuml :exports both :file exercise-5-3-dataflow-good-enough-improve.png :noweb false
@startuml
skinparam monochrome true
skinparam componentStyle uml2

component 1 <<const>> as one
component guess <<reg>> as guess
interface "1→guess" <<assign>> as og
one -up- og
og  -up-> guess

package "good-enough?" as goodenough_package {
component square <<op>> as goodenough
component abs <<op>> as abs
component "−" <<op>> as minus
component ">" <<op>> as gt
component "0.001" <<const>> as thresh
component "square-result" <<reg>> as sqres
interface "s→sr" <<assign>> as runsquare
goodenough -- runsquare
runsquare --> sqres
sqres -up-> minus
component "minus-result" <<reg>> as minres
interface "m→mr" <<assign>> as runminus
minus -up- runminus
runminus -up-> minres
minres -left-> abs
interface "a→absres" <<assign>> as runabs
abs -down- runabs
component "abs-result" <<reg>> as absres
runabs -down->absres
absres -left-> gt
thresh -down- gt
'  goodenough -[hidden]up- thresh
}
guess --> goodenough

package "improve " as improve {
component "/" <<op>> as div
component "div-res" <<reg>> as divres
interface "/→" as rundiv
div - rundiv
rundiv -> divres
component average <<op>> as average
divres --> average

}

guess -left-> div
interface "i→g" <<assign>> as itog
average -down- itog
itog --> guess

component x <<reg>> as x
x --> minus
x -> div
x --> average
@enduml
#+end_src

#+RESULTS[5d2e55f02b49a494e460ce469d55f62b5efa6c69]: exercise-5-3-dataflow-good-enough-improve.png
[[file:exercise-5-3-dataflow-good-enough-improve.png]]


#+begin_src scheme :exports code
(controller
    (assign guess (const 1))
  test-guess
    (assign square-result (op square) (reg guess))
    (assign minus-result  (op -) (reg x) (reg square-result))
    (assign abs-result (op abs) (reg minus-result))
    (test (op >) (reg abs-result) (const 0.001))
    (branch (label sqrt-done))
    (assign div-res (op /) (reg x) (reg guess))
    (assign guess (op average) (reg x) (reg div-res))
    (goto (label test-guess))
  sqrt-done)
#+end_src

**** DONE Exercise 5.4 Recursive register machines
     CLOSED: [2020-02-24 Mon 20:49]
***** a Recursive exponentiation

#+name: exercise-5.4-expt-dataflow.png
#+begin_src plantuml :exports both :noweb no :file exercise-5.4-expt-dataflow.png
@startuml
  skinparam monochrome true
  skinparam componentStyle uml2

  component 1 <<const>> as one
  component 0 <<const>> as zero

  component n <<reg>> as n
  component b <<reg>> as b

  component "=" <<op>> as eq
  component "×" <<op>> as mul
  component "−" <<op>> as minus

  component stack <<reg>> as stack
  component continue <<reg>> as continue

  n --> minus
  one --> minus

  interface "run −" as btn_minus
  minus -- btn_minus
  btn_minus --> n

  interface "sn" as sn
  interface "rn" as rn

  n -up- sn
  sn -up-> stack
  stack -- rn
  rn --> n

  interface "sc" as sc
  continue -- sc
  sc --> stack

  interface "rc" as rc
  stack -up- rc
  rc -up-> continue

  n -[hidden]- stack
  stack -[hidden]- continue

  n -> eq
  zero --> eq

  component result <<reg>> as result
  result -> mul
  b --> mul
  interface "run ×" as btn_mul
  mul -- btn_mul
  btn_mul --> result

'  one --> result

  interface " " as btn_one
  one -- btn_one
  btn_one --> result

  component "expt-done" <<label>> as exptdone
  component "general-aftercall" <<label>> as exptloop

  exptdone -[hidden]- continue
  exptloop -[hidden]- continue

  interface " " as lbl_done
  interface " " as lbl_loop

  exptdone -- lbl_done
  lbl_done --> continue
  exptloop -- lbl_loop
  lbl_loop --> continue
@enduml
#+end_src

#+RESULTS[e05a32dc4cd69eb4a6b1b5c9675103b640abbee6]: exercise-5.4-expt-dataflow.png
[[file:exercise-5.4-expt-dataflow.png]]


The machine is ugly, as is usual with PlantUML.

#+name: regmac-controller-recursive-exponentiation
#+begin_src scheme :exports code
(controller
  (assign continue (label expt-done))
expt-loop
  (test (op =) (reg n) (const 0))
  (branch (label case-one))
  (save continue)
  (assign continue (label general-aftercall))
  (assign n (op -) (reg n) (const 1))
  (goto (label expt-loop))
case-one
  (assign result (const 1))
  (goto (reg continue))
general-aftercall
  (restore continue)
  (assign result (op *) (reg b) (reg result))
  (goto (reg continue))
expt-done)
#+end_src

The amount of labels is greater than ever stored into the "continue"
register, therefore we only put two labels onto the datapath diagram
explicitly.

***** b Iterative exponentiation

#+name: exercise-5.4-expt-iterative-dataflow.png
#+begin_src plantuml :exports both :noweb no :file exercise-5.4-expt-iterative-dataflow.png
@startuml
  skinparam monochrome true
  skinparam componentStyle uml2
  left to right direction
  component 1 <<const>> as one
  component 0 <<const>> as zero

  component n <<reg>> as n
  component b <<reg>> as b

  component "=" <<op>> as eq
  component "×" <<op>> as mul
  component "−" <<op>> as minus

  n --> minus
  one --> minus

  interface "run −" as btn_minus
  minus -- btn_minus
  btn_minus --> n

  n -> eq
  zero --> eq

  component result <<reg>> as result
  result -> mul
  b --> mul
  interface "run ×" as btn_mul
  mul -- btn_mul
  btn_mul --> result

  interface " " as btn_one
  one -- btn_one
  btn_one --> result

@enduml
#+end_src

#+RESULTS[7eb8ed328ad82ddd4731fb505399643b8052414d]: exercise-5.4-expt-iterative-dataflow.png
[[file:exercise-5.4-expt-iterative-dataflow.png]]


This diagram is a stripped-down version of the previous one. Since the
iterative version doesn't need to save anything on the stack, we can
ignore the stack and continue registers.

#+name: regmac-controller-iterative-expt
#+begin_src scheme :exports code
(controller
  (assign product (const 1))
expt-loop
  (test (op =) (reg n) (const 0))
  (branch (label expt-done))
  (assign product (op *) (reg product) (reg b))
  (assign n (op -) (reg n) (const 1))
  (goto (label expt-loop))
expt-done)
#+end_src

I cheated here a little bit, because I destroy ~n~ and don't
explicitly pass parameters from ~expt~ to ~expt-iter~, but I'm lazy.

**** DONE Exercise 5.5 Hand simulation for factorial and Fibonacci
     CLOSED: [2020-02-24 Mon 23:27]
     :PROPERTIES:
     :ID:       0655de98-61a2-4efe-881e-3f82f39fa125
     :END:
***** a A factorial machine

#+begin_src scheme :exports code
  (controller
01   (assign continue (label fact-done))
;set up final return address
fact-loop
02   (test (op =) (reg n) (const 1))
03   (branch (label base-case))
;; Set up for the recursive call by saving n and continue.
;; Set up continue so that the computation will continue
;; at after-fact when the subroutine returns.
04   (save continue)
05   (save n)
06   (assign n (op -) (reg n) (const 1))
07   (assign continue (label after-fact))
08   (goto (label fact-loop))
after-fact
09   (restore n)
10   (restore continue)
11   (assign val (op *) (reg n) (reg val)) ;val now contains n(n - 1)!
12   (goto (reg continue))
;return to caller
base-case
13   (assign val (const 1))
;base case: 1! = 1
14   (goto (reg continue))
;return to caller
fact-done)
#+end_src

#+ATTR_LATEX: :center :environment supertabular :align l|l|l|l|l|l|l|p{6cm}
|  # | ip | op                                    | test | val | n | continue   | stack                                                       |
|----+----+---------------------------------------+------+-----+---+------------+-------------------------------------------------------------|
|  0 |    |                                       |      | '() | 5 | '()        | '()                                                         |
|  1 | 01 | (assign continue (label fact-done))   |      | '() | 5 | fact-done  | '()                                                         |
|  2 | 02 | (test (op =) (reg n) (const 1))       | #f   | '() | 5 | fact-done  | '()                                                         |
|  3 | 03 | (branch (label base-case))            | #f   | '() | 5 | fact-done  | '()                                                         |
|  4 | 04 | (save continue)                       | #f   | '() | 5 | fact-done  | (fact-done)                                                 |
|  5 | 05 | (save n)                              | #f   | '() | 5 | fact-done  | (5, fact-done)                                              |
|  6 | 06 | (assign n (op -) (reg n) (const 1))   | #f   | '() | 4 | fact-done  | (5, fact-done)                                              |
|  7 | 07 | (assign continue (label after-fact))  | #f   | '() | 4 | after-fact | (5, fact-done)                                              |
|  8 | 08 | (goto (label fact-loop))              | #f   | '() | 4 | after-fact | (5, fact-done)                                              |
|  9 | 02 | (test (op =) (reg n) (const 1))       | #f   | '() | 4 | after-fact | (5, fact-done)                                              |
| 10 | 03 | (branch (label base-case))            | #f   | '() | 4 | after-fact | (5, fact-done)                                              |
| 11 | 04 | (save continue)                       | #f   | '() | 4 | after-fact | (after-fact, 5, fact-done)                                  |
| 12 | 05 | (save n)                              | #f   | '() | 4 | after-fact | (4, after-fact, 5, fact-done)                               |
| 13 | 06 | (assign n (op -) (reg n) (const 1))   | #f   | '() | 3 | after-fact | (4, after-fact, 5, fact-done)                               |
| 14 | 07 | (assign continue (label after-fact))  | #f   | '() | 3 | after-fact | (4, after-fact, 5, fact-done)                               |
| 15 | 08 | (goto (label fact-loop))              | #f   | '() | 3 | after-fact | (4, after-fact, 5, fact-done)                               |
| 16 | 02 | (test (op =) (reg n) (const 1))       | #f   | '() | 3 | after-fact | (4, after-fact, 5, fact-done)                               |
| 17 | 03 | (branch (label base-case))            | #f   | '() | 3 | after-fact | (4, after-fact, 5, fact-done)                               |
| 18 | 04 | (save continue)                       | #f   | '() | 3 | after-fact | (after-fact, 4, after-fact, 5, fact-done)                   |
| 19 | 05 | (save n)                              | #f   | '() | 3 | after-fact | (3, after-fact, 4, after-fact, 5, fact-done)                |
| 20 | 06 | (assign n (op -) (reg n) (const 1))   | #f   | '() | 2 | after-fact | (3, after-fact, 4, after-fact, 5, fact-done)                |
| 21 | 07 | (assign continue (label after-fact))  | #f   | '() | 2 | after-fact | (3, after-fact, 4, after-fact, 5, fact-done)                |
| 22 | 08 | (goto (label fact-loop))              | #f   | '() | 2 | after-fact | (3, after-fact, 4, after-fact, 5, fact-done)                |
| 23 | 02 | (test (op =) (reg n) (const 1))       | #f   | '() | 2 | after-fact | (3, after-fact, 4, after-fact, 5, fact-done)                |
| 24 | 03 | (branch (label base-case))            | #f   | '() | 2 | after-fact | (3, after-fact, 4, after-fact, 5, fact-done)                |
| 25 | 04 | (save continue)                       | #f   | '() | 2 | after-fact | (after-fact, 3, after-fact, 4, after-fact, 5, fact-done)    |
| 26 | 05 | (save n)                              | #f   | '() | 2 | after-fact | (2, after-fact, 3, after-fact, 4, after-fact, 5, fact-done) |
| 27 | 06 | (assign n (op -) (reg n) (const 1))   | #f   | '() | 1 | after-fact | (2, after-fact, 3, after-fact, 4, after-fact, 5, fact-done) |
| 28 | 07 | (assign continue (label after-fact))  | #f   | '() | 1 | after-fact | (2, after-fact, 3, after-fact, 4, after-fact, 5, fact-done) |
| 29 | 08 | (goto (label fact-loop))              | #f   | '() | 1 | after-fact | (2, after-fact, 3, after-fact, 4, after-fact, 5, fact-done) |
| 30 | 02 | (test (op =) (reg n) (const 1))       | #t   | '() | 1 | after-fact | (2, after-fact, 3, after-fact, 4, after-fact, 5, fact-done) |
| 31 | 03 | (branch (label base-case))            | #t   | '() | 1 | after-fact | (2, after-fact, 3, after-fact, 4, after-fact, 5, fact-done) |
| 32 | 13 | (assign val (const 1))                | #t   | 1   | 1 | after-fact | (2, after-fact, 3, after-fact, 4, after-fact, 5, fact-done) |
| 33 | 14 | (goto (reg continue))                 | #t   | 1   | 1 | after-fact | (2, after-fact, 3, after-fact, 4, after-fact, 5, fact-done) |
| 34 | 09 | (restore n)                           | #t   | 1   | 2 | after-fact | (after-fact, 3, after-fact, 4, after-fact, 5, fact-done)    |
| 35 | 10 | (restore continue)                    | #t   | 1   | 2 | after-fact | (3, after-fact, 4, after-fact, 5, fact-done)                |
| 36 | 11 | (assign val (op *) (reg n) (reg val)) | #t   | 2   | 2 | after-fact | (3, after-fact, 4, after-fact, 5, fact-done)                |
| 37 | 12 | (goto (reg continue))                 | #t   | 2   | 2 | after-fact | (3, after-fact, 4, after-fact, 5, fact-done)                |
| 38 | 09 | (restore n)                           | #t   | 2   | 3 | after-fact | (after-fact, 4, after-fact, 5, fact-done)                   |
| 39 | 10 | (restore continue)                    | #t   | 2   | 3 | after-fact | (4, after-fact, 5, fact-done)                               |
| 40 | 11 | (assign val (op *) (reg n) (reg val)) | #t   | 6   | 3 | after-fact | (4, after-fact, 5, fact-done)                               |
| 41 | 12 | (goto (reg continue))                 | #t   | 6   | 3 | after-fact | (4, after-fact, 5, fact-done)                               |
| 42 | 09 | (restore n)                           | #t   | 6   | 4 | after-fact | (after-fact, 5, fact-done)                                  |
| 43 | 10 | (restore continue)                    | #t   | 6   | 4 | after-fact | (5, fact-done)                                              |
| 44 | 11 | (assign val (op *) (reg n) (reg val)) | #t   | 24  | 4 | after-fact | (5, fact-done)                                              |
| 45 | 12 | (goto (reg continue))                 | #t   | 24  | 4 | after-fact | (5, fact-done)                                              |
| 46 | 09 | (restore n)                           | #t   | 24  | 5 | after-fact | (fact-done)                                                 |
| 47 | 10 | (restore continue)                    | #t   | 24  | 5 | fact-down  | '()                                                         |
| 48 | 11 | (assign val (op *) (reg n) (reg val)) | #t   | 120 | 5 | fact-down  | '()                                                         |
| 49 | 12 | (goto (reg continue))                 | #t   | 120 | 5 | fact-down  | '()                                                         |
| 50 |  # | DONE                                  | #t   | 120 | 5 | fact-down  | '()                                                         |
|  # |  # | #                                     | #    | ans | # | #          | #                                                           |

***** b Fibonacci machine

#+begin_src scheme :exports code
(controller
01   (assign continue (label fib-done))
fib-loop
02   (test (op <) (reg n) (const 2))
03   (branch (label immediate-answer))
;; set up to compute Fib(n − 1)
04   (save continue)
05   (assign continue (label afterfib-n-1))
06   (save n) ; save old value of n
07   (assign n (op -) (reg n) (const 1)) ; clobber n to n-1
08   (goto (label fib-loop)) ; perform recursive call
afterfib-n-1 ; upon return, val contains Fib(n − 1)
09   (restore n)
10   (restore continue)
;; set up to compute Fib(n − 2)
11   (assign n (op -) (reg n) (const 2))
12   (save continue)
13   (assign continue (label afterfib-n-2))
14   (save val) ; save Fib(n − 1)
15   (goto (label fib-loop))
afterfib-n-2 ; upon return, val contains Fib(n − 2)
16   (assign n (reg val)) ; n now contains Fib(n − 2)
17   (restore val) ; val now contains Fib(n − 1)
18   (restore continue)
19   (assign val (op +) (reg val) (reg n)) ; Fib(n − 1) + Fib(n − 2)
20   (goto (reg continue)) ; return to caller, answer is in val
immediate-answer
21   (assign val (reg n)) ; base case: Fib(n) = n
22   (goto (reg continue))
fib-done
23)
#+end_src

#+ATTR_LATEX: :center :environment supertabular :align l|l|l|l|l|l|l|p{6cm}
|  # | ip | instruction                            | test | n | val | continue     | stack          |
|----+----+----------------------------------------+------+---+-----+--------------+----------------|
|    |    |                                        |      | 2 |     |              |                |
| 00 | 01 | (assign continue (label fib-done))     |      | 2 |     | fib-done     | '()            |
| 01 | 02 | (test (op <) (reg n) (const 2))        | #f   | 2 |     | fib-done     | '()            |
| 02 | 03 | (branch (label immediate-answer))      | #f   | 2 |     | fib-done     | '()            |
| 03 | 04 | (save continue)                        | #f   | 2 |     | fib-done     | '(fib-done)    |
| 04 | 05 | (assign continue (label afterfib-n-1)) | #f   | 2 |     | afterfib-n-1 | '(fib-done)    |
| 05 | 06 | (save n)                               | #f   | 2 |     | afterfib-n-1 | '(2, fib-done) |
| 06 | 07 | (assign n (op -) (reg n) (const 1))    | #f   | 1 |     | afterfib-n-1 | '(2, fib-done) |
| 07 | 08 | (goto (label fib-loop))                | #f   | 1 |     | afterfib-n-1 | '(2, fib-done) |
| 08 | 02 | (test (op <) (reg n) (const 2))        | #t   | 1 |     | afterfib-n-1 | '(2, fib-done) |
| 09 | 03 | (branch (label immediate-answer))      | #t   | 1 |     | afterfib-n-1 | '(2, fib-done) |
| 10 | 21 | (assign val (reg n))                   | #t   | 1 |   1 | afterfib-n-1 | '(2, fib-done) |
| 11 | 22 | (goto (reg continue))                  | #t   | 1 |   1 | afterfib-n-1 | '(2, fib-done) |
| 12 | 09 | (restore n)                            | #t   | 2 |   1 | afterfib-n-1 | '(fib-done)    |
| 13 | 10 | (restore continue)                     | #t   | 2 |   1 | fib-done     | '()            |
| 14 | 11 | (assign n (op -) (reg n) (const 2))    | #t   | 0 |   1 | fib-done     | '()            |
| 15 | 12 | (save continue)                        | #t   | 0 |   1 | fib-done     | '(fib-done)    |
| 16 | 13 | (assign continue (label afterfib-n-2)) | #t   | 0 |   1 | afterfib-n-2 | '(fib-done)    |
| 17 | 14 | (save val)                             | #t   | 0 |   1 | afterfib-n-2 | '(1, fib-done) |
| 18 | 02 | (test (op <) (reg n) (const 2))        | #t   | 0 |   1 | afterfib-n-2 | '(1, fib-done) |
| 19 | 03 | (branch (label immediate-answer))      | #t   | 0 |   1 | afterfib-n-2 | '(1, fib-done) |
| 20 | 21 | (assign val (reg n))                   | #t   | 0 |   0 | afterfib-n-2 | '(1, fib-done) |
| 21 | 22 | (goto (reg continue))                  | #t   | 0 |   0 | afterfib-n-2 | '(1, fib-done) |
| 22 | 16 | (assign n (reg val))                   | #t   | 0 |   0 | afterfib-n-2 | '(1, fib-done) |
| 23 | 17 | (restore val)                          | #t   | 0 |   1 | afterfib-n-2 | '(fib-done)    |
| 24 | 18 | (restore continue)                     | #t   | 0 |   1 | fib-done     | '()            |
| 25 | 19 | (assign val (op +) (reg val) (reg n))  | #t   | 0 |   1 | fib-done     | '()            |
| 26 | 23 | DONE                                   | #    | # |   1 | #            | #              |
|  # |  # | #                                      | #    | # | ans | #            | #              |

Well, evidently, the Fibonacci 2 is indeed 1, and it took two
recursive calls and 26 operations. Phew.

**** DONE Exercise 5.6 Fibonacci machine extra instructions
     CLOSED: [2020-02-24 Mon 23:43]

In the [[Exercise 5.5 Hand simulation for factorial and Fibonacci]], after
the label ~afterfib-n-1~, there are lines 10 and 12, which do useless
job of restoring and saving the return address. They can be removed.

*** 5.2 Register-Machine Simulator [13/13]
**** Common code

#+name: regmac-glue1
#+begin_src scheme :exports code :results none
(import (scheme small))
(import (scheme list))
(import (srfi 159))
(define false #t)
(define true #t)
(define (tagged-list? exp tag)
            (if (pair? exp)
                (eq? (car exp) tag)
                false))
#+end_src

#+name: regmac-controller-gcd-machine
#+begin_src scheme :exports code :results none
(test-b (test (op =) (reg b) (const 0))
	      (branch (label gcd-done))
	      (assign t (op rem) (reg a) (reg b))
	      (assign a (reg b))
	      (assign b (reg t))
	      (goto (label test-b))
	      gcd-done)
#+end_src

#+name: regmac-test-gcd-1
#+begin_src scheme :exports code :results none
(define gcd-machine
    (make-machine
     '(a b t)
     (list (list 'rem remainder) (list '= =))
     (quote
<<regmac-controller-gcd-machine>>
)))

  (set-register-contents! gcd-machine 'a 206)
  (set-register-contents! gcd-machine 'b 40)
  (start gcd-machine)
  (display (get-register-contents gcd-machine 'a))

#+end_src

#+header: :stdin empty
#+begin_src shell :shebang "#! /usr/bin/chibi-scheme" :exports both :results output scalar code
  <<regmac-glue1>>
  <<regmac-make-machine>>
  <<regmac-make-register>>
  <<regmac-make-stack>>
  <<regmac-make-new-machine>>
  <<regmac-extract-labels>>
  <<regmac-assembler>>
  <<regmac-generating-execution-procedures>>
  <<regmac-make-operation-exp>>
  <<regmac-make-operation-exp-syntax>>
  <<regmac-make-assign>>
  <<regmac-make-test>>
  <<regmac-make-save-restore>>
  <<regmac-other-instructions>>

  <<regmac-test-gcd-1>>
#+end_src

#+RESULTS[eb5a89381188e0947dd61e42f48135b684b3036d]:
#+begin_src shell
2
#+end_src


#+name: regmac-make-machine
#+begin_src scheme :exports code :results none
  (define (make-machine register-names ops controller-text)
    (let ((machine (make-new-machine)))
      (for-each
       (lambda (register-name)
	 ((machine 'allocate-register) register-name))
       register-names)
      ((machine 'install-operations) ops)
      ((machine 'install-instruction-sequence)
       (assemble controller-text machine))
      machine))
#+end_src

#+name: regmac-make-register
#+begin_src scheme :exports code :results none
  (define (make-register name)
    (let ((contents '*unassigned*))
      (define (dispatch message)
	(cond ((eq? message 'get) contents)
	      ((eq? message 'set)
	       (lambda (value) (set! contents value)))
	      (else
	       (error "Unknown request: REGISTER" message))))
      dispatch))
  (define (get-contents register) (register 'get))
  (define (set-contents! register value)
    ((register 'set) value))
#+end_src

#+name: regmac-make-stack
#+begin_src scheme :exports code :results none
  (define (make-stack)
    (let ((s '()))
      (define (push x) (set! s (cons x s)))
      (define (pop)
	(if (null? s)
	    (error "Empty stack: POP")
	    (let ((top (car s)))
	      (set! s (cdr s))
	      top)))
      (define (initialize)
	(set! s '())
	'done)
      (define (dispatch message)
	(cond ((eq? message 'push) push)
	      ((eq? message 'pop) (pop))
	      ((eq? message 'initialize) (initialize))
	      (else (error "Unknown request: STACK" message))))
      dispatch))
  (define (pop stack) (stack 'pop))
  (define (push stack value) ((stack 'push) value))
#+end_src

#+name: regmac-make-new-machine
#+begin_src scheme :exports code :results none
  (define (make-new-machine)
    (let ((pc (make-register 'pc))
	  (flag (make-register 'flag))
	  (stack (make-stack))
	  (the-instruction-sequence '()))
      (let ((the-ops
	     (list (list 'initialize-stack
			 (lambda () (stack 'initialize)))))
	    (register-table
	     (list (list 'pc pc) (list 'flag flag))))
	(define (allocate-register name)
	  (if (assoc name register-table)
	      (error "Multiply defined register: " name)
	      (set! register-table
		(cons (list name (make-register name))
		      register-table)))
	  'register-allocated)
	(define (lookup-register name)
	  (let ((val (assoc name register-table)))
	    (if val
		(cadr val)
		(error "Unknown register:" name))))
	(define (execute)
	  (let ((insts (get-contents pc)))
	    (if (null? insts)
		'done
		(begin
		  ((instruction-execution-proc (car insts)))
		  (execute)))))
	(define (dispatch message)
	  (cond ((eq? message 'start)
		 (set-contents! pc the-instruction-sequence)
		 (execute))
		((eq? message 'install-instruction-sequence)
		 (lambda (seq)
		   (set! the-instruction-sequence seq)))
		((eq? message 'allocate-register)
		 allocate-register)
		((eq? message 'get-register)
		 lookup-register)
		((eq? message 'install-operations)
		 (lambda (ops)
		   (set! the-ops (append the-ops ops))))
		((eq? message 'stack) stack)
		((eq? message 'operations) the-ops)
		(else (error "Unknown request: MACHINE"
			     message))))
	dispatch)))
  (define (start machine) (machine 'start))
  (define (get-register-contents machine register-name)
    (get-contents (get-register machine register-name)))
  (define (set-register-contents! machine register-name value)
    (set-contents! (get-register machine register-name)
		   value)
    'done)

  (define (get-register machine reg-name)
    ((machine 'get-register) reg-name))
  (define (advance-pc pc)
    (set-contents! pc (cdr (get-contents pc))))
#+end_src

#+name: regmac-extract-labels
#+begin_src scheme :exports code :results none
  (define (extract-labels text receive)
    (if (null? text)
	(receive '() '())
	(extract-labels
	 (cdr text)
	 (lambda (insts labels)
	   (let ((next-inst (car text)))
	     (if (symbol? next-inst) ;; i.e. label
		 (receive insts
		     (cons (make-label-entry next-inst
					     insts)
			   labels))
		 (receive (cons (make-instruction next-inst)
				insts)
		     labels)))))))
#+end_src


#+name: regmac-assembler
#+begin_src scheme :exports code :results none
  (define (assemble controller-text machine)
    (extract-labels
     controller-text
     (lambda (insts labels)
       (update-insts! insts labels machine)
       insts)))

  (define (update-insts! insts labels machine)
    (let ((pc (get-register machine 'pc))
	  (flag (get-register machine 'flag))
	  (stack (machine 'stack))
	  (ops (machine 'operations)))
      (for-each
       (lambda (inst)
	 (set-instruction-execution-proc!
	  inst
	  (make-execution-procedure
	   (instruction-text inst)
	   labels machine pc flag stack ops)))
       insts)))

  (define (make-instruction text) (cons text '()))
  (define (instruction-text inst) (car inst))
  (define (instruction-execution-proc inst) (cdr inst))
  (define (set-instruction-execution-proc! inst proc)
    (set-cdr! inst proc))

  (define (make-label-entry label-name insts)
    (cons label-name insts))
  (define (lookup-label labels label-name)
    (let ((val (assoc label-name labels)))
      (if val
	  (cdr val)
	  (error "Undefined label: ASSEMBLE"
		 label-name))))
#+end_src

#+name: regmac-generating-execution-procedures
#+begin_src scheme :exports code :results none
  (define (make-execution-procedure
      inst labels machine pc flag stack ops)
    (cond ((eq? (car inst) 'assign)
	   (make-assign inst machine labels ops pc))
	  ((eq? (car inst) 'test)
	   (make-test inst machine labels ops flag pc))
	  ((eq? (car inst) 'branch)
	   (make-branch inst machine labels flag pc))
	  ((eq? (car inst) 'goto)
	   (make-goto inst machine labels pc))
	  ((eq? (car inst) 'save)
	   (make-save inst machine stack pc))
	  ((eq? (car inst) 'restore)
	   (make-restore inst machine stack pc))
	  ((eq? (car inst) 'perform)
	   (make-perform inst machine labels ops pc))
	  (else
	   (error "Unknown instruction type: ASSEMBLE"
		  inst))))
#+end_src

#+name: regmac-make-assign
#+begin_src scheme :exports code :results none
  (define (make-assign inst machine labels operations pc)
    (let ((target
	   (get-register machine (assign-reg-name inst)))
	  (value-exp (assign-value-exp inst)))
      (let ((value-proc
	     (if (operation-exp? value-exp)
		 (make-operation-exp
		  value-exp machine labels operations)
		 (make-primitive-exp
		  (car value-exp) machine labels))))
	(lambda ()
					  ; execution procedure for assign
	  (set-contents! target (value-proc))
	  (advance-pc pc)))))
  (define (assign-reg-name assign-instruction)
    (cadr assign-instruction))
  (define (assign-value-exp assign-instruction)
    (cddr assign-instruction))

#+end_src

#+name: regmac-make-test
#+begin_src scheme :exports code :results none
  (define (make-test inst machine labels operations flag pc)
    (let ((condition (test-condition inst)))
      (if (operation-exp? condition)
	  (let ((condition-proc
		 (make-operation-exp
		  condition machine labels operations)))
	    (lambda ()
	      (set-contents! flag (condition-proc))
	      (advance-pc pc)))
	  (error "Bad TEST instruction: ASSEMBLE" inst))))
  (define (test-condition test-instruction)
    (cdr test-instruction))
  (define (make-branch inst machine labels flag pc)
    (let ((dest (branch-dest inst)))
      (if (label-exp? dest)
	  (let ((insts
		 (lookup-label
		  labels
		  (label-exp-label dest))))
	    (lambda ()
	      (if (get-contents flag)
		  (set-contents! pc insts)
		  (advance-pc pc))))
	  (error "Bad BRANCH instruction: ASSEMBLE" inst))))
  (define (branch-dest branch-instruction)
    (cadr branch-instruction))
  (define (make-goto inst machine labels pc)
    (let ((dest (goto-dest inst)))
      (cond ((label-exp? dest)
	     (let ((insts (lookup-label
			   labels
			   (label-exp-label dest))))
	       (lambda () (set-contents! pc insts))))
	    ((register-exp? dest)
	     (let ((reg (get-register
			 machine
			 (register-exp-reg dest))))
	       (lambda ()
		 (set-contents! pc (get-contents reg)))))
	    (else (error "Bad GOTO instruction: ASSEMBLE" inst)))))
  (define (goto-dest goto-instruction)
    (cadr goto-instruction))
#+end_src

#+name: regmac-make-save-restore
#+begin_src scheme :exports code :results none
  (define (make-save inst machine stack pc)
    (let ((reg (get-register machine
			     (stack-inst-reg-name inst))))
      (lambda ()
	(push stack (get-contents reg))
	(advance-pc pc))))
  (define (make-restore inst machine stack pc)
    (let ((reg (get-register machine
			     (stack-inst-reg-name inst))))
      (lambda ()
	(set-contents! reg (pop stack))
	(advance-pc pc))))
#+end_src

#+name: regmac-other-instructions
#+begin_src scheme :exports code :results none
  (define (stack-inst-reg-name stack-instruction)
    (cadr stack-instruction))
  (define (make-perform inst machine labels operations pc)
    (let ((action (perform-action inst)))
      (if (operation-exp? action)
	  (let ((action-proc
		 (make-operation-exp
		  action machine labels operations)))
	    (lambda () (action-proc) (advance-pc pc)))
	  (error "Bad PERFORM instruction: ASSEMBLE" inst))))
  (define (perform-action inst) (cdr inst))
  (define (make-primitive-exp exp machine labels)
    (cond ((constant-exp? exp)
	   (let ((c (constant-exp-value exp)))
	     (lambda () c)))
	  ((label-exp? exp)
	   (let ((insts (lookup-label
			 labels
			 (label-exp-label exp))))
	     (lambda () insts)))
	  ((register-exp? exp)
	   (let ((r (get-register machine (register-exp-reg exp))))
	     (lambda () (get-contents r))))
	  (else (error "Unknown expression type: ASSEMBLE" exp))))
  (define (register-exp? exp) (tagged-list? exp 'reg))
  (define (register-exp-reg exp) (cadr exp))
  (define (constant-exp? exp) (tagged-list? exp 'const))
  (define (constant-exp-value exp) (cadr exp))
  (define (label-exp? exp) (tagged-list? exp 'label))
  (define (label-exp-label exp) (cadr exp))
#+end_src

#+name: regmac-make-operation-exp
#+begin_src scheme :exports code :results none
  (define (make-operation-exp exp machine labels operations)
    (let ((op (lookup-prim (operation-exp-op exp)
			   operations))
	  (aprocs
	   (map (lambda (e)
		  (make-primitive-exp e machine labels))
		(operation-exp-operands exp))))
      (lambda ()
	(apply op (map (lambda (p) (p)) aprocs)))))
#+end_src

#+name: regmac-make-operation-exp-syntax
#+begin_src scheme :exports code :results none
  (define (operation-exp? exp)
    (and (pair? exp) (tagged-list? (car exp) 'op)))
  (define (operation-exp-op operation-exp)
    (cadr (car operation-exp)))
  (define (operation-exp-operands operation-exp)
    (cdr operation-exp))
  (define (lookup-prim symbol operations)
    (let ((val (assoc symbol operations)))
      (if val
	  (cadr val)
	  (error "Unknown operation: ASSEMBLE"
		 symbol))))

#+end_src

#+name: regmac-make-stack-with-performance
#+begin_src scheme :exports code :results none
  (define (make-stack)
    (let ((s '())
	  (number-pushes 0)
	  (max-depth 0)
	  (current-depth 0))
      (define (push x)
	(set! s (cons x s))
	(set! number-pushes (+ 1 number-pushes))
	(set! current-depth (+ 1 current-depth))
	(set! max-depth (max current-depth max-depth)))
      (define (pop)
	(if (null? s)
	    (error "Empty stack: POP")
	    (let ((top (car s)))
	      (set! s (cdr s))
	      (set! current-depth (- current-depth 1))
	      top)))
      (define (initialize)
	(set! s '())
	(set! number-pushes 0)
	(set! max-depth 0)
	(set! current-depth 0)
	'done)
      (define (print-statistics)
	(newline)
	(display (list 'total-pushes
		       '= number-pushes
		       'maximum-depth '= max-depth)))
      (define (dispatch message)
	(cond ((eq? message 'push) push)
	      ((eq? message 'pop) (pop))
	      ((eq? message 'initialize) (initialize))
	      ((eq? message 'print-statistics)
	       (print-statistics))
	      (else (error "Unknown request: STACK" message))))
      dispatch))
  (define (pop stack) (stack 'pop))
  (define (push stack value) ((stack 'push) value))
#+end_src

#+RESULTS: regmac-make-stack-with-performance
: #<undef>

**** DONE Exercise 5.7 Test the 5.4 machine on a simulator
     CLOSED: [2020-02-25 Tue 10:42]

This turned out to be easier than I had thought.

***** a Recursive exponentiation

#+name: regmac-test-recursive-expt
#+begin_src scheme :exports code :results none
(define expt-recursive-machine
    (make-machine
     '(n b result stack continue)
     (list (list '- -) (list '* *) (list '= =) (list 'rem remainder))
     (quote
       <<regmac-controller-recursive-exponentiation>>)))

  (set-register-contents! expt-recursive-machine 'n 10)
  (set-register-contents! expt-recursive-machine 'b 2)
  (set-register-contents! expt-recursive-machine 'result -1)
  (start expt-recursive-machine)
  (display (get-register-contents expt-recursive-machine 'result))

#+end_src


#+header: :stdin empty
#+begin_src shell :shebang "#! /usr/bin/chibi-scheme" :exports both :results output scalar code
  <<regmac-glue1>>
  <<regmac-make-machine>>
  <<regmac-make-register>>
  <<regmac-make-stack>>
  <<regmac-make-new-machine>>
  <<regmac-extract-labels>>
  <<regmac-assembler>>
  <<regmac-generating-execution-procedures>>
  <<regmac-make-operation-exp>>
  <<regmac-make-operation-exp-syntax>>
  <<regmac-make-assign>>
  <<regmac-make-test>>
  <<regmac-make-save-restore>>
  <<regmac-other-instructions>>

  <<regmac-test-recursive-expt>>
#+end_src

#+RESULTS[5111e22bab47d4dac20208dcddbf53e77e2c5e37]:
#+begin_src shell
1024
#+end_src

***** b Iterative exponentiation

#+name: regmac-test-iterative-expt
#+begin_src scheme :exports code :results none
(define expt-machine
    (make-machine
     '(n b product)
     (list (list '- -) (list '* *) (list '= =) (list 'rem remainder))
     (quote
       <<regmac-controller-iterative-expt>>)))

  (set-register-contents! expt-machine 'n 10)
  (set-register-contents! expt-machine 'b 2)
  (set-register-contents! expt-machine 'product -1)
  (start expt-machine)
  (display (get-register-contents expt-machine 'product))

#+end_src


#+header: :stdin empty
#+begin_src shell :shebang "#! /usr/bin/chibi-scheme" :exports both :results output scalar code
  <<regmac-glue1>>
  <<regmac-make-machine>>
  <<regmac-make-register>>
  <<regmac-make-stack>>
  <<regmac-make-new-machine>>
  <<regmac-extract-labels>>
  <<regmac-assembler>>
  <<regmac-generating-execution-procedures>>
  <<regmac-make-operation-exp>>
  <<regmac-make-operation-exp-syntax>>
  <<regmac-make-assign>>
  <<regmac-make-test>>
  <<regmac-make-save-restore>>
  <<regmac-other-instructions>>

  <<regmac-test-iterative-expt>>
#+end_src

#+RESULTS[ec063a19690aca7b3cfae06493d409226fc81a5a]:
#+begin_src shell
1024
#+end_src

**** DONE Exercise 5.8 Ambiguous labels
     CLOSED: [2020-02-25 Tue 21:58]

#+header: :stdin empty
#+begin_src shell :shebang "#! /usr/bin/chibi-scheme" :exports both :results output scalar code
  <<regmac-glue1>>
  <<regmac-make-machine>>
  <<regmac-make-register>>
  <<regmac-make-stack>>
  <<regmac-make-new-machine>>
  <<regmac-extract-labels>>
  <<regmac-assembler>>
  <<regmac-generating-execution-procedures>>
  <<regmac-make-operation-exp>>
  <<regmac-make-operation-exp-syntax>>
  <<regmac-make-assign>>
  <<regmac-make-test>>
  <<regmac-make-save-restore>>
  <<regmac-other-instructions>>


  (define test-machine
    (make-machine
     '(a)
     (list)
     (quote (start
         (goto (label here))
       here
         (assign a (const 3))
         (goto (label there))
       here
         (assign a (const 4))
         (goto (label there))
       there))))

  (set-register-contents! test-machine 'a -1)
  (start test-machine)
  (display (get-register-contents test-machine 'a))
#+end_src

#+RESULTS[b7247377c72c1868caab60149e819de2842300ad]:
#+begin_src shell
3
#+end_src

This example shows that the first label is used.

Let's modify ~extract-labels~:

#+name: regmac-extract-labels-improved
#+begin_src scheme :exports code :results none
  (define (extract-labels text receive)
    (if (null? text)
	(receive '() '())
	(extract-labels
	 (cdr text)
	 (lambda (insts labels)
	   (let ((next-inst (car text)))
	     (if (symbol? next-inst)
		 (receive insts
		     (if (assoc next-inst labels)
			 (error "extract-labels: ambiguous label" next-inst)
			 (cons (make-label-entry next-inst
						 insts)
			       labels)))
		 (receive (cons (make-instruction next-inst)
				insts)
		     labels)))))))
#+end_src

#+header: :stdin empty
#+begin_src shell :shebang "#! /usr/bin/chibi-scheme" :exports both :results output scalar code
  <<regmac-glue1>>
  <<regmac-make-machine>>
  <<regmac-make-register>>
  <<regmac-make-stack>>
  <<regmac-make-new-machine>>
  <<regmac-extract-labels-improved>>
  <<regmac-assembler>>
  <<regmac-generating-execution-procedures>>
  <<regmac-make-operation-exp>>
  <<regmac-make-operation-exp-syntax>>
  <<regmac-make-assign>>
  <<regmac-make-test>>
  <<regmac-make-save-restore>>
  <<regmac-other-instructions>>

  (define test-machine
    (make-machine
     '(a)
     (list)
     (quote (start
         (goto (label here))
       here
         (assign a (const 3))
         (goto (label there))
       here
         (assign a (const 4))
         (goto (label there))
       there))))

  (set-register-contents! test-machine 'a -1)
  (start test-machine)
  (display (get-register-contents test-machine 'a))
#+end_src

#+RESULTS[80dff3d877476d8e2c255fe5cdacb70fab69e232]:
#+begin_src shell
ERROR: extract-labels: ambiguous label: here
  called from <anonymous> on line 122 of file /tmp/babel-NNNv58/sh-script-lnTFyD
  called from <anonymous> on line 14 of file /tmp/babel-NNNv58/sh-script-lnTFyD
  called from <anonymous> on line 314 of file /tmp/babel-NNNv58/sh-script-lnTFyD
  called from <anonymous> on line 1289 of file /usr/lib64/chibi/init-7.scm
  called from <anonymous> on line 280 of file /usr/lib64/chibi/init-7.scm
  called from <anonymous> on line 817 of file /usr/lib64/chibi/init-7.scm
#+end_src

Errors as expected.

#+header: :stdin empty
#+begin_src shell :shebang "#! /usr/bin/chibi-scheme" :exports both :results output scalar code
  <<regmac-glue1>>
  <<regmac-make-machine>>
  <<regmac-make-register>>
  <<regmac-make-stack>>
  <<regmac-make-new-machine>>
  <<regmac-extract-labels-improved>>
  <<regmac-assembler>>
  <<regmac-generating-execution-procedures>>
  <<regmac-make-operation-exp>>
  <<regmac-make-operation-exp-syntax>>
  <<regmac-make-assign>>
  <<regmac-make-test>>
  <<regmac-make-save-restore>>
  <<regmac-other-instructions>>

  (define test-machine
    (make-machine
     '(a)
     (list)
     (quote (start
         (goto (label here))
       here
         (assign a (const 3))
         (goto (label there))
       here2
         (assign a (const 4))
         (goto (label there))
       there))))

  (set-register-contents! test-machine 'a -1)
  (start test-machine)
  (display (get-register-contents test-machine 'a))
#+end_src

#+RESULTS[374e16973a19e96eefdfc0e5f09d342344203d85]:
#+begin_src shell
3
#+end_src


Works as expected.

**** DONE Exercise 5.9 Prohibit (op)s on labels
     CLOSED: [2020-02-25 Tue 22:23]

#+name: regmac-make-operation-exp-improved
#+begin_src scheme :exports code :results none
  (define (make-operation-exp exp machine labels operations)
    (let ((op (lookup-prim (operation-exp-op exp)
			   operations))
	  (aprocs
	   (map (lambda (e)
		  (if (label-exp? e)
                      (error "make-operation-exp: operations cannot be applied to labels"
                              e exp)
                      (make-primitive-exp e machine labels)))
		(operation-exp-operands exp))))
      (lambda ()
	(apply op (map (lambda (p) (p)) aprocs)))))
#+end_src


#+header: :stdin empty
#+begin_src shell :shebang "#! /usr/bin/chibi-scheme" :exports both :results output scalar code
  <<regmac-glue1>>
  <<regmac-make-machine>>
  <<regmac-make-register>>
  <<regmac-make-stack>>
  <<regmac-make-new-machine>>
  <<regmac-extract-labels-improved>>
  <<regmac-assembler>>
  <<regmac-generating-execution-procedures>>
  <<regmac-make-operation-exp-improved>>
  <<regmac-make-operation-exp-syntax>>
  <<regmac-make-assign>>
  <<regmac-make-test>>
  <<regmac-make-save-restore>>
  <<regmac-other-instructions>>

  (define test-machine
    (make-machine
     '(a)
     (list (list '= =))
     (quote (start
         (goto (label here))
       here
         (assign a (const 3))
         (assign a (op =) (const 1) (label here))
         (goto (label there))
       here2
         (assign a (const 4))
         (goto (label there))
       there))))

  (set-register-contents! test-machine 'a -1)
  (start test-machine)
  (display (get-register-contents test-machine 'a))
#+end_src

#+RESULTS[2fd4b470face0d43cdedaa2b863689de231354d9]:
#+begin_src shell
ERROR: make-operation-exp: operations cannot be applied to labels
    (label here)
    ((op =) (const 1) (label here))
  called from map1 on line 62 of file /usr/lib64/chibi/init-7.scm
  called from make-operation-exp on line 280 of file /usr/lib64/chibi/init-7.scm
  called from <anonymous> on line 216 of file /tmp/babel-NNNv58/sh-script-yM9NYT
  called from <anonymous> on line 145 of file /tmp/babel-NNNv58/sh-script-yM9NYT
  called from for1 on line 75 of file /usr/lib64/chibi/init-7.scm
  called from <anonymous> on line 135 of file /tmp/babel-NNNv58/sh-script-yM9NYT
  called from <anonymous> on line 14 of file /tmp/babel-NNNv58/sh-script-yM9NYT
  called from <anonymous> on line 317 of file /tmp/babel-NNNv58/sh-script-yM9NYT
  called from <anonymous> on line 1289 of file /usr/lib64/chibi/init-7.scm
  called from <anonymous> on line 280 of file /usr/lib64/chibi/init-7.scm
  called from <anonymous> on line 817 of file /usr/lib64/chibi/init-7.scm
#+end_src

Is this what was expected?

**** DONE Exercise 5.10 Changing syntax
     CLOSED: [2020-02-25 Tue 22:39]

What is the easiest part of changing syntax we may think of? Well, for
example, I am confused by the fact that when assignment is done, we
don't explicitly say that we want to assign to a register. Let's make
it work like this: ~(assign (reg a) (reg b))~.

#+name: regmac-make-assign-improved
#+begin_src scheme :exports code  :results none
  (define (make-assign inst machine labels operations pc)
    (let ((target
	   (get-register machine (assign-reg-name inst)))
	  (value-exp (assign-value-exp inst)))
      (let ((value-proc
	     (if (operation-exp? value-exp)
		 (make-operation-exp
		  value-exp machine labels operations)
		 (make-primitive-exp
		  (car value-exp) machine labels))))
	(lambda ()
					  ; execution procedure for assign
	  (set-contents! target (value-proc))
	  (advance-pc pc)))))
  (define (assign-reg-name assign-instruction)
    (cadadr assign-instruction))
  (define (assign-value-exp assign-instruction)
    (cddr assign-instruction))
#+end_src

#+header: :stdin empty
#+begin_src shell :shebang "#! /usr/bin/chibi-scheme" :exports both :results output scalar code
  <<regmac-glue1>>
  <<regmac-make-machine>>
  <<regmac-make-register>>
  <<regmac-make-stack>>
  <<regmac-make-new-machine>>
  <<regmac-extract-labels-improved>>
  <<regmac-assembler>>
  <<regmac-generating-execution-procedures>>
  <<regmac-make-operation-exp-improved>>
  <<regmac-make-operation-exp-syntax>>
  <<regmac-make-assign-improved>>
  <<regmac-make-test>>
  <<regmac-make-save-restore>>
  <<regmac-other-instructions>>

  (define test-machine
    (make-machine
     '(a)
     (list (list '= =))
     (quote (start
         (goto (label here))
       here
         (assign (reg a) (const 3))
         (assign (reg a) (op =) (const 1) (reg a))
         (goto (label there))
       here2
         (assign (reg a) (const 4))
         (goto (label there))
       there))))

  (set-register-contents! test-machine 'a -1)
  (start test-machine)
  (display (get-register-contents test-machine 'a))
#+end_src

#+RESULTS[90127e26640a4b6691f586023f2c81209c52f77c]:
#+begin_src shell
#f
#+end_src

Works! In principle, if we model a machine that is not a
load-and-store machine, we could extend the syntax further in order to
make a memory address the target of an assignment!

**** DONE Exercise 5.11 Save and restore
     CLOSED: [2020-02-26 Wed 13:30]

***** a A better Fibonacci machine with out-of-order restore

In the ~afterfib-n-2~ block, there is an ~(assign n (reg val))~. This
is only needed so that we could then ~(restore val)~. In our current
design we can do ~(restore n)~ directly. Let's test.

First let's test a standard Fibonacci machine.

#+name: regmac-controller-fibonacci-512
#+begin_src scheme :exports code :results none
(controller
   (assign continue (label fib-done))
fib-loop
   (test (op <) (reg n) (const 2))
   (branch (label immediate-answer))
   (save continue)
   (assign continue (label afterfib-n-1))
   (save n)
   (assign n (op -) (reg n) (const 1))
   (goto (label fib-loop))
afterfib-n-1
   (restore n)
   (restore continue)
   (assign n (op -) (reg n) (const 2))
   (save continue)
   (assign continue (label afterfib-n-2))
   (save val)
   (goto (label fib-loop))
afterfib-n-2
   (assign n (reg val))
   (restore val)
   (restore continue)
   (assign val (op +) (reg val) (reg n))
   (goto (reg continue))
immediate-answer
   (assign val (reg n))
   (goto (reg continue))
fib-done)
#+end_src

#+header: :stdin empty
#+begin_src shell :shebang "#! /usr/bin/chibi-scheme" :exports both :results output scalar code
  <<regmac-glue1>>
  <<regmac-make-machine>>
  <<regmac-make-register>>
  <<regmac-make-stack>>
  <<regmac-make-new-machine>>
  <<regmac-extract-labels-improved>>
  <<regmac-assembler>>
  <<regmac-generating-execution-procedures>>
  <<regmac-make-operation-exp-improved>>
  <<regmac-make-operation-exp-syntax>>
  <<regmac-make-assign>>
  <<regmac-make-test>>
  <<regmac-make-save-restore>>
  <<regmac-other-instructions>>

  (define test-machine
    (make-machine
     '(n val continue)
     (list (list '= =) (list '< <) (list '- -) (list '+ +))
     (quote
<<regmac-controller-fibonacci-512>>)))

  (set-register-contents! test-machine 'n 10)
  (start test-machine)
  (display (get-register-contents test-machine 'val))
#+end_src

#+RESULTS[337b71c41f05fe5de58272fe49d04988d29a772b]:
#+begin_src shell
55
#+end_src

#+name: regmac-controller-fibonacci-improved-a
#+begin_src scheme :exports code :results none
(controller
   (assign continue (label fib-done))
fib-loop
   (test (op <) (reg n) (const 2))
   (branch (label immediate-answer))
   (save continue)
   (assign continue (label afterfib-n-1))
   (save n)
   (assign n (op -) (reg n) (const 1))
   (goto (label fib-loop))
afterfib-n-1
   (restore n)
   (restore continue)
   (assign n (op -) (reg n) (const 2))
   (save continue)
   (assign continue (label afterfib-n-2))
   (save val)
   (goto (label fib-loop))
afterfib-n-2
   (restore n)
   (restore continue)
   (assign val (op +) (reg val) (reg n))
   (goto (reg continue))
immediate-answer
   (assign val (reg n))
   (goto (reg continue))
fib-done)
#+end_src

#+header: :stdin empty
#+begin_src shell :shebang "#! /usr/bin/chibi-scheme" :exports both :results output scalar code
  <<regmac-glue1>>
  <<regmac-make-machine>>
  <<regmac-make-register>>
  <<regmac-make-stack>>
  <<regmac-make-new-machine>>
  <<regmac-extract-labels-improved>>
  <<regmac-assembler>>
  <<regmac-generating-execution-procedures>>
  <<regmac-make-operation-exp-improved>>
  <<regmac-make-operation-exp-syntax>>
  <<regmac-make-assign>>
  <<regmac-make-test>>
  <<regmac-make-save-restore>>
  <<regmac-other-instructions>>

  (define test-machine
    (make-machine
     '(n val continue)
     (list (list '= =) (list '< <) (list '- -) (list '+ +))
     (quote
<<regmac-controller-fibonacci-improved-a>>)))

  (set-register-contents! test-machine 'n 10)
  (start test-machine)
  (display (get-register-contents test-machine 'val))
#+end_src

#+RESULTS[5ba5937b446ec06cc2c86c7472bdb49f3ac5f87c]:
#+begin_src shell
55
#+end_src

Works.

***** b Strict stack control

To enforce variable control on the stack, we have to add variable
checking to ~(save)~ and ~(restore)~.

#+name: regmac-make-save-restore-regcheck
#+begin_src scheme :exports code  :results none
  (define (make-save inst machine stack pc)
    (let ((reg (get-register machine
			     (stack-inst-reg-name inst))))
      (lambda ()
	(push stack (list reg (get-contents reg)))
	(advance-pc pc))))
  (define (make-restore inst machine stack pc)
    (let ((reg (get-register machine
			     (stack-inst-reg-name inst))))
      (lambda ()
	(let ((reg-pair (pop stack)))
          (if (not (eq? reg (car reg-pair)))
             (error "make-restore: restoring register values into different register is forbidden" reg (car reg-pair)))
          (set-contents! reg (cadr reg-pair))
	  (advance-pc pc)))))
#+end_src


With the variable control, the following code should fail.

#+header: :stdin empty
#+begin_src shell :shebang "#! /usr/bin/chibi-scheme" :exports both :results output scalar code
  <<regmac-glue1>>
  <<regmac-make-machine>>
  <<regmac-make-register>>
  <<regmac-make-stack>>
  <<regmac-make-new-machine>>
  <<regmac-extract-labels-improved>>
  <<regmac-assembler>>
  <<regmac-generating-execution-procedures>>
  <<regmac-make-operation-exp-improved>>
  <<regmac-make-operation-exp-syntax>>
  <<regmac-make-assign>>
  <<regmac-make-test>>
  <<regmac-make-save-restore-regcheck>>
  <<regmac-other-instructions>>

  (define test-machine
    (make-machine
     '(n val continue)
     (list (list '= =) (list '< <) (list '- -) (list '+ +))
     (quote
<<regmac-controller-fibonacci-improved-a>>)))

  (set-register-contents! test-machine 'n 10)
  (start test-machine)
  (display (get-register-contents test-machine 'val))
#+end_src

#+RESULTS[9c916f832c3d2e597f0289c8a91226d0b038209a]:
#+begin_src shell
ERROR: make-restore: restoring register values into different register is forbidden
    #<procedure dispatch>
    #<procedure dispatch>
  called from <anonymous> on line 282 of file /tmp/babel-NNNv58/sh-script-n72UZ2
  called from <anonymous> on line 78 of file /tmp/babel-NNNv58/sh-script-n72UZ2
  called from <anonymous> on line 1289 of file /usr/lib64/chibi/init-7.scm
  called from <anonymous> on line 280 of file /usr/lib64/chibi/init-7.scm
  called from <anonymous> on line 817 of file /usr/lib64/chibi/init-7.scm
#+end_src

But the old one should still work.

#+header: :stdin empty
#+begin_src shell :shebang "#! /usr/bin/chibi-scheme" :exports both :results output scalar code
  <<regmac-glue1>>
  <<regmac-make-machine>>
  <<regmac-make-register>>
  <<regmac-make-stack>>
  <<regmac-make-new-machine>>
  <<regmac-extract-labels-improved>>
  <<regmac-assembler>>
  <<regmac-generating-execution-procedures>>
  <<regmac-make-operation-exp-improved>>
  <<regmac-make-operation-exp-syntax>>
  <<regmac-make-assign>>
  <<regmac-make-test>>
  <<regmac-make-save-restore-regcheck>>
  <<regmac-other-instructions>>

  (define test-machine
    (make-machine
     '(n val continue)
     (list (list '= =) (list '< <) (list '- -) (list '+ +))
     (quote
<<regmac-controller-fibonacci-512>>)))

  (set-register-contents! test-machine 'n 10)
  (start test-machine)
  (display (get-register-contents test-machine 'val))
#+end_src

#+RESULTS[452234ec7888f6a6230f2b52b1af62bc81bf7218]:
#+begin_src shell
55
#+end_src

As expected.

***** c Different stacks

#+name: regmac-make-stack-multistack
#+begin_src scheme :exports code :results none
  (define (make-stack)
    (let ((s '()))
      (define (push reg x)
             (let ((regstack (assoc reg s)))
                (unless regstack
                   (set! s (cons (cons reg '()) s))
                   (set! regstack (assoc reg s)))
                (set-cdr! regstack (cons x (cdr regstack)))))
      (define (pop reg)
	(let ((regstack (assoc reg s)))
          (unless regstack
              (error "POP: no values saved for this register" reg))
          (if (null? (cdr regstack))
	    (error "Empty stack: POP" reg)
	    (let ((top (car (cdr regstack))))
	      (set-cdr! regstack (cdr (cdr regstack)))
	      top))))
      (define (initialize) ; I didn't change initialize, because it is embedded into push
	(set! s '())
	'done)
      (define (dispatch message)
	(cond ((eq? message 'push) push)
	      ((eq? message 'pop) pop)
	      ((eq? message 'initialize) (initialize))
	      (else (error "Unknown request: STACK" message))))
      (initialize)
      dispatch))
  (define (pop stack reg) ((stack 'pop) reg))
  (define (push stack reg value) ((stack 'push) reg value))
#+end_src

#+name: regmac-make-save-restore-multistack
#+begin_src scheme :exports code :results none
  (define (make-save inst machine stack pc)
    (let ((reg (get-register machine
			     (stack-inst-reg-name inst)))
          (reg-name (stack-inst-reg-name inst)))
      (lambda ()
	(push stack reg-name (get-contents reg))
	(advance-pc pc))))
  (define (make-restore inst machine stack pc)
    (let ((reg (get-register machine
			     (stack-inst-reg-name inst)))
          (reg-name (stack-inst-reg-name inst)))
      (lambda ()
	(set-contents! reg (pop stack reg-name))
	(advance-pc pc))))
#+end_src


The test for this behaviour would be:

#+header: :stdin empty
#+begin_src shell :shebang "#! /usr/bin/chibi-scheme" :exports both :results output scalar code
  <<regmac-glue1>>
  <<regmac-make-machine>>
  <<regmac-make-register>>
  <<regmac-make-stack-multistack>>
  <<regmac-make-new-machine>>
  <<regmac-extract-labels-improved>>
  <<regmac-assembler>>
  <<regmac-generating-execution-procedures>>
  <<regmac-make-operation-exp-improved>>
  <<regmac-make-operation-exp-syntax>>
  <<regmac-make-assign>>
  <<regmac-make-test>>
  <<regmac-make-save-restore-multistack>>
  <<regmac-other-instructions>>

  (define test-machine
    (make-machine
     '(a b)
     (list (list '= =) (list '< <) (list '- -) (list '+ +))
     (quote
         (controller
            (assign a (const 1))
            (assign b (const 2))
            (save a)
            (save b)
            (assign a (const 3))
            (restore a)))))

  (start test-machine)
  (display (get-register-contents test-machine 'a))
#+end_src

#+RESULTS[2fc273cb91cdf7ed68ac940b0229e7a765fc5e0d]:
#+begin_src shell
1
#+end_src

The Fibonacci machine should still work.

#+header: :stdin empty
#+begin_src shell :shebang "#! /usr/bin/chibi-scheme" :exports both :results output scalar code
  <<regmac-glue1>>
  <<regmac-make-machine>>
  <<regmac-make-register>>
  <<regmac-make-stack-multistack>>
  <<regmac-make-new-machine>>
  <<regmac-extract-labels-improved>>
  <<regmac-assembler>>
  <<regmac-generating-execution-procedures>>
  <<regmac-make-operation-exp-improved>>
  <<regmac-make-operation-exp-syntax>>
  <<regmac-make-assign>>
  <<regmac-make-test>>
  <<regmac-make-save-restore-multistack>>
  <<regmac-other-instructions>>

  (define test-machine
    (make-machine
     '(n val continue)
     (list (list '= =) (list '< <) (list '- -) (list '+ +))
     (quote
<<regmac-controller-fibonacci-512>>)))

  (set-register-contents! test-machine 'n 10)
  (start test-machine)
  (display (get-register-contents test-machine 'val))
#+end_src

#+RESULTS[6aa9d94b3a9f0435f55f2096d1abad6ad7d332d2]:
#+begin_src shell
55
#+end_src

Works.

**** DONE Exercise 5.12 Data paths from controller
     CLOSED: [2020-02-26 Wed 23:40]
Extend the assembler to store:


#+name: regmac-assembler-with-metadata
#+begin_src scheme :exports code :results none
  (define (goto-inst? inst) (tagged-list? (instruction-text inst) 'goto))
  (define (save-inst? inst) (tagged-list? (instruction-text inst) 'save))
  (define (restore-inst? inst) (tagged-list? (instruction-text inst) 'restore))
  (define (assign-inst? inst) (tagged-list? (instruction-text inst) 'assign))


  (define (instruction-text-type inst) (car (instruction-text inst)))

  (define (assemble controller-text machine)
    (extract-labels
     controller-text
     (lambda (insts labels)
       (let ((meta-instructions (delete-duplicates (map instruction-text-type insts)))
             (meta-entry-registers (delete-duplicates (append-map
				    (lambda (inst)
				      (if (and (goto-inst? inst)
					       (register-exp? (goto-dest (instruction-text inst))))
					  (list (register-exp-reg (goto-dest (instruction-text inst))))
					  '())) insts)))
             (meta-stack-registers (delete-duplicates (append-map
				    (lambda (inst)
				      (if (or (save-inst? inst)
					      (restore-inst? inst))
					  (list (cadr (instruction-text inst)))
					  '())) insts)))
             (meta-datapaths (let* ((todo (append-map
			     (lambda (inst)
			       (if (assign-inst? inst)
				   (list (cons (cadr (instruction-text inst)) (cddr (instruction-text inst))))
				   '())) insts))
                       (s '()))
                      (for-each
                         (lambda (sspair)
                             (let ((reg (assoc (car sspair) s)))
                                (if reg
                                    (set-cdr! reg (lset-adjoin equal? (cdr reg) (cdr sspair)))
                                    (set! s (cons (cons (car sspair) (list (cdr sspair))) s)))))
                         todo) s)))
       ((machine 'set-metadata!) (make-metadata
                                      (list 'instructions meta-instructions)
                                      (list 'entry-points meta-entry-registers)
                                      (list 'stack-registers meta-stack-registers)
                                      (list 'datapaths meta-datapaths)))
       (update-insts! insts labels machine))
       insts)))
  (define make-metadata list)

  (define (update-insts! insts labels machine)
    (let ((pc (get-register machine 'pc))
	  (flag (get-register machine 'flag))
	  (stack (machine 'stack))
	  (ops (machine 'operations)))
      (for-each
       (lambda (inst)
	 (set-instruction-execution-proc!
	  inst
	  (make-execution-procedure
	   (instruction-text inst)
	   labels machine pc flag stack ops)))
       insts)))
  (define (make-instruction text) (cons text '()))
  (define (instruction-text inst) (car inst))
  (define (instruction-execution-proc inst) (cdr inst))
  (define (set-instruction-execution-proc! inst proc)
    (set-cdr! inst proc))
  (define (make-label-entry label-name insts)
    (cons label-name insts))
  (define (lookup-label labels label-name)
    (let ((val (assoc label-name labels)))
      (if val
	  (cdr val)
	  (error "Undefined label: ASSEMBLE"
		 label-name))))
#+end_src

#+name: regmac-make-new-machine-with-metadata
#+begin_src scheme :exports code :results none
  (define (make-new-machine)
    (let ((pc (make-register 'pc))
	  (flag (make-register 'flag))
	  (stack (make-stack))
	  (the-instruction-sequence '())
	  (metadata '()))
      (let ((the-ops
	     (list (list 'initialize-stack
			 (lambda () (stack 'initialize)))
		   (list 'print-stack-statistics
			 (lambda () (stack 'print-statistics)))))

	    (register-table
	     (list (list 'pc pc) (list 'flag flag))))
	(define (allocate-register name)
	  (if (assoc name register-table)
	      (error "Multiply defined register: " name)
	      (set! register-table
		(cons (list name (make-register name))
		      register-table)))
	  'register-allocated)
	(define (lookup-register name)
	  (let ((val (assoc name register-table)))
	    (if val
		(cadr val)
		(error "Unknown register:" name))))
	(define (execute)
	  (let ((insts (get-contents pc)))
	    (if (null? insts)
		'done
		(begin
		  ((instruction-execution-proc (car insts)))
		  (execute)))))
	(define (dispatch message)
	  (cond ((eq? message 'start)
		 (set-contents! pc the-instruction-sequence)
		 (execute))
		((eq? message 'install-instruction-sequence)
		 (lambda (seq)
		   (set! the-instruction-sequence seq)))
		((eq? message 'allocate-register)
		 allocate-register)
		((eq? message 'get-register)
		 lookup-register)
		((eq? message 'install-operations)
		 (lambda (ops)
		   (set! the-ops (append the-ops ops))))
		((eq? message 'stack) stack)
		((eq? message 'operations) the-ops)
		((eq? message 'set-metadata!) (lambda (new-metadata) (set! metadata new-metadata)))
		((eq? message 'get-metadata) metadata)
		(else (error "Unknown request: MACHINE"
			     message))))
	dispatch)))
  (define (start machine) (machine 'start))
  (define (get-register-contents machine register-name)
    (get-contents (get-register machine register-name)))
  (define (set-register-contents! machine register-name value)
    (set-contents! (get-register machine register-name)
		   value)
    'done)

  (define (get-register machine reg-name)
    ((machine 'get-register) reg-name))
  (define (advance-pc pc)
    (set-contents! pc (cdr (get-contents pc))))

#+end_src


#+header: :stdin empty
#+begin_src shell :shebang "#! /usr/bin/chibi-scheme" :exports both :results output scalar code
  <<regmac-glue1>>
  <<regmac-make-machine>>
  <<regmac-make-register>>
  <<regmac-make-stack>>
  <<regmac-make-new-machine-with-metadata>>
  <<regmac-extract-labels-improved>>
  <<regmac-assembler-with-metadata>>
  <<regmac-generating-execution-procedures>>
  <<regmac-make-operation-exp-improved>>
  <<regmac-make-operation-exp-syntax>>
  <<regmac-make-assign>>
  <<regmac-make-test>>
  <<regmac-make-save-restore>>
  <<regmac-other-instructions>>

  (define test-machine
    (make-machine
     '(a b c)
     (list (list '= =))
     (quote (start
         (goto (label here))
         (save a)
       here
         (assign a (const 3))
         (goto (label there))
       here2
         (assign a (const 4))
         (assign a (label there))
         (assign b (const 1))
         (assign b (op =) (const 2) (const 1))
         (assign b (const 3))
         (goto (label there))
         (goto (reg a))
       there))))

  (set-register-contents! test-machine 'a -1)
  (start test-machine)
  (display "(reg a) has ")
  (display (get-register-contents test-machine 'a))
  (newline)
  (display "metadata=")
  (map (lambda (x) (newline) (display x)) (test-machine 'get-metadata))
  (newline)
#+end_src

#+RESULTS[f8ad63cf59609082beedb53ecebef952558242bc]:
#+begin_src shell
(reg a) has 3
metadata=
(instructions (goto save assign))
(entry-points (a))
(stack-registers (a))
(datapaths ((b ((const 3)) ((op =) (const 2) (const 1)) ((const 1))) (a ((label there)) ((const 4)) ((const 3)))))
#+end_src

Seems to be working.

#+header: :stdin empty
#+begin_src shell :shebang "#! /usr/bin/chibi-scheme" :exports both :results output scalar code
  <<regmac-glue1>>
  <<regmac-make-machine>>
  <<regmac-make-register>>
  <<regmac-make-stack>>
  <<regmac-make-new-machine-with-metadata>>
  <<regmac-extract-labels-improved>>
  <<regmac-assembler-with-metadata>>
  <<regmac-generating-execution-procedures>>
  <<regmac-make-operation-exp-improved>>
  <<regmac-make-operation-exp-syntax>>
  <<regmac-make-assign>>
  <<regmac-make-test>>
  <<regmac-make-save-restore>>
  <<regmac-other-instructions>>

  (define test-machine
    (make-machine
     '(n val continue)
     (list (list '= =) (list '< <) (list '- -) (list '+ +))
     (quote
<<regmac-controller-fibonacci-512>>)))


  (set-register-contents! test-machine 'n 10)
  (start test-machine)
  (display "(reg val) has ")
  (display (get-register-contents test-machine 'val))
  (newline)
  (display "metadata=")
  (map (lambda (x) (newline) (show #t (pretty x))) (test-machine 'get-metadata))
  (newline)
#+end_src

#+RESULTS[7fed31a20dc42d7aede353c9b512c899615cc187]:
#+begin_src shell
(reg val) has 55
metadata=
(instructions (assign test branch save goto restore))

(entry-points (continue))

(stack-registers (continue n val))

(datapaths
 ((val ((reg n)) ((op +) (reg val) (reg n)))
  (n ((reg val)) ((op -) (reg n) (const 2)) ((op -) (reg n) (const 1)))
  (continue ((label afterfib-n-2)) ((label afterfib-n-1)) ((label fib-done)))))

#+end_src

**** DONE Exercise 5.13 Registers from controller
     CLOSED: [2020-02-27 Thu 10:57]

#+name: regmac-assembler-with-metadata-and-register-allocation
#+begin_src scheme :exports code :results none
  (define (goto-inst? inst) (tagged-list? (instruction-text inst) 'goto))
  (define (save-inst? inst) (tagged-list? (instruction-text inst) 'save))
  (define (restore-inst? inst) (tagged-list? (instruction-text inst) 'restore))
  (define (assign-inst? inst) (tagged-list? (instruction-text inst) 'assign))


  (define (instruction-text-type inst) (car (instruction-text inst)))

  (define (extract-reg source)
    (append-map (lambda (sexp) (if (tagged-list? sexp 'reg)
			      (list (cadr sexp))
			      '())) source))
  (define (extract-registers text)
;    (display "extract-registers:text=") (display text) (newline)
    (delete-duplicates
     (append-map
      (lambda (sexp)
;        (display "extract-registers:sexp=") (display sexp) (newline)
	(cond ((symbol? sexp) '())
              ((tagged-list? sexp 'assign)
	            (cons (cadr sexp) (extract-reg (cddr sexp))))
              ((tagged-list? sexp 'save) (cdr sexp))
              ((tagged-list? sexp 'restore) (cdr sexp))
              (else (extract-reg (cdr sexp)))))
      text)))


  (define (assemble controller-text machine)
    (let ((allregs (extract-registers controller-text)))
     (for-each
       (lambda (reg) ((machine 'allocate-register) reg))
       allregs))
    (extract-labels
     controller-text
     (lambda (insts labels)
       (let* ((meta-instructions (delete-duplicates (map instruction-text-type insts)))
	      (meta-entry-registers (delete-duplicates (append-map
							(lambda (inst)
							  (if (and (goto-inst? inst)
								   (register-exp? (goto-dest (instruction-text inst))))
							      (list (register-exp-reg (goto-dest (instruction-text inst))))
							      '())) insts)))
	      (meta-stack-registers (delete-duplicates (append-map
							(lambda (inst)
							  (if (or (save-inst? inst)
								  (restore-inst? inst))
							      (list (cadr (instruction-text inst)))
							      '())) insts)))
	      (meta-datapaths (let* ((todo (append-map
					    (lambda (inst)
					      (if (assign-inst? inst)
						  (list (cons (cadr (instruction-text inst)) (cddr (instruction-text inst))))
						  '())) insts))
				     (s '()))
				(for-each
				 (lambda (sspair)
				   (let ((reg (assoc (car sspair) s)))
				     (if reg
					 (set-cdr! reg (lset-adjoin equal? (cdr reg) (cdr sspair)))
					 (set! s (cons (cons (car sspair) (list (cdr sspair))) s)))))
				 todo) s)))
	 ((machine 'set-metadata!) (make-metadata
				    (list 'instructions meta-instructions)
				    (list 'entry-points meta-entry-registers)
				    (list 'stack-registers meta-stack-registers)
				    (list 'datapaths meta-datapaths)))
	 (update-insts! insts labels machine))
       insts)))
  (define make-metadata list)

  (define (update-insts! insts labels machine)
    (let ((pc (get-register machine 'pc))
	  (flag (get-register machine 'flag))
	  (stack (machine 'stack))
	  (ops (machine 'operations)))
      (for-each
       (lambda (inst)
	 (set-instruction-execution-proc!
	  inst
	  (make-execution-procedure
	   (instruction-text inst)
	   labels machine pc flag stack ops)))
       insts)))
  (define (make-instruction text) (cons text '()))
  (define (instruction-text inst) (car inst))
  (define (instruction-execution-proc inst) (cdr inst))
  (define (set-instruction-execution-proc! inst proc)
    (set-cdr! inst proc))
  (define (make-label-entry label-name insts)
    (cons label-name insts))
  (define (lookup-label labels label-name)
    (let ((val (assoc label-name labels)))
      (if val
	  (cdr val)
	  (error "Undefined label: ASSEMBLE"
		 label-name))))
#+end_src


#+header: :stdin empty
#+begin_src shell :shebang "#! /usr/bin/chibi-scheme" :exports both :results output scalar code
  <<regmac-glue1>>
  <<regmac-make-machine>>
  <<regmac-make-register>>
  <<regmac-make-stack>>
  <<regmac-make-new-machine-with-metadata>>
  <<regmac-extract-labels-improved>>
  <<regmac-assembler-with-metadata-and-register-allocation>>
  <<regmac-generating-execution-procedures>>
  <<regmac-make-operation-exp-improved>>
  <<regmac-make-operation-exp-syntax>>
  <<regmac-make-assign>>
  <<regmac-make-test>>
  <<regmac-make-save-restore>>
  <<regmac-other-instructions>>

  (define test-machine
    (make-machine
     '()
     (list (list '= =))
     (quote (start
         (goto (label here))
         (save a)
       here
         (assign a (const 3))
         (goto (label there))
       here2
         (assign a (const 4))
         (assign a (label there))
         (assign b (const 1))
         (assign b (op =) (const 2) (const 1))
         (assign b (const 3))
         (goto (label there))
         (goto (reg a))
       there))))

  (set-register-contents! test-machine 'a -1)
  (start test-machine)
  (display "(reg a) has ")
  (display (get-register-contents test-machine 'a))
  (newline)
  (display "metadata=")
  (map (lambda (x) (newline) (display x)) (test-machine 'get-metadata))
  (newline)
#+end_src

#+RESULTS[3829130c54f4c7850d14937fa71ee942bb90ebe5]:
#+begin_src shell
(reg a) has 3
metadata=
(instructions (goto save assign))
(entry-points (a))
(stack-registers (a))
(datapaths ((b ((const 3)) ((op =) (const 2) (const 1)) ((const 1))) (a ((label there)) ((const 4)) ((const 3)))))
#+end_src


#+header: :stdin empty
#+begin_src shell :shebang "#! /usr/bin/chibi-scheme" :exports both :results output scalar code
  <<regmac-glue1>>
  <<regmac-make-machine>>
  <<regmac-make-register>>
  <<regmac-make-stack>>
  <<regmac-make-new-machine-with-metadata>>
  <<regmac-extract-labels-improved>>
  <<regmac-assembler-with-metadata-and-register-allocation>>
  <<regmac-generating-execution-procedures>>
  <<regmac-make-operation-exp-improved>>
  <<regmac-make-operation-exp-syntax>>
  <<regmac-make-assign>>
  <<regmac-make-test>>
  <<regmac-make-save-restore>>
  <<regmac-other-instructions>>

  (define test-machine
    (make-machine
     '()
     (list (list '= =) (list '< <) (list '- -) (list '+ +))
     (quote
<<regmac-controller-fibonacci-512>>)))


  (set-register-contents! test-machine 'n 10)
  (display "metadata=")
  (map (lambda (x) (newline) (show #t (pretty x))) (test-machine 'get-metadata))
  (newline)
  (start test-machine)
  (display "(reg val) has ")
  (display (get-register-contents test-machine 'val))
  (newline)
#+end_src

#+RESULTS[7fc0d20ef0e8b9d3d569e47ac4099b8b9818eae7]:
#+begin_src shell
metadata=
(instructions (assign test branch save goto restore))

(entry-points (continue))

(stack-registers (continue n val))

(datapaths
 ((val ((reg n)) ((op +) (reg val) (reg n)))
  (n ((reg val)) ((op -) (reg n) (const 2)) ((op -) (reg n) (const 1)))
  (continue ((label afterfib-n-2)) ((label afterfib-n-1)) ((label fib-done)))))

(reg val) has 55
#+end_src

Seems to be working. I am keeping the interface with the empty first
argument just in case.

**** DONE Exercise 5.14 Profiling
     CLOSED: [2020-02-28 Fri 20:21]

Let us define the factorial machine first:

#+name: regmac-controller-factorial-511
#+begin_src scheme :exports code :results none
  (controller
   (assign continue (label fact-done)) ;set up final return address
   fact-loop
   (test (op =) (reg n) (const 1))
   (branch (label base-case))
   ;; Set up for the recursive call by saving n and continue.
   ;; Set up continue so that the computation will continue
   ;; at after-fact when the subroutine returns.
   (save continue)
   (save n)
   (assign n (op -) (reg n) (const 1))
   (assign continue (label after-fact))
   (goto (label fact-loop))
   after-fact
   (restore n)
   (restore continue)
   (assign val (op *) (reg n) (reg val)) ;val now contains n(n - 1)!
   (goto (reg continue)) ;return to caller
   base-case
   (assign val (const 1)) ;base case: 1! = 1
   (goto (reg continue))  ;return to caller
   fact-done)
#+end_src

Let us test the simulator on the unmodified machine.

#+header: :stdin empty
#+begin_src shell :shebang "#! /usr/bin/chibi-scheme" :exports both :results output scalar code
  <<regmac-glue1>>
  <<regmac-make-machine>>
  <<regmac-make-register>>
  <<regmac-make-stack-with-performance>>
  <<regmac-make-new-machine-with-metadata>>
  <<regmac-extract-labels-improved>>
  <<regmac-assembler-with-metadata-and-register-allocation>>
  <<regmac-generating-execution-procedures>>
  <<regmac-make-operation-exp-improved>>
  <<regmac-make-operation-exp-syntax>>
  <<regmac-make-assign>>
  <<regmac-make-test>>
  <<regmac-make-save-restore>>
  <<regmac-other-instructions>>

  (define test-machine
    (make-machine
     '()
     (list (list '= =) (list '< <) (list '- -) (list '+ +) (list '* *))
     (quote
<<regmac-controller-factorial-511>>)))

  (set-register-contents! test-machine 'n 10)
  (display "metadata=\n")
  (map (lambda (x)  (show #t "  "(pretty  x))) (test-machine 'get-metadata))
  (start test-machine)
  (display "(reg val) has ")
  (show #t (pretty (get-register-contents test-machine 'val)))
#+end_src

#+RESULTS:
: metadata=
:   (instructions (assign test branch save goto restore))
:   (entry-points (continue))
:   (stack-registers (continue n))
:   (datapaths
:    ((val ((const 1)) ((op *) (reg n) (reg val)))
:     (n ((op -) (reg n) (const 1)))
:     (continue ((label after-fact)) ((label fact-done)))))
: (reg val) has 3628800



#+header: :stdin empty
#+begin_src shell :shebang "#! /usr/bin/chibi-scheme" :exports both :results output scalar code
  <<regmac-glue1>>
  <<regmac-make-machine>>
  <<regmac-make-register>>
  <<regmac-make-stack-with-performance>>
  <<regmac-make-new-machine-with-metadata>>
  <<regmac-extract-labels-improved>>
  <<regmac-assembler-with-metadata-and-register-allocation>>
  <<regmac-generating-execution-procedures>>
  <<regmac-make-operation-exp-improved>>
  <<regmac-make-operation-exp-syntax>>
  <<regmac-make-assign>>
  <<regmac-make-test>>
  <<regmac-make-save-restore>>
  <<regmac-other-instructions>>

  (define test-machine
    (make-machine
     '()
     (list (list '= =) (list '< <) (list '- -) (list '+ +) (list '* *)
           (list 'null? null?) (list 'print display)
           (list 'newdata (let ((argin '(2 4 6 8 10 12 -1)))
                                  (lambda () (let ((retval (car argin)))
                                       (set! argin (cdr argin))
                                       retval)))))
     (quote
(controller
   meta-start
   (assign n (op newdata))
   (test (op =) (reg n) (const -1))
   (branch (label final-end))
   (perform (op print) (const "\nn="))
   (perform (op print) (reg n))
   (perform (op initialize-stack))
   (perform (op print-stack-statistics))
   (assign continue (label fact-done)) ;set up final return address
   fact-loop
   (test (op =) (reg n) (const 1))
   (branch (label base-case))
   ;; Set up for the recursive call by saving n and continue.
   ;; Set up continue so that the computation will continue
   ;; at after-fact when the subroutine returns.
   (save continue)
   (save n)
   (assign n (op -) (reg n) (const 1))
   (assign continue (label after-fact))
   (goto (label fact-loop))
   after-fact
   (restore n)
   (restore continue)
   (assign val (op *) (reg n) (reg val)) ;val now contains n(n - 1)!
   (goto (reg continue)) ;return to caller
   base-case
   (assign val (const 1)) ;base case: 1! = 1
   (goto (reg continue))  ;return to caller
   fact-done
   (perform (op print-stack-statistics))
   (perform (op print) (const "\nreg val has "))
   (perform (op print) (reg val))
   (goto (label meta-start))
   final-end
)
)))

  (set-register-contents! test-machine 'n 10)
  (display "metadata=\n")
  (map (lambda (x)  (show #t "  "(pretty  x))) (test-machine 'get-metadata))
  (start test-machine)
#+end_src

#+RESULTS[78301c633cd7522343b97b6ae7c8eeac828f3374]:
#+begin_src shell
metadata=
  (instructions (assign test branch perform save goto restore))
  (entry-points (continue))
  (stack-registers (continue n))
  (datapaths
   ((val ((const 1)) ((op *) (reg n) (reg val)))
    (continue ((label after-fact)) ((label fact-done)))
    (n ((op -) (reg n) (const 1)) ((op newdata)))))

n=2
(total-pushes = 0 maximum-depth = 0)
(total-pushes = 2 maximum-depth = 2)
reg val has 2
n=4
(total-pushes = 0 maximum-depth = 0)
(total-pushes = 6 maximum-depth = 6)
reg val has 24
n=6
(total-pushes = 0 maximum-depth = 0)
(total-pushes = 10 maximum-depth = 10)
reg val has 720
n=8
(total-pushes = 0 maximum-depth = 0)
(total-pushes = 14 maximum-depth = 14)
reg val has 40320
n=10
(total-pushes = 0 maximum-depth = 0)
(total-pushes = 18 maximum-depth = 18)
reg val has 3628800
n=12
(total-pushes = 0 maximum-depth = 0)
(total-pushes = 22 maximum-depth = 22)
reg val has 479001600
#+end_src

Works. Now let's rewrite the machine.

The linear function formula seems to be \(2n - 2\) for both the number
of pushes and stack depth.

**** DONE Exercise 5.15 Instruction counting
     CLOSED: [2020-02-28 Fri 21:36]

#+name: regmac-make-new-machine-with-metadata-instr-count
#+begin_src scheme :exports code :results none
  (define (make-new-machine)
    (let ((pc (make-register 'pc))
	  (flag (make-register 'flag))
	  (stack (make-stack))
	  (the-instruction-sequence '())
          (the-instruction-counter 0)
	  (metadata '()))
      (let ((the-ops
	     (list (list 'initialize-stack
			 (lambda () (stack 'initialize)))
		   (list 'print-stack-statistics
			 (lambda () (stack 'print-statistics)))
                   (list 'reset-instruction-counter
                         (lambda () (set! the-instruction-counter 0)))))

	    (register-table
	     (list (list 'pc pc) (list 'flag flag))))
	(define (allocate-register name)
	  (if (assoc name register-table)
	      (error "Multiply defined register: " name)
	      (set! register-table
		(cons (list name (make-register name))
		      register-table)))
	  'register-allocated)
	(define (lookup-register name)
	  (let ((val (assoc name register-table)))
	    (if val
		(cadr val)
		(error "Unknown register:" name))))
	(define (execute)
	  (let ((insts (get-contents pc)))
            (set! the-instruction-counter (+ the-instruction-counter 1))
	    (if (null? insts)
		'done
		(begin
		  ((instruction-execution-proc (car insts)))
		  (execute)))))
	(define (dispatch message)
	  (cond ((eq? message 'start)
		 (set-contents! pc the-instruction-sequence)
		 (execute))
		((eq? message 'install-instruction-sequence)
		 (lambda (seq)
		   (set! the-instruction-sequence seq)))
		((eq? message 'allocate-register)
		 allocate-register)
		((eq? message 'get-register)
		 lookup-register)
		((eq? message 'install-operations)
		 (lambda (ops)
		   (set! the-ops (append the-ops ops))))
		((eq? message 'stack) stack)
		((eq? message 'operations) the-ops)
		((eq? message 'set-metadata!) (lambda (new-metadata) (set! metadata new-metadata)))
		((eq? message 'get-metadata) metadata)
                ((eq? message 'get-instruction-count) the-instruction-counter)
                ((eq? message 'reset-instruction-count) (set! the-instruction-counter 0))
		(else (error "Unknown request: MACHINE"
			     message))))
	dispatch)))
  (define (start machine) (machine 'start))
  (define (get-register-contents machine register-name)
    (get-contents (get-register machine register-name)))
  (define (set-register-contents! machine register-name value)
    (set-contents! (get-register machine register-name)
		   value)
    'done)

  (define (get-register machine reg-name)
    ((machine 'get-register) reg-name))
  (define (advance-pc pc)
    (set-contents! pc (cdr (get-contents pc))))

#+end_src


#+header: :stdin empty
#+begin_src shell :shebang "#! /usr/bin/chibi-scheme" :exports both :results output scalar code
    <<regmac-glue1>>
    <<regmac-make-machine>>
    <<regmac-make-register>>
    <<regmac-make-stack-with-performance>>
    <<regmac-make-new-machine-with-metadata-instr-count>>
    <<regmac-extract-labels-improved>>
    <<regmac-assembler-with-metadata-and-register-allocation>>
    <<regmac-generating-execution-procedures>>
    <<regmac-make-operation-exp-improved>>
    <<regmac-make-operation-exp-syntax>>
    <<regmac-make-assign>>
    <<regmac-make-test>>
    <<regmac-make-save-restore>>
    <<regmac-other-instructions>>

    (define test-machine
      (make-machine
       '()
       (list (list '= =) (list '< <) (list '- -) (list '+ +) (list '* *)
	     (list 'null? null?) (list 'print display)
	     (list 'newdata (let ((argin '(2 4 6 8 10 12 -1)))
				    (lambda () (let ((retval (car argin)))
					 (set! argin (cdr argin))
					 retval)))))
       (quote
  (controller
     meta-start
     (assign n (op newdata))
     (test (op =) (reg n) (const -1))
     (branch (label final-end))
     (perform (op print) (const "\nn="))
     (perform (op print) (reg n))
     (perform (op initialize-stack))
     (perform (op print-stack-statistics))
     (assign continue (label fact-done)) ;set up final return address
     fact-loop
     (test (op =) (reg n) (const 1))
     (branch (label base-case))
     ;; Set up for the recursive call by saving n and continue.
     ;; Set up continue so that the computation will continue
     ;; at after-fact when the subroutine returns.
     (save continue)
     (save n)
     (assign n (op -) (reg n) (const 1))
     (assign continue (label after-fact))
     (goto (label fact-loop))
     after-fact
     (restore n)
     (restore continue)
     (assign val (op *) (reg n) (reg val)) ;val now contains n(n - 1)!
     (goto (reg continue)) ;return to caller
     base-case
     (assign val (const 1)) ;base case: 1! = 1
     (goto (reg continue))  ;return to caller
     fact-done
     (perform (op print-stack-statistics))
     (perform (op print) (const "\nreg val has "))
     (perform (op print) (reg val))
     (goto (label meta-start))
     final-end
  )
  )))

    (set-register-contents! test-machine 'n 10)
    (display "metadata=\n")
    (map (lambda (x)  (show #t "  "(pretty  x))) (test-machine 'get-metadata))
    (start test-machine)
    (show #t "\nInstructions executed: " (test-machine 'get-instruction-count))
#+end_src

#+RESULTS[51b8089cb14f6e507a7ca7ded803daf29112828f]:
#+begin_src shell
metadata=
  (instructions (assign test branch perform save goto restore))
  (entry-points (continue))
  (stack-registers (continue n))
  (datapaths
   ((val ((const 1)) ((op *) (reg n) (reg val)))
    (continue ((label after-fact)) ((label fact-done)))
    (n ((op -) (reg n) (const 1)) ((op newdata)))))

n=2
(total-pushes = 0 maximum-depth = 0)
(total-pushes = 2 maximum-depth = 2)
reg val has 2
n=4
(total-pushes = 0 maximum-depth = 0)
(total-pushes = 6 maximum-depth = 6)
reg val has 24
n=6
(total-pushes = 0 maximum-depth = 0)
(total-pushes = 10 maximum-depth = 10)
reg val has 720
n=8
(total-pushes = 0 maximum-depth = 0)
(total-pushes = 14 maximum-depth = 14)
reg val has 40320
n=10
(total-pushes = 0 maximum-depth = 0)
(total-pushes = 18 maximum-depth = 18)
reg val has 3628800
n=12
(total-pushes = 0 maximum-depth = 0)
(total-pushes = 22 maximum-depth = 22)
reg val has 479001600
Instructions executed: 496
#+end_src

**** DONE Exercise 5.16 Tracing execution
     CLOSED: [2020-02-28 Fri 22:59]

#+name: regmac-make-new-machine-with-metadata-instr-count-trace
#+begin_src scheme :exports code :results none
  (define (make-new-machine)
    (let ((pc (make-register 'pc))
	  (flag (make-register 'flag))
	  (stack (make-stack))
	  (the-instruction-sequence '())
          (the-instruction-counter 0)
          (tracing-flag #f)
	  (metadata '()))
      (let ((the-ops
	     (list (list 'initialize-stack
			 (lambda () (stack 'initialize)))
		   (list 'print-stack-statistics
			 (lambda () (stack 'print-statistics)))))

	    (register-table
	     (list (list 'pc pc) (list 'flag flag))))
	(define (allocate-register name)
	  (if (assoc name register-table)
	      (error "Multiply defined register: " name)
	      (set! register-table
		(cons (list name (make-register name))
		      register-table)))
	  'register-allocated)
	(define (lookup-register name)
	  (let ((val (assoc name register-table)))
	    (if val
		(cadr val)
		(error "Unknown register:" name))))
	(define (execute)
	  (let ((insts (get-contents pc)))
            (set! the-instruction-counter (+ the-instruction-counter 1))
	    (if (null? insts)
		'done
		(begin
                  (if tracing-flag
                     (begin
                        (display "\ninstruction: ")
                        (display (instruction-text (car insts)))))
		  ((instruction-execution-proc (car insts)))
		  (execute)))))
	(define (dispatch message)
	  (cond ((eq? message 'start)
		 (set-contents! pc the-instruction-sequence)
		 (execute))
		((eq? message 'install-instruction-sequence)
		 (lambda (seq)
		   (set! the-instruction-sequence seq)))
		((eq? message 'allocate-register)
		 allocate-register)
		((eq? message 'get-register)
		 lookup-register)
		((eq? message 'install-operations)
		 (lambda (ops)
		   (set! the-ops (append the-ops ops))))
		((eq? message 'stack) stack)
		((eq? message 'operations) the-ops)
		((eq? message 'set-metadata!) (lambda (new-metadata) (set! metadata new-metadata)))
		((eq? message 'get-metadata) metadata)
                ((eq? message 'get-instruction-count) the-instruction-counter)
                ((eq? message 'reset-instruction-count) (set! the-instruction-counter 0))
                ((eq? message 'trace-on) (set! tracing-flag #t))
                ((eq? message 'trace-off) (set! tracing-flag #f))
		(else (error "Unknown request: MACHINE"
			     message))))
	dispatch)))
  (define (start machine) (machine 'start))
  (define (get-register-contents machine register-name)
    (get-contents (get-register machine register-name)))
  (define (set-register-contents! machine register-name value)
    (set-contents! (get-register machine register-name)
		   value)
    'done)

  (define (get-register machine reg-name)
    ((machine 'get-register) reg-name))
  (define (advance-pc pc)
    (set-contents! pc (cdr (get-contents pc))))

#+end_src


#+header: :stdin empty
#+begin_src shell :shebang "#! /usr/bin/chibi-scheme" :exports both :results output scalar code
    <<regmac-glue1>>
    <<regmac-make-machine>>
    <<regmac-make-register>>
    <<regmac-make-stack-with-performance>>
    <<regmac-make-new-machine-with-metadata-instr-count-trace>>
    <<regmac-extract-labels-improved>>
    <<regmac-assembler-with-metadata-and-register-allocation>>
    <<regmac-generating-execution-procedures>>
    <<regmac-make-operation-exp-improved>>
    <<regmac-make-operation-exp-syntax>>
    <<regmac-make-assign>>
    <<regmac-make-test>>
    <<regmac-make-save-restore>>
    <<regmac-other-instructions>>

    (define test-machine
      (make-machine
       '()
       (list (list '= =) (list '< <) (list '- -) (list '+ +) (list '* *)
	     (list 'null? null?) (list 'print display)
	     (list 'newdata (let ((argin '(2 4 -1)))
				    (lambda () (let ((retval (car argin)))
					 (set! argin (cdr argin))
					 retval)))))
       (quote
  (controller
     meta-start
     (assign n (op newdata))
     (test (op =) (reg n) (const -1))
     (branch (label final-end))
     (perform (op print) (const "\nn="))
     (perform (op print) (reg n))
     (perform (op initialize-stack))
     (perform (op print-stack-statistics))
     (assign continue (label fact-done)) ;set up final return address
     fact-loop
     (test (op =) (reg n) (const 1))
     (branch (label base-case))
     ;; Set up for the recursive call by saving n and continue.
     ;; Set up continue so that the computation will continue
     ;; at after-fact when the subroutine returns.
     (save continue)
     (save n)
     (assign n (op -) (reg n) (const 1))
     (assign continue (label after-fact))
     (goto (label fact-loop))
     after-fact
     (restore n)
     (restore continue)
     (assign val (op *) (reg n) (reg val)) ;val now contains n(n - 1)!
     (goto (reg continue)) ;return to caller
     base-case
     (assign val (const 1)) ;base case: 1! = 1
     (goto (reg continue))  ;return to caller
     fact-done
     (perform (op print-stack-statistics))
     (perform (op print) (const "\nreg val has "))
     (perform (op print) (reg val))
     (goto (label meta-start))
     final-end
  )
  )))

    (set-register-contents! test-machine 'n 10)
    (display "metadata=\n")
    (map (lambda (x)  (show #t "  "(pretty  x))) (test-machine 'get-metadata))
    (test-machine 'trace-on)
    (start test-machine)
    (test-machine 'trace-off)
    (show #t "\nInstructions executed: " (test-machine 'get-instruction-count))
#+end_src

#+RESULTS[b3a6b7e78190b0c681d15e4de8e895204e8d7115]:
#+begin_src shell
metadata=
  (instructions (assign test branch perform save goto restore))
  (entry-points (continue))
  (stack-registers (continue n))
  (datapaths
   ((val ((const 1)) ((op *) (reg n) (reg val)))
    (continue ((label after-fact)) ((label fact-done)))
    (n ((op -) (reg n) (const 1)) ((op newdata)))))

instruction: (assign n (op newdata))
instruction: (test (op =) (reg n) (const -1))
instruction: (branch (label final-end))
instruction: (perform (op print) (const "\nn="))
n=
instruction: (perform (op print) (reg n))2
instruction: (perform (op initialize-stack))
instruction: (perform (op print-stack-statistics))
(total-pushes = 0 maximum-depth = 0)
instruction: (assign continue (label fact-done))
instruction: (test (op =) (reg n) (const 1))
instruction: (branch (label base-case))
instruction: (save continue)
instruction: (save n)
instruction: (assign n (op -) (reg n) (const 1))
instruction: (assign continue (label after-fact))
instruction: (goto (label fact-loop))
instruction: (test (op =) (reg n) (const 1))
instruction: (branch (label base-case))
instruction: (assign val (const 1))
instruction: (goto (reg continue))
instruction: (restore n)
instruction: (restore continue)
instruction: (assign val (op *) (reg n) (reg val))
instruction: (goto (reg continue))
instruction: (perform (op print-stack-statistics))
(total-pushes = 2 maximum-depth = 2)
instruction: (perform (op print) (const "\nreg val has "))
reg val has 
instruction: (perform (op print) (reg val))2
instruction: (goto (label meta-start))
instruction: (assign n (op newdata))
instruction: (test (op =) (reg n) (const -1))
instruction: (branch (label final-end))
instruction: (perform (op print) (const "\nn="))
n=
instruction: (perform (op print) (reg n))4
instruction: (perform (op initialize-stack))
instruction: (perform (op print-stack-statistics))
(total-pushes = 0 maximum-depth = 0)
instruction: (assign continue (label fact-done))
instruction: (test (op =) (reg n) (const 1))
instruction: (branch (label base-case))
instruction: (save continue)
instruction: (save n)
instruction: (assign n (op -) (reg n) (const 1))
instruction: (assign continue (label after-fact))
instruction: (goto (label fact-loop))
instruction: (test (op =) (reg n) (const 1))
instruction: (branch (label base-case))
instruction: (save continue)
instruction: (save n)
instruction: (assign n (op -) (reg n) (const 1))
instruction: (assign continue (label after-fact))
instruction: (goto (label fact-loop))
instruction: (test (op =) (reg n) (const 1))
instruction: (branch (label base-case))
instruction: (save continue)
instruction: (save n)
instruction: (assign n (op -) (reg n) (const 1))
instruction: (assign continue (label after-fact))
instruction: (goto (label fact-loop))
instruction: (test (op =) (reg n) (const 1))
instruction: (branch (label base-case))
instruction: (assign val (const 1))
instruction: (goto (reg continue))
instruction: (restore n)
instruction: (restore continue)
instruction: (assign val (op *) (reg n) (reg val))
instruction: (goto (reg continue))
instruction: (restore n)
instruction: (restore continue)
instruction: (assign val (op *) (reg n) (reg val))
instruction: (goto (reg continue))
instruction: (restore n)
instruction: (restore continue)
instruction: (assign val (op *) (reg n) (reg val))
instruction: (goto (reg continue))
instruction: (perform (op print-stack-statistics))
(total-pushes = 6 maximum-depth = 6)
instruction: (perform (op print) (const "\nreg val has "))
reg val has 
instruction: (perform (op print) (reg val))24
instruction: (goto (label meta-start))
instruction: (assign n (op newdata))
instruction: (test (op =) (reg n) (const -1))
instruction: (branch (label final-end))
Instructions executed: 80
#+end_src

**** DONE Exercise 5.17 Printing labels
     CLOSED: [2020-02-29 Sat 17:43]

Firstly, let us make the assembler save labels.

#+name: regmac-extract-labels-improved-labels
#+begin_src scheme :exports code :results none
  (define (add-inst-label! instr label)
    (let* ((label-cell (cddr instr)))
      (set-car! label-cell (cons label (car label-cell)))))
  (define (instruction-labels inst) (caddr inst))

  (define (extract-labels text receive)
    (if (null? text)
	(receive '() '())
	(extract-labels
	 (cdr text)
	 (lambda (insts labels)
	   (let ((next-inst (car text)))
	     (if (symbol? next-inst)
		 (receive insts
		     (if (assoc next-inst labels)
			 (error "extract-labels: ambiguous label" next-inst)
			 (begin (unless (null? insts)
				  (add-inst-label! (car insts) next-inst))
				(cons (make-label-entry next-inst insts)
				      labels))))
		 (receive (cons (make-instruction next-inst)
				insts)
		     labels)))))))
#+end_src


#+name: regmac-assembler-with-metadata-register-labels
#+begin_src scheme :exports code :results none
  (define (goto-inst? inst) (tagged-list? (instruction-text inst) 'goto))
  (define (save-inst? inst) (tagged-list? (instruction-text inst) 'save))
  (define (restore-inst? inst) (tagged-list? (instruction-text inst) 'restore))
  (define (assign-inst? inst) (tagged-list? (instruction-text inst) 'assign))


  (define (instruction-text-type inst) (car (instruction-text inst)))

  (define (extract-reg source)
    (append-map (lambda (sexp) (if (tagged-list? sexp 'reg)
			      (list (cadr sexp))
			      '())) source))
  (define (extract-registers text)
    (delete-duplicates
     (append-map
      (lambda (sexp)
	(cond ((symbol? sexp) '())
              ((tagged-list? sexp 'assign)
	            (cons (cadr sexp) (extract-reg (cddr sexp))))
              ((tagged-list? sexp 'save) (cdr sexp))
              ((tagged-list? sexp 'restore) (cdr sexp))
              (else (extract-reg (cdr sexp)))))
      text)))


  (define (assemble controller-text machine)
    (let ((allregs (extract-registers controller-text)))
     (for-each
       (lambda (reg) ((machine 'allocate-register) reg))
       allregs))
    (extract-labels
     controller-text
     (lambda (insts labels)
       (let* ((meta-instructions (delete-duplicates (map instruction-text-type insts)))
	      (meta-entry-registers (delete-duplicates (append-map
							(lambda (inst)
							  (if (and (goto-inst? inst)
								   (register-exp? (goto-dest (instruction-text inst))))
							      (list (register-exp-reg (goto-dest (instruction-text inst))))
							      '())) insts)))
	      (meta-stack-registers (delete-duplicates (append-map
							(lambda (inst)
							  (if (or (save-inst? inst)
								  (restore-inst? inst))
							      (list (cadr (instruction-text inst)))
							      '())) insts)))
	      (meta-datapaths (let* ((todo (append-map
					    (lambda (inst)
					      (if (assign-inst? inst)
						  (list (cons (cadr (instruction-text inst)) (cddr (instruction-text inst))))
						  '())) insts))
				     (s '()))
				(for-each
				 (lambda (sspair)
				   (let ((reg (assoc (car sspair) s)))
				     (if reg
					 (set-cdr! reg (lset-adjoin equal? (cdr reg) (cdr sspair)))
					 (set! s (cons (cons (car sspair) (list (cdr sspair))) s)))))
				 todo) s)))
	 ((machine 'set-metadata!) (make-metadata
				    (list 'instructions meta-instructions)
				    (list 'entry-points meta-entry-registers)
				    (list 'stack-registers meta-stack-registers)
				    (list 'datapaths meta-datapaths)))
	 (update-insts! insts labels machine))
       insts)))
  (define make-metadata list)

  (define (update-insts! insts labels machine)
    (let ((pc (get-register machine 'pc))
	  (flag (get-register machine 'flag))
	  (stack (machine 'stack))
	  (ops (machine 'operations)))
      (for-each
       (lambda (inst)
	 (set-instruction-execution-proc!
	  inst
	  (make-execution-procedure
	   (instruction-text inst)
	   labels machine pc flag stack ops)))
       insts)))

  (define (make-instruction text) (list text '() '())) ;; text, procedure, labels
  (define (instruction-text inst) (car inst))
  (define (instruction-execution-proc inst) (cadr inst))

  (define (set-instruction-execution-proc! inst proc)
    (set-car! (cdr inst) proc))

  (define (make-label-entry label-name insts)
    (cons label-name insts))
  (define (lookup-label labels label-name)
    (let ((val (assoc label-name labels)))
      (if val
	  (cdr val)
	  (error "Undefined label: ASSEMBLE"
		 label-name))))
#+end_src

#+name: regmac-make-new-machine-with-metadata-instr-count-trace-labels
#+begin_src scheme :exports code :results none
  (define (make-new-machine)
    (let ((pc (make-register 'pc))
	  (flag (make-register 'flag))
	  (stack (make-stack))
	  (the-instruction-sequence '())
          (the-instruction-counter 0)
          (tracing-flag #f)
          (labels-flag #f)
	  (metadata '()))
      (let ((the-ops
	     (list (list 'initialize-stack
			 (lambda () (stack 'initialize)))
		   (list 'print-stack-statistics
			 (lambda () (stack 'print-statistics)))))

	    (register-table
	     (list (list 'pc pc) (list 'flag flag))))
	(define (allocate-register name)
	  (if (assoc name register-table)
	      (error "Multiply defined register: " name)
	      (set! register-table
		(cons (list name (make-register name))
		      register-table)))
	  'register-allocated)
	(define (lookup-register name)
	  (let ((val (assoc name register-table)))
	    (if val
		(cadr val)
		(error "Unknown register:" name))))
	(define (execute)
	  (let ((insts (get-contents pc)))
            (set! the-instruction-counter (+ the-instruction-counter 1))
	    (if (null? insts)
		'done
		(begin
                  (if (and labels-flag (not (null? (instruction-labels (car insts)))))
                     (begin
                        (display "\nlabels: ")
                        (display (instruction-labels (car insts)))))
                  (if tracing-flag
                     (begin
                        (display "\ninstruction text: ")
                        (display (instruction-text (car insts)))))

		  ((instruction-execution-proc (car insts)))
		  (execute)))))
	(define (dispatch message)
	  (cond ((eq? message 'start)
		 (set-contents! pc the-instruction-sequence)
		 (execute))
		((eq? message 'install-instruction-sequence)
		 (lambda (seq)
		   (set! the-instruction-sequence seq)))
		((eq? message 'allocate-register)
		 allocate-register)
		((eq? message 'get-register)
		 lookup-register)
		((eq? message 'install-operations)
		 (lambda (ops)
		   (set! the-ops (append the-ops ops))))
		((eq? message 'stack) stack)
		((eq? message 'operations) the-ops)
		((eq? message 'set-metadata!) (lambda (new-metadata) (set! metadata new-metadata)))
		((eq? message 'get-metadata) metadata)
                ((eq? message 'get-instruction-count) the-instruction-counter)
                ((eq? message 'reset-instruction-count) (set! the-instruction-counter 0))
                ((eq? message 'trace-on) (set! tracing-flag #t))
                ((eq? message 'trace-off) (set! tracing-flag #f))
                ((eq? message 'labels-on) (set! labels-flag #t))
                ((eq? message 'labels-off) (set! labels-flag #f))
		(else (error "Unknown request: MACHINE"
			     message))))
	dispatch)))
  (define (start machine) (machine 'start))
  (define (get-register-contents machine register-name)
    (get-contents (get-register machine register-name)))
  (define (set-register-contents! machine register-name value)
    (set-contents! (get-register machine register-name)
		   value)
    'done)

  (define (get-register machine reg-name)
    ((machine 'get-register) reg-name))
  (define (advance-pc pc)
    (set-contents! pc (cdr (get-contents pc))))

#+end_src


#+header: :stdin empty
#+begin_src shell :shebang "#! /usr/bin/chibi-scheme" :exports both :results output scalar code
    <<regmac-glue1>>
    <<regmac-make-machine>>
    <<regmac-make-register>>
    <<regmac-make-stack-with-performance>>
    <<regmac-make-new-machine-with-metadata-instr-count-trace-labels>>
    <<regmac-extract-labels-improved-labels>>
    <<regmac-assembler-with-metadata-register-labels>>
    <<regmac-generating-execution-procedures>>
    <<regmac-make-operation-exp-improved>>
    <<regmac-make-operation-exp-syntax>>
    <<regmac-make-assign>>
    <<regmac-make-test>>
    <<regmac-make-save-restore>>
    <<regmac-other-instructions>>

    (define test-machine
      (make-machine
       '()
       (list (list '= =) (list '< <) (list '- -) (list '+ +) (list '* *)
	     (list 'null? null?) (list 'print display)
	     (list 'newdata (let ((argin '(2 4 -1)))
				    (lambda () (let ((retval (car argin)))
					 (set! argin (cdr argin))
					 retval)))))
       (quote
  (controller
     meta-start
     (assign n (op newdata))
     (test (op =) (reg n) (const -1))
     (branch (label final-end))
     (perform (op print) (const "\nn="))
     (perform (op print) (reg n))
     (perform (op initialize-stack))
     (perform (op print-stack-statistics))
     (assign continue (label fact-done)) ;set up final return address
     fact-loop
     (test (op =) (reg n) (const 1))
     (branch (label base-case))
     ;; Set up for the recursive call by saving n and continue.
     ;; Set up continue so that the computation will continue
     ;; at after-fact when the subroutine returns.
     (save continue)
     (save n)
     (assign n (op -) (reg n) (const 1))
     (assign continue (label after-fact))
     (goto (label fact-loop))
     after-fact
     (restore n)
     (restore continue)
     (assign val (op *) (reg n) (reg val)) ;val now contains n(n - 1)!
     (goto (reg continue)) ;return to caller
     base-case
     (assign val (const 1)) ;base case: 1! = 1
     (goto (reg continue))  ;return to caller
     fact-done
     (perform (op print-stack-statistics))
     (perform (op print) (const "\nreg val has"))
     (perform (op print) (reg val))
     (goto (label meta-start))
     final-end
  )
  )))

    (set-register-contents! test-machine 'n 10)
    (display "metadata=\n")
    (map (lambda (x)  (show #t "  "(pretty  x))) (test-machine 'get-metadata))
    (test-machine 'trace-on)
    (test-machine 'labels-on)
    (start test-machine)
    (test-machine 'trace-off)
    (test-machine 'labels-off)
    (show #t "\nInstructions executed: " (test-machine 'get-instruction-count))
#+end_src

#+RESULTS[677828f5713a8732975403654acf417a6dfa56cb]:
#+begin_src shell
metadata=
  (instructions (assign test branch perform save goto restore))
  (entry-points (continue))
  (stack-registers (continue n))
  (datapaths
   ((val ((const 1)) ((op *) (reg n) (reg val)))
    (continue ((label after-fact)) ((label fact-done)))
    (n ((op -) (reg n) (const 1)) ((op newdata)))))

labels: (controller meta-start)
instruction text: (assign n (op newdata))
instruction text: (test (op =) (reg n) (const -1))
instruction text: (branch (label final-end))
instruction text: (perform (op print) (const "\nn="))
n=
instruction text: (perform (op print) (reg n))2
instruction text: (perform (op initialize-stack))
instruction text: (perform (op print-stack-statistics))
(total-pushes = 0 maximum-depth = 0)
instruction text: (assign continue (label fact-done))
labels: (fact-loop)
instruction text: (test (op =) (reg n) (const 1))
instruction text: (branch (label base-case))
instruction text: (save continue)
instruction text: (save n)
instruction text: (assign n (op -) (reg n) (const 1))
instruction text: (assign continue (label after-fact))
instruction text: (goto (label fact-loop))
labels: (fact-loop)
instruction text: (test (op =) (reg n) (const 1))
instruction text: (branch (label base-case))
labels: (base-case)
instruction text: (assign val (const 1))
instruction text: (goto (reg continue))
labels: (after-fact)
instruction text: (restore n)
instruction text: (restore continue)
instruction text: (assign val (op *) (reg n) (reg val))
instruction text: (goto (reg continue))
labels: (fact-done)
instruction text: (perform (op print-stack-statistics))
(total-pushes = 2 maximum-depth = 2)
instruction text: (perform (op print) (const "\nreg val has"))
reg val has
instruction text: (perform (op print) (reg val))2
instruction text: (goto (label meta-start))
labels: (controller meta-start)
instruction text: (assign n (op newdata))
instruction text: (test (op =) (reg n) (const -1))
instruction text: (branch (label final-end))
instruction text: (perform (op print) (const "\nn="))
n=
instruction text: (perform (op print) (reg n))4
instruction text: (perform (op initialize-stack))
instruction text: (perform (op print-stack-statistics))
(total-pushes = 0 maximum-depth = 0)
instruction text: (assign continue (label fact-done))
labels: (fact-loop)
instruction text: (test (op =) (reg n) (const 1))
instruction text: (branch (label base-case))
instruction text: (save continue)
instruction text: (save n)
instruction text: (assign n (op -) (reg n) (const 1))
instruction text: (assign continue (label after-fact))
instruction text: (goto (label fact-loop))
labels: (fact-loop)
instruction text: (test (op =) (reg n) (const 1))
instruction text: (branch (label base-case))
instruction text: (save continue)
instruction text: (save n)
instruction text: (assign n (op -) (reg n) (const 1))
instruction text: (assign continue (label after-fact))
instruction text: (goto (label fact-loop))
labels: (fact-loop)
instruction text: (test (op =) (reg n) (const 1))
instruction text: (branch (label base-case))
instruction text: (save continue)
instruction text: (save n)
instruction text: (assign n (op -) (reg n) (const 1))
instruction text: (assign continue (label after-fact))
instruction text: (goto (label fact-loop))
labels: (fact-loop)
instruction text: (test (op =) (reg n) (const 1))
instruction text: (branch (label base-case))
labels: (base-case)
instruction text: (assign val (const 1))
instruction text: (goto (reg continue))
labels: (after-fact)
instruction text: (restore n)
instruction text: (restore continue)
instruction text: (assign val (op *) (reg n) (reg val))
instruction text: (goto (reg continue))
labels: (after-fact)
instruction text: (restore n)
instruction text: (restore continue)
instruction text: (assign val (op *) (reg n) (reg val))
instruction text: (goto (reg continue))
labels: (after-fact)
instruction text: (restore n)
instruction text: (restore continue)
instruction text: (assign val (op *) (reg n) (reg val))
instruction text: (goto (reg continue))
labels: (fact-done)
instruction text: (perform (op print-stack-statistics))
(total-pushes = 6 maximum-depth = 6)
instruction text: (perform (op print) (const "\nreg val has"))
reg val has
instruction text: (perform (op print) (reg val))24
instruction text: (goto (label meta-start))
labels: (controller meta-start)
instruction text: (assign n (op newdata))
instruction text: (test (op =) (reg n) (const -1))
instruction text: (branch (label final-end))
Instructions executed: 80
#+end_src

Seems to be working, and the labels don't interfere with instruction counting.

**** DONE Exercise 5.18 Register tracing
     CLOSED: [2020-02-29 Sat 14:07]

#+name: regmac-make-register-tracing
#+begin_src scheme :exports code
  (define (make-register name)
    (let ((contents '*unassigned*)
          (tracing-flag #f))
      (define (dispatch message)
	(cond ((eq? message 'get) contents)
	      ((eq? message 'set)
	       (lambda (value)
                 (when tracing-flag
                  (show #t "\ntrace:"
                           (written name)
                           ":"
                           (written contents)
                           "->"
                           (written value)))
                 (set! contents value)))
              ((eq? message 'trace-on) (set! tracing-flag #t))
              ((eq? message 'trace-off) (set! tracing-flag #f))
	      (else
	       (error "Unknown request: REGISTER" message))))
      dispatch))
  (define (get-contents register) (register 'get))
  (define (set-contents! register value)
    ((register 'set) value))
#+end_src

#+header: :stdin empty
#+begin_src shell :shebang "#! /usr/bin/chibi-scheme" :exports both :results output scalar code
    <<regmac-glue1>>
    <<regmac-make-machine>>
    <<regmac-make-register-tracing>>
    <<regmac-make-stack-with-performance>>
    <<regmac-make-new-machine-with-metadata-instr-count-trace-labels>>
    <<regmac-extract-labels-improved-labels>>
    <<regmac-assembler-with-metadata-register-labels>>
    <<regmac-generating-execution-procedures>>
    <<regmac-make-operation-exp-improved>>
    <<regmac-make-operation-exp-syntax>>
    <<regmac-make-assign>>
    <<regmac-make-test>>
    <<regmac-make-save-restore>>
    <<regmac-other-instructions>>

    (define test-machine
      (make-machine
       '()
       (list (list '= =) (list '< <) (list '- -) (list '+ +) (list '* *)
	     (list 'null? null?) (list 'print display)
	     (list 'newdata (let ((argin '(2 4 -1)))
				    (lambda () (let ((retval (car argin)))
					 (set! argin (cdr argin))
					 retval)))))
       (quote
  (controller
     meta-start
     (assign n (op newdata))
     (test (op =) (reg n) (const -1))
     (branch (label final-end))
     (perform (op print) (const "\nn="))
     (perform (op print) (reg n))
     (perform (op initialize-stack))
     (perform (op print-stack-statistics))
     (assign continue (label fact-done)) ;set up final return address
     fact-loop
     (test (op =) (reg n) (const 1))
     (branch (label base-case))
     ;; Set up for the recursive call by saving n and continue.
     ;; Set up continue so that the computation will continue
     ;; at after-fact when the subroutine returns.
     (save continue)
     (save n)
     (assign n (op -) (reg n) (const 1))
     (assign continue (label after-fact))
     (goto (label fact-loop))
     after-fact
     (restore n)
     (restore continue)
     (assign val (op *) (reg n) (reg val)) ;val now contains n(n - 1)!
     (goto (reg continue)) ;return to caller
     base-case
     (assign val (const 1)) ;base case: 1! = 1
     (goto (reg continue))  ;return to caller
     fact-done
     (perform (op print-stack-statistics))
     (perform (op print) (const "\nreg val has"))
     (perform (op print) (reg val))
     (goto (label meta-start))
     final-end
  )
  )))

    (set-register-contents! test-machine 'n 10)
    (display "metadata=\n")
    (map (lambda (x)  (show #t "  "(pretty  x))) (test-machine 'get-metadata))
    (test-machine 'trace-on)
    (test-machine 'labels-on)
    ((get-register test-machine 'val) 'trace-on)
    (start test-machine)
    (test-machine 'trace-off)
    (test-machine 'labels-off)
    (show #t "\nInstructions executed: " (test-machine 'get-instruction-count))
#+end_src

#+RESULTS[e016aff9530dc1204181a64dd59fc91a0a35ea01]:
#+begin_src shell
metadata=
  (instructions (assign test branch perform save goto restore))
  (entry-points (continue))
  (stack-registers (continue n))
  (datapaths
   ((val ((const 1)) ((op *) (reg n) (reg val)))
    (continue ((label after-fact)) ((label fact-done)))
    (n ((op -) (reg n) (const 1)) ((op newdata)))))

labels: (controller meta-start)
instruction text: (assign n (op newdata))
instruction text: (test (op =) (reg n) (const -1))
instruction text: (branch (label final-end))
instruction text: (perform (op print) (const "\nn="))
n=
instruction text: (perform (op print) (reg n))2
instruction text: (perform (op initialize-stack))
instruction text: (perform (op print-stack-statistics))
(total-pushes = 0 maximum-depth = 0)
instruction text: (assign continue (label fact-done))
labels: (fact-loop)
instruction text: (test (op =) (reg n) (const 1))
instruction text: (branch (label base-case))
instruction text: (save continue)
instruction text: (save n)
instruction text: (assign n (op -) (reg n) (const 1))
instruction text: (assign continue (label after-fact))
instruction text: (goto (label fact-loop))
labels: (fact-loop)
instruction text: (test (op =) (reg n) (const 1))
instruction text: (branch (label base-case))
labels: (base-case)
instruction text: (assign val (const 1))
trace:val:*unassigned*->1
instruction text: (goto (reg continue))
labels: (after-fact)
instruction text: (restore n)
instruction text: (restore continue)
instruction text: (assign val (op *) (reg n) (reg val))
trace:val:1->2
instruction text: (goto (reg continue))
labels: (fact-done)
instruction text: (perform (op print-stack-statistics))
(total-pushes = 2 maximum-depth = 2)
instruction text: (perform (op print) (const "\nreg val has"))
reg val has
instruction text: (perform (op print) (reg val))2
instruction text: (goto (label meta-start))
labels: (controller meta-start)
instruction text: (assign n (op newdata))
instruction text: (test (op =) (reg n) (const -1))
instruction text: (branch (label final-end))
instruction text: (perform (op print) (const "\nn="))
n=
instruction text: (perform (op print) (reg n))4
instruction text: (perform (op initialize-stack))
instruction text: (perform (op print-stack-statistics))
(total-pushes = 0 maximum-depth = 0)
instruction text: (assign continue (label fact-done))
labels: (fact-loop)
instruction text: (test (op =) (reg n) (const 1))
instruction text: (branch (label base-case))
instruction text: (save continue)
instruction text: (save n)
instruction text: (assign n (op -) (reg n) (const 1))
instruction text: (assign continue (label after-fact))
instruction text: (goto (label fact-loop))
labels: (fact-loop)
instruction text: (test (op =) (reg n) (const 1))
instruction text: (branch (label base-case))
instruction text: (save continue)
instruction text: (save n)
instruction text: (assign n (op -) (reg n) (const 1))
instruction text: (assign continue (label after-fact))
instruction text: (goto (label fact-loop))
labels: (fact-loop)
instruction text: (test (op =) (reg n) (const 1))
instruction text: (branch (label base-case))
instruction text: (save continue)
instruction text: (save n)
instruction text: (assign n (op -) (reg n) (const 1))
instruction text: (assign continue (label after-fact))
instruction text: (goto (label fact-loop))
labels: (fact-loop)
instruction text: (test (op =) (reg n) (const 1))
instruction text: (branch (label base-case))
labels: (base-case)
instruction text: (assign val (const 1))
trace:val:2->1
instruction text: (goto (reg continue))
labels: (after-fact)
instruction text: (restore n)
instruction text: (restore continue)
instruction text: (assign val (op *) (reg n) (reg val))
trace:val:1->2
instruction text: (goto (reg continue))
labels: (after-fact)
instruction text: (restore n)
instruction text: (restore continue)
instruction text: (assign val (op *) (reg n) (reg val))
trace:val:2->6
instruction text: (goto (reg continue))
labels: (after-fact)
instruction text: (restore n)
instruction text: (restore continue)
instruction text: (assign val (op *) (reg n) (reg val))
trace:val:6->24
instruction text: (goto (reg continue))
labels: (fact-done)
instruction text: (perform (op print-stack-statistics))
(total-pushes = 6 maximum-depth = 6)
instruction text: (perform (op print) (const "\nreg val has"))
reg val has
instruction text: (perform (op print) (reg val))24
instruction text: (goto (label meta-start))
labels: (controller meta-start)
instruction text: (assign n (op newdata))
instruction text: (test (op =) (reg n) (const -1))
instruction text: (branch (label final-end))
Instructions executed: 80
#+end_src

Seems to be working okay.

**** DONE Exercise 5.19 Breakpoints
     CLOSED: [2020-02-29 Sat 17:42]

Since the exercise 5.17 we already have label information embedded
into the instruction sequence.

#+name: regmac-extract-labels-improved-labels-brk
#+begin_src scheme :exports code :results none
  (define (add-inst-label! instr label)
    (let* ((label-cell (cddr instr)))
      (set-car! label-cell (cons label (car label-cell)))))
  (define (instruction-labels inst) (caddr inst))

  (define (extract-labels text receive)
    (if (null? text)
	(receive '() '())
	(extract-labels
	 (cdr text)
	 (lambda (insts labels)
	   (let ((next-inst (car text)))
	     (if (symbol? next-inst)
		 (receive insts
		     (if (assoc next-inst labels)
			 (error "extract-labels: ambiguous label" next-inst)
			 (begin (unless (null? insts)
				  (add-inst-label! (car insts) next-inst))
				(cons (make-label-entry next-inst insts)
				      labels))))
		 (receive (cons (make-instruction next-inst)
				insts)
		     labels)))))))
#+end_src


#+name: regmac-assembler-with-metadata-register-labels-brk
#+begin_src scheme :exports code :results none
  (define (goto-inst? inst) (tagged-list? (instruction-text inst) 'goto))
  (define (save-inst? inst) (tagged-list? (instruction-text inst) 'save))
  (define (restore-inst? inst) (tagged-list? (instruction-text inst) 'restore))
  (define (assign-inst? inst) (tagged-list? (instruction-text inst) 'assign))


  (define (instruction-text-type inst) (car (instruction-text inst)))

  (define (extract-reg source)
    (append-map (lambda (sexp) (if (tagged-list? sexp 'reg)
			      (list (cadr sexp))
			      '())) source))
  (define (extract-registers text)
    (delete-duplicates
     (append-map
      (lambda (sexp)
	(cond ((symbol? sexp) '())
              ((tagged-list? sexp 'assign)
	            (cons (cadr sexp) (extract-reg (cddr sexp))))
              ((tagged-list? sexp 'save) (cdr sexp))
              ((tagged-list? sexp 'restore) (cdr sexp))
              (else (extract-reg (cdr sexp)))))
      text)))


  (define (assemble controller-text machine)
    #;(show #t "assemble:\n  registers-to-allocate: " (extract-registers controller-text)
                      "\n  machine registers    : " (machine 'all-register-names)
                      "\n  difference           : "  (lset-difference eq? (extract-registers controller-text)
                                                       (machine 'all-register-names)
                                                    ))
    (let ((allregs (lset-difference eq? (extract-registers controller-text)
                                    (machine 'all-register-names)
                                    )))
     (for-each
       (lambda (reg) ((machine 'allocate-register) reg))
       allregs))
    (extract-labels
     controller-text
     (lambda (insts labels)
       (let* ((meta-instructions (delete-duplicates (map instruction-text-type insts)))
	      (meta-entry-registers (delete-duplicates (append-map
							(lambda (inst)
							  (if (and (goto-inst? inst)
								   (register-exp? (goto-dest (instruction-text inst))))
							      (list (register-exp-reg (goto-dest (instruction-text inst))))
							      '())) insts)))
	      (meta-stack-registers (delete-duplicates (append-map
							(lambda (inst)
							  (if (or (save-inst? inst)
								  (restore-inst? inst))
							      (list (cadr (instruction-text inst)))
							      '())) insts)))
	      (meta-datapaths (let* ((todo (append-map
					    (lambda (inst)
					      (if (assign-inst? inst)
						  (list (cons (cadr (instruction-text inst)) (cddr (instruction-text inst))))
						  '())) insts))
				     (s '()))
				(for-each
				 (lambda (sspair)
				   (let ((reg (assoc (car sspair) s)))
				     (if reg
					 (set-cdr! reg (lset-adjoin equal? (cdr reg) (cdr sspair)))
					 (set! s (cons (cons (car sspair) (list (cdr sspair))) s)))))
				 todo) s)))
	 ((machine 'set-metadata!) (make-metadata
				    (list 'instructions meta-instructions)
				    (list 'entry-points meta-entry-registers)
				    (list 'stack-registers meta-stack-registers)
				    (list 'datapaths meta-datapaths)))
         ((machine 'set-labels) labels)
	 (update-insts! insts labels machine))
       insts)))
  (define make-metadata list)

  (define (update-insts! insts labels machine)
    (let ((pc (get-register machine 'pc))
	  (flag (get-register machine 'flag))
	  (stack (machine 'stack))
	  (ops (machine 'operations)))
      (for-each
       (lambda (inst)
	 (set-instruction-execution-proc!
	  inst
	  (make-execution-procedure
	   (instruction-text inst)
	   labels machine pc flag stack ops)))
       insts)))

  (define (make-instruction text) (list text '() '() '())) ;; text, procedure, labels
  (define (instruction-text inst) (car inst))
  (define (instruction-execution-proc inst) (cadr inst))
  (define (instruction-breakpoints inst) (list-ref inst 3))
  (define (set-instruction-breakpoint! inst break)
      (set-car! (list-tail inst 3)
                (lset-adjoin equal? (list-tail inst 3) break)))
  (define (clear-instruction-breakpoint! inst break)
      (set-car! (list-tail inst 3)
                (lset-difference equal? (list-tail inst 3) (list break))))

  (define (set-instruction-execution-proc! inst proc)
    (set-car! (cdr inst) proc))

  (define (make-label-entry label-name insts)
    (cons label-name insts))
  (define (lookup-label labels label-name)
    (let ((val (assoc label-name labels)))
      (if val
	  (cdr val)
	  (error "Undefined label: ASSEMBLE"
		 label-name))))
#+end_src


#+name: regmac-make-new-machine-with-metadata-instr-count-trace-labels-brk
#+begin_src scheme :exports code :results none

  (define (make-breakpoint label offset)
    (list label offset))
  (define (breakpoint-label brk)
    (car brk))
  (define (breakpoint-offset brk)
    (cadr brk))

  (define (make-new-machine)
    (let ((pc (make-register 'pc))
	  (flag (make-register 'flag))
	  (stack (make-stack))
	  (the-instruction-sequence '())
	  (the-instruction-counter 0)
	  (tracing-flag #f)
	  (labels-flag #f)
	  (the-labels '())
	  (the-breakpoints '())
	  (reverse-breakpoints '())
	  (metadata '())
	  (resume-continuation '()))
      (let ((the-ops
	     (list (list 'initialize-stack
			 (lambda () (stack 'initialize)))
		   (list 'print-stack-statistics
			 (lambda () (stack 'print-statistics)))))

	    (register-table
	     (list (list 'pc pc) (list 'flag flag))))
	(define (allocate-register name)
	  (if (assoc name register-table)
	      (error "Multiply defined register: " name)
	      (set! register-table
		(cons (list name (make-register name))
		      register-table)))
	  'register-allocated)
	(define (lookup-register name)
	  (let ((val (assoc name register-table)))
	    (if val
		(cadr val)
		(error "Unknown register:" name))))
        (define (all-register-names)
            (map car register-table))
	(define (set-breakpoint label offset) ;; brk has label and offset
	  (let ((break (make-breakpoint label offset))
		(target (lookup-label the-labels label)))
	    (when (assoc break the-breakpoints)
	      (error "Breakpoint already set" break))
	    (unless target
	      (error "Label not found" label))
	    (when (< (length target) offset)
	      (error "Wrong offset" offset target))
	    (set! the-breakpoints (cons (list break (list-tail target offset))
					the-breakpoints))
	    (set! reverse-breakpoints (cons (list (list-tail target offset) break)
					    reverse-breakpoints))))
	(define (cancel-breakpoint label offset)
	  (let ((breakpoint (make-breakpoint label offset)))
	    (unless (assoc breakpoint the-breakpoints)
	      (error "No such breakpoint" breakpoint))
	    (let* ((break (assoc breakpoint the-breakpoints)))
	      (unless (assoc (cadr break) reverse-breakpoints)
		(error "Breakpoints inconsistent: " (cadr break)))
	      (set! the-breakpoints (alist-delete breakpoint the-breakpoints equal?))
	      (set! reverse-breakpoints (alist-delete (cadr break) reverse-breakpoints equal?)))))
	(define (execute continuation)
	  (let ((insts (get-contents pc)))
	    (set! the-instruction-counter (+ the-instruction-counter 1))
	    (if (null? insts)
		'done
		(begin
		  (if (and labels-flag (not (null? (instruction-labels (car insts)))))
		      (begin
			(display "\nlabels: ")
			(display (instruction-labels (car insts)))))
		  (if tracing-flag
		      (begin
			(display "\ninstruction text: ")
			(display (instruction-text (car insts)))))
		  (when (assoc insts reverse-breakpoints)
		      (show #t "\nBreakpoint: "
			    (pretty (cdr (assoc insts reverse-breakpoints)))
			    "Inst="
			    (pretty (car insts)))
		      (call/cc (lambda (res)
				 (set! resume-continuation res)
				 (continuation)))
                      (show #t "\nResuming."))
		  ((instruction-execution-proc (car insts)))
		  (execute continuation)))))
	(define (dispatch message)
	  (cond ((eq? message 'start)
		 (set-contents! pc the-instruction-sequence)
		 (call/cc execute))
		((eq? message 'install-instruction-sequence)
		 (lambda (seq)
		   (set! the-instruction-sequence seq)))
		((eq? message 'allocate-register)
		 allocate-register)
		((eq? message 'get-register)
		 lookup-register)
		((eq? message 'install-operations)
		 (lambda (ops)
		   (set! the-ops (append the-ops ops))))
		((eq? message 'stack) stack)
		((eq? message 'operations) the-ops)
		((eq? message 'set-metadata!) (lambda (new-metadata) (set! metadata new-metadata)))
		((eq? message 'get-metadata) metadata)
		((eq? message 'get-instruction-count) the-instruction-counter)
		((eq? message 'reset-instruction-count) (set! the-instruction-counter 0))
		((eq? message 'trace-on) (set! tracing-flag #t))
		((eq? message 'trace-off) (set! tracing-flag #f))
		((eq? message 'labels-on) (set! labels-flag #t))
		((eq? message 'labels-off) (set! labels-flag #f))
                ((eq? message 'all-register-names) (all-register-names))
		((eq? message 'set-breakpoint) set-breakpoint)
		((eq? message 'cancel-breakpoint) cancel-breakpoint)
		((eq? message 'cancel-all-breakpoints)
		 (set! the-breakpoints '())
		 (set! reverse-breakpoints '()))
		((eq? message 'proceed) (resume-continuation))
		((eq? message 'set-labels) (lambda (l) (set! the-labels l)))
		(else (error "Unknown request: MACHINE"
			     message))))
	dispatch)))
  (define (start machine) (machine 'start))
  (define (get-register-contents machine register-name)
    (get-contents (get-register machine register-name)))
  (define (set-register-contents! machine register-name value)
    (set-contents! (get-register machine register-name)
		   value)
    'done)

  (define (get-register machine reg-name)
    ((machine 'get-register) reg-name))
  (define (advance-pc pc)
    (set-contents! pc (cdr (get-contents pc))))
  (define (set-breakpoint machine label offset)
    ((machine 'set-breakpoint) label offset))
  (define (cancel-breakpoint machine label offset)
    ((machine 'cancel-breakpoint) label offset))
  (define (cancel-all-breakpoints machine)
    (machine 'cancel-all-breakpoints))
  (define (proceed-machine machine) (machine 'proceed))
#+end_src

#+header: :stdin empty
#+begin_src shell :shebang "#! /usr/bin/chibi-scheme" :exports both :results output scalar code
      <<regmac-glue1>>
      <<regmac-make-machine>>
      <<regmac-make-register-tracing>>
      <<regmac-make-stack-with-performance>>
      <<regmac-make-new-machine-with-metadata-instr-count-trace-labels-brk>>
      <<regmac-extract-labels-improved-labels-brk>>
      <<regmac-assembler-with-metadata-register-labels-brk>>
      <<regmac-generating-execution-procedures>>
      <<regmac-make-operation-exp-improved>>
      <<regmac-make-operation-exp-syntax>>
      <<regmac-make-assign>>
      <<regmac-make-test>>
      <<regmac-make-save-restore>>
      <<regmac-other-instructions>>

      (define gcd-machine
	(make-machine
	 '()
	 (list (list '= =) (list '< <) (list '- -) (list '+ +) (list '* *)
	       (list 'null? null?) (list 'print display) (list 'rem remainder)
	       )
	 (quote
<<regmac-controller-gcd-machine>>
    )))
      (cancel-all-breakpoints gcd-machine)
      (set-breakpoint gcd-machine 'test-b 4)
      ((get-register gcd-machine 'b) 'trace-on)
      (gcd-machine 'trace-on)
      (gcd-machine 'labels-on)
      (set-register-contents! gcd-machine 'a 120)
      (set-register-contents! gcd-machine 'b 90)
      (show #t "\nb=" (pretty (get-register-contents gcd-machine 'b)))
;      (display "metadata=\n")
;      (map (lambda (x)  (show #t "  "(pretty  x))) (gcd-machine 'get-metadata))

      (start gcd-machine)
      ;; returning from a breakpoint
;      (gcd-machine 'trace-off)
;      (gcd-machine 'labels-off)
;      (show #t "\nInstructions executed: " (gcd-machine 'get-instruction-count))
;      (show #t "\nRemoving breakpoints")
      (cancel-breakpoint gcd-machine 'test-b 4)
      (proceed-machine gcd-machine)
      (show #t "\nInstructions executed: " (gcd-machine 'get-instruction-count))
      (show #t "\nAnswer=" (get-register-contents gcd-machine 'a))

#+end_src

#+RESULTS[f5b502255476ea231e7c53e4bfaf6c74d81e499f]:
#+begin_src shell

trace:b:*unassigned*->90
b=90

labels: (test-b)
instruction text: (test (op =) (reg b) (const 0))
instruction text: (branch (label gcd-done))
instruction text: (assign t (op rem) (reg a) (reg b))
instruction text: (assign a (reg b))
instruction text: (assign b (reg t))
Breakpoint: ((test-b 4))
Inst=((assign b (reg t)) #<procedure #f> () ())

Resuming.
trace:b:90->30
instruction text: (goto (label test-b))
labels: (test-b)
instruction text: (test (op =) (reg b) (const 0))
instruction text: (branch (label gcd-done))
instruction text: (assign t (op rem) (reg a) (reg b))
instruction text: (assign a (reg b))
instruction text: (assign b (reg t))
trace:b:30->0
instruction text: (goto (label test-b))
labels: (test-b)
instruction text: (test (op =) (reg b) (const 0))
instruction text: (branch (label gcd-done))
Instructions executed: 15
Answer=30
#+end_src

Heh. Without ~call/cc~ all this would have been a lot of pain. But
with ~call/cc~ and ~(scheme list)~ works like charm.

*** 5.3 Storage Allocation and Garbage Collection [3/3]
**** DONE Exercise 5.20 Drawing a list "~(#1=(1 . 2) #1)~"
     CLOSED: [2020-02-29 Sat 22:15]


#+name: exercise-5-20-list-register-memory
#+header: :imagemagick yes :iminoptions -density 300 :imoutoptions -geometry 250
#+header: :fit yes :headers '("\\usepackage{tikz} \\usetikzlibrary{positioning,fit,petri,arrows,calc,matrix,quotes}")
#+header: :buffer on
#+begin_src latex :results raw file :exports both :file exercise-5-20-list-register-memory.png
\begin{tikzpicture}[inner sep=0mm,>=stealth',very thick,color=blue!99,
       every node/.style={font=\sffamily,align=left},
             node distance=20mm,
      pics/cons cell/.style n args={4}{code={
      \coordinate (origin);
      \node[anchor=east,minimum size=10mm,inner sep=0, label=below left:#4] (#1-car) at(0,0) {};
      \node[anchor=west,minimum size=10mm,inner sep=0] (#1-cdr) at(0,0) {};
      \node[name=#1-box,fit=(#1-car) (#1-cdr),draw,shape=rectangle,rounded
 corners=0.5mm]  {};
      \draw[shorten <=1pt, shorten >=1pt] (#1-box.south -| origin) -- (#1-box.north -| origin);
      \if#2t
      % \path node[shape=circle,fill,draw,radius=2mm] at (#1-car.center) {};
      \filldraw (#1-car.center) circle[radius=0.66mm] ;
      \else
      \draw[shorten <=1pt] (#1-car.south west) to (#1-car.north east);
      \fi
      \if#3t
      \filldraw (#1-cdr.center) circle[radius=0.66mm] ;
      \else
      \draw[shorten >=1pt] (#1-cdr.south west) to (#1-cdr.north east);
      \fi
      }},
      pics/cons element/.style n args={2}{code={
      \node [minimum size=10mm,inner sep=0,rounded corners=1mm, draw, shape=rectangle] (#1) {#2};
      }}
      ]

\node (x) {x};
%\node[right=1cm of x] {};
\pic[right=of x] {cons cell={cell-a}{t}{t}{0}};
\draw[->] (x) to (cell-a-box);
\pic[below=of cell-a-car] {cons element={one}{1}};
%\pic[right=of cell-a-cdr] {cons cell={cell-b}{t}{f}};
\pic[below=of cell-a-cdr] {cons element={two}{2}};
%\pic[below=of cell-b-car] {cons element={b}{b}};
%\draw[->] (cell-a-cdr.center) to (cell-b-box);
\draw[->] (cell-a-car.center) to (one);
\draw[->] (cell-a-cdr.center) to (two);
\pic[above=of cell-a-box.center] {cons cell={list-1}{t}{t}{2}};
\draw[->] (list-1-car.center) -- (cell-a-box);
\node[left=of list-1-box.center] (y) {y} edge [->] (list-1-box);
\pic[right=of list-1-box] {cons cell={list-2}{t}{f}{1}};
\draw[->] (list-1-cdr.center) -- (list-2-box);
\draw[->] (list-2-car.center) -- (cell-a-box);
\end{tikzpicture}
#+end_src

#+RESULTS[d09697a6a57d1d90de4e35290bde1ad0123eb550]: exercise-5-20-list-register-memory
[[file:exercise-5-20-list-register-memory.png]]

Now let us make a table with the memory summary.

 | #        | 0 | 1  | 2  | 3  | 4 | 5 | 6 | ... |
 |----------+---+----+----+----+---+---+---+-----|
 | the-cars |   | n1 | p1 | p1 |   |   |   | ... |
 | the-cdrs |   | n2 | e0 | p2 |   |   |   | ... |

Now the value of ~free~ should be 4, as it is the first free cell.
(For some reason we don't count from 0.)

The values corresponding to ~x~ and ~y~ should be ~p1~ and ~p3~.

**** DONE Exercise 5.21 Register machines for list operations
     CLOSED: [2020-03-01 Sun 13:03]
***** a. Recursive count-leaves

#+begin_src scheme :exports code :results none
  (define (count-leaves tree)
    (cond ((null? tree) 0)
	  ((not (pair? tree)) 1)
	  (else (+ (count-leaves (car tree))
		   (count-leaves (cdr tree))))))
#+end_src

#+name: regmac-controller-count-leaves-1
#+begin_src scheme :exports code :results none
(controller
   (assign continue (label finale))
   count-leaves-loop
   (test (op null?) (reg tree))
   (branch (label case-null))
   (test (op notpair?) (reg tree))
   (branch (label case-leaf))
   (save continue)
   (save tree)
   (assign continue (label after-first-rec-call))
   (assign tree (op car) (reg tree))
   (goto (label count-leaves-loop))
after-first-rec-call
   (assign subresult1 (reg result))
   (restore tree)
   (assign tree (op cdr) (reg tree))
   (save subresult1)
   (assign continue (label after-second-rec-call))
   (goto (label count-leaves-loop))
after-second-rec-call
   (assign subresult2 (reg result))
   (restore subresult1)
   (restore continue)
   (assign result (op +) (reg subresult1) (reg subresult2))
   (goto (reg continue))
case-null
   (assign result (const 0))
   (goto (reg continue))
case-leaf
   (assign result (const 1))
   (goto (reg continue))
finale
   (perform (op print) (const "\nResult=") (reg result))
end)
#+end_src

#+header: :stdin empty
#+begin_src shell :shebang "#! /usr/bin/chibi-scheme" :exports both :results output scalar code
      <<regmac-glue1>>
      <<regmac-make-machine>>
      <<regmac-make-register-tracing>>
      <<regmac-make-stack-with-performance>>
      <<regmac-make-new-machine-with-metadata-instr-count-trace-labels-brk>>
      <<regmac-extract-labels-improved-labels-brk>>
      <<regmac-assembler-with-metadata-register-labels-brk>>
      <<regmac-generating-execution-procedures>>
      <<regmac-make-operation-exp-improved>>
      <<regmac-make-operation-exp-syntax>>
      <<regmac-make-assign>>
      <<regmac-make-test>>
      <<regmac-make-save-restore>>
      <<regmac-other-instructions>>

      (define machine
	(make-machine
	 '()
	 (list (list '= =)
               (list '< <)
               (list '- -)
               (list '+ +)
               (list '* *)
	       (list 'null? null?)
               (list 'print (lambda (x . o)
                                       (display x) (map display o)) 'done)
               (list 'rem remainder)
               (list 'notpair? (lambda (x) (not (pair? x))))
               (list 'car car)
               (list 'cdr cdr)
	       )
	 (quote
<<regmac-controller-count-leaves-1>>
    )))
;      (cancel-all-breakpoints machine)
;      (set-breakpoint machine 'test-b 4)
;      ((get-register machine 'continue) 'trace-on)
;      (machine 'trace-on)
;      (machine 'labels-on)
      (set-register-contents! machine 'tree (cons (cons 4 4) (cons 1 2)))
      (start machine)
      ;; returning from a breakpoint
;      (proceed-machine gcd-machine)

#+end_src

#+RESULTS[5c00e912fb039ea0d648b9795f437c413314ed4f]:
#+begin_src shell

Result=4
#+end_src

Seems to work.

***** b. Recursive count-leaves with explicit counter:

#+begin_src scheme :exports code :results none
  (define (count-leaves tree)
    (define (count-iter tree n)
      (cond ((null? tree) n)
	    ((not (pair? tree)) (+ n 1))
	    (else
	     (count-iter (cdr tree)
			 (count-iter (car tree)
				     n)))))
    (count-iter tree 0))
#+end_src

#+name: regmac-controller-count-leaves-iterative
#+begin_src scheme :exports code :results none
(controller
   (assign continue (label finale))
   (assign n (const 0))
count-iter
   (test (op null?) (reg tree))
   (branch (label case-null))
   (test (op notpair?) (reg tree))
   (branch (label case-notpair))
   ;;else
   (assign operand (op cdr) (reg tree))
   (save operand)
   (assign tree (op car) (reg tree))
   (save continue)
   (assign continue (label after-call))
   (goto (label count-iter))
after-call
   (restore continue)
   (restore operand)
   (assign tree (reg operand))
   (goto (label count-iter))
case-notpair
   (assign n (op +) (reg n) (const 1))
   (goto (reg continue))
case-null
   (goto (reg continue))
finale
   (perform (op print) (const "\nResult=") (reg n))
end
)
#+end_src

#+header: :stdin empty
#+begin_src shell :shebang "#! /usr/bin/chibi-scheme" :exports both :results output scalar code
      <<regmac-glue1>>
      <<regmac-make-machine>>
      <<regmac-make-register-tracing>>
      <<regmac-make-stack-with-performance>>
      <<regmac-make-new-machine-with-metadata-instr-count-trace-labels-brk>>
      <<regmac-extract-labels-improved-labels-brk>>
      <<regmac-assembler-with-metadata-register-labels-brk>>
      <<regmac-generating-execution-procedures>>
      <<regmac-make-operation-exp-improved>>
      <<regmac-make-operation-exp-syntax>>
      <<regmac-make-assign>>
      <<regmac-make-test>>
      <<regmac-make-save-restore>>
      <<regmac-other-instructions>>

      (define machine
	(make-machine
	 '()
	 (list (list '= =)
               (list '< <)
               (list '- -)
               (list '+ +)
               (list '* *)
	       (list 'null? null?)
               (list 'print (lambda (x . o)
                                       (display x) (map display o)) 'done)
               (list 'rem remainder)
               (list 'notpair? (lambda (x) (not (pair? x))))
               (list 'car car)
               (list 'cdr cdr)
	       )
	 (quote
<<regmac-controller-count-leaves-iterative>>
    )))
;      (cancel-all-breakpoints machine)
;      (set-breakpoint machine 'test-b 4)
;      ((get-register machine 'continue) 'trace-on)
      (machine 'trace-on)
      (machine 'labels-on)
      (set-register-contents! machine 'tree (cons (cons 4 4) (cons 1 2)))
      (start machine)
      ;; returning from a breakpoint
;      (proceed-machine machine)

#+end_src

#+RESULTS[b1ad33c1858e66fcd9687c7f0d28aaebfdd2cbe3]:
#+begin_src shell

labels: (controller)
instruction text: (assign continue (label finale))
instruction text: (assign n (const 0))
labels: (count-iter)
instruction text: (test (op null?) (reg tree))
instruction text: (branch (label case-null))
instruction text: (test (op notpair?) (reg tree))
instruction text: (branch (label case-notpair))
instruction text: (assign operand (op cdr) (reg tree))
instruction text: (save operand)
instruction text: (assign tree (op car) (reg tree))
instruction text: (save continue)
instruction text: (assign continue (label after-call))
instruction text: (goto (label count-iter))
labels: (count-iter)
instruction text: (test (op null?) (reg tree))
instruction text: (branch (label case-null))
instruction text: (test (op notpair?) (reg tree))
instruction text: (branch (label case-notpair))
instruction text: (assign operand (op cdr) (reg tree))
instruction text: (save operand)
instruction text: (assign tree (op car) (reg tree))
instruction text: (save continue)
instruction text: (assign continue (label after-call))
instruction text: (goto (label count-iter))
labels: (count-iter)
instruction text: (test (op null?) (reg tree))
instruction text: (branch (label case-null))
instruction text: (test (op notpair?) (reg tree))
instruction text: (branch (label case-notpair))
labels: (case-notpair)
instruction text: (assign n (op +) (reg n) (const 1))
instruction text: (goto (reg continue))
labels: (after-call)
instruction text: (restore continue)
instruction text: (restore operand)
instruction text: (assign tree (reg operand))
instruction text: (goto (label count-iter))
labels: (count-iter)
instruction text: (test (op null?) (reg tree))
instruction text: (branch (label case-null))
instruction text: (test (op notpair?) (reg tree))
instruction text: (branch (label case-notpair))
labels: (case-notpair)
instruction text: (assign n (op +) (reg n) (const 1))
instruction text: (goto (reg continue))
labels: (after-call)
instruction text: (restore continue)
instruction text: (restore operand)
instruction text: (assign tree (reg operand))
instruction text: (goto (label count-iter))
labels: (count-iter)
instruction text: (test (op null?) (reg tree))
instruction text: (branch (label case-null))
instruction text: (test (op notpair?) (reg tree))
instruction text: (branch (label case-notpair))
instruction text: (assign operand (op cdr) (reg tree))
instruction text: (save operand)
instruction text: (assign tree (op car) (reg tree))
instruction text: (save continue)
instruction text: (assign continue (label after-call))
instruction text: (goto (label count-iter))
labels: (count-iter)
instruction text: (test (op null?) (reg tree))
instruction text: (branch (label case-null))
instruction text: (test (op notpair?) (reg tree))
instruction text: (branch (label case-notpair))
labels: (case-notpair)
instruction text: (assign n (op +) (reg n) (const 1))
instruction text: (goto (reg continue))
labels: (after-call)
instruction text: (restore continue)
instruction text: (restore operand)
instruction text: (assign tree (reg operand))
instruction text: (goto (label count-iter))
labels: (count-iter)
instruction text: (test (op null?) (reg tree))
instruction text: (branch (label case-null))
instruction text: (test (op notpair?) (reg tree))
instruction text: (branch (label case-notpair))
labels: (case-notpair)
instruction text: (assign n (op +) (reg n) (const 1))
instruction text: (goto (reg continue))
labels: (finale)
instruction text: (perform (op print) (const "\nResult=") (reg n))
Result=4
#+end_src

Turned out to be even easier.

**** DONE Exercise 5.22 ~append~ and ~append!~ as register machines
     CLOSED: [2020-03-01 Sun 14:11]

***** a ~append~

#+begin_src scheme :exports code :results none
  (define (append x y)
    (if (null? x)
	y
	(cons (car x) (append (cdr x) y))))
#+end_src

#+name: regmac-controller-append
#+begin_src scheme :exports code :results none
(controller
    (assign continue (label finale))
append
    (test (op null?) (reg x))
    (branch (label null-case))
    (assign operand (op car) (reg x))
    (save operand)
    (assign x (op cdr) (reg x))
    (save continue)
    (assign continue (label after-call))
    (goto (label append))
after-call
    (restore continue)
    (restore operand)
    (assign y (op cons) (reg operand) (reg y))
    (goto (reg continue))
null-case
    (goto (reg continue))
finale
    (perform (op print) (const "\nResult=") (reg y))
end)

#+end_src

#+header: :stdin empty
#+begin_src shell :shebang "#! /usr/bin/chibi-scheme" :exports both :results output scalar code
      <<regmac-glue1>>
      <<regmac-make-machine>>
      <<regmac-make-register-tracing>>
      <<regmac-make-stack-with-performance>>
      <<regmac-make-new-machine-with-metadata-instr-count-trace-labels-brk>>
      <<regmac-extract-labels-improved-labels-brk>>
      <<regmac-assembler-with-metadata-register-labels-brk>>
      <<regmac-generating-execution-procedures>>
      <<regmac-make-operation-exp-improved>>
      <<regmac-make-operation-exp-syntax>>
      <<regmac-make-assign>>
      <<regmac-make-test>>
      <<regmac-make-save-restore>>
      <<regmac-other-instructions>>

      (define machine
	(make-machine
	 '()
	 (list (list '= =)
               (list '< <)
               (list '- -)
               (list '+ +)
               (list '* *)
	       (list 'null? null?)
               (list 'print (lambda (x . o)
                                       (display x) (map display o)) 'done)
               (list 'rem remainder)
               (list 'notpair? (lambda (x) (not (pair? x))))
               (list 'car car)
               (list 'cdr cdr)
               (list 'cons cons)
	       )
	 (quote
<<regmac-controller-append>>
    )))
;      (cancel-all-breakpoints machine)
;      (set-breakpoint machine 'test-b 4)
;      ((get-register machine 'continue) 'trace-on)
      (machine 'trace-on)
      (machine 'labels-on)
      (set-register-contents! machine 'x '(1 2 3 4))
      (set-register-contents! machine 'y '(a b c d))

      (start machine)
      ;; returning from a breakpoint
;      (proceed-machine machine)

#+end_src

#+RESULTS[cb448908aab5cbd54cc598d67a6bc898646b3a46]:
#+begin_src shell

labels: (controller)
instruction text: (assign continue (label finale))
labels: (append)
instruction text: (test (op null?) (reg x))
instruction text: (branch (label null-case))
instruction text: (assign operand (op car) (reg x))
instruction text: (save operand)
instruction text: (assign x (op cdr) (reg x))
instruction text: (save continue)
instruction text: (assign continue (label after-call))
instruction text: (goto (label append))
labels: (append)
instruction text: (test (op null?) (reg x))
instruction text: (branch (label null-case))
instruction text: (assign operand (op car) (reg x))
instruction text: (save operand)
instruction text: (assign x (op cdr) (reg x))
instruction text: (save continue)
instruction text: (assign continue (label after-call))
instruction text: (goto (label append))
labels: (append)
instruction text: (test (op null?) (reg x))
instruction text: (branch (label null-case))
instruction text: (assign operand (op car) (reg x))
instruction text: (save operand)
instruction text: (assign x (op cdr) (reg x))
instruction text: (save continue)
instruction text: (assign continue (label after-call))
instruction text: (goto (label append))
labels: (append)
instruction text: (test (op null?) (reg x))
instruction text: (branch (label null-case))
instruction text: (assign operand (op car) (reg x))
instruction text: (save operand)
instruction text: (assign x (op cdr) (reg x))
instruction text: (save continue)
instruction text: (assign continue (label after-call))
instruction text: (goto (label append))
labels: (append)
instruction text: (test (op null?) (reg x))
instruction text: (branch (label null-case))
labels: (null-case)
instruction text: (goto (reg continue))
labels: (after-call)
instruction text: (restore continue)
instruction text: (restore operand)
instruction text: (assign y (op cons) (reg operand) (reg y))
instruction text: (goto (reg continue))
labels: (after-call)
instruction text: (restore continue)
instruction text: (restore operand)
instruction text: (assign y (op cons) (reg operand) (reg y))
instruction text: (goto (reg continue))
labels: (after-call)
instruction text: (restore continue)
instruction text: (restore operand)
instruction text: (assign y (op cons) (reg operand) (reg y))
instruction text: (goto (reg continue))
labels: (after-call)
instruction text: (restore continue)
instruction text: (restore operand)
instruction text: (assign y (op cons) (reg operand) (reg y))
instruction text: (goto (reg continue))
labels: (finale)
instruction text: (perform (op print) (const "\nResult=") (reg y))
Result=(1 2 3 4 a b c d)
#+end_src

Seems to work.

***** b ~append!~

#+begin_src scheme :exports code :results none
  (define (append! x y)
    (set-cdr! (last-pair x) y)
    x)
#+end_src

I will borrow the ~last-pair~ operation from the ~(scheme list)~.

#+name: regmac-controller-append!
#+begin_src scheme :exports code :results none
(controller
  (assign retval (reg x))
  (assign x (op last-pair) (reg x))
  (perform (op set-cdr!) (reg x) (reg y))
  (perform (op print) (const "\nResult=") (reg retval))
end)
#+end_src

#+header: :stdin empty
#+begin_src shell :shebang "#! /usr/bin/chibi-scheme" :exports both :results output scalar code
      <<regmac-glue1>>
      <<regmac-make-machine>>
      <<regmac-make-register-tracing>>
      <<regmac-make-stack-with-performance>>
      <<regmac-make-new-machine-with-metadata-instr-count-trace-labels-brk>>
      <<regmac-extract-labels-improved-labels-brk>>
      <<regmac-assembler-with-metadata-register-labels-brk>>
      <<regmac-generating-execution-procedures>>
      <<regmac-make-operation-exp-improved>>
      <<regmac-make-operation-exp-syntax>>
      <<regmac-make-assign>>
      <<regmac-make-test>>
      <<regmac-make-save-restore>>
      <<regmac-other-instructions>>

      (define machine
	(make-machine
	 '()
	 (list (list '= =)
               (list '< <)
               (list '- -)
               (list '+ +)
               (list '* *)
	       (list 'null? null?)
               (list 'print (lambda (x . o)
                                       (display x) (map display o)) 'done)
               (list 'rem remainder)
               (list 'notpair? (lambda (x) (not (pair? x))))
               (list 'car car)
               (list 'cdr cdr)
               (list 'cons cons)
               (list 'set-cdr! set-cdr!)
               (list 'last-pair last-pair)
	       )
	 (quote
<<regmac-controller-append!>>
    )))
;      (cancel-all-breakpoints machine)
;      (set-breakpoint machine 'test-b 4)
;      ((get-register machine 'continue) 'trace-on)
      (machine 'trace-on)
      (machine 'labels-on)
      (set-register-contents! machine 'x (list 1 2 3 4))
      (set-register-contents! machine 'y '(a b c d))

      (start machine)
      ;; returning from a breakpoint
;      (proceed-machine machine)

#+end_src

#+RESULTS[c51e23461b18930eec34db9750a89edd63bba025]:
#+begin_src shell

labels: (controller)
instruction text: (assign retval (reg x))
instruction text: (assign x (op last-pair) (reg x))
instruction text: (perform (op set-cdr!) (reg x) (reg y))
instruction text: (perform (op print) (const "\nResult=") (reg retval))
Result=(1 2 3 4 a b c d)
#+end_src

Seems to work.

*** 5.4 The Explicit-Control Evaluator [8/8]
**** Common code
     :PROPERTIES:
     :ORDERED:  t
     :END:

#+name: ec-solutionbook-error
#+begin_src scheme :exports code :results none
(perform (op error) (const "The code should not reach here"))
#+end_src

#+name: ec-eval-dispatch
#+begin_src scheme :exports code :results none
  eval-dispatch
  (test (op self-evaluating?) (reg exp))
  (branch (label ev-self-eval))
  (test (op variable?) (reg exp))
  (branch (label ev-variable))
  (test (op quoted?) (reg exp))
  (branch (label ev-quoted))
  (test (op assignment?) (reg exp))
  (branch (label ev-assignment))
  (test (op definition?) (reg exp))
  (branch (label ev-definition))
  (test (op if?) (reg exp))
  (branch (label ev-if))
  (test (op lambda?) (reg exp))
  (branch (label ev-lambda))
  (test (op begin?) (reg exp))
  (branch (label ev-begin))
  (test (op application?) (reg exp))
  (branch (label ev-application))
  (goto (label unknown-expression-type))
#+end_src

#+name: ec-simple-expressions
#+begin_src scheme :exports code :results none
  ev-self-eval
  (assign val (reg exp))
  (goto (reg continue))
  ev-variable
  (assign val (op lookup-variable-value) (reg exp) (reg env))
  (goto (reg continue))
  ev-quoted
  (assign val (op text-of-quotation) (reg exp))
  (goto (reg continue))
  ev-lambda
  (assign unev (op lambda-parameters) (reg exp))
  (assign exp (op lambda-body) (reg exp))
  (assign val (op make-procedure) (reg unev) (reg exp) (reg env))
  (goto (reg continue))
#+end_src

#+name: ec-ev-application
#+begin_src scheme :exports code :results none
ev-application
(save continue)
(save env)
(assign unev (op operands) (reg exp))
(save unev)
(assign exp (op operator) (reg exp))
(assign continue (label ev-appl-did-operator))
(goto (label eval-dispatch))
#+end_src

#+name: ec-s-additional-syntax
#+begin_src scheme :exports code :results none
(define (empty-arglist) '())
(define (adjoin-arg arg arglist) (append arglist (list arg)))
(define (last-operand? ops) (null? (cdr ops)))
#+end_src

#+name: ec-ev-appl-did-operator
#+begin_src scheme :exports code :results none
ev-appl-did-operator
(restore unev) ; the operands
(restore env)
(assign argl (op empty-arglist))
(assign proc (reg val)) ; the operator
(test (op no-operands?) (reg unev))
(branch (label apply-dispatch))
(save proc)
#+end_src

#+name: ec-ev-appl-operand-loop
#+begin_src scheme :exports code :results none
ev-appl-operand-loop
(save argl)
(assign exp (op first-operand) (reg unev))
(test (op last-operand?) (reg unev))
(branch (label ev-appl-last-arg))
(save env)
(save unev)
(assign continue (label ev-appl-accumulate-arg))
(goto (label eval-dispatch))
#+end_src

#+name: ec-ev-appl-accumulate-arg
#+begin_src scheme :exports code :results none
ev-appl-accumulate-arg
(restore unev)
(restore env)
(restore argl)
(assign argl (op adjoin-arg) (reg val) (reg argl))
(assign unev (op rest-operands) (reg unev))
(goto (label ev-appl-operand-loop))
#+end_src

#+name: ec-ev-appl-last-arg
#+begin_src scheme :exports code :results none
ev-appl-last-arg
(assign continue (label ev-appl-accum-last-arg))
(goto (label eval-dispatch))
#+end_src

#+name: ec-ev-appl-accum-last-arg
#+begin_src scheme :exports code :results none
ev-appl-accum-last-arg
(restore argl)
(assign argl (op adjoin-arg) (reg val) (reg argl))
(restore proc)
(goto (label apply-dispatch))
#+end_src

#+name: ec-apply-dispatch
#+begin_src scheme :exports code :results none
apply-dispatch
(test (op primitive-procedure?) (reg proc))
(branch (label primitive-apply))
(test (op compound-procedure?) (reg proc))
(branch (label compound-apply))
(goto (label unknown-procedure-type))
#+end_src

#+name: ec-primitive-apply
#+begin_src scheme :exports code :results none
primitive-apply
(assign val (op apply-primitive-procedure) (reg proc) (reg argl))
(restore continue)
(goto (reg continue))
#+end_src

#+name: ec-compound-apply
#+begin_src scheme :exports code :results none
compound-apply
(assign unev (op procedure-parameters) (reg proc))
(assign env (op procedure-environment) (reg proc))
(assign env (op extend-environment)
(reg unev) (reg argl) (reg env))
(assign unev (op procedure-body) (reg proc))
(goto (label ev-sequence))
#+end_src

#+name: ec-ev-begin
#+begin_src scheme :exports code :results none
ev-begin
(assign unev (op begin-actions) (reg exp))
(save continue)
(goto (label ev-sequence))
#+end_src

#+name: ec-ev-sequence
#+begin_src scheme :exports code :results none
ev-sequence
(assign exp (op first-exp) (reg unev))
(test (op last-exp?) (reg unev))
(branch (label ev-sequence-last-exp))
(save unev)
(save env)
(assign continue (label ev-sequence-continue))
(goto (label eval-dispatch))
#+end_src

#+name: ec-ev-sequence-continue
#+begin_src scheme :exports code :results none
ev-sequence-continue
(restore env)
(restore unev)
(assign unev (op rest-exps) (reg unev))
(goto (label ev-sequence))
ev-sequence-last-exp
(restore continue)
(goto (label eval-dispatch))
#+end_src

#+name: ec-ev-if
#+begin_src scheme :exports code :results none
ev-if
(save exp) ; save expression for later
(save env)
(save continue)
(assign continue (label ev-if-decide))
(assign exp (op if-predicate) (reg exp))
(goto (label eval-dispatch)) ; evaluate the predicate
#+end_src

#+name: ec-ev-if-decide
#+begin_src scheme :exports code :results none
ev-if-decide
(restore continue)
(restore env)
(restore exp)
(test (op true?) (reg val))
(branch (label ev-if-consequent))
ev-if-alternative
(assign exp (op if-alternative) (reg exp))
(goto (label eval-dispatch))
ev-if-consequent
(assign exp (op if-consequent) (reg exp))
(goto (label eval-dispatch))
#+end_src

#+name: ec-ev-assignment
#+begin_src scheme :exports code :results none
ev-assignment
(assign unev (op assignment-variable) (reg exp))
(save unev) ; save variable for later
(assign exp (op assignment-value) (reg exp))
(save env)
(save continue)
(assign continue (label ev-assignment-1))
(goto (label eval-dispatch)) ; evaluate the assignment value
ev-assignment-1
(restore continue)
(restore env)
(restore unev)
(perform (op set-variable-value!) (reg unev) (reg val) (reg env))
(assign val (const ok))
(goto (reg continue))
#+end_src

#+name: ec-ev-definition
#+begin_src scheme :exports code :results none
ev-definition
(assign unev (op definition-variable) (reg exp))
(save unev) ; save variable for later
(assign exp (op definition-value) (reg exp))
(save env)
(save continue)
(assign continue (label ev-definition-1))
(goto (label eval-dispatch)) ; evaluate the definition value
ev-definition-1
(restore continue)
(restore env)
(restore unev)
(perform (op define-variable!) (reg unev) (reg val) (reg env))
(assign val (const ok))
(goto (reg continue))
#+end_src

#+name: ec-repl
#+begin_src scheme :exports code :results none
read-eval-print-loop
(perform (op initialize-stack))
(perform (op prompt-for-input) (const ";;EC-Eval input:"))
(assign exp (op read))
(perform (op user-print) (reg exp))
(assign env (op get-global-environment))
(assign continue (label print-result))
(goto (label eval-dispatch))
print-result
(perform (op announce-output) (const ";;EC-Eval value:"))
(perform (op user-print) (reg val))
(goto (label read-eval-print-loop))
#+end_src

#+name: ec-errors
#+begin_src scheme :exports code :results none
unknown-expression-type
(assign val (const unknown-expression-type-error))
(goto (label signal-error))
unknown-procedure-type
(restore continue) ; clean up stack (from apply-dispatch )
(assign val (const unknown-procedure-type-error))
(goto (label signal-error))
signal-error
(perform (op user-print) (reg val))
(goto (label read-eval-print-loop))
#+end_src

#+name: ec-glue1
#+begin_src scheme :exports code :results none
  (import (scheme small))
  (import (scheme list))
  (import (srfi 159))
  (import (srfi 27))
  (define false #t)
  (define true #t)
  (define (tagged-list? exp tag)
	      (if (pair? exp)
		  (eq? (car exp) tag)
		  false))
  (define apply-in-underlying-scheme apply)

#+end_src

#+name: ec-eceval-operations-basic
#+begin_src scheme :exports code :results none
(list 'self-evaluating? self-evaluating?)
(list 'car car)
(list 'cdr cdr)
(list 'cons cons)
(list 'prompt-for-input prompt-for-input)
(list 'announce-output announce-output)
(list 'exit exit)
(list 'get-global-environment get-global-environment)
(list 'self-evaluating? self-evaluating?)
(list 'quoted? quoted?)
(list 'variable? variable?)
(list 'assignment? assignment?)
(list 'definition? definition?)
(list 'if? if?)
(list 'lambda? lambda?)
(list 'begin? begin?)
(list 'application? application?)
(list 'lookup-variable-value lookup-variable-value)
(list 'text-of-quotation text-of-quotation)
(list 'lambda-parameters lambda-parameters)
(list 'lambda-body lambda-body)
(list 'make-procedure make-procedure)
(list 'operands operands)
(list 'operator operator)
(list 'empty-arglist empty-arglist)
(list 'no-operands? no-operands?)
(list 'last-operand? last-operand?)
(list 'first-operand first-operand)
(list 'adjoin-arg adjoin-arg)
(list 'rest-operands rest-operands)
(list 'primitive-procedure? primitive-procedure?)
(list 'compound-procedure? compound-procedure?)
(list 'apply-primitive-procedure apply-primitive-procedure)
(list 'procedure-parameters procedure-parameters)
(list 'procedure-environment procedure-environment)
(list 'extend-environment extend-environment)
(list 'procedure-body procedure-body)
(list 'begin-actions begin-actions)
(list 'first-exp first-exp)
(list 'last-exp? last-exp?)
(list 'rest-exps rest-exps)
(list 'if-predicate if-predicate)
(list 'true? true?)
(list 'if-alternative if-alternative)
(list 'if-consequent if-consequent)
(list 'assignment-variable assignment-variable)
(list 'assignment-value assignment-value)
(list 'set-variable-value! set-variable-value!)
(list 'definition-variable definition-variable)
(list 'definition-value definition-value)
(list 'define-variable! define-variable!)
(list 'read read)
(list 'user-print user-print)
(list 'error error)

#+end_src

#+name: ec-eceval
#+begin_src scheme :exports code :results none
  <<ec-glue1>>
  <<s-truefalse>>
  <<ec-s-additional-syntax>>
  <<s-syntax>>
  <<s-application>>
  <<s-environments>>
  <<s-compound-procedures>>
  <<s-primitive-procedures>>
  <<s-user-prompt-print>>
  <<regmac-glue1>>
  <<regmac-make-machine>>
  <<regmac-make-register-tracing>>
  <<regmac-make-stack-with-performance>>
  <<regmac-make-new-machine-with-metadata-instr-count-trace-labels-brk>>
  <<regmac-extract-labels-improved-labels-brk>>
  <<regmac-assembler-with-metadata-register-labels-brk>>
  <<regmac-generating-execution-procedures>>
  <<regmac-make-operation-exp-improved>>
  <<regmac-make-operation-exp-syntax>>
  <<regmac-make-assign>>
  <<regmac-make-test>>
  <<regmac-make-save-restore>>
  <<regmac-other-instructions>>

      (define the-global-environment (setup-environment))
      (define (get-global-environment) the-global-environment)
      (define eceval-operations
	(list
  <<ec-eceval-operations-basic>>
    ))

  (define eceval
	(make-machine
	 '() ;'(exp env val proc argl continue unev)
	 eceval-operations
	 (quote (
  <<ec-repl>>
  <<ec-errors>>
  <<ec-ev-definition>>
  <<ec-ev-assignment>>
  <<ec-ev-if>>
  <<ec-ev-if-decide>>
  <<ec-ev-sequence>>
  <<ec-ev-sequence-continue>>
  <<ec-ev-begin>>
  <<ec-compound-apply>>
  <<ec-primitive-apply>>
  <<ec-ev-application>>
  <<ec-ev-appl-did-operator>>
  <<ec-ev-appl-operand-loop>>
  <<ec-ev-appl-accumulate-arg>>
  <<ec-ev-appl-last-arg>>
  <<ec-ev-appl-accum-last-arg>>
  <<ec-solutionbook-error>>
  <<ec-apply-dispatch>>
  <<ec-solutionbook-error>>
  <<ec-simple-expressions>>
  <<ec-solutionbook-error>>
  <<ec-eval-dispatch>>
  <<ec-solutionbook-error>>
    ))))

#+end_src

#+name: eceval-test-append
#+begin_src shell :exports code :results verbatim output
cat <<EOF
  (define (append x y)
    (if (null? x) y (cons (car x) (append (cdr x) y))))
  (append '(a b c) '(d e f))
  (exit)
EOF
#+end_src

#+header: :stdin eceval-test-append
#+begin_src shell :shebang "#!/usr/bin/chibi-scheme" :exports code :results output scalar code
<<ec-eceval>>
(start eceval)
#+end_src

#+RESULTS[6038665e29fe0da95c8c5ee492dd0b73174980ee]:
#+begin_src shell

;;EC-Eval input:
(define (append x y) (if (null? x) y (cons (car x) (append (cdr x) y))))
;;EC-Eval value:
ok
;;EC-Eval input:
(append (quote (a b c)) (quote (d e f)))
;;EC-Eval value:
(a b c d e f)
;;EC-Eval input:
(exit)
#+end_src

**** DONE Exercise 5.23 Extending EC-evaluator with ~let~ and ~cond~
     CLOSED: [2020-03-02 Mon 10:52]

~let~'s basic SICP implementation is in the s-let-implementation block.

#+name: ec-eval-dispatch-let-cond
#+begin_src scheme :exports code :results none
  eval-dispatch
  (test (op self-evaluating?) (reg exp))
  (branch (label ev-self-eval))
  (test (op variable?) (reg exp))
  (branch (label ev-variable))
  (test (op quoted?) (reg exp))
  (branch (label ev-quoted))
  (test (op assignment?) (reg exp))
  (branch (label ev-assignment))
  (test (op definition?) (reg exp))
  (branch (label ev-definition))
  (test (op if?) (reg exp))
  (branch (label ev-if))
  (test (op lambda?) (reg exp))
  (branch (label ev-lambda))
  (test (op begin?) (reg exp))
  (branch (label ev-begin))
  ;; added
  (test (op let?) (reg exp))
  (branch (label ev-let))
  (test (op cond?) (reg exp))
  (branch (label ev-cond))
  ;; end
  (test (op application?) (reg exp))
  (branch (label ev-application))
  (goto (label unknown-expression-type))
  ;; added
ev-let
  (assign exp (op let->combination) (reg exp))
  ;(save continue)
  (goto (label eval-dispatch))
ev-cond
  (assign exp (op cond->if) (reg exp))
  (goto (label eval-dispatch))
  ;; end
#+end_src

#+name: ec-eceval-operations-let-cond
#+begin_src scheme :exports code :results none
(list 'let? let?)
(list 'let->combination let->combination)
(list 'cond? cond?)
(list 'cond->if cond->if)
#+end_src

#+name: eceval-test-let-cond
#+begin_src shell :exports code :results verbatim output
cat <<EOF
  (define (append x y)
    (if (null? x) y (cons (car x) (append (cdr x) y))))
  (append '(a b c) '(d e f))
  (let ((a 1))
    a)
  (cond ((= 1 0) #f)
        ((= 1 1) #t)
        (else "Arithmetic is broken"))
  (exit)
EOF
#+end_src

#+header: :stdin eceval-test-let-cond
#+begin_src shell :shebang "#!/usr/bin/chibi-scheme" :exports code :results output scalar code
  <<ec-glue1>>
  <<s-truefalse>>
  <<ec-s-additional-syntax>>
  <<s-syntax>>
  <<s-application>>
  <<s-environments>>
  <<s-compound-procedures>>
  <<s-primitive-procedures>>
  <<s-let-implementation>>
  <<s-cond>>
  <<s-user-prompt-print>>
  <<regmac-glue1>>
  <<regmac-make-machine>>
  <<regmac-make-register-tracing>>
  <<regmac-make-stack-with-performance>>
  <<regmac-make-new-machine-with-metadata-instr-count-trace-labels-brk>>
  <<regmac-extract-labels-improved-labels-brk>>
  <<regmac-assembler-with-metadata-register-labels-brk>>
  <<regmac-generating-execution-procedures>>
  <<regmac-make-operation-exp-improved>>
  <<regmac-make-operation-exp-syntax>>
  <<regmac-make-assign>>
  <<regmac-make-test>>
  <<regmac-make-save-restore>>
  <<regmac-other-instructions>>

      (define the-global-environment (setup-environment))
      (define (get-global-environment) the-global-environment)
      (define eceval-operations
	(list
  <<ec-eceval-operations-basic>>
  <<ec-eceval-operations-let-cond>>
    ))

  (define eceval
	(make-machine
	 '() ;'(exp env val proc argl continue unev)
	 eceval-operations
	 (quote (
  <<ec-repl>>
  <<ec-errors>>
  <<ec-ev-definition>>
  <<ec-ev-assignment>>
  <<ec-ev-if>>
  <<ec-ev-if-decide>>
  <<ec-ev-sequence>>
  <<ec-ev-sequence-continue>>
  <<ec-ev-begin>>
  <<ec-compound-apply>>
  <<ec-primitive-apply>>
  <<ec-ev-application>>
  <<ec-ev-appl-did-operator>>
  <<ec-ev-appl-operand-loop>>
  <<ec-ev-appl-accumulate-arg>>
  <<ec-ev-appl-last-arg>>
  <<ec-ev-appl-accum-last-arg>>
  <<ec-solutionbook-error>>
  <<ec-apply-dispatch>>
  <<ec-solutionbook-error>>
  <<ec-simple-expressions>>
  <<ec-solutionbook-error>>
  <<ec-eval-dispatch-let-cond>>
  <<ec-solutionbook-error>>
    ))))
(start eceval)

#+end_src

#+RESULTS[f925f384aaff16904811f5ac6e428815c6e2bcf8]:
#+begin_src shell

;;EC-Eval input:
(define (append x y) (if (null? x) y (cons (car x) (append (cdr x) y))))
;;EC-Eval value:
ok
;;EC-Eval input:
(append (quote (a b c)) (quote (d e f)))
;;EC-Eval value:
(a b c d e f)
;;EC-Eval input:
(let ((a 1)) a)
;;EC-Eval value:
1
;;EC-Eval input:
(cond ((= 1 0) #f) ((= 1 1) #t) (else "Arithmetic is broken"))
;;EC-Eval value:
#t
;;EC-Eval input:
(exit)
#+end_src

Turned out to be not too hard.

**** DONE Exercise 5.24 Making ~cond~ a primitive
     CLOSED: [2020-03-02 Mon 14:42]

#+name: ec-eval-dispatch-let-cond-primitive
#+begin_src scheme :exports code :results none
  eval-dispatch
  (test (op self-evaluating?) (reg exp))
  (branch (label ev-self-eval))
  (test (op variable?) (reg exp))
  (branch (label ev-variable))
  (test (op quoted?) (reg exp))
  (branch (label ev-quoted))
  (test (op assignment?) (reg exp))
  (branch (label ev-assignment))
  (test (op definition?) (reg exp))
  (branch (label ev-definition))
  (test (op if?) (reg exp))
  (branch (label ev-if))
  (test (op lambda?) (reg exp))
  (branch (label ev-lambda))
  (test (op begin?) (reg exp))
  (branch (label ev-begin))
  ;; added
  (test (op let?) (reg exp))
  (branch (label ev-let))
  (test (op cond?) (reg exp))
  (branch (label ev-cond))
  ;; end
  (test (op application?) (reg exp))
  (branch (label ev-application))
  (goto (label unknown-expression-type))
  ;; added
ev-let
  (assign exp (op let->combination) (reg exp))
  (goto (label eval-dispatch))
ev-cond
  ;(assign exp (op cond->if) (reg exp))
  ;(goto (label eval-dispatch))
  (assign exp (op cond-clauses) (reg exp))
ev-cond-process
  (assign unev (op cdr) (reg exp)) ; rest
  (assign exp (op car) (reg exp)) ; first
  (save unev) ; 3
ev-cond-process-one-clause
  (assign unev (op cond-actions) (reg exp))
  (assign exp (op cond-predicate) (reg exp))
  (test (op eq?) (reg exp) (const else))
  (branch (label ev-cond-process-cond-actions))
  (save continue) ; 2
  (assign continue (label ev-cond-after-pred))
  (save unev) ; 1
  (goto (label eval-dispatch))
ev-cond-after-pred
  (restore unev) ; 1 cond-actions
  (restore continue) ; 2
  (test (op true?) (reg val))
  (branch (label ev-cond-process-cond-actions))
  (restore exp) ; rest
  (goto (label ev-cond-process))
ev-cond-process-cond-actions
  (restore exp) ; 3 useless now, clear stack
  (save continue) ;?
  (goto (label ev-sequence))
  ;; end
#+end_src

#+name: ec-eceval-operations-let-cond-primitive
#+begin_src scheme :exports code :results none
(list 'let? let?)
(list 'let->combination let->combination)
(list 'cond? cond?)
(list 'cond-clauses cond-clauses)
(list 'cond-actions cond-actions)
(list 'cond-predicate cond-predicate)
(list 'eq? eq?)
#+end_src

#+header: :stdin eceval-test-let-cond-primitive
#+begin_src shell :shebang "#!/usr/bin/chibi-scheme" :exports code :results output scalar code
  <<ec-glue1>>
  <<s-truefalse>>
  <<ec-s-additional-syntax>>
  <<s-syntax>>
  <<s-application>>
  <<s-environments>>
  <<s-compound-procedures>>
  <<s-primitive-procedures>>
  <<s-let-implementation>>
  <<s-cond>>
  <<s-user-prompt-print>>
  <<regmac-glue1>>
  <<regmac-make-machine>>
  <<regmac-make-register-tracing>>
  <<regmac-make-stack-with-performance>>
  <<regmac-make-new-machine-with-metadata-instr-count-trace-labels-brk>>
  <<regmac-extract-labels-improved-labels-brk>>
  <<regmac-assembler-with-metadata-register-labels-brk>>
  <<regmac-generating-execution-procedures>>
  <<regmac-make-operation-exp-improved>>
  <<regmac-make-operation-exp-syntax>>
  <<regmac-make-assign>>
  <<regmac-make-test>>
  <<regmac-make-save-restore>>
  <<regmac-other-instructions>>

      (define the-global-environment (setup-environment))
      (define (get-global-environment) the-global-environment)
      (define eceval-operations
	(list
  <<ec-eceval-operations-basic>>
  <<ec-eceval-operations-let-cond-primitive>>
    ))

  (define eceval
	(make-machine
	 '() ;'(exp env val proc argl continue unev)
	 eceval-operations
	 (quote (
  <<ec-repl>>
  <<ec-errors>>
  <<ec-ev-definition>>
  <<ec-ev-assignment>>
  <<ec-ev-if>>
  <<ec-ev-if-decide>>
  <<ec-ev-sequence>>
  <<ec-ev-sequence-continue>>
  <<ec-ev-begin>>
  <<ec-compound-apply>>
  <<ec-primitive-apply>>
  <<ec-ev-application>>
  <<ec-ev-appl-did-operator>>
  <<ec-ev-appl-operand-loop>>
  <<ec-ev-appl-accumulate-arg>>
  <<ec-ev-appl-last-arg>>
  <<ec-ev-appl-accum-last-arg>>
  <<ec-solutionbook-error>>
  <<ec-apply-dispatch>>
  <<ec-solutionbook-error>>
  <<ec-simple-expressions>>
  <<ec-solutionbook-error>>
  <<ec-eval-dispatch-let-cond-primitive>>
  <<ec-solutionbook-error>>
    ))))
;((get-register eceval 'val) 'trace-on)
;(eceval 'trace-on)
;(eceval 'labels-on)

(start eceval)

#+end_src

#+RESULTS[d7a0ee0b946a2c5593958d5eacd0d102d3578187]:
#+begin_src shell

;;EC-Eval input:
(cond ((= 1 0) #f) ((= 1 1) #t) (else "Arithmetic is broken"))
;;EC-Eval value:
#t
;;EC-Eval input:
(cond ((= 1 0) #f) (else "Else clause"))
;;EC-Eval value:
"Else clause"
;;EC-Eval input:
(exit)
#+end_src


#+name: eceval-test-let-cond-primitive
#+begin_src shell :exports code :results verbatim output
cat <<EOF
  (cond ((= 1 0) #f)
        ((= 1 1) #t)
        (else "Arithmetic is broken"))
  (cond ((= 1 0) #f)
        (else "Else clause"))
  (exit)
EOF
#+end_src

I used all the de-structuring functions as primitives from the original
metacircular evaluator, but the assembly seems to do the job.

**** DONE Exercise 5.25 Normal-order (lazy) evaluation
     CLOSED: [2020-03-03 Tue 14:57]

#+name: ec-lazy-actual-value-delay-force
#+begin_src scheme :exports code :results none
actual-value
(save continue) ; 1
(assign continue (label actual-value-did-eval))
(goto (label eval-dispatch))
actual-value-did-eval
(restore continue) ; 1
(assign exp (reg val)) ; eval produced a thunk into val
(goto (label force-it))

force-it
(test (op thunk?) (reg exp))
(branch (label force-it-thunk))
(assign val (reg exp)) ; not thunk
(goto (reg continue))
force-it-thunk
(save env) ; 1
(save continue); 2
(assign env (op thunk-env) (reg exp))
(assign exp (op thunk-exp) (reg exp))
(assign continue (label force-it-return))
(goto (label actual-value))
force-it-return
(restore continue) ;2
(restore env) ; 1
(goto (reg continue))

delay-it
(assign val (op delay-it) (reg exp) (reg env))
(goto (reg continue))

#+end_src

A great exercise! Made me rethink everything! One difference between
the metacircular evaluator and the explicit control evaluator is that
in the explicit one, the arguments for an application are produced by
~eval~ rather than by ~apply~ itself. Therefore we may keep
~apply-dispatch~ as-is, since it will automatically apply primitive
procedures to eager arguments and compound procedures to lazy
arguments... given that we populate ~argl~ correctly in advance.

#+name: ec-lazy-ev-application
#+begin_src scheme :exports code :results none
  ev-application
  (save continue)
  (save env)
  (assign unev (op operands) (reg exp))
  (save unev)
  (assign exp (op operator) (reg exp))
  (assign continue (label ev-appl-did-operator))
  (goto (label actual-value)) ;
; need to find out if it is a primitive procedure or a
; compound procedure. If primitive, do the ~actual-value~ loop. If compound,
; do a ~delay-it~ loop.
  ev-appl-did-operator
  (restore unev) ; the operands
  (restore env)
  (assign argl (op empty-arglist))
  (assign proc (reg val)) ; the operator, actual value
  (test (op no-operands?) (reg unev))
  (branch (label apply-dispatch))
  (save proc)
  (test (op compound-procedure?) (reg proc))
  (branch (label ev-appl-operand-loop-lazy)) ;
;; eager part
  ev-appl-operand-loop-eager ; primitive-procedure
  (save argl)
  (assign exp (op first-operand) (reg unev))
  (test (op last-operand?) (reg unev))
  (branch (label ev-appl-last-arg-eager))
  (save env)
  (save unev)
  (assign continue (label ev-appl-accumulate-arg-eager))
  (goto (label actual-value)) ; this place has changed
  ev-appl-accumulate-arg-eager
  (restore unev)
  (restore env)
  (restore argl)
  (assign argl (op adjoin-arg) (reg val) (reg argl))
  (assign unev (op rest-operands) (reg unev))
  (goto (label ev-appl-operand-loop-eager))
  ev-appl-last-arg-eager
  (assign continue (label ev-appl-accum-last-arg))
  (goto (label actual-value)) ; this place has changed
;; lazy part
ev-appl-operand-loop-lazy
  (save argl)
  (assign exp (op first-operand) (reg unev))
  (test (op last-operand?) (reg unev))
  (branch (label ev-appl-last-arg-lazy))
  (save env)
  (save unev)
  (assign continue (label ev-appl-accumulate-arg-lazy))
  (goto (label delay-it)) ; this place has changed
  ev-appl-accumulate-arg-lazy
  (restore unev)
  (restore env)
  (restore argl)
  (assign argl (op adjoin-arg) (reg val) (reg argl))
  (assign unev (op rest-operands) (reg unev))
  (goto (label ev-appl-operand-loop-lazy))
  ev-appl-last-arg-lazy
  (assign continue (label ev-appl-accum-last-arg))
  (goto (label delay-it)) ; this place has changed
;; same for both lazy and eager
  ev-appl-accum-last-arg
  (restore argl)
  (assign argl (op adjoin-arg) (reg val) (reg argl))
  (restore proc)
  (goto (label apply-dispatch))
#+end_src

#+name: ec-repl-lazy
#+begin_src scheme :exports code :results none
read-eval-print-loop
(perform (op initialize-stack))
(perform (op prompt-for-input) (const ";;LEC-Eval input:"))
(assign exp (op read))
(perform (op user-print) (reg exp))
(assign env (op get-global-environment))
(assign continue (label print-result))
(goto (label actual-value))
print-result
(perform (op announce-output) (const ";;LEC-Eval value:"))
(perform (op user-print) (reg val))
(goto (label read-eval-print-loop))
#+end_src

#+name: ec-ev-if-lazy
#+begin_src scheme :exports code :results none
  ev-if
  (save exp) ; save expression for later
  (save env)
  (save continue)
  (assign continue (label ev-if-decide))
  (assign exp (op if-predicate) (reg exp))
  (goto (label actual-value)) ; evaluate the predicate
  ev-if-decide
  (restore continue)
  (restore env)
  (restore exp)
  (test (op true?) (reg val))
  (branch (label ev-if-consequent))
  ev-if-alternative
  (assign exp (op if-alternative) (reg exp))
  (goto (label eval-dispatch))
  ev-if-consequent
  (assign exp (op if-consequent) (reg exp))
  (goto (label eval-dispatch))
#+end_src

#+name: ec-eceval-operations-lazy
#+begin_src scheme :exports code :results none
(list 'thunk? thunk?) ; just tagged-list?
(list 'thunk-env thunk-env) ; just cNr
(list 'thunk-exp thunk-exp) ;just cNr
(list 'delay-it delay-it) ;just cons
#+end_src

#+name: eceval-test-lazy
#+begin_src shell :exports code :results verbatim output
cat <<EOF
  (define (append x y)
    (if (null? x) y (cons (car x) (append (cdr x) y))))
  (append '(a b c) '(d e f))
  (let ((a 1))
    a)
  (cond ((= 1 0) #f)
        ((= 1 1) #t)
        (else "Arithmetic is broken"))
  (define (test x y)
      x)
  (test 1 (/ 1 0))
  (exit)
EOF
#+end_src

#+header: :stdin eceval-test-lazy
#+begin_src shell :shebang "#!/usr/bin/chibi-scheme" :exports code :results output scalar code
  <<ec-glue1>>
  <<s-truefalse>>
  <<ec-s-additional-syntax>>
  <<s-syntax>>
  <<s-application>>
  <<s-environments>>
  <<s-compound-procedures>>
  <<s-primitive-procedures>>
  <<s-let-implementation>>
  <<s-cond>>
  <<s-user-prompt-print>>
  (define (delay-it exp env)
    (list 'thunk exp env))
  (define (thunk? obj)
    (tagged-list? obj 'thunk))
  (define (thunk-exp thunk) (cadr thunk))
  (define (thunk-env thunk) (caddr thunk))
  <<regmac-make-machine>>
  <<regmac-make-register-tracing>>
  <<regmac-make-stack-with-performance>>
  <<regmac-make-new-machine-with-metadata-instr-count-trace-labels-brk>>
  <<regmac-extract-labels-improved-labels-brk>>
  <<regmac-assembler-with-metadata-register-labels-brk>>
  <<regmac-generating-execution-procedures>>
  <<regmac-make-operation-exp-improved>>
  <<regmac-make-operation-exp-syntax>>
  <<regmac-make-assign>>
  <<regmac-make-test>>
  <<regmac-make-save-restore>>
  <<regmac-other-instructions>>

(define the-global-environment (setup-environment))
(define (get-global-environment) the-global-environment)
(define eceval-operations
  (list
<<ec-eceval-operations-basic>>
<<ec-eceval-operations-let-cond>>
<<ec-eceval-operations-lazy>>
    ))

  (define eceval
	(make-machine
	 '() ;'(exp env val proc argl continue unev)
	 eceval-operations
	 (quote (
  <<ec-repl-lazy>>
  <<ec-errors>>
;; The equivalent of ~eval~
  <<ec-eval-dispatch-let-cond>>
  <<ec-simple-expressions>>
  <<ec-ev-definition>>
  <<ec-ev-assignment>>
  <<ec-ev-if-lazy>>
  <<ec-ev-sequence>>
  <<ec-ev-sequence-continue>>
  <<ec-ev-begin>>
;; ~list-of-args~ embedded into the ~eval~
  <<ec-lazy-ev-application>>
  <<ec-lazy-actual-value-delay-force>>
;; The equivalent of apply
  <<ec-apply-dispatch>>
  <<ec-compound-apply>>
  <<ec-primitive-apply>>

    ))))

(start eceval)

#+end_src

#+RESULTS[ccbbffed4db981de4f88f15704ba1df11e459b86]:
#+begin_src shell

;;LEC-Eval input:
(define (append x y) (if (null? x) y (cons (car x) (append (cdr x) y))))
;;LEC-Eval value:
ok
;;LEC-Eval input:
(append (quote (a b c)) (quote (d e f)))
;;LEC-Eval value:
(a b c d e f)
;;LEC-Eval input:
(let ((a 1)) a)
;;LEC-Eval value:
1
;;LEC-Eval input:
(cond ((= 1 0) #f) ((= 1 1) #t) (else "Arithmetic is broken"))
;;LEC-Eval value:
#t
;;LEC-Eval input:
(define (test x y) x)
;;LEC-Eval value:
ok
;;LEC-Eval input:
(test 1 (/ 1 0))
;;LEC-Eval value:
1
;;LEC-Eval input:
(exit)
#+end_src

Turned out to be actually much-much easier than I had expected.

**** DONE Exercise 5.26 Explore tail recursion with ~factorial~
     CLOSED: [2020-03-03 Tue 19:38]

#+name: ec-repl-stack-monitor
#+begin_src scheme :exports code :results none
read-eval-print-loop
(perform (op initialize-stack))
(perform (op prompt-for-input) (const "\n;;EC-Eval input:"))
(assign exp (op read))
(perform (op user-print) (reg exp))
(assign env (op get-global-environment))
(assign continue (label print-result))
(goto (label eval-dispatch))
print-result
(perform (op announce-output) (const ";;EC-Eval value:"))
(perform (op user-print) (reg val))
(perform (op print-stack-statistics))
(goto (label read-eval-print-loop))
#+end_src


#+name: eceval-test-factorial-iter
#+begin_src shell :exports code :results verbatim output
  cat <<EOF
  (define (factorial n)
    (define (iter product counter)
      (if (> counter n)
        product
        (iter (* counter product) (+ counter 1))))
    (iter 1 1))
  (factorial 6)
  (factorial 7)
  (factorial 8)
  (factorial 9)
  (exit)
  EOF
#+end_src

#+header: :stdin eceval-test-factorial-iter
#+begin_src shell :shebang "#!/usr/bin/chibi-scheme" :exports code :results output scalar code
  <<ec-glue1>>
  <<s-truefalse>>
  <<ec-s-additional-syntax>>
  <<s-syntax>>
  <<s-application>>
  <<s-environments>>
  <<s-compound-procedures>>
  <<s-primitive-procedures>>
  <<s-let-implementation>>
  <<s-cond>>
  <<s-user-prompt-print>>
  <<regmac-glue1>>
  <<regmac-make-machine>>
  <<regmac-make-register-tracing>>
  <<regmac-make-stack-with-performance>>
  <<regmac-make-new-machine-with-metadata-instr-count-trace-labels-brk>>
  <<regmac-extract-labels-improved-labels-brk>>
  <<regmac-assembler-with-metadata-register-labels-brk>>
  <<regmac-generating-execution-procedures>>
  <<regmac-make-operation-exp-improved>>
  <<regmac-make-operation-exp-syntax>>
  <<regmac-make-assign>>
  <<regmac-make-test>>
  <<regmac-make-save-restore>>
  <<regmac-other-instructions>>

      (define the-global-environment (setup-environment))
      (define (get-global-environment) the-global-environment)
      (define eceval-operations
	(list
  <<ec-eceval-operations-basic>>
  <<ec-eceval-operations-let-cond>>
    ))

  (define eceval
	(make-machine
	 '() ;'(exp env val proc argl continue unev)
	 eceval-operations
	 (quote (
  <<ec-repl-stack-monitor>>
  <<ec-errors>>
  <<ec-ev-definition>>
  <<ec-ev-assignment>>
  <<ec-ev-if>>
  <<ec-ev-if-decide>>
  <<ec-ev-sequence>>
  <<ec-ev-sequence-continue>>
  <<ec-ev-begin>>
  <<ec-compound-apply>>
  <<ec-primitive-apply>>
  <<ec-ev-application>>
  <<ec-ev-appl-did-operator>>
  <<ec-ev-appl-operand-loop>>
  <<ec-ev-appl-accumulate-arg>>
  <<ec-ev-appl-last-arg>>
  <<ec-ev-appl-accum-last-arg>>
  <<ec-apply-dispatch>>
  <<ec-simple-expressions>>
  <<ec-eval-dispatch-let-cond>>

    ))))
(start eceval)

#+end_src

#+RESULTS[6222c86604548d231c2588f610fb7c59f3e0cdc3]:
#+begin_src shell


;;EC-Eval input:
(define (factorial n) (define (iter product counter) (if (> counter n) product (iter (* counter product) (+ counter 1)))) (iter 1 1))
;;EC-Eval value:
ok
(total-pushes = 3 maximum-depth = 3)

;;EC-Eval input:
(factorial 6)
;;EC-Eval value:
720
(total-pushes = 239 maximum-depth = 10)

;;EC-Eval input:
(factorial 7)
;;EC-Eval value:
5040
(total-pushes = 274 maximum-depth = 10)

;;EC-Eval input:
(factorial 8)
;;EC-Eval value:
40320
(total-pushes = 309 maximum-depth = 10)

;;EC-Eval input:
(factorial 9)
;;EC-Eval value:
362880
(total-pushes = 344 maximum-depth = 10)

;;EC-Eval input:
(exit)
#+end_src

I just added the monitor operation into the REPL. Indeed, the depth is
independent of ~n~, and is 10. That's essentially the deepest nested
call we are needing. There are a lot more pushes, evidently.

\[p = 35n+29\]

**** DONE Exercise 5.27 Stack depth for a recursive factorial
     CLOSED: [2020-03-03 Tue 19:49]

#+name: eceval-test-factorial-recursive
#+begin_src shell :exports code :results verbatim output
  cat <<EOF
(define (factorial n)
  (if (= n 1) 1 (* (factorial (- n 1)) n)))
  (factorial 6)
  (factorial 7)
  (factorial 8)
  (factorial 9)
  (exit)
  EOF
#+end_src

#+header: :stdin eceval-test-factorial-recursive
#+begin_src shell :shebang "#!/usr/bin/chibi-scheme" :exports code :results output scalar code
  <<ec-glue1>>
  <<s-truefalse>>
  <<ec-s-additional-syntax>>
  <<s-syntax>>
  <<s-application>>
  <<s-environments>>
  <<s-compound-procedures>>
  <<s-primitive-procedures>>
  <<s-let-implementation>>
  <<s-cond>>
  <<s-user-prompt-print>>
  <<regmac-glue1>>
  <<regmac-make-machine>>
  <<regmac-make-register-tracing>>
  <<regmac-make-stack-with-performance>>
  <<regmac-make-new-machine-with-metadata-instr-count-trace-labels-brk>>
  <<regmac-extract-labels-improved-labels-brk>>
  <<regmac-assembler-with-metadata-register-labels-brk>>
  <<regmac-generating-execution-procedures>>
  <<regmac-make-operation-exp-improved>>
  <<regmac-make-operation-exp-syntax>>
  <<regmac-make-assign>>
  <<regmac-make-test>>
  <<regmac-make-save-restore>>
  <<regmac-other-instructions>>

      (define the-global-environment (setup-environment))
      (define (get-global-environment) the-global-environment)
      (define eceval-operations
	(list
  <<ec-eceval-operations-basic>>
  <<ec-eceval-operations-let-cond>>
    ))

  (define eceval
	(make-machine
	 '() ;'(exp env val proc argl continue unev)
	 eceval-operations
	 (quote (
  <<ec-repl-stack-monitor>>
  <<ec-errors>>
  <<ec-ev-definition>>
  <<ec-ev-assignment>>
  <<ec-ev-if>>
  <<ec-ev-if-decide>>
  <<ec-ev-sequence>>
  <<ec-ev-sequence-continue>>
  <<ec-ev-begin>>
  <<ec-compound-apply>>
  <<ec-primitive-apply>>
  <<ec-ev-application>>
  <<ec-ev-appl-did-operator>>
  <<ec-ev-appl-operand-loop>>
  <<ec-ev-appl-accumulate-arg>>
  <<ec-ev-appl-last-arg>>
  <<ec-ev-appl-accum-last-arg>>
  <<ec-apply-dispatch>>
  <<ec-simple-expressions>>
  <<ec-eval-dispatch-let-cond>>

    ))))
(start eceval)

#+end_src

#+RESULTS[462d5bebee6715924013a3d44de26feaca2c2c55]:
#+begin_src shell


;;EC-Eval input:
(define (factorial n) (if (= n 1) 1 (* (factorial (- n 1)) n)))
;;EC-Eval value:
ok
(total-pushes = 3 maximum-depth = 3)

;;EC-Eval input:
(factorial 6)
;;EC-Eval value:
720
(total-pushes = 176 maximum-depth = 33)

;;EC-Eval input:
(factorial 7)
;;EC-Eval value:
5040
(total-pushes = 208 maximum-depth = 38)

;;EC-Eval input:
(factorial 8)
;;EC-Eval value:
40320
(total-pushes = 240 maximum-depth = 43)

;;EC-Eval input:
(factorial 9)
;;EC-Eval value:
362880
(total-pushes = 272 maximum-depth = 48)

;;EC-Eval input:
(exit)
#+end_src

The maximal depth: \(d=5n+3\)
Total-pushes: \(p=32n-16\)

The summary table:

|                     | Maximum depth | Number of pushes |
|---------------------+---------------+------------------|
| Recursive factorial | 5n+3          | 32n-16           |
| Iterative factorial | 10            | 35n+29           |

**** DONE Exercise 5.28 Interpreters without tail recursion
     CLOSED: [2020-03-03 Tue 20:29]

#+name: ec-ev-sequence-no-tail
#+begin_src scheme :exports code :results none
ev-sequence
(test (op no-more-exps?) (reg unev))
(branch (label ev-sequence-end))
(assign exp (op first-exp) (reg unev))
(save unev)
(save env)
(assign continue (label ev-sequence-continue))
(goto (label eval-dispatch))
ev-sequence-continue
(restore env)
(restore unev)
(assign unev (op rest-exps) (reg unev))
(goto (label ev-sequence))
ev-sequence-end
(restore continue)
(goto (reg continue))
#+end_src

#+name: eceval-test-factorial-combined
#+begin_src shell :exports code :results verbatim output
  cat <<EOF
  (define (factorial n)
  (if (= n 1) 1 (* (factorial (- n 1)) n)))
  (factorial 6)
  (factorial 7)
  (factorial 8)
  (factorial 9)

  (define (factorial n)
    (define (iter product counter)
      (if (> counter n)
        product
        (iter (* counter product) (+ counter 1))))
    (iter 1 1))
  (factorial 6)
  (factorial 7)
  (factorial 8)
  (factorial 9)

  (exit)
  EOF
#+end_src

#+header: :stdin eceval-test-factorial-combined
#+begin_src shell :shebang "#!/usr/bin/chibi-scheme" :exports code :results output scalar code
  <<ec-glue1>>
  <<s-truefalse>>
  <<ec-s-additional-syntax>>
  <<s-syntax>>
  <<s-application>>
  <<s-environments>>
  <<s-compound-procedures>>
  <<s-primitive-procedures>>
  <<s-let-implementation>>
  <<s-cond>>
  <<s-user-prompt-print>>
  <<regmac-glue1>>
  <<regmac-make-machine>>
  <<regmac-make-register-tracing>>
  <<regmac-make-stack-with-performance>>
  <<regmac-make-new-machine-with-metadata-instr-count-trace-labels-brk>>
  <<regmac-extract-labels-improved-labels-brk>>
  <<regmac-assembler-with-metadata-register-labels-brk>>
  <<regmac-generating-execution-procedures>>
  <<regmac-make-operation-exp-improved>>
  <<regmac-make-operation-exp-syntax>>
  <<regmac-make-assign>>
  <<regmac-make-test>>
  <<regmac-make-save-restore>>
  <<regmac-other-instructions>>

(define (no-more-exps? seq) (null? seq))
(define the-global-environment (setup-environment))
(define (get-global-environment) the-global-environment)
(define eceval-operations
    (list
<<ec-eceval-operations-basic>>
<<ec-eceval-operations-let-cond>>
(list 'no-more-exps? no-more-exps?)
    ))

  (define eceval
	(make-machine
	 '() ;'(exp env val proc argl continue unev)
	 eceval-operations
	 (quote (
  <<ec-repl-stack-monitor>>
  <<ec-errors>>
  <<ec-ev-definition>>
  <<ec-ev-assignment>>
  <<ec-ev-if>>
  <<ec-ev-if-decide>>
  <<ec-ev-sequence-no-tail>>
  <<ec-ev-begin>>
  <<ec-compound-apply>>
  <<ec-primitive-apply>>
  <<ec-ev-application>>
  <<ec-ev-appl-did-operator>>
  <<ec-ev-appl-operand-loop>>
  <<ec-ev-appl-accumulate-arg>>
  <<ec-ev-appl-last-arg>>
  <<ec-ev-appl-accum-last-arg>>
  <<ec-apply-dispatch>>
  <<ec-simple-expressions>>
  <<ec-eval-dispatch-let-cond>>

    ))))
(start eceval)

#+end_src

#+RESULTS[328338fd5d91714570cb5bbb64176c1e7b5a0fc9]:
#+begin_src shell


;;EC-Eval input:
(define (factorial n) (if (= n 1) 1 (* (factorial (- n 1)) n)))
;;EC-Eval value:
ok
(total-pushes = 3 maximum-depth = 3)

;;EC-Eval input:
(factorial 6)
;;EC-Eval value:
720
(total-pushes = 188 maximum-depth = 51)

;;EC-Eval input:
(factorial 7)
;;EC-Eval value:
5040
(total-pushes = 222 maximum-depth = 59)

;;EC-Eval input:
(factorial 8)
;;EC-Eval value:
40320
(total-pushes = 256 maximum-depth = 67)

;;EC-Eval input:
(factorial 9)
;;EC-Eval value:
362880
(total-pushes = 290 maximum-depth = 75)

;;EC-Eval input:
(define (factorial n) (define (iter product counter) (if (> counter n) product (iter (* counter product) (+ counter 1)))) (iter 1 1))
;;EC-Eval value:
ok
(total-pushes = 3 maximum-depth = 3)

;;EC-Eval input:
(factorial 6)
;;EC-Eval value:
720
(total-pushes = 255 maximum-depth = 32)

;;EC-Eval input:
(factorial 7)
;;EC-Eval value:
5040
(total-pushes = 292 maximum-depth = 35)

;;EC-Eval input:
(factorial 8)
;;EC-Eval value:
40320
(total-pushes = 329 maximum-depth = 38)

;;EC-Eval input:
(factorial 9)
;;EC-Eval value:
362880
(total-pushes = 366 maximum-depth = 41)

;;EC-Eval input:
(exit)
#+end_src

Indeed, both the depth and the number of pushes increase with n:

|                     | Maximum depth | Number of pushes |
|---------------------+---------------+------------------|
| Recursive factorial | 8n+3          | 34n+26           |
| Iterative factorial | 3n+14         | 37n+33           |

**** DONE Exercise 5.29 Stack in tree-recursive Fibonacci
     CLOSED: [2020-03-03 Tue 20:50]

#+name: eceval-test-fibonacci
#+begin_src shell :exports code :results verbatim output
  cat <<EOF
  (define (fib n)
    (if (< n 2)
      n
      (+ (fib (- n 1)) (fib (- n 2)))))
  (fib 5)
  (fib 6)
  (fib 7)
  (fib 8)
  (exit)
  EOF
#+end_src

#+header: :stdin eceval-test-fibonacci
#+begin_src shell :shebang "#!/usr/bin/chibi-scheme" :exports code :results output scalar code
  <<ec-glue1>>
  <<s-truefalse>>
  <<ec-s-additional-syntax>>
  <<s-syntax>>
  <<s-application>>
  <<s-environments>>
  <<s-compound-procedures>>
  <<s-primitive-procedures>>
  <<s-let-implementation>>
  <<s-cond>>
  <<s-user-prompt-print>>
  <<regmac-glue1>>
  <<regmac-make-machine>>
  <<regmac-make-register-tracing>>
  <<regmac-make-stack-with-performance>>
  <<regmac-make-new-machine-with-metadata-instr-count-trace-labels-brk>>
  <<regmac-extract-labels-improved-labels-brk>>
  <<regmac-assembler-with-metadata-register-labels-brk>>
  <<regmac-generating-execution-procedures>>
  <<regmac-make-operation-exp-improved>>
  <<regmac-make-operation-exp-syntax>>
  <<regmac-make-assign>>
  <<regmac-make-test>>
  <<regmac-make-save-restore>>
  <<regmac-other-instructions>>

      (define the-global-environment (setup-environment))
      (define (get-global-environment) the-global-environment)
      (define eceval-operations
	(list
  <<ec-eceval-operations-basic>>
  <<ec-eceval-operations-let-cond>>
    ))

  (define eceval
	(make-machine
	 '() ;'(exp env val proc argl continue unev)
	 eceval-operations
	 (quote (
  <<ec-repl-stack-monitor>>
  <<ec-errors>>
  <<ec-ev-definition>>
  <<ec-ev-assignment>>
  <<ec-ev-if>>
  <<ec-ev-if-decide>>
  <<ec-ev-sequence>>
  <<ec-ev-sequence-continue>>
  <<ec-ev-begin>>
  <<ec-compound-apply>>
  <<ec-primitive-apply>>
  <<ec-ev-application>>
  <<ec-ev-appl-did-operator>>
  <<ec-ev-appl-operand-loop>>
  <<ec-ev-appl-accumulate-arg>>
  <<ec-ev-appl-last-arg>>
  <<ec-ev-appl-accum-last-arg>>
  <<ec-apply-dispatch>>
  <<ec-simple-expressions>>
  <<ec-eval-dispatch-let-cond>>
    ))))
(start eceval)

#+end_src

#+RESULTS[fcf2b7dfd72251d2d89f876f2508e869be46f345]:
#+begin_src shell


;;EC-Eval input:
(define (fib n) (if (< n 2) n (+ (fib (- n 1)) (fib (- n 2)))))
;;EC-Eval value:
ok
(total-pushes = 3 maximum-depth = 3)

;;EC-Eval input:
(fib 5)
;;EC-Eval value:
5
(total-pushes = 408 maximum-depth = 28)

;;EC-Eval input:
(fib 6)
;;EC-Eval value:
8
(total-pushes = 688 maximum-depth = 33)

;;EC-Eval input:
(fib 7)
;;EC-Eval value:
13
(total-pushes = 1136 maximum-depth = 38)

;;EC-Eval input:
(fib 8)
;;EC-Eval value:
21
(total-pushes = 1864 maximum-depth = 43)

;;EC-Eval input:
(exit)
#+end_src

***** Stack depth

Indeed, \(d = 5n + 3\)

***** Number of pushes

Indeed \(S(n) = S(n-1) + S(n-2) + k\)
\( 1864 = 1136 + 688 + k\)
\(k=40\)
\( 1136 = 21a + b\)
\( 688  = 13a + b\)
\(448 = 8a\)
\(a = 56\)
\(b = -40 \)
An we know that Fibonacci numbers grow roughly like \(\varphi^n\), the golden ratio.

\( S(n) = 56\varphi^{(n + 1)} - 40 \)

**** DONE Exercise 5.30 Errors
     CLOSED: [2020-03-04 Wed 11:35]

***** undefined variables

#+name: eceval-test-error-undefined-variable
#+begin_src shell :exports code :results verbatim output scalar code
  cat <<EOF
  (fib 8)
  (set! test 1)
  (show #t "hello")
  (exit)
  EOF
#+end_src

#+name: eceval-s-environments
#+begin_src scheme :exports both :results none
     (define (enclosing-environment env) (cdr env))
     (define (first-frame env) (car env))
     (define the-empty-environment '())
     (define (make-frame variables values)
       (cons variables values))
     (define (frame-variables frame) (car frame))
     (define (frame-values frame) (cdr frame))
     (define (add-binding-to-frame! var val frame)
       (set-car! frame (cons var (car frame)))
       (set-cdr! frame (cons val (cdr frame))))
     (define (extend-environment vars vals base-env)
       (if (= (length vars) (length vals))
           (cons (make-frame vars vals) base-env)
           (if (< (length vars) (length vals))
               (error "Too many arguments supplied" vars vals)
               (error "Too few arguments supplied" vars vals))))
     (define (lookup-variable-value var env)
       (define (env-loop env)
         (define (scan vars vals)
           (cond ((null? vars)
                  (env-loop (enclosing-environment env)))
                 ((eq? var (car vars))
                  (cons 'bound (car vals)))
                 (else (scan (cdr vars) (cdr vals)))))
         (if (eq? env the-empty-environment)
             #;(error "Unbound variable" var)
             (cons 'unbound 'error)
             (let ((frame (first-frame env)))
               (scan (frame-variables frame)
                     (frame-values frame)))))
       (env-loop env))
     (define (set-variable-value! var val env)
       (define (env-loop env)
         (define (scan vars vals)
           (cond ((null? vars)
                  (env-loop (enclosing-environment env)))
                 ((eq? var (car vars))
                  (set-car! vals val))
                 (else (scan (cdr vars) (cdr vals)))))
         (if (eq? env the-empty-environment)
             #;(error "Unbound variable -- SET!" var)
             (cons 'unbound 'error)
             (let ((frame (first-frame env)))
               (scan (frame-variables frame)
                     (frame-values frame)))))
       (env-loop env))
     (define (define-variable! var val env)
       (let ((frame (first-frame env)))
         (define (scan vars vals)
           (cond ((null? vars)
                  (add-binding-to-frame! var val frame))
                 ((eq? var (car vars))
                  (set-car! vals val))
                 (else (scan (cdr vars) (cdr vals)))))
         (scan (frame-variables frame)
               (frame-values frame))))

#+end_src

#+name: ec-error-simple-expressions-assignment
#+begin_src scheme :exports code :results none
  ev-self-eval
  (assign val (reg exp))
  (goto (reg continue))
  ev-quoted
  (assign val (op text-of-quotation) (reg exp))
  (goto (reg continue))
  ev-lambda
  (assign unev (op lambda-parameters) (reg exp))
  (assign exp (op lambda-body) (reg exp))
  (assign val (op make-procedure) (reg unev) (reg exp) (reg env))
  (goto (reg continue))
  ev-variable
  (assign val (op lookup-variable-value) (reg exp) (reg env))
  (save exp)
  (assign exp (op car) (reg val))
  (test (op eq?) (reg exp) (const unbound))
  (branch (label error-unbound-variable))
  (restore exp)
  (assign val (op cdr) (reg val))
  (goto (reg continue))
  error-unbound-variable
  (restore exp)
  (assign val (op cons) (const unbound-variable-error) (reg exp))
  (goto (label signal-error))
  ev-assignment
  (assign unev (op assignment-variable) (reg exp))
  (save unev) ; save variable for later
  (assign exp (op assignment-value) (reg exp))
  (save env)
  (save continue)
  (assign continue (label ev-assignment-1))
  (goto (label eval-dispatch)) ; evaluate the assignment value
  ev-assignment-1
  (restore continue)
  (restore env)
  (restore unev)
  (assign val (op set-variable-value!) (reg unev) (reg val) (reg env))
  (assign val (op car) (reg val))
  (test (op eq?) (reg val) (const unbound))
  (branch (label assignment-failed))
  (assign val (const ok))
  (goto (reg continue))
  assignment-failed
  (assign exp (reg unev))
  (save exp)
  (goto (label error-unbound-variable))

#+end_src

#+name: eceval-test-error-undefined-variable-2
#+begin_src shell :exports code :results verbatim output scalar code
  cat <<EOF
  (fib 8)
  (set! test 1)
  (show #t "hello")
  (define test 5)
  test
  (exit)
  EOF
#+end_src


#+header: :stdin eceval-test-error-undefined-variable-2
#+begin_src shell :shebang "#!/usr/bin/chibi-scheme" :exports code :results output scalar code
  <<ec-glue1>>
  <<s-truefalse>>
  <<ec-s-additional-syntax>>
  <<s-syntax>>
  <<s-application>>
  <<eceval-s-environments>>
  <<s-compound-procedures>>
  <<s-primitive-procedures>>
  <<s-let-implementation>>
  <<s-cond>>
  <<s-user-prompt-print>>
  <<regmac-glue1>>
  <<regmac-make-machine>>
  <<regmac-make-register-tracing>>
  <<regmac-make-stack-with-performance>>
  <<regmac-make-new-machine-with-metadata-instr-count-trace-labels-brk>>
  <<regmac-extract-labels-improved-labels-brk>>
  <<regmac-assembler-with-metadata-register-labels-brk>>
  <<regmac-generating-execution-procedures>>
  <<regmac-make-operation-exp-improved>>
  <<regmac-make-operation-exp-syntax>>
  <<regmac-make-assign>>
  <<regmac-make-test>>
  <<regmac-make-save-restore>>
  <<regmac-other-instructions>>

      (define the-global-environment (setup-environment))
      (define (get-global-environment) the-global-environment)
      (define eceval-operations
	(list
  <<ec-eceval-operations-basic>>
  <<ec-eceval-operations-let-cond>>
     (list 'eq? eq?)
    ))

  (define eceval
	(make-machine
	 '() ;'(exp env val proc argl continue unev)
	 eceval-operations
	 (quote (
  <<ec-repl-stack-monitor>>
  <<ec-errors>>
  <<ec-ev-definition>>
  <<ec-error-simple-expressions-assignment>>
  <<ec-ev-if>>
  <<ec-ev-if-decide>>
  <<ec-ev-sequence>>
  <<ec-ev-sequence-continue>>
  <<ec-ev-begin>>
  <<ec-compound-apply>>
  <<ec-primitive-apply>>
  <<ec-ev-application>>
  <<ec-ev-appl-did-operator>>
  <<ec-ev-appl-operand-loop>>
  <<ec-ev-appl-accumulate-arg>>
  <<ec-ev-appl-last-arg>>
  <<ec-ev-appl-accum-last-arg>>
  <<ec-apply-dispatch>>

  <<ec-eval-dispatch-let-cond>>
    ))))
(start eceval)

#+end_src

#+RESULTS[9b4384b69ef83fbdeb25e58f9907621f7cd16e92]:
#+begin_src shell


;;EC-Eval input:
(fib 8)(unbound-variable-error . fib)

;;EC-Eval input:
(set! test 1)(unbound-variable-error . test)

;;EC-Eval input:
(show #t "hello")hello
;;EC-Eval value:
{Show-Env #56 #<Output-Port 139870599364064> 0 5 78 10 #f #\  #f #f #<procedure substring-length> #f #f #<procedure output-default> ()}
(total-pushes = 9 maximum-depth = 5)

;;EC-Eval input:
(define test 5)
;;EC-Eval value:
ok
(total-pushes = 3 maximum-depth = 3)

;;EC-Eval input:
test
;;EC-Eval value:
5
(total-pushes = 1 maximum-depth = 1)

;;EC-Eval input:
(exit)
#+end_src

***** wrong function arguments

One of the methods of implementing the error-reporting would be to use
the built-in scheme exceptioning mechanism ~guard~ (a lightweight
exceptioning). This is appropriate if the underlying interpreter
supports exceptions. I guess, SICP authors expected a different thing.

#+name: ec-primitive-apply-with-errors
#+begin_src scheme :exports code :results none
primitive-apply
(assign val (op apply-primitive-procedure-with-errors) (reg proc) (reg argl))
(save val)
(assign val (op car) (reg val)) ; error or not
(test (op eq?) (const error) (reg val))
(branch (label primitive-error))
(restore val)
(assign val (op cdr) (reg val))
(restore continue)
(goto (reg continue))
primitive-error
(restore val)
(assign val (op cdr) (reg val)) ; error-code
(assign val (op cons) (const primitive-application-error) (reg val))
(goto (label signal-error))
#+end_src

#+name: ec-primitive-with-errors
#+begin_src scheme :exports code :results none

(define primitive-implementation-checkers
  (list
       (list / (lambda (l)  (cond ((< (length l) 2) 'not-enough-arguments)
                        ((= (cadr l) 0) 'division-by-zero)
                        (else #f))))
       (list car (lambda (l)  (cond ((not (= (length l) 1)) 'wrong-number-of-arguments)
                               ((not (pair? (car l))) 'car-not-a-pair)
                               (else #f))))
       (list cdr (lambda (l)  (cond ((not (= (length l) 1)) 'wrong-number-of-arguments)
                               ((not (pair? (car l))) 'cdr-not-a-pair)
                               (else #f)))))
)

(define (apply-primitive-procedure-with-errors proc arglist)
  #;(show #t "\ncheckers=" (pretty primitive-implementation-checkers)
           "\nproc=" (written proc)
           "\n(primitive-implementation proc)=" (written (primitive-implementation proc))
           "\narglist=" (pretty arglist))
  (let ((checker (assoc (primitive-implementation proc)
                         primitive-implementation-checkers)))
    (if checker
      (let ((error ((cadr checker) arglist)))
        (if error
            (cons 'error error)
            (cons 'no-error (apply-in-underlying-scheme
                 (primitive-implementation proc) arglist))))
      (cons 'no-checker (apply-in-underlying-scheme
                 (primitive-implementation proc) arglist)))))
#+end_src

#+name: eceval-test-error-undefined-variable-function
#+begin_src shell :exports code :results verbatim output scalar code
  cat <<EOF
  (fib 8)
  (set! test 1)
  (show #t "hello")
  (cons 'a 'b)
  (/ 1 0)
  (car 1)
  (exit)
  EOF
#+end_src


#+header: :stdin eceval-test-error-undefined-variable-function
#+begin_src shell :shebang "#!/usr/bin/chibi-scheme" :exports code :results output scalar code
  <<ec-glue1>>
  <<s-truefalse>>
  <<ec-primitive-with-errors>>
  <<ec-s-additional-syntax>>
  <<s-syntax>>
  <<s-application>>
  <<eceval-s-environments>>
  <<s-compound-procedures>>
  <<s-primitive-procedures>>
  <<s-let-implementation>>
  <<s-cond>>
  <<s-user-prompt-print>>

  <<regmac-make-machine>>
  <<regmac-make-register-tracing>>
  <<regmac-make-stack-with-performance>>
  <<regmac-make-new-machine-with-metadata-instr-count-trace-labels-brk>>
  <<regmac-extract-labels-improved-labels-brk>>
  <<regmac-assembler-with-metadata-register-labels-brk>>
  <<regmac-generating-execution-procedures>>
  <<regmac-make-operation-exp-improved>>
  <<regmac-make-operation-exp-syntax>>
  <<regmac-make-assign>>
  <<regmac-make-test>>
  <<regmac-make-save-restore>>
  <<regmac-other-instructions>>

      (define the-global-environment (setup-environment))
      (define (get-global-environment) the-global-environment)
      (define eceval-operations
	(list
  <<ec-eceval-operations-basic>>
  <<ec-eceval-operations-let-cond>>
     (list 'eq? eq?)
     (list 'apply-primitive-procedure-with-errors apply-primitive-procedure-with-errors)
    ))

  (define eceval
	(make-machine
	 '() ;'(exp env val proc argl continue unev)
	 eceval-operations
	 (quote (
  <<ec-repl-stack-monitor>>
  <<ec-errors>>
  <<ec-ev-definition>>
  <<ec-error-simple-expressions-assignment>>
  <<ec-ev-if>>
  <<ec-ev-if-decide>>
  <<ec-ev-sequence>>
  <<ec-ev-sequence-continue>>
  <<ec-ev-begin>>
  <<ec-compound-apply>>
  <<ec-primitive-apply-with-errors>>
  <<ec-ev-application>>
  <<ec-ev-appl-did-operator>>
  <<ec-ev-appl-operand-loop>>
  <<ec-ev-appl-accumulate-arg>>
  <<ec-ev-appl-last-arg>>
  <<ec-ev-appl-accum-last-arg>>
  <<ec-apply-dispatch>>

  <<ec-eval-dispatch-let-cond>>
    ))))
(start eceval)

#+end_src

#+RESULTS[be10ef722208dd8e5441b345bd646724b282a078]:
#+begin_src shell


;;EC-Eval input:
(fib 8)(unbound-variable-error . fib)

;;EC-Eval input:
(set! test 1)(unbound-variable-error . test)

;;EC-Eval input:
(show #t "hello")hello
;;EC-Eval value:
{Show-Env #56 #<Output-Port 139971607322080> 0 5 78 10 #f #\  #f #f #<procedure substring-length> #f #f #<procedure output-default> ()}
(total-pushes = 10 maximum-depth = 5)

;;EC-Eval input:
(cons (quote a) (quote b))
;;EC-Eval value:
(a . b)
(total-pushes = 10 maximum-depth = 5)

;;EC-Eval input:
(/ 1 0)(primitive-application-error . division-by-zero)

;;EC-Eval input:
(car 1)(primitive-application-error . car-not-a-pair)

;;EC-Eval input:
(exit)
#+end_src

Okay, the system is working, but I am too lazy to implement it for all
primitive procedures.

*** 5.5 Compilation [22/22]
**** Common code

#+name: c-compile
#+begin_src scheme :exports code :results none
  (define (compile exp target linkage)
    (cond ((self-evaluating? exp)
	   (compile-self-evaluating exp target linkage))
	  ((quoted? exp) (compile-quoted exp target linkage))
	  ((variable? exp)
	   (compile-variable exp target linkage))
	  ((assignment? exp)
	   (compile-assignment exp target linkage))
	  ((definition? exp)
	   (compile-definition exp target linkage))
	  ((if? exp) (compile-if exp target linkage))
	  ((lambda? exp) (compile-lambda exp target linkage))
	  ((begin? exp)
	   (compile-sequence
	    (begin-actions exp) target linkage))
	  ((cond? exp)
	   (compile (cond->if exp) target linkage))
	  ((application? exp)
	   (compile-application exp target linkage))
	  (else
	   (error "Unknown expression type: COMPILE" exp))))
#+end_src

#+name: c-make-instruction-sequence-empty-instruction-sequence
#+begin_src scheme :exports code :results none
  (define (make-instruction-sequence needs modifies statements)
    (list needs modifies statements))
(define (empty-instruction-sequence)
    (make-instruction-sequence '() '() '()))
#+end_src

#+name: c-compile-linkage
#+begin_src scheme :exports code :results none
  (define (compile-linkage linkage)
    (cond ((eq? linkage 'return)
	   (make-instruction-sequence '(continue) '()
				      '((goto (reg continue)))))
	  ((eq? linkage 'next)
	   (empty-instruction-sequence))
	  (else
	   (make-instruction-sequence '() '()
				      `((goto (label ,linkage)))))))
#+end_src

#+name: c-end-with-linkage
#+begin_src scheme :exports code :results none
  (define (end-with-linkage linkage instruction-sequence)
    (preserving '(continue)
		instruction-sequence
		(compile-linkage linkage)))
#+end_src

#+name: c-compile-simple-expressions
#+begin_src scheme :exports code :results none
  (define (compile-self-evaluating exp target linkage)
    (end-with-linkage linkage
		      (make-instruction-sequence '() (list target)
						 `((assign ,target (const ,exp))))))
  (define (compile-quoted exp target linkage)
    (end-with-linkage linkage
		      (make-instruction-sequence '() (list target)
						 `((assign ,target (const ,(text-of-quotation exp)))))))
  (define (compile-variable exp target linkage)
    (end-with-linkage linkage
		      (make-instruction-sequence '(env) (list target)
						 `((assign ,target
							   (op lookup-variable-value)
							   (const ,exp)
							   (reg env))))))
#+end_src

#+name: c-compile-assignment
#+begin_src scheme :exports code :results none
  (define (compile-assignment exp target linkage)
    (let ((var (assignment-variable exp))
	  (get-value-code
	   (compile (assignment-value exp) 'val 'next)))
      (end-with-linkage linkage
			(preserving '(env)
				    get-value-code
				    (make-instruction-sequence '(env val) (list target)
							       `((perform (op set-variable-value!)
									  (const ,var)
									  (reg val)
									  (reg env))
								 (assign ,target (const ok))))))))
  (define (compile-definition exp target linkage)
    (let ((var (definition-variable exp))
	  (get-value-code
	   (compile (definition-value exp) 'val 'next)))
      (end-with-linkage linkage
			(preserving '(env)
				    get-value-code
				    (make-instruction-sequence '(env val) (list target)
							       `((perform (op define-variable!)
									  (const ,var)
									  (reg val)
									  (reg env))
								 (assign ,target (const ok))))))))
#+end_src

#+name: c-make-label
#+begin_src scheme :exports code :results none
  (define label-counter 0)
  (define (new-label-number)
    (set! label-counter (+ 1 label-counter))
    label-counter)
  (define (make-label name)
    (string->symbol
     (string-append (symbol->string name)
		    (number->string (new-label-number)))))
#+end_src

#+name: c-compile-if
#+begin_src scheme :exports code :results none
  (define (compile-if exp target linkage)
    (let ((t-branch (make-label 'true-branch))
	  (f-branch (make-label 'false-branch))
	  (after-if (make-label 'after-if)))
      (let ((consequent-linkage
	     (if (eq? linkage 'next) after-if linkage)))
	(let ((p-code (compile (if-predicate exp) 'val 'next))
	      (c-code
	       (compile
		(if-consequent exp) target
		consequent-linkage))
	      (a-code
	       (compile (if-alternative exp) target linkage)))
	  (preserving '(env continue)
		      p-code
		      (append-instruction-sequences
		       (make-instruction-sequence '(val) '()
						  `((test (op false?) (reg val))
						    (branch (label ,f-branch))))
		       (parallel-instruction-sequences
			(append-instruction-sequences t-branch c-code)
			(append-instruction-sequences f-branch a-code))
		       after-if))))))
#+end_src

#+name: c-compile-sequence
#+begin_src scheme :exports code :results none
  (define (compile-sequence seq target linkage)
    (if (last-exp? seq)
	(compile (first-exp seq) target linkage)
	(preserving
	 '(env continue)
	 (compile (first-exp seq) target 'next)
	 (compile-sequence (rest-exps seq) target linkage))))
#+end_src

#+name: c-compiled-procedures
#+begin_src scheme :exports code :results none
  (define (make-compiled-procedure entry env)
    (list 'compiled-procedure entry env))
  (define (compiled-procedure? proc)
    (tagged-list? proc 'compiled-procedure))
  (define (compiled-procedure-entry c-proc) (cadr c-proc))
  (define (compiled-procedure-env c-proc) (caddr c-proc))
#+end_src

#+name: c-compile-lambda
#+begin_src scheme :exports code :results none
  (define (compile-lambda exp target linkage)
    (let ((proc-entry (make-label 'entry))
	  (after-lambda (make-label 'after-lambda)))
      (let ((lambda-linkage
	     (if (eq? linkage 'next) after-lambda linkage)))
	(append-instruction-sequences
	 (tack-on-instruction-sequence
	  (end-with-linkage lambda-linkage
			    (make-instruction-sequence '(env) (list target)
						       `((assign ,target
								 (op make-compiled-procedure)
								 (label ,proc-entry)
								 (reg env)))))
	  (compile-lambda-body exp proc-entry))
	 after-lambda))))
#+end_src

#+name: c-compile-lambda-body
#+begin_src scheme :exports code :results none
  (define (compile-lambda-body exp proc-entry)
    (let ((formals (lambda-parameters exp)))
      (append-instruction-sequences
       (make-instruction-sequence '(env proc argl) '(env)
				  `(,proc-entry
				    (assign env
					    (op compiled-procedure-env)
					    (reg proc))
				    (assign env
					    (op extend-environment)
					    (const ,formals)
					    (reg argl)
					    (reg env))))
       (compile-sequence (lambda-body exp) 'val 'return))))
#+end_src

#+name: c-compile-application
#+begin_src scheme :exports code :results none
  (define (compile-application exp target linkage)
    (let ((proc-code (compile (operator exp) 'proc 'next))
	  (operand-codes
	   (map (lambda
		    (operand) (compile operand 'val 'next))
		(operands exp))))
      (preserving '(env continue)
		  proc-code
		  (preserving '(proc continue)
			      (construct-arglist operand-codes)
			      (compile-procedure-call target linkage)))))
#+end_src

#+name: c-construct-arglist
#+begin_src scheme :exports code :results none
  (define (construct-arglist operand-codes)
    (let ((operand-codes (reverse operand-codes)))
      (if (null? operand-codes)
	  (make-instruction-sequence '() '(argl)
				     '((assign argl (const ()))))
	  (let ((code-to-get-last-arg
		 (append-instruction-sequences
		  (car operand-codes)
		  (make-instruction-sequence '(val) '(argl)
					     '((assign argl (op list) (reg val)))))))
	    (if (null? (cdr operand-codes))
		code-to-get-last-arg
		(preserving '(env)
			    code-to-get-last-arg
			    (code-to-get-rest-args
			     (cdr operand-codes))))))))
  (define (code-to-get-rest-args operand-codes)
    (let ((code-for-next-arg
	   (preserving '(argl)
		       (car operand-codes)
		       (make-instruction-sequence '(val argl) '(argl)
						  '((assign argl
							    (op cons) (reg val) (reg argl)))))))
      (if (null? (cdr operand-codes))
	  code-for-next-arg
	  (preserving '(env)
		      code-for-next-arg
		      (code-to-get-rest-args (cdr operand-codes))))))
#+end_src

#+name: c-compile-procedure-call
#+begin_src scheme :exports code :results none
  (define (compile-procedure-call target linkage)
    (let ((primitive-branch (make-label 'primitive-branch))
	  (compiled-branch (make-label 'compiled-branch))
	  (after-call (make-label 'after-call)))
      (let ((compiled-linkage
	     (if (eq? linkage 'next) after-call linkage)))
	(append-instruction-sequences
	 (make-instruction-sequence '(proc) '()
				    `((test (op primitive-procedure?) (reg proc))
				      (branch (label ,primitive-branch))))
	 (parallel-instruction-sequences
	  (append-instruction-sequences
	   compiled-branch
	   (compile-proc-appl target compiled-linkage))
	  (append-instruction-sequences
	   primitive-branch
	   (end-with-linkage linkage
			     (make-instruction-sequence '(proc argl)
							(list target)
							`((assign ,target
								  (op apply-primitive-procedure)
								  (reg proc)
								  (reg argl)))))))
	 after-call))))
#+end_src

#+name: c-compile-proc-appl
#+begin_src scheme :exports code :results none
  (define all-regs '(env proc val argl continue))
  (define (compile-proc-appl target linkage)
    (cond ((and (eq? target 'val) (not (eq? linkage 'return)))
	   (make-instruction-sequence '(proc) all-regs
				      `((assign continue (label ,linkage))
					(assign val (op compiled-procedure-entry)
						(reg proc))
					(goto (reg val)))))
	  ((and (not (eq? target 'val))
		(not (eq? linkage 'return)))
	   (let ((proc-return (make-label 'proc-return)))
	     (make-instruction-sequence '(proc) all-regs
					`((assign continue (label ,proc-return))
					  (assign val (op compiled-procedure-entry)
						  (reg proc))
					  (goto (reg val))
					  ,proc-return
					  (assign ,target (reg val))
					  (goto (label ,linkage))))))
	  ((and (eq? target 'val) (eq? linkage 'return))
	   (make-instruction-sequence
	    '(proc continue)
	    all-regs
	    '((assign val (op compiled-procedure-entry)
		      (reg proc))
	      (goto (reg val)))))
	  ((and (not (eq? target 'val))
		(eq? linkage 'return))
	   (error "return linkage, target not val: COMPILE"
		  target))))
#+end_src

#+name: c-combining-registers
#+begin_src scheme :exports code :results none
  (define (registers-needed s)
    (if (symbol? s) '() (car s)))
  (define (registers-modified s)
    (if (symbol? s) '() (cadr s)))
  (define (statements s)
    (if (symbol? s) (list s) (caddr s)))
  (define (needs-register? seq reg)
    (memq reg (registers-needed seq)))
  (define (modifies-register? seq reg)
    (memq reg (registers-modified seq)))
#+end_src

#+name: c-append-instruction-sequences
#+begin_src scheme :exports code :results none
  (define (append-instruction-sequences . seqs)
    (define (append-2-sequences seq1 seq2)
      (make-instruction-sequence
       (list-union
	(registers-needed seq1)
	(list-difference (registers-needed seq2)
			 (registers-modified seq1)))
       (list-union (registers-modified seq1)
		   (registers-modified seq2))
       (append (statements seq1) (statements seq2))))
    (define (append-seq-list seqs)
      (if (null? seqs)
	  (empty-instruction-sequence)
	  (append-2-sequences
	   (car seqs)
	   (append-seq-list (cdr seqs)))))
    (append-seq-list seqs))
#+end_src

#+name: c-list-union
#+begin_src scheme :exports code :results none
  (define (list-union s1 s2)
    (cond ((null? s1) s2)
	  ((memq (car s1) s2) (list-union (cdr s1) s2))
	  (else (cons (car s1) (list-union (cdr s1) s2)))))
  (define (list-difference s1 s2)
    (cond ((null? s1) '())
	  ((memq (car s1) s2) (list-difference (cdr s1) s2))
	  (else (cons (car s1)
		      (list-difference (cdr s1) s2)))))
#+end_src

#+name: c-preserving
#+begin_src scheme :exports code :results none
  (define (preserving regs seq1 seq2)
    (if (null? regs)
	(append-instruction-sequences seq1 seq2)
	(let ((first-reg (car regs)))
	  (if (and (needs-register? seq2 first-reg)
		   (modifies-register? seq1 first-reg))
	      (preserving (cdr regs)
			  (make-instruction-sequence
			   (list-union (list first-reg)
				       (registers-needed seq1))
			   (list-difference (registers-modified seq1)
					    (list first-reg))
			   (append `((save ,first-reg))
				   (statements seq1)
				   `((restore ,first-reg))))
			  seq2)
	      (preserving (cdr regs) seq1 seq2)))))
#+end_src

#+name: c-tack-on-instruction-sequence
#+begin_src scheme :exports code :results none
  (define (tack-on-instruction-sequence seq body-seq)
    (make-instruction-sequence
     (registers-needed seq)
     (registers-modified seq)
     (append (statements seq)
	     (statements body-seq))))
#+end_src

#+name: c-parallel-instruction-sequences
#+begin_src scheme :exports code :results none
  (define (parallel-instruction-sequences seq1 seq2)
    (make-instruction-sequence
     (list-union (registers-needed seq1)
		 (registers-needed seq2))
     (list-union (registers-modified seq1)
		 (registers-modified seq2))
     (append (statements seq1)
	     (statements seq2))))
#+end_src

#+name: c-test-compile-1
#+begin_src scheme :exports code :results none
  (compile
   '(define (factorial n)
      (if (= n 1)
	  1
	  (* (factorial (- n 1)) n)))
   'val
   'next)
#+end_src

#+name: c-test-factorial-1
#+header: :stdin empty
#+begin_src shell :shebang "#!/usr/bin/chibi-scheme" :exports code :results output
<<ec-glue1>>
<<c-compile>>
<<c-make-instruction-sequence-empty-instruction-sequence>>
<<c-compile-linkage>>
<<c-end-with-linkage>>
<<c-compile-simple-expressions>>
<<c-compile-assignment>>
<<c-make-label>>
<<c-compile-if>>
<<c-compile-sequence>>
<<c-compiled-procedures>>
<<c-compile-lambda>>
<<c-compile-lambda-body>>
<<c-compile-application>>
<<c-construct-arglist>>
<<c-compile-procedure-call>>
<<c-compile-proc-appl>>
<<c-combining-registers>>
<<c-append-instruction-sequences>>
<<c-list-union>>
<<c-preserving>>
<<c-tack-on-instruction-sequence>>
<<c-parallel-instruction-sequences>>
<<s-syntax>>
<<s-cond-with-arrow>>
<<s-application>>

(define compiled-factorial (compile
   '(define (factorial n)
      (if (= n 1)
	  1
	  (* (factorial (- n 1)) n)))
   'val
   'next))

(show #t (pretty compiled-factorial))
#+end_src

#+RESULTS[db1dfbf14e04a8d1f1d0cdaac75bccdfdde7f4c7]: c-test-factorial-1
#+begin_example
((env) (val)
       ((assign val (op make-compiled-procedure) (label entry2) (reg env))
        (goto (label after-lambda1))
        entry2
        (assign env (op compiled-procedure-env) (reg proc))
        (assign env (op extend-environment) (const (n)) (reg argl) (reg env))
        (save continue)
        (save env)
        (assign proc (op lookup-variable-value) (const =) (reg env))
        (assign val (const 1))
        (assign argl (op list) (reg val))
        (assign val (op lookup-variable-value) (const n) (reg env))
        (assign argl (op cons) (reg val) (reg argl))
        (test (op primitive-procedure?) (reg proc))
        (branch (label primitive-branch17))
        compiled-branch16
        (assign continue (label after-call15))
        (assign val (op compiled-procedure-entry) (reg proc))
        (goto (reg val))
        primitive-branch17
        (assign val (op apply-primitive-procedure) (reg proc) (reg argl))
        after-call15
        (restore env)
        (restore continue)
        (test (op false?) (reg val))
        (branch (label false-branch4))
        true-branch5
        (assign val (const 1))
        (goto (reg continue))
        false-branch4
        (assign proc (op lookup-variable-value) (const *) (reg env))
        (save continue)
        (save proc)
        (assign val (op lookup-variable-value) (const n) (reg env))
        (assign argl (op list) (reg val))
        (save argl)
        (assign proc (op lookup-variable-value) (const factorial) (reg env))
        (save proc)
        (assign proc (op lookup-variable-value) (const -) (reg env))
        (assign val (const 1))
        (assign argl (op list) (reg val))
        (assign val (op lookup-variable-value) (const n) (reg env))
        (assign argl (op cons) (reg val) (reg argl))
        (test (op primitive-procedure?) (reg proc))
        (branch (label primitive-branch8))
        compiled-branch7
        (assign continue (label after-call6))
        (assign val (op compiled-procedure-entry) (reg proc))
        (goto (reg val))
        primitive-branch8
        (assign val (op apply-primitive-procedure) (reg proc) (reg argl))
        after-call6
        (assign argl (op list) (reg val))
        (restore proc)
        (test (op primitive-procedure?) (reg proc))
        (branch (label primitive-branch11))
        compiled-branch10
        (assign continue (label after-call9))
        (assign val (op compiled-procedure-entry) (reg proc))
        (goto (reg val))
        primitive-branch11
        (assign val (op apply-primitive-procedure) (reg proc) (reg argl))
        after-call9
        (restore argl)
        (assign argl (op cons) (reg val) (reg argl))
        (restore proc)
        (restore continue)
        (test (op primitive-procedure?) (reg proc))
        (branch (label primitive-branch14))
        compiled-branch13
        (assign val (op compiled-procedure-entry) (reg proc))
        (goto (reg val))
        primitive-branch14
        (assign val (op apply-primitive-procedure) (reg proc) (reg argl))
        (goto (reg continue))
        after-call12
        after-if3
        after-lambda1
        (perform (op define-variable!) (const factorial) (reg val) (reg env))
        (assign val (const ok))))
#+end_example


#+name: c-compile-and-go
#+begin_src scheme :exports code :results none
  (define (compile-and-go expression)
    (let ((instructions
	   (assemble
	    (statements
	     (compile expression 'val 'return))
	    eceval)))
      (set! the-global-environment (setup-environment))
      (set-register-contents! eceval 'val instructions)
      (set-register-contents! eceval 'flag true)
      (start eceval)))
#+end_src

#+name: ec-apply-dispatch-with-compiled
#+begin_src scheme :exports code :results none
  apply-dispatch
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-apply))
  (test (op compound-procedure?) (reg proc))
  (branch (label compound-apply))
  (test (op compiled-procedure?) (reg proc))
  (branch (label compiled-apply))
  (goto (label unknown-procedure-type))
  compiled-apply
  (restore continue)
  (assign val (op compiled-procedure-entry) (reg proc))
  (goto (reg val))
#+end_src

#+name: ec-before-repl-branch-to-compile
#+begin_src scheme :exports code :results none
(branch (label external-entry))
#+end_src

#+name: ec-external-entry
#+begin_src scheme :exports code :results none
  external-entry
  (perform (op initialize-stack))
  (assign env (op get-global-environment))
  (assign continue (label print-result))
  (goto (reg val))
#+end_src

#+name: s-user-prompt-print-with-compiled
#+begin_src scheme :exports both :results value scalar code
  (define (prompt-for-input string)
    #;(newline) #;(newline) (display string) (newline))
  (define (announce-output string)
    #;(newline) (display string) (newline))
  (define (user-print object)
    (cond ((compound-procedure? object)
                (show #t (pretty (list 'compound-procedure
	 	         (procedure-parameters object)
                         (procedure-body object)
		        '<procedure-env>))))
          ((compiled-procedure? object)
                (show #t (pretty '<compiled-procedure>)))
          (else (show #t (pretty object)))))

#+end_src

#+name: ec-eceval-operations-compiled
#+begin_src scheme :exports code :results none
     (list 'eq? eq?)
     (list 'apply-primitive-procedure apply)
     (list 'compiled-procedure? compiled-procedure?)
     (list 'compiled-procedure-entry compiled-procedure-entry)
     (list 'make-compiled-procedure make-compiled-procedure)
     (list 'compiled-procedure-env compiled-procedure-env)
     (list 'list list)
     (list 'false? false?)
#+end_src

#+name: c-test-compile-and-go
#+begin_src shell :exports code :results verbatim output
  cat <<EOF
  (factorial 5)
  (exit)
  EOF
#+end_src


#+header: :stdin c-test-compile-and-go
#+begin_src shell :shebang "#!/usr/bin/chibi-scheme" :exports code :results output scalar code
  <<ec-glue1>>
  <<s-truefalse>>
  <<ec-s-additional-syntax>>
  <<s-syntax>>
  <<s-application>>
  <<s-environments>>
  <<s-compound-procedures>>
  <<s-primitive-procedures>>
  <<s-let-implementation>>
  <<s-cond>>
  <<s-user-prompt-print-with-compiled>>
  <<regmac-make-machine>>
  <<regmac-make-register-tracing>>
  <<regmac-make-stack-with-performance>>
  <<regmac-make-new-machine-with-metadata-instr-count-trace-labels-brk>>
  <<regmac-extract-labels-improved-labels-brk>>
  <<regmac-assembler-with-metadata-register-labels-brk>>
  <<regmac-generating-execution-procedures>>
  <<regmac-make-operation-exp>>
  <<regmac-make-operation-exp-syntax>>
  <<regmac-make-assign>>
  <<regmac-make-test>>
  <<regmac-make-save-restore>>
  <<regmac-other-instructions>>

  <<c-compile-and-go>>
    <<c-compile>>
  <<c-make-instruction-sequence-empty-instruction-sequence>>
  <<c-compile-linkage>>
  <<c-end-with-linkage>>
  <<c-compile-simple-expressions>>
  <<c-compile-assignment>>
  <<c-make-label>>
  <<c-compile-if>>
  <<c-compile-sequence>>
  <<c-compiled-procedures>>
  <<c-compile-lambda>>
  <<c-compile-lambda-body>>
  <<c-compile-application>>
  <<c-construct-arglist>>
  <<c-compile-procedure-call>>
  <<c-compile-proc-appl>>
  <<c-combining-registers>>
  <<c-append-instruction-sequences>>
  <<c-list-union>>
  <<c-preserving>>
  <<c-tack-on-instruction-sequence>>
  <<c-parallel-instruction-sequences>>

      (define the-global-environment (setup-environment))
      (define (get-global-environment) the-global-environment)
      (define eceval-operations
	(list
  <<ec-eceval-operations-basic>>
  <<ec-eceval-operations-let-cond>>
  <<ec-eceval-operations-compiled>>
    ))

  (define eceval
	(make-machine
	 '() ;'(exp env val proc argl continue unev)
	 eceval-operations
	 (quote (
  <<ec-before-repl-branch-to-compile>>
  <<ec-repl-stack-monitor>>
  <<ec-errors>>
  <<ec-ev-definition>>
  <<ec-ev-assignment>>
  <<ec-ev-if>>
  <<ec-ev-if-decide>>
  <<ec-ev-sequence>>
  <<ec-ev-sequence-continue>>
  <<ec-ev-begin>>
  <<ec-compound-apply>>
  <<ec-primitive-apply>>
  <<ec-ev-application>>
  <<ec-ev-appl-did-operator>>
  <<ec-ev-appl-operand-loop>>
  <<ec-ev-appl-accumulate-arg>>
  <<ec-ev-appl-last-arg>>
  <<ec-ev-appl-accum-last-arg>>
  <<ec-apply-dispatch-with-compiled>>
  <<ec-simple-expressions>>
  <<ec-eval-dispatch-let-cond>>
  <<ec-external-entry>>
    )))
  )
(set-register-contents! eceval 'flag false)

(compile-and-go
   '(define (factorial n)
      (if (= n 1)
      1
      (* (factorial (- n 1)) n))))

#+end_src

#+RESULTS[d9250fff6ef75a54fff25e40b2acb5f582b72bc4]:
#+begin_src shell
;;EC-Eval value:
ok

(total-pushes = 0 maximum-depth = 0)
;;EC-Eval input:
(factorial 5)
;;EC-Eval value:
120

(total-pushes = 31 maximum-depth = 14)
;;EC-Eval input:
(exit)
#+end_src

**** DONE Exercise 5.31 a ~preserving~ mechanism
     CLOSED: [2020-03-04 Wed 21:36]
***** ~(f 'x 'y)~

 - env around the operator: no need, it's just a lookup
 - env around 'x: no need it's self-evaluating
 - argl around 'x: no need, 'x is self-evaluating
 - argl around 'y: no need, 'y is self-evaluating
 - proc around 'x: no need, 'x is self-evaluating
 - proc around 'y: no need, 'y is self-evaluating

***** ~((f) 'x 'y)~


 - env around the operator: yes, as we don't know what ~(f)~ does
 - env around 'x: no need
 - argl around 'x: no need
 - argl around 'y: no need
 - proc around 'x: no need
 - proc around 'y: no need

***** ~(f (g 'x) y)~

 - env around ~f~ -- no need, it's just a variable
 - env around ~(g 'x)~, yes
 - argl around ~(g 'x)~: yes, as it is an application
 - argl around y: no need
 - proc around ~(g 'x)~, yes, as the proc changes
 - proc around y: no need

***** ~(f (g 'x) 'y)~

 No need to restore ~env~ after ~(g 'x)~, since ~'y~ is just a symbol

**** DONE Exercise 5.32 symbol-lookup optimization
     CLOSED: [2020-03-04 Wed 22:51]

***** a

#+name: ec-test-symbol-optimization
#+begin_src shell :exports code :results verbatim output
  cat <<EOF
  (/ 4 2)
  (exit)
  EOF
#+end_src

#+name: ec-ev-application-optimized
#+begin_src scheme :exports code :results none
ev-application
(save continue)
(assign unev (op operands) (reg exp))
(assign exp (op operator) (reg exp))
(test (op symbol?) (reg exp))
(branch (label symbol-optimization))
(save env)
(save unev)
(assign continue (label ev-appl-did-operator))
(goto (label eval-dispatch))
symbol-optimization
(assign continue (label symbol-optimization-shortcut))
;(assign val (op lookup-variable-value) (reg exp) (reg env))
(goto (label eval-dispatch))
#+end_src

#+name: ec-ev-appl-did-operator-optimized
#+begin_src scheme :exports code :results none
ev-appl-did-operator
(restore unev) ; the operands
(restore env)
symbol-optimization-shortcut
(assign argl (op empty-arglist))
(assign proc (reg val)) ; the operator
(test (op no-operands?) (reg unev))
(branch (label apply-dispatch))
(save proc)
#+end_src


#+header: :stdin ec-test-symbol-optimization
#+begin_src shell :shebang "#!/usr/bin/chibi-scheme" :exports both :results output scalar code
  <<ec-glue1>>
  <<s-truefalse>>
  <<ec-primitive-with-errors>>
  <<ec-s-additional-syntax>>
  <<s-syntax>>
  <<s-application>>
  <<eceval-s-environments>>
  <<s-compound-procedures>>
  <<s-primitive-procedures>>
  <<s-let-implementation>>
  <<s-cond>>
  <<s-user-prompt-print>>

  <<regmac-make-machine>>
  <<regmac-make-register-tracing>>
  <<regmac-make-stack-with-performance>>
  <<regmac-make-new-machine-with-metadata-instr-count-trace-labels-brk>>
  <<regmac-extract-labels-improved-labels-brk>>
  <<regmac-assembler-with-metadata-register-labels-brk>>
  <<regmac-generating-execution-procedures>>
  <<regmac-make-operation-exp-improved>>
  <<regmac-make-operation-exp-syntax>>
  <<regmac-make-assign>>
  <<regmac-make-test>>
  <<regmac-make-save-restore>>
  <<regmac-other-instructions>>

      (define the-global-environment (setup-environment))
      (define (get-global-environment) the-global-environment)
      (define eceval-operations
	(list
  <<ec-eceval-operations-basic>>
  <<ec-eceval-operations-let-cond>>
     (list 'eq? eq?)
     (list 'symbol? symbol?)
     (list 'apply-primitive-procedure-with-errors apply-primitive-procedure-with-errors)
    ))

  (define eceval
	(make-machine
	 '() ;'(exp env val proc argl continue unev)
	 eceval-operations
	 (quote (
  <<ec-repl-stack-monitor>>
  <<ec-errors>>
  <<ec-ev-definition>>
  <<ec-error-simple-expressions-assignment>>
  <<ec-ev-if>>
  <<ec-ev-if-decide>>
  <<ec-ev-sequence>>
  <<ec-ev-sequence-continue>>
  <<ec-ev-begin>>
  <<ec-compound-apply>>
  <<ec-primitive-apply-with-errors>>
  <<ec-ev-application-optimized>>
  <<ec-ev-appl-did-operator-optimized>>
  <<ec-ev-appl-operand-loop>>
  <<ec-ev-appl-accumulate-arg>>
  <<ec-ev-appl-last-arg>>
  <<ec-ev-appl-accum-last-arg>>
  <<ec-apply-dispatch>>

  <<ec-eval-dispatch-let-cond>>
    ))))
(start eceval)

#+end_src

#+RESULTS[2b19ed2019b18f76ff68bebd3f18291696ad9765]:
#+begin_src shell


;;EC-Eval input:
(/ 4 2)
;;EC-Eval value:
2
(total-pushes = 8 maximum-depth = 5)

;;EC-Eval input:
(exit)
#+end_src

Works, and apparently stack is even less used than in the typical case.


***** b

Well, if the operator is a constant, this optimization works. (It is
also similar to the optimization that was built in the prolog
interpreter, the indexed expressions.) But firstly, we would still
have to go through all this process during every function application,
whereas the compiler would do it _in compile time_.

Secondly, the more sophisticated such optimizations are, the more time
they take in the evaluation step. Again, it's better to do everything
in compile-time.

**** DONE Exercise 5.33 compiling ~factorial-alt~
     CLOSED: [2020-03-05 Thu 16:55]

#+name: c-test-factorial-2
#+header: :stdin empty
#+begin_src shell :shebang "#!/usr/bin/chibi-scheme" :exports code :results output verbatim
  <<ec-glue1>>
  <<c-compile>>
  <<c-make-instruction-sequence-empty-instruction-sequence>>
  <<c-compile-linkage>>
  <<c-end-with-linkage>>
  <<c-compile-simple-expressions>>
  <<c-compile-assignment>>
  <<c-make-label>>
  <<c-compile-if>>
  <<c-compile-sequence>>
  <<c-compiled-procedures>>
  <<c-compile-lambda>>
  <<c-compile-lambda-body>>
  <<c-compile-application>>
  <<c-construct-arglist>>
  <<c-compile-procedure-call>>
  <<c-compile-proc-appl>>
  <<c-combining-registers>>
  <<c-append-instruction-sequences>>
  <<c-list-union>>
  <<c-preserving>>
  <<c-tack-on-instruction-sequence>>
  <<c-parallel-instruction-sequences>>
  <<s-syntax>>
  <<s-cond-with-arrow>>
  <<s-application>>

  (define compiled-factorial (compile
     '(define (factorial n)
        (if (= n 1)
          1
          (* n (factorial (- n 1)))))
     'val
     'next))

  (show #t (pretty compiled-factorial))

#+end_src

#+RESULTS[4898ba702e1b2157a1f5715335c7714fdd29af48]: c-test-factorial-2
#+begin_example
((env) (val)
       ((assign val (op make-compiled-procedure) (label entry2) (reg env))
        (goto (label after-lambda1))
        entry2
        (assign env (op compiled-procedure-env) (reg proc))
        (assign env (op extend-environment) (const (n)) (reg argl) (reg env))
        (save continue)
        (save env)
        (assign proc (op lookup-variable-value) (const =) (reg env))
        (assign val (const 1))
        (assign argl (op list) (reg val))
        (assign val (op lookup-variable-value) (const n) (reg env))
        (assign argl (op cons) (reg val) (reg argl))
        (test (op primitive-procedure?) (reg proc))
        (branch (label primitive-branch17))
        compiled-branch16
        (assign continue (label after-call15))
        (assign val (op compiled-procedure-entry) (reg proc))
        (goto (reg val))
        primitive-branch17
        (assign val (op apply-primitive-procedure) (reg proc) (reg argl))
        after-call15
        (restore env)
        (restore continue)
        (test (op false?) (reg val))
        (branch (label false-branch4))
        true-branch5
        (assign val (const 1))
        (goto (reg continue))
        false-branch4
        (assign proc (op lookup-variable-value) (const *) (reg env))
        (save continue)
        (save proc)
        (save env)
        (assign proc (op lookup-variable-value) (const factorial) (reg env))
        (save proc)
        (assign proc (op lookup-variable-value) (const -) (reg env))
        (assign val (const 1))
        (assign argl (op list) (reg val))
        (assign val (op lookup-variable-value) (const n) (reg env))
        (assign argl (op cons) (reg val) (reg argl))
        (test (op primitive-procedure?) (reg proc))
        (branch (label primitive-branch8))
        compiled-branch7
        (assign continue (label after-call6))
        (assign val (op compiled-procedure-entry) (reg proc))
        (goto (reg val))
        primitive-branch8
        (assign val (op apply-primitive-procedure) (reg proc) (reg argl))
        after-call6
        (assign argl (op list) (reg val))
        (restore proc)
        (test (op primitive-procedure?) (reg proc))
        (branch (label primitive-branch11))
        compiled-branch10
        (assign continue (label after-call9))
        (assign val (op compiled-procedure-entry) (reg proc))
        (goto (reg val))
        primitive-branch11
        (assign val (op apply-primitive-procedure) (reg proc) (reg argl))
        after-call9
        (assign argl (op list) (reg val))
        (restore env)
        (assign val (op lookup-variable-value) (const n) (reg env))
        (assign argl (op cons) (reg val) (reg argl))
        (restore proc)
        (restore continue)
        (test (op primitive-procedure?) (reg proc))
        (branch (label primitive-branch14))
        compiled-branch13
        (assign val (op compiled-procedure-entry) (reg proc))
        (goto (reg val))
        primitive-branch14
        (assign val (op apply-primitive-procedure) (reg proc) (reg argl))
        (goto (reg continue))
        after-call12
        after-if3
        after-lambda1
        (perform (op define-variable!) (const factorial) (reg val) (reg env))
        (assign val (const ok))))
#+end_example


#+name: diff-two-factorials
#+begin_src shell :exports both :results output code :stdin empty :wrap src patch
  output1=$(
  cat <<'EOF'
  <<c-test-factorial-1()>>
  EOF
  )

  output2=$(
  cat <<'EOF'
  <<c-test-factorial-2()>>
  EOF
  )
  #echo "$output1"
  #echo "============"
  #echo "$output2"

  diff -s -u <(echo "$output1") <(echo "$output2") 
#+end_src

#+RESULTS[4503be01564091f952090823aa12eabe60ae2ffc]: diff-two-factorials
#+begin_src patch
--- /dev/fd/63	2020-05-28 10:11:18.037676968 +0800
+++ /dev/fd/62	2020-05-28 10:11:18.037676968 +0800
@@ -31,9 +31,7 @@
         (assign proc (op lookup-variable-value) (const *) (reg env))
         (save continue)
         (save proc)
-        (assign val (op lookup-variable-value) (const n) (reg env))
-        (assign argl (op list) (reg val))
-        (save argl)
+        (save env)
         (assign proc (op lookup-variable-value) (const factorial) (reg env))
         (save proc)
         (assign proc (op lookup-variable-value) (const -) (reg env))
@@ -61,7 +59,9 @@
         primitive-branch11
         (assign val (op apply-primitive-procedure) (reg proc) (reg argl))
         after-call9
-        (restore argl)
+        (assign argl (op list) (reg val))
+        (restore env)
+        (assign val (op lookup-variable-value) (const n) (reg env))
         (assign argl (op cons) (reg val) (reg argl))
         (restore proc)
         (restore continue)
#+end_src


We can see that saving and restoring (reg argl) and (reg env) have
been swapped, but the total amount of operations is the same, so the
functions have equal efficiency.

**** DONE Exercise 5.34 compiling iterative factorial
     CLOSED: [2020-03-05 Thu 20:58]

#+name: c-test-factorial-iter
#+header: :stdin empty
#+begin_src shell :shebang "#!/usr/bin/chibi-scheme" :exports both :results output verbatim

<<ec-glue1>>
  <<c-compile>>
  <<c-make-instruction-sequence-empty-instruction-sequence>>
  <<c-compile-linkage>>
  <<c-end-with-linkage>>
  <<c-compile-simple-expressions>>
  <<c-compile-assignment>>
  <<c-make-label>>
  <<c-compile-if>>
  <<c-compile-sequence>>
  <<c-compiled-procedures>>
  <<c-compile-lambda>>
  <<c-compile-lambda-body>>
  <<c-compile-application>>
  <<c-construct-arglist>>
  <<c-compile-procedure-call>>
  <<c-compile-proc-appl>>
  <<c-combining-registers>>
  <<c-append-instruction-sequences>>
  <<c-list-union>>
  <<c-preserving>>
  <<c-tack-on-instruction-sequence>>
  <<c-parallel-instruction-sequences>>
  <<s-syntax>>
  <<s-cond-with-arrow>>
  <<s-application>>

  (define compiled-factorial (compile
			      '(define (factorial n)
                                 (define (iter product counter)
                                   (if (> counter n)
                                      product
                                     (iter (* counter product)
                                         (+ counter 1))))
                                 (iter 1 1))
                              'val
                              'next))

    (show #t (pretty compiled-factorial))

#+end_src

The result of the next block is easier to study on a screen greater
than 128 characters wide.

#+header: :stdin empty
#+begin_src shell :exports both :results output code :wrap src patch
  output1=$(
  cat <<'EOF'
  <<c-test-factorial-1()>>
  EOF
  )

  output2=$(
  cat <<'EOF'
  <<c-test-factorial-iter()>>
  EOF
  )
  #echo "$output1"
  #echo "============"
  #echo "$output2"

  diff -w -s -y <(echo "$output1") <(echo "$output2") | nl -w2 -
#+end_src

#+RESULTS:
#+begin_src patch
 1	((env) (val)							((env) (val)
 2	       ((assign val (op make-compiled-procedure) (label entry	       ((assign val (op make-compiled-procedure) (label entry
 3	        (goto (label after-lambda1))				        (goto (label after-lambda1))
 4	        entry2							        entry2
 5	        (assign env (op compiled-procedure-env) (reg proc))	        (assign env (op compiled-procedure-env) (reg proc))
 6	        (assign env (op extend-environment) (const (n)) (reg 	        (assign env (op extend-environment) (const (n)) (reg
 7								      >	        (assign val (op make-compiled-procedure) (label entry
 8								      >	        (goto (label after-lambda6))
 9								      >	        entry7
10								      >	        (assign env (op compiled-procedure-env) (reg proc))
11								      >	        (assign env
12								      >	                (op extend-environment)
13								      >	                (const (product counter))
14								      >	                (reg argl)
15								      >	                (reg env))
16	        (save continue)						        (save continue)
17	        (save env)						        (save env)
18	        (assign proc (op lookup-variable-value) (const =) (re |	        (assign proc (op lookup-variable-value) (const >) (re
19	        (assign val (const 1))				      <
20	        (assign argl (op list) (reg val))		      <
21	        (assign val (op lookup-variable-value) (const n) (reg	        (assign val (op lookup-variable-value) (const n) (reg
22								      >	        (assign argl (op list) (reg val))
23								      >	        (assign val (op lookup-variable-value) (const counter
24	        (assign argl (op cons) (reg val) (reg argl))		        (assign argl (op cons) (reg val) (reg argl))
25	        (test (op primitive-procedure?) (reg proc))		        (test (op primitive-procedure?) (reg proc))
26	        (branch (label primitive-branch17))		      |	        (branch (label primitive-branch22))
27	        compiled-branch16				      |	        compiled-branch21
28	        (assign continue (label after-call15))		      |	        (assign continue (label after-call20))
29	        (assign val (op compiled-procedure-entry) (reg proc))	        (assign val (op compiled-procedure-entry) (reg proc))
30	        (goto (reg val))					        (goto (reg val))
31	        primitive-branch17				      |	        primitive-branch22
32	        (assign val (op apply-primitive-procedure) (reg proc)	        (assign val (op apply-primitive-procedure) (reg proc)
33	        after-call15					      |	        after-call20
34	        (restore env)						        (restore env)
35	        (restore continue)					        (restore continue)
36	        (test (op false?) (reg val))				        (test (op false?) (reg val))
37	        (branch (label false-branch4))			      |	        (branch (label false-branch9))
38	        true-branch5					      |	        true-branch10
39	        (assign val (const 1))				      |	        (assign val (op lookup-variable-value) (const product
40	        (goto (reg continue))					        (goto (reg continue))
41	        false-branch4					      |	        false-branch9
42	        (assign proc (op lookup-variable-value) (const *) (re |	        (assign proc (op lookup-variable-value) (const iter)
43	        (save continue)						        (save continue)
44	        (save proc)						        (save proc)
45	        (assign val (op lookup-variable-value) (const n) (reg |	        (save env)
46	        (assign argl (op list) (reg val))		      |	        (assign proc (op lookup-variable-value) (const +) (re
47	        (save argl)					      <
48	        (assign proc (op lookup-variable-value) (const factor <
49	        (save proc)					      <
50	        (assign proc (op lookup-variable-value) (const -) (re <
51	        (assign val (const 1))					        (assign val (const 1))
52	        (assign argl (op list) (reg val))			        (assign argl (op list) (reg val))
53	        (assign val (op lookup-variable-value) (const n) (reg |	        (assign val (op lookup-variable-value) (const counter
54	        (assign argl (op cons) (reg val) (reg argl))		        (assign argl (op cons) (reg val) (reg argl))
55	        (test (op primitive-procedure?) (reg proc))		        (test (op primitive-procedure?) (reg proc))
56	        (branch (label primitive-branch8))		      |	        (branch (label primitive-branch16))
57	        compiled-branch7				      |	        compiled-branch15
58	        (assign continue (label after-call6))		      |	        (assign continue (label after-call14))
59	        (assign val (op compiled-procedure-entry) (reg proc))	        (assign val (op compiled-procedure-entry) (reg proc))
60	        (goto (reg val))					        (goto (reg val))
61	        primitive-branch8				      |	        primitive-branch16
62	        (assign val (op apply-primitive-procedure) (reg proc)	        (assign val (op apply-primitive-procedure) (reg proc)
63	        after-call6					      |	        after-call14
64	        (assign argl (op list) (reg val))			        (assign argl (op list) (reg val))
65	        (restore proc)					      |	        (restore env)
66								      >	        (save argl)
67								      >	        (assign proc (op lookup-variable-value) (const *) (re
68								      >	        (assign val (op lookup-variable-value) (const product
69								      >	        (assign argl (op list) (reg val))
70								      >	        (assign val (op lookup-variable-value) (const counter
71								      >	        (assign argl (op cons) (reg val) (reg argl))
72	        (test (op primitive-procedure?) (reg proc))		        (test (op primitive-procedure?) (reg proc))
73	        (branch (label primitive-branch11))		      |	        (branch (label primitive-branch13))
74	        compiled-branch10				      |	        compiled-branch12
75	        (assign continue (label after-call9))		      |	        (assign continue (label after-call11))
76	        (assign val (op compiled-procedure-entry) (reg proc))	        (assign val (op compiled-procedure-entry) (reg proc))
77	        (goto (reg val))					        (goto (reg val))
78	        primitive-branch11				      |	        primitive-branch13
79	        (assign val (op apply-primitive-procedure) (reg proc)	        (assign val (op apply-primitive-procedure) (reg proc)
80	        after-call9					      |	        after-call11
81	        (restore argl)						        (restore argl)
82	        (assign argl (op cons) (reg val) (reg argl))		        (assign argl (op cons) (reg val) (reg argl))
83	        (restore proc)						        (restore proc)
84	        (restore continue)					        (restore continue)
85	        (test (op primitive-procedure?) (reg proc))		        (test (op primitive-procedure?) (reg proc))
86	        (branch (label primitive-branch14))		      |	        (branch (label primitive-branch19))
87	        compiled-branch13				      |	        compiled-branch18
88								      >	        (assign val (op compiled-procedure-entry) (reg proc))
89								      >	        (goto (reg val))
90								      >	        primitive-branch19
91								      >	        (assign val (op apply-primitive-procedure) (reg proc)
92								      >	        (goto (reg continue))
93								      >	        after-call17
94								      >	        after-if8
95								      >	        after-lambda6
96								      >	        (perform (op define-variable!) (const iter) (reg val)
97								      >	        (assign val (const ok))
98								      >	        (assign proc (op lookup-variable-value) (const iter)
99								      >	        (assign val (const 1))
100								      >	        (assign argl (op list) (reg val))
101								      >	        (assign val (const 1))
102								      >	        (assign argl (op cons) (reg val) (reg argl))
103								      >	        (test (op primitive-procedure?) (reg proc))
104								      >	        (branch (label primitive-branch5))
105								      >	        compiled-branch4
106	        (assign val (op compiled-procedure-entry) (reg proc))	        (assign val (op compiled-procedure-entry) (reg proc))
107	        (goto (reg val))					        (goto (reg val))
108	        primitive-branch14				      |	        primitive-branch5
109	        (assign val (op apply-primitive-procedure) (reg proc)	        (assign val (op apply-primitive-procedure) (reg proc)
110	        (goto (reg continue))					        (goto (reg continue))
111	        after-call12					      |	        after-call3
112	        after-if3					      <
113	        after-lambda1						        after-lambda1
114	        (perform (op define-variable!) (const factorial) (reg	        (perform (op define-variable!) (const factorial) (reg
115	        (assign val (const ok))))				        (assign val (const ok))))
#+end_src

On line 47, in the false branch of the ~if~, we are saving ~argl~ and
~proc~, in order to do a recursive call. These ~save~ operations are
not present on the right hand side, and moreover, are executed on
every iteration. Therefore, stack for them grows linearly with ~n~.
Diff highlights this for us.

**** DONE Exercise 5.35 Decompilation
     CLOSED: [2020-03-05 Thu 21:30]

#+name: decompilation-listing-535
#+begin_src shell :shebang "#!/usr/bin/chibi-scheme" :results output
(import (scheme small))
(import (srfi 159))
(show #t  (pretty (quote ( (env) (val)
  ((assign val
	  (op make-compiled-procedure)
	  (label entry16)
	  (reg env)) ; define
  (goto (label after-lambda15))
  entry16
  (assign env (op compiled-procedure-env) (reg proc))
  (assign env
	  (op extend-environment)
	  (const (x))
	  (reg argl)
	  (reg env))
  (assign proc
	  (op lookup-variable-value)
	  (const +) ; first opening parenthesis with a "+"
	  (reg env))
  (save continue)
  (save proc)
  (save env)
  (assign proc
	  (op lookup-variable-value)
	  (const g) ;  (+ ... (g ... ))
	  (reg env))
  (save proc)
  (assign proc
	  (op lookup-variable-value)
	  (const +)  ;  (+ ... (g ... (+ )))
	  (reg env))
  (assign val (const 2)) ; (+ ... (g ... (+ ... 2)))
  (assign argl (op list) (reg val))
  (assign val
	  (op lookup-variable-value)
	  (const x) ; (+ ... (g ... (+ ... x 2)))
	  (reg env))
  (assign argl (op cons) (reg val) (reg argl)) ; (+ ... (g ... (+ x 2)))
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-branch19))
  compiled-branch18
  (assign continue (label after-call17))
  (assign val (op compiled-procedure-entry) (reg proc))
  (goto (reg val))
  primitive-branch19
  (assign val
	  (op apply-primitive-procedure)
	  (reg proc)
	  (reg argl)) ; (+ ... (g (+ x 2)))
  after-call17
  (assign argl (op list) (reg val))
  (restore proc)
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-branch22))
  compiled-branch21
  (assign continue (label after-call20))
  (assign val (op compiled-procedure-entry) (reg proc))
  (goto (reg val))
  primitive-branch22
  (assign val
	  (op apply-primitive-procedure)
	  (reg proc)
	  (reg argl))
  after-call20
  (assign argl (op list) (reg val))
  (restore env)
  (assign val
	  (op lookup-variable-value)
	  (const x) ; (+ x (g (+ x 2)))
	  (reg env))
  (assign argl (op cons) (reg val) (reg argl))
  (restore proc)
  (restore continue)
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-branch25))
  compiled-branch24
  (assign val
	  (op compiled-procedure-entry)
	  (reg proc))
  (goto (reg val))
  primitive-branch25
  (assign val
	  (op apply-primitive-procedure)
	  (reg proc)
	  (reg argl))
  (goto (reg continue))
  after-call23
  after-lambda15
  (perform (op define-variable!)
	   (const f) ;the name of the function
	   (reg val)
	   (reg env))
  (assign val (const ok)))))))
#+end_src

#+RESULTS[a7bb60f99e1c89fc9f65d85d793998f75a72f66a]: decompilation-listing-535
#+begin_src shell
((env) (val)
       ((assign val (op make-compiled-procedure) (label entry16) (reg env))
        (goto (label after-lambda15))
        entry16
        (assign env (op compiled-procedure-env) (reg proc))
        (assign env (op extend-environment) (const (x)) (reg argl) (reg env))
        (assign proc (op lookup-variable-value) (const +) (reg env))
        (save continue)
        (save proc)
        (save env)
        (assign proc (op lookup-variable-value) (const g) (reg env))
        (save proc)
        (assign proc (op lookup-variable-value) (const +) (reg env))
        (assign val (const 2))
        (assign argl (op list) (reg val))
        (assign val (op lookup-variable-value) (const x) (reg env))
        (assign argl (op cons) (reg val) (reg argl))
        (test (op primitive-procedure?) (reg proc))
        (branch (label primitive-branch19))
        compiled-branch18
        (assign continue (label after-call17))
        (assign val (op compiled-procedure-entry) (reg proc))
        (goto (reg val))
        primitive-branch19
        (assign val (op apply-primitive-procedure) (reg proc) (reg argl))
        after-call17
        (assign argl (op list) (reg val))
        (restore proc)
        (test (op primitive-procedure?) (reg proc))
        (branch (label primitive-branch22))
        compiled-branch21
        (assign continue (label after-call20))
        (assign val (op compiled-procedure-entry) (reg proc))
        (goto (reg val))
        primitive-branch22
        (assign val (op apply-primitive-procedure) (reg proc) (reg argl))
        after-call20
        (assign argl (op list) (reg val))
        (restore env)
        (assign val (op lookup-variable-value) (const x) (reg env))
        (assign argl (op cons) (reg val) (reg argl))
        (restore proc)
        (restore continue)
        (test (op primitive-procedure?) (reg proc))
        (branch (label primitive-branch25))
        compiled-branch24
        (assign val (op compiled-procedure-entry) (reg proc))
        (goto (reg val))
        primitive-branch25
        (assign val (op apply-primitive-procedure) (reg proc) (reg argl))
        (goto (reg continue))
        after-call23
        after-lambda15
        (perform (op define-variable!) (const f) (reg val) (reg env))
        (assign val (const ok))))
#+end_src


The key to solving this exercise is to understand that the compiler
compiles code the following way: first, the operator, then the
operands, right-to-left. Everything we have here is a tree of nested
sexps, therefore every time we see a ~proc~ register assigned, this
means an opening parenthesis, and then we fill the argument list right
to left.


#+name: c-listing-decompilation
#+header: :stdin empty :exports code
#+begin_src shell :shebang "#!/usr/bin/chibi-scheme" :results output
<<ec-glue1>>
  <<c-compile>>
  <<c-make-instruction-sequence-empty-instruction-sequence>>
  <<c-compile-linkage>>
  <<c-end-with-linkage>>
  <<c-compile-simple-expressions>>
  <<c-compile-assignment>>
  <<c-make-label>>
  <<c-compile-if>>
  <<c-compile-sequence>>
  <<c-compiled-procedures>>
  <<c-compile-lambda>>
  <<c-compile-lambda-body>>
  <<c-compile-application>>
  <<c-construct-arglist>>
  <<c-compile-procedure-call>>
  <<c-compile-proc-appl>>
  <<c-combining-registers>>
  <<c-append-instruction-sequences>>
  <<c-list-union>>
  <<c-preserving>>
  <<c-tack-on-instruction-sequence>>
  <<c-parallel-instruction-sequences>>
  <<s-syntax>>
  <<s-cond-with-arrow>>
  <<s-application>>
  (define label-counter 14)
  (define compiled-expr (compile
			      '(define (f x)
                                  (+ x (g (+ x 2))))
                              'val
                              'next))

    (show #t (pretty compiled-expr))

#+end_src

#+RESULTS[6f57c45d3d08e1ab866948b8bea559bf89e8a106]: c-listing-decompilation
#+begin_src shell
((env) (val)
       ((assign val (op make-compiled-procedure) (label entry16) (reg env))
        (goto (label after-lambda15))
        entry16
        (assign env (op compiled-procedure-env) (reg proc))
        (assign env (op extend-environment) (const (x)) (reg argl) (reg env))
        (assign proc (op lookup-variable-value) (const +) (reg env))
        (save continue)
        (save proc)
        (save env)
        (assign proc (op lookup-variable-value) (const g) (reg env))
        (save proc)
        (assign proc (op lookup-variable-value) (const +) (reg env))
        (assign val (const 2))
        (assign argl (op list) (reg val))
        (assign val (op lookup-variable-value) (const x) (reg env))
        (assign argl (op cons) (reg val) (reg argl))
        (test (op primitive-procedure?) (reg proc))
        (branch (label primitive-branch19))
        compiled-branch18
        (assign continue (label after-call17))
        (assign val (op compiled-procedure-entry) (reg proc))
        (goto (reg val))
        primitive-branch19
        (assign val (op apply-primitive-procedure) (reg proc) (reg argl))
        after-call17
        (assign argl (op list) (reg val))
        (restore proc)
        (test (op primitive-procedure?) (reg proc))
        (branch (label primitive-branch22))
        compiled-branch21
        (assign continue (label after-call20))
        (assign val (op compiled-procedure-entry) (reg proc))
        (goto (reg val))
        primitive-branch22
        (assign val (op apply-primitive-procedure) (reg proc) (reg argl))
        after-call20
        (assign argl (op list) (reg val))
        (restore env)
        (assign val (op lookup-variable-value) (const x) (reg env))
        (assign argl (op cons) (reg val) (reg argl))
        (restore proc)
        (restore continue)
        (test (op primitive-procedure?) (reg proc))
        (branch (label primitive-branch25))
        compiled-branch24
        (assign val (op compiled-procedure-entry) (reg proc))
        (goto (reg val))
        primitive-branch25
        (assign val (op apply-primitive-procedure) (reg proc) (reg argl))
        (goto (reg continue))
        after-call23
        after-lambda15
        (perform (op define-variable!) (const f) (reg val) (reg env))
        (assign val (const ok))))
#+end_src

#+header: :stdin empty
#+begin_src shell :results output code :wrap src patch exports both
  output1=$(
  cat <<'EOF'
  <<decompilation-listing-535()>>
  EOF
  )

  output2=$(
  cat <<'EOF'
  <<c-listing-decompilation()>>
  EOF
  )
  #echo "$output1"
  #echo "============"
  #echo "$output2"

  diff -w -s -y <(echo "$output1") <(echo "$output2") | nl -w2 -
#+end_src

#+RESULTS[53a48167e31e708d30f408f86fb33fa47fd1e0bf]:
#+begin_src patch exports both
 1	((env) (val)							((env) (val)
 2	       ((assign val (op make-compiled-procedure) (label entry	       ((assign val (op make-compiled-procedure) (label entry
 3	        (goto (label after-lambda15))				        (goto (label after-lambda15))
 4	        entry16							        entry16
 5	        (assign env (op compiled-procedure-env) (reg proc))	        (assign env (op compiled-procedure-env) (reg proc))
 6	        (assign env (op extend-environment) (const (x)) (reg 	        (assign env (op extend-environment) (const (x)) (reg 
 7	        (assign proc (op lookup-variable-value) (const +) (re	        (assign proc (op lookup-variable-value) (const +) (re
 8	        (save continue)						        (save continue)
 9	        (save proc)						        (save proc)
10	        (save env)						        (save env)
11	        (assign proc (op lookup-variable-value) (const g) (re	        (assign proc (op lookup-variable-value) (const g) (re
12	        (save proc)						        (save proc)
13	        (assign proc (op lookup-variable-value) (const +) (re	        (assign proc (op lookup-variable-value) (const +) (re
14	        (assign val (const 2))					        (assign val (const 2))
15	        (assign argl (op list) (reg val))			        (assign argl (op list) (reg val))
16	        (assign val (op lookup-variable-value) (const x) (reg	        (assign val (op lookup-variable-value) (const x) (reg
17	        (assign argl (op cons) (reg val) (reg argl))		        (assign argl (op cons) (reg val) (reg argl))
18	        (test (op primitive-procedure?) (reg proc))		        (test (op primitive-procedure?) (reg proc))
19	        (branch (label primitive-branch19))			        (branch (label primitive-branch19))
20	        compiled-branch18					        compiled-branch18
21	        (assign continue (label after-call17))			        (assign continue (label after-call17))
22	        (assign val (op compiled-procedure-entry) (reg proc))	        (assign val (op compiled-procedure-entry) (reg proc))
23	        (goto (reg val))					        (goto (reg val))
24	        primitive-branch19					        primitive-branch19
25	        (assign val (op apply-primitive-procedure) (reg proc)	        (assign val (op apply-primitive-procedure) (reg proc)
26	        after-call17						        after-call17
27	        (assign argl (op list) (reg val))			        (assign argl (op list) (reg val))
28	        (restore proc)						        (restore proc)
29	        (test (op primitive-procedure?) (reg proc))		        (test (op primitive-procedure?) (reg proc))
30	        (branch (label primitive-branch22))			        (branch (label primitive-branch22))
31	        compiled-branch21					        compiled-branch21
32	        (assign continue (label after-call20))			        (assign continue (label after-call20))
33	        (assign val (op compiled-procedure-entry) (reg proc))	        (assign val (op compiled-procedure-entry) (reg proc))
34	        (goto (reg val))					        (goto (reg val))
35	        primitive-branch22					        primitive-branch22
36	        (assign val (op apply-primitive-procedure) (reg proc)	        (assign val (op apply-primitive-procedure) (reg proc)
37	        after-call20						        after-call20
38	        (assign argl (op list) (reg val))			        (assign argl (op list) (reg val))
39	        (restore env)						        (restore env)
40	        (assign val (op lookup-variable-value) (const x) (reg	        (assign val (op lookup-variable-value) (const x) (reg
41	        (assign argl (op cons) (reg val) (reg argl))		        (assign argl (op cons) (reg val) (reg argl))
42	        (restore proc)						        (restore proc)
43	        (restore continue)					        (restore continue)
44	        (test (op primitive-procedure?) (reg proc))		        (test (op primitive-procedure?) (reg proc))
45	        (branch (label primitive-branch25))			        (branch (label primitive-branch25))
46	        compiled-branch24					        compiled-branch24
47	        (assign val (op compiled-procedure-entry) (reg proc))	        (assign val (op compiled-procedure-entry) (reg proc))
48	        (goto (reg val))					        (goto (reg val))
49	        primitive-branch25					        primitive-branch25
50	        (assign val (op apply-primitive-procedure) (reg proc)	        (assign val (op apply-primitive-procedure) (reg proc)
51	        (goto (reg continue))					        (goto (reg continue))
52	        after-call23						        after-call23
53	        after-lambda15						        after-lambda15
54	        (perform (op define-variable!) (const f) (reg val) (r	        (perform (op define-variable!) (const f) (reg val) (r
55	        (assign val (const ok))))				        (assign val (const ok))))
56	Files /dev/fd/63 and /dev/fd/62 are identical
#+end_src

**** DONE Exercise 5.36 Order of evaluation
     CLOSED: [2020-03-06 Fri 17:47]

The previous exercise shows that this compiler provides the
right-to-left order of evaluation. Let's change it to be
left-to-right.


#+name: c-construct-arglist-reversed
#+begin_src scheme :exports code :results none
  (define (construct-arglist operand-codes)
    (let ((operand-codes (reverse operand-codes))) ; reverse in order to get last argument
      (if (null? operand-codes)
	  (make-instruction-sequence '() '(argl)
				     '((assign argl (const ()))))
	  (let ((code-to-get-last-arg
		 (append-instruction-sequences
		  (car operand-codes)
		  (make-instruction-sequence '(val) '(argl)
					     '((assign argl (op list) (reg val)))))))
	    (if (null? (cdr operand-codes))
		code-to-get-last-arg
		(preserving '(env)
			    code-to-get-last-arg
			    (code-to-get-rest-args
			     (reverse (cdr operand-codes)))))))))
  (define (code-to-get-rest-args operand-codes)
    (let ((code-for-next-arg
	   (preserving '(argl)
		       (car operand-codes)
		       (make-instruction-sequence '(val argl) '(argl)
						  '((assign argl
							    (op cons) (reg val) (reg argl)))))))
      (if (null? (cdr operand-codes))
	  code-for-next-arg
	  (preserving '(env)
		      code-for-next-arg
		      (code-to-get-rest-args (cdr operand-codes))))))
#+end_src

#+header: :stdin c-test-compile-and-go
#+begin_src shell :shebang "#!/usr/bin/chibi-scheme" :exports code :results output scalar code
  <<ec-glue1>>
  <<s-truefalse>>
  <<ec-s-additional-syntax>>
  <<s-syntax>>
  <<s-application>>
  <<s-environments>>
  <<s-compound-procedures>>
  <<s-primitive-procedures>>
  <<s-let-implementation>>
  <<s-cond>>
  <<s-user-prompt-print-with-compiled>>
  <<regmac-make-machine>>
  <<regmac-make-register-tracing>>
  <<regmac-make-stack-with-performance>>
  <<regmac-make-new-machine-with-metadata-instr-count-trace-labels-brk>>
  <<regmac-extract-labels-improved-labels-brk>>
  <<regmac-assembler-with-metadata-register-labels-brk>>
  <<regmac-generating-execution-procedures>>
  <<regmac-make-operation-exp>>
  <<regmac-make-operation-exp-syntax>>
  <<regmac-make-assign>>
  <<regmac-make-test>>
  <<regmac-make-save-restore>>
  <<regmac-other-instructions>>

  <<c-compile-and-go>>
    <<c-compile>>
  <<c-make-instruction-sequence-empty-instruction-sequence>>
  <<c-compile-linkage>>
  <<c-end-with-linkage>>
  <<c-compile-simple-expressions>>
  <<c-compile-assignment>>
  <<c-make-label>>
  <<c-compile-if>>
  <<c-compile-sequence>>
  <<c-compiled-procedures>>
  <<c-compile-lambda>>
  <<c-compile-lambda-body>>
  <<c-compile-application>>
  <<c-construct-arglist>>
  <<c-compile-procedure-call>>
  <<c-compile-proc-appl>>
  <<c-combining-registers>>
  <<c-append-instruction-sequences>>
  <<c-list-union>>
  <<c-preserving>>
  <<c-tack-on-instruction-sequence>>
  <<c-parallel-instruction-sequences>>

      (define the-global-environment (setup-environment))
      (define (get-global-environment) the-global-environment)
      (define eceval-operations
	(list
  <<ec-eceval-operations-basic>>
  <<ec-eceval-operations-let-cond>>
  <<ec-eceval-operations-compiled>>
    ))

  (define eceval
	(make-machine
	 '() ;'(exp env val proc argl continue unev)
	 eceval-operations
	 (quote (
  <<ec-before-repl-branch-to-compile>>
  <<ec-repl-stack-monitor>>
  <<ec-errors>>
  <<ec-ev-definition>>
  <<ec-ev-assignment>>
  <<ec-ev-if>>
  <<ec-ev-if-decide>>
  <<ec-ev-sequence>>
  <<ec-ev-sequence-continue>>
  <<ec-ev-begin>>
  <<ec-compound-apply>>
  <<ec-primitive-apply>>
  <<ec-ev-application>>
  <<ec-ev-appl-did-operator>>
  <<ec-ev-appl-operand-loop>>
  <<ec-ev-appl-accumulate-arg>>
  <<ec-ev-appl-last-arg>>
  <<ec-ev-appl-accum-last-arg>>
  <<ec-apply-dispatch-with-compiled>>
  <<ec-simple-expressions>>
  <<ec-eval-dispatch-let-cond>>
  <<ec-external-entry>>
    )))
  )
(set-register-contents! eceval 'flag false)

(compile-and-go
   '(define (factorial n)
      (if (= n 1)
      1
      (* (factorial (- n 1)) n))))

#+end_src

#+RESULTS[d9250fff6ef75a54fff25e40b2acb5f582b72bc4]:
#+begin_src shell
;;EC-Eval value:
ok

(total-pushes = 0 maximum-depth = 0)
;;EC-Eval input:
(factorial 5)
;;EC-Eval value:
120

(total-pushes = 31 maximum-depth = 14)
;;EC-Eval input:
(exit)
#+end_src


#+header: :stdin c-test-compile-and-go
#+begin_src shell :shebang "#!/usr/bin/chibi-scheme" :exports code :results output scalar code
  <<ec-glue1>>
  <<s-truefalse>>
  <<ec-s-additional-syntax>>
  <<s-syntax>>
  <<s-application>>
  <<s-environments>>
  <<s-compound-procedures>>
  <<s-primitive-procedures>>
  <<s-let-implementation>>
  <<s-cond>>
  <<s-user-prompt-print-with-compiled>>
  <<regmac-make-machine>>
  <<regmac-make-register-tracing>>
  <<regmac-make-stack-with-performance>>
  <<regmac-make-new-machine-with-metadata-instr-count-trace-labels-brk>>
  <<regmac-extract-labels-improved-labels-brk>>
  <<regmac-assembler-with-metadata-register-labels-brk>>
  <<regmac-generating-execution-procedures>>
  <<regmac-make-operation-exp>>
  <<regmac-make-operation-exp-syntax>>
  <<regmac-make-assign>>
  <<regmac-make-test>>
  <<regmac-make-save-restore>>
  <<regmac-other-instructions>>

  <<c-compile-and-go>>
    <<c-compile>>
  <<c-make-instruction-sequence-empty-instruction-sequence>>
  <<c-compile-linkage>>
  <<c-end-with-linkage>>
  <<c-compile-simple-expressions>>
  <<c-compile-assignment>>
  <<c-make-label>>
  <<c-compile-if>>
  <<c-compile-sequence>>
  <<c-compiled-procedures>>
  <<c-compile-lambda>>
  <<c-compile-lambda-body>>
  <<c-compile-application>>
  <<c-construct-arglist-reversed>>
  <<c-compile-procedure-call>>
  <<c-compile-proc-appl>>
  <<c-combining-registers>>
  <<c-append-instruction-sequences>>
  <<c-list-union>>
  <<c-preserving>>
  <<c-tack-on-instruction-sequence>>
  <<c-parallel-instruction-sequences>>

      (define the-global-environment (setup-environment))
      (define (get-global-environment) the-global-environment)
      (define eceval-operations
	(list
  <<ec-eceval-operations-basic>>
  <<ec-eceval-operations-let-cond>>
  <<ec-eceval-operations-compiled>>
    ))

  (define eceval
	(make-machine
	 '() ;'(exp env val proc argl continue unev)
	 eceval-operations
	 (quote (
  <<ec-before-repl-branch-to-compile>>
  <<ec-repl-stack-monitor>>
  <<ec-errors>>
  <<ec-ev-definition>>
  <<ec-ev-assignment>>
  <<ec-ev-if>>
  <<ec-ev-if-decide>>
  <<ec-ev-sequence>>
  <<ec-ev-sequence-continue>>
  <<ec-ev-begin>>
  <<ec-compound-apply>>
  <<ec-primitive-apply>>
  <<ec-ev-application>>
  <<ec-ev-appl-did-operator>>
  <<ec-ev-appl-operand-loop>>
  <<ec-ev-appl-accumulate-arg>>
  <<ec-ev-appl-last-arg>>
  <<ec-ev-appl-accum-last-arg>>
  <<ec-apply-dispatch-with-compiled>>
  <<ec-simple-expressions>>
  <<ec-eval-dispatch-let-cond>>
  <<ec-external-entry>>
    )))
  )
(set-register-contents! eceval 'flag false)

(compile-and-go
   '(define (factorial n)
      (if (= n 1)
      1
      (* (factorial (- n 1)) n))))

#+end_src

#+RESULTS[fb7e18735580342462cba6a2d60de37952889c91]:
#+begin_src shell
;;EC-Eval value:
ok

(total-pushes = 0 maximum-depth = 0)
;;EC-Eval input:
(factorial 5)
;;EC-Eval value:
120

(total-pushes = 31 maximum-depth = 14)
;;EC-Eval input:
(exit)
#+end_src

The resulting evaluation order is in fact: (1) operator, (2) last
operand, (3) all operands in the middle. I chose to implement this
order, well, because it amounts to just once reversing the list. Hence
the efficiency of compiling left-to-right is worse by the additive
length of the argument list.

**** DONE Exercise 5.37 ~preserving~
     CLOSED: [2020-03-06 Fri 21:01]

The following modification always saves the registers given to it.
(But not _all_ registers ever.)

#+name: c-preserving-all-registers
#+begin_src scheme :exports code :results none
  (define (preserving regs seq1 seq2)
    (if (null? regs)
	(append-instruction-sequences seq1 seq2)
	(let ((first-reg (car regs)))
	  (if #t #;(and (needs-register? seq2 first-reg)
		   (modifies-register? seq1 first-reg))
	      (preserving (cdr regs)
			  (make-instruction-sequence
			   (list-union (list first-reg)
				       (registers-needed seq1))
			   (list-difference (registers-modified seq1)
					    (list first-reg))
			   (append `((save ,first-reg))
				   (statements seq1)
				   `((restore ,first-reg))))
			  seq2)
	      (preserving (cdr regs) seq1 seq2)))))
#+end_src

#+name: c-preserving-expression
#+begin_src scheme :exports code :results none
(define (f x)
  (+ x (g (+ x 2))))
#+end_src

#+name: c-test-preserving-standard
#+header: :stdin empty  :exports code
#+begin_src shell :shebang "#!/usr/bin/chibi-scheme" :results output code
<<ec-glue1>>
  <<c-compile>>
  <<c-make-instruction-sequence-empty-instruction-sequence>>
  <<c-compile-linkage>>
  <<c-end-with-linkage>>
  <<c-compile-simple-expressions>>
  <<c-compile-assignment>>
  <<c-make-label>>
  <<c-compile-if>>
  <<c-compile-sequence>>
  <<c-compiled-procedures>>
  <<c-compile-lambda>>
  <<c-compile-lambda-body>>
  <<c-compile-application>>
  <<c-construct-arglist>>
  <<c-compile-procedure-call>>
  <<c-compile-proc-appl>>
  <<c-combining-registers>>
  <<c-append-instruction-sequences>>
  <<c-list-union>>
  <<c-preserving>>
  <<c-tack-on-instruction-sequence>>
  <<c-parallel-instruction-sequences>>
  <<s-syntax>>
  <<s-cond-with-arrow>>
  <<s-application>>
  (define label-counter 14)
  (define compiled-expr (compile
			      (quote
<<c-preserving-expression>>
)
                              'val
                              'next))

   (show #t (car compiled-expr) nl)
   (show #t (cadr compiled-expr) nl)
   (for-each (lambda (x) (show #t (written x) nl)) (caddr compiled-expr))

#+end_src



#+name: c-test-preserving-unoptimized
#+header: :stdin empty  :exports code
#+begin_src shell :shebang "#!/usr/bin/chibi-scheme" :results output
<<ec-glue1>>
  <<c-compile>>
  <<c-make-instruction-sequence-empty-instruction-sequence>>
  <<c-compile-linkage>>
  <<c-end-with-linkage>>
  <<c-compile-simple-expressions>>
  <<c-compile-assignment>>
  <<c-make-label>>
  <<c-compile-if>>
  <<c-compile-sequence>>
  <<c-compiled-procedures>>
  <<c-compile-lambda>>
  <<c-compile-lambda-body>>
  <<c-compile-application>>
  <<c-construct-arglist>>
  <<c-compile-procedure-call>>
  <<c-compile-proc-appl>>
  <<c-combining-registers>>
  <<c-append-instruction-sequences>>
  <<c-list-union>>
  <<c-preserving-all-registers>>
  <<c-tack-on-instruction-sequence>>
  <<c-parallel-instruction-sequences>>
  <<s-syntax>>
  <<s-cond-with-arrow>>
  <<s-application>>
  (define label-counter 14)
  (define compiled-expr (compile
			      (quote
<<c-preserving-expression>>
)
                              'val
                              'next))

   (show #t (car compiled-expr) nl)
   (show #t (cadr compiled-expr) nl)
   (for-each (lambda (x) (show #t (written x) nl)) (caddr compiled-expr))
#+end_src


#+header: :stdin empty
#+begin_src shell :results output code :wrap src patch :exports both
  output1=$(
  cat <<'EOF'
  <<c-test-preserving-standard()>>
  EOF
  )

  output2=$(
  cat <<'EOF'
  <<c-test-preserving-unoptimized()>>
  EOF
  )
  #echo "$output1"
  #echo "============"
  #echo "$output2"

  diff -w -s -y <(echo "$output1") <(echo "$output2") | nl -w2 -
#+end_src

#+RESULTS[4a4dc5240c88770ad4c3e604ec4942a0021d4af6]:
#+begin_src patch
 1	(env)							      |	(continue env)
 2	(val)								(val)
 3								      >	(save continue)
 4								      >	(save env)
 5								      >	(save continue)
 6	(assign val (op make-compiled-procedure) (label entry16) (reg	(assign val (op make-compiled-procedure) (label entry16) (reg
 7								      >	(restore continue)
 8	(goto (label after-lambda15))					(goto (label after-lambda15))
 9	entry16								entry16
10	(assign env (op compiled-procedure-env) (reg proc))		(assign env (op compiled-procedure-env) (reg proc))
11	(assign env (op extend-environment) (const (x)) (reg argl) (r	(assign env (op extend-environment) (const (x)) (reg argl) (r
12								      >	(save continue)
13								      >	(save env)
14								      >	(save continue)
15	(assign proc (op lookup-variable-value) (const +) (reg env))	(assign proc (op lookup-variable-value) (const +) (reg env))
16								      >	(restore continue)
17								      >	(restore env)
18								      >	(restore continue)
19	(save continue)							(save continue)
20	(save proc)							(save proc)
21	(save env)							(save env)
22								      >	(save continue)
23								      >	(save env)
24								      >	(save continue)
25	(assign proc (op lookup-variable-value) (const g) (reg env))	(assign proc (op lookup-variable-value) (const g) (reg env))
26								      >	(restore continue)
27								      >	(restore env)
28								      >	(restore continue)
29								      >	(save continue)
30	(save proc)							(save proc)
31								      >	(save continue)
32								      >	(save env)
33								      >	(save continue)
34	(assign proc (op lookup-variable-value) (const +) (reg env))	(assign proc (op lookup-variable-value) (const +) (reg env))
35								      >	(restore continue)
36								      >	(restore env)
37								      >	(restore continue)
38								      >	(save continue)
39								      >	(save proc)
40								      >	(save env)
41								      >	(save continue)
42	(assign val (const 2))						(assign val (const 2))
43								      >	(restore continue)
44	(assign argl (op list) (reg val))				(assign argl (op list) (reg val))
45								      >	(restore env)
46								      >	(save argl)
47								      >	(save continue)
48	(assign val (op lookup-variable-value) (const x) (reg env))	(assign val (op lookup-variable-value) (const x) (reg env))
49								      >	(restore continue)
50								      >	(restore argl)
51	(assign argl (op cons) (reg val) (reg argl))			(assign argl (op cons) (reg val) (reg argl))
52								      >	(restore proc)
53								      >	(restore continue)
54	(test (op primitive-procedure?) (reg proc))			(test (op primitive-procedure?) (reg proc))
55	(branch (label primitive-branch19))				(branch (label primitive-branch19))
56	compiled-branch18						compiled-branch18
57	(assign continue (label after-call17))				(assign continue (label after-call17))
58	(assign val (op compiled-procedure-entry) (reg proc))		(assign val (op compiled-procedure-entry) (reg proc))
59	(goto (reg val))						(goto (reg val))
60	primitive-branch19						primitive-branch19
61								      >	(save continue)
62	(assign val (op apply-primitive-procedure) (reg proc) (reg ar	(assign val (op apply-primitive-procedure) (reg proc) (reg ar
63								      >	(restore continue)
64	after-call17							after-call17
65	(assign argl (op list) (reg val))				(assign argl (op list) (reg val))
66	(restore proc)							(restore proc)
67								      >	(restore continue)
68	(test (op primitive-procedure?) (reg proc))			(test (op primitive-procedure?) (reg proc))
69	(branch (label primitive-branch22))				(branch (label primitive-branch22))
70	compiled-branch21						compiled-branch21
71	(assign continue (label after-call20))				(assign continue (label after-call20))
72	(assign val (op compiled-procedure-entry) (reg proc))		(assign val (op compiled-procedure-entry) (reg proc))
73	(goto (reg val))						(goto (reg val))
74	primitive-branch22						primitive-branch22
75								      >	(save continue)
76	(assign val (op apply-primitive-procedure) (reg proc) (reg ar	(assign val (op apply-primitive-procedure) (reg proc) (reg ar
77								      >	(restore continue)
78	after-call20							after-call20
79	(assign argl (op list) (reg val))				(assign argl (op list) (reg val))
80	(restore env)							(restore env)
81								      >	(save argl)
82								      >	(save continue)
83	(assign val (op lookup-variable-value) (const x) (reg env))	(assign val (op lookup-variable-value) (const x) (reg env))
84								      >	(restore continue)
85								      >	(restore argl)
86	(assign argl (op cons) (reg val) (reg argl))			(assign argl (op cons) (reg val) (reg argl))
87	(restore proc)							(restore proc)
88	(restore continue)						(restore continue)
89	(test (op primitive-procedure?) (reg proc))			(test (op primitive-procedure?) (reg proc))
90	(branch (label primitive-branch25))				(branch (label primitive-branch25))
91	compiled-branch24						compiled-branch24
92	(assign val (op compiled-procedure-entry) (reg proc))		(assign val (op compiled-procedure-entry) (reg proc))
93	(goto (reg val))						(goto (reg val))
94	primitive-branch25						primitive-branch25
95								      >	(save continue)
96	(assign val (op apply-primitive-procedure) (reg proc) (reg ar	(assign val (op apply-primitive-procedure) (reg proc) (reg ar
97								      >	(restore continue)
98	(goto (reg continue))						(goto (reg continue))
99	after-call23							after-call23
100	after-lambda15							after-lambda15
101								      >	(restore env)
102	(perform (op define-variable!) (const f) (reg val) (reg env))	(perform (op define-variable!) (const f) (reg val) (reg env))
103	(assign val (const ok))						(assign val (const ok))
104								      >	(restore continue)
#+end_src

The diff above is quite illustrative, especially in the places where a
primitive operation is called (definitely not touching ~continue~).

**** DONE Exercise 5.38 open code primitives
     CLOSED: [2020-03-07 Sat 18:57]

***** a ~spread-arguments~

#+name: c-opencode-spread-arguments
#+begin_src scheme :exports code :results none
  (define (spread-arguments operands-src)
    (when (not (= 2 (length operands-src)))
	(error "spread-arguments: wrong number of arguments: " (length operands-src)))
    (preserving '(env)
        (compile (car operands-src) 'arg1 'next)
        (preserving '(arg1)
          (compile (cadr operands-src) 'arg2 'next)
          (make-instruction-sequence '(arg1) '() '()))) ; dirty trick
)
#+end_src

***** b code generators

#+name: c-compile-open-code
#+begin_src scheme :exports code :results none
  (define (compile-open-code-application exp target linkage)
    (let ((primitive (operator exp))
	  (operand-list (operands exp)))
      (end-with-linkage linkage
	(append-instruction-sequences
	  (spread-arguments operand-list)
	  (make-instruction-sequence '(arg1 arg2) (list target)
	    `((assign ,target (op ,primitive) (reg arg1) (reg arg2))))))))

  (define (open-code? exp)
    (and (pair? exp) (symbol? (car exp)) (member (car exp) (list '+ '- '* '/))))

#+end_src

#+name: c-compile-with-opencode
#+begin_src scheme :exports code :results none
  (define (compile exp target linkage)
    (cond ((self-evaluating? exp)
	   (compile-self-evaluating exp target linkage))
	  ((quoted? exp) (compile-quoted exp target linkage))
	  ((variable? exp)
	   (compile-variable exp target linkage))
	  ((assignment? exp)
	   (compile-assignment exp target linkage))
	  ((definition? exp)
	   (compile-definition exp target linkage))
	  ((if? exp) (compile-if exp target linkage))
	  ((lambda? exp) (compile-lambda exp target linkage))
	  ((begin? exp)
	   (compile-sequence
	    (begin-actions exp) target linkage))
	  ((cond? exp)
	   (compile (cond->if exp) target linkage))
          ((open-code? exp)
           (compile-open-code-application exp target linkage))
	  ((application? exp)
	   (compile-application exp target linkage))
	  (else
	   (error "Unknown expression type: COMPILE" exp))))
#+end_src

#+name: ec-eceval-operations-opencode
#+begin_src scheme :exports code :results none
(list '- -)
(list '+ +)
(list '* *)
(list '/ /)
#+end_src


***** c the ~factorial~ example

#+header: :stdin c-test-compile-and-go
#+begin_src shell :shebang "#!/usr/bin/chibi-scheme" :exports both :results output scalar code
  <<ec-glue1>>
  <<s-truefalse>>
  <<ec-s-additional-syntax>>
  <<s-syntax>>
  <<s-application>>
  <<s-environments>>
  <<s-compound-procedures>>
  <<s-primitive-procedures>>
  <<s-let-implementation>>
  <<s-cond>>
  <<s-user-prompt-print-with-compiled>>
  <<regmac-make-machine>>
  <<regmac-make-register-tracing>>
  <<regmac-make-stack-with-performance>>
  <<regmac-make-new-machine-with-metadata-instr-count-trace-labels-brk>>
  <<regmac-extract-labels-improved-labels-brk>>
  <<regmac-assembler-with-metadata-register-labels-brk>>
  <<regmac-generating-execution-procedures>>
  <<regmac-make-operation-exp>>
  <<regmac-make-operation-exp-syntax>>
  <<regmac-make-assign>>
  <<regmac-make-test>>
  <<regmac-make-save-restore>>
  <<regmac-other-instructions>>

  <<c-compile-and-go>>
  <<c-compile-with-opencode>>
  <<c-make-instruction-sequence-empty-instruction-sequence>>
  <<c-compile-linkage>>
  <<c-end-with-linkage>>
  <<c-compile-simple-expressions>>
  <<c-compile-assignment>>
  <<c-make-label>>
  <<c-compile-if>>
  <<c-compile-sequence>>
  <<c-compiled-procedures>>
  <<c-compile-lambda>>
  <<c-compile-lambda-body>>
  <<c-compile-application>>
  <<c-opencode-spread-arguments>>
  <<c-compile-open-code>>
  <<c-construct-arglist-reversed>>
  <<c-compile-procedure-call>>
  <<c-compile-proc-appl>>
  <<c-combining-registers>>
  <<c-append-instruction-sequences>>
  <<c-list-union>>
  <<c-preserving>>
  <<c-tack-on-instruction-sequence>>
  <<c-parallel-instruction-sequences>>

      (define the-global-environment (setup-environment))
      (define (get-global-environment) the-global-environment)
      (define eceval-operations
	(list
  <<ec-eceval-operations-basic>>
  <<ec-eceval-operations-let-cond>>
  <<ec-eceval-operations-compiled>>
  <<ec-eceval-operations-opencode>>
    ))

  (define eceval
	(make-machine
	 '() ;'(exp env val proc argl continue unev)
	 eceval-operations
	 (quote (
  <<ec-before-repl-branch-to-compile>>
  <<ec-repl-stack-monitor>>
  <<ec-errors>>
  <<ec-ev-definition>>
  <<ec-ev-assignment>>
  <<ec-ev-if>>
  <<ec-ev-if-decide>>
  <<ec-ev-sequence>>
  <<ec-ev-sequence-continue>>
  <<ec-ev-begin>>
  <<ec-compound-apply>>
  <<ec-primitive-apply>>
  <<ec-ev-application>>
  <<ec-ev-appl-did-operator>>
  <<ec-ev-appl-operand-loop>>
  <<ec-ev-appl-accumulate-arg>>
  <<ec-ev-appl-last-arg>>
  <<ec-ev-appl-accum-last-arg>>
  <<ec-apply-dispatch-with-compiled>>
  <<ec-simple-expressions>>
  <<ec-eval-dispatch-let-cond>>
  <<ec-external-entry>>
    )))
  )
(set-register-contents! eceval 'flag false)

(compile-and-go
   '(define (factorial n)
      (if (= n 1)
      1
      (* (factorial (- n 1)) n))))
#;(show #t (pretty (compile
    '(define (factorial n)
      (if (= n 1)
      1
      (* (factorial (- n 1)) n)))
     'val
     'next)))

#+end_src

#+RESULTS[f07095d958e93becfef98d9996580a834f8efb4e]:
#+begin_src shell
;;EC-Eval value:
ok

(total-pushes = 0 maximum-depth = 0)
;;EC-Eval input:
(factorial 5)
;;EC-Eval value:
120

(total-pushes = 23 maximum-depth = 10)
;;EC-Eval input:
(exit)
#+end_src

Compared to the previous case, when we had ~(total-pushes = 31
maximum-depth = 14)~, it seems that our "open code" approach is working.



***** d arbitrary number of aruments for ~+~ and ~*~

This is a bit of a trick, but I think it's quite schemy in nature, so
I am fine with it.

#+name: c-opencode-nested
#+begin_src scheme :exports code :results none
  (define (opencode->nested exp)
    (if (= 3 (length exp))
       exp
      (list (car exp) (cadr exp) (opencode->nested (cons (car exp) (cddr exp))))))
#+end_src

#+name: c-compile-with-opencode-multiarg
#+begin_src scheme :exports code :results none
  (define (compile exp target linkage)
    (cond ((self-evaluating? exp)
	   (compile-self-evaluating exp target linkage))
	  ((quoted? exp) (compile-quoted exp target linkage))
	  ((variable? exp)
	   (compile-variable exp target linkage))
	  ((assignment? exp)
	   (compile-assignment exp target linkage))
	  ((definition? exp)
	   (compile-definition exp target linkage))
	  ((if? exp) (compile-if exp target linkage))
	  ((lambda? exp) (compile-lambda exp target linkage))
	  ((begin? exp)
	   (compile-sequence
	    (begin-actions exp) target linkage))
	  ((cond? exp)
	   (compile (cond->if exp) target linkage))
          ((open-code? exp)
           (compile-open-code-application (opencode->nested exp) target linkage))
	  ((application? exp)
	   (compile-application exp target linkage))
	  (else
	   (error "Unknown expression type: COMPILE" exp))))
#+end_src

#+header: :stdin c-test-compile-and-go
#+begin_src shell :shebang "#!/usr/bin/chibi-scheme" :exports both :results output scalar code
  <<ec-glue1>>
  <<s-truefalse>>
  <<ec-s-additional-syntax>>
  <<s-syntax>>
  <<s-application>>
  <<s-environments>>
  <<s-compound-procedures>>
  <<s-primitive-procedures>>
  <<s-let-implementation>>
  <<s-cond>>
  <<s-user-prompt-print-with-compiled>>
  <<regmac-make-machine>>
  <<regmac-make-register-tracing>>
  <<regmac-make-stack-with-performance>>
  <<regmac-make-new-machine-with-metadata-instr-count-trace-labels-brk>>
  <<regmac-extract-labels-improved-labels-brk>>
  <<regmac-assembler-with-metadata-register-labels-brk>>
  <<regmac-generating-execution-procedures>>
  <<regmac-make-operation-exp>>
  <<regmac-make-operation-exp-syntax>>
  <<regmac-make-assign>>
  <<regmac-make-test>>
  <<regmac-make-save-restore>>
  <<regmac-other-instructions>>

  <<c-compile-and-go>>
  <<c-compile-with-opencode-multiarg>>
  <<c-compile-open-code>>
  <<c-opencode-nested>>
  <<c-make-instruction-sequence-empty-instruction-sequence>>
  <<c-compile-linkage>>
  <<c-end-with-linkage>>
  <<c-compile-simple-expressions>>
  <<c-compile-assignment>>
  <<c-make-label>>
  <<c-compile-if>>
  <<c-compile-sequence>>
  <<c-compiled-procedures>>
  <<c-compile-lambda>>
  <<c-compile-lambda-body>>
  <<c-compile-application>>
  <<c-opencode-spread-arguments>>

  <<c-construct-arglist-reversed>>
  <<c-compile-procedure-call>>
  <<c-compile-proc-appl>>
  <<c-combining-registers>>
  <<c-append-instruction-sequences>>
  <<c-list-union>>
  <<c-preserving>>
  <<c-tack-on-instruction-sequence>>
  <<c-parallel-instruction-sequences>>

      (define the-global-environment (setup-environment))
      (define (get-global-environment) the-global-environment)
      (define eceval-operations
	(list
  <<ec-eceval-operations-basic>>
  <<ec-eceval-operations-let-cond>>
  <<ec-eceval-operations-compiled>>
  <<ec-eceval-operations-opencode>>
    ))

  (define eceval
	(make-machine
	 '() ;'(exp env val proc argl continue unev)
	 eceval-operations
	 (quote (
  <<ec-before-repl-branch-to-compile>>
  <<ec-repl-stack-monitor>>
  <<ec-errors>>
  <<ec-ev-definition>>
  <<ec-ev-assignment>>
  <<ec-ev-if>>
  <<ec-ev-if-decide>>
  <<ec-ev-sequence>>
  <<ec-ev-sequence-continue>>
  <<ec-ev-begin>>
  <<ec-compound-apply>>
  <<ec-primitive-apply>>
  <<ec-ev-application>>
  <<ec-ev-appl-did-operator>>
  <<ec-ev-appl-operand-loop>>
  <<ec-ev-appl-accumulate-arg>>
  <<ec-ev-appl-last-arg>>
  <<ec-ev-appl-accum-last-arg>>
  <<ec-apply-dispatch-with-compiled>>
  <<ec-simple-expressions>>
  <<ec-eval-dispatch-let-cond>>
  <<ec-external-entry>>
    )))
  )
(set-register-contents! eceval 'flag false)

(show #t (pretty (compile
    '(define (factorial n)
      (+ 1 2 3))
     'val
     'next)))

(compile-and-go
   '(define (factorial n)
      (+ 1 2 3)))


#+end_src

#+RESULTS[5676fc50e28716e6d9d1e8e4b4db298300919d92]:
#+begin_src shell
((env) (val)
       ((assign val (op make-compiled-procedure) (label entry2) (reg env))
        (goto (label after-lambda1))
        entry2
        (assign env (op compiled-procedure-env) (reg proc))
        (assign env (op extend-environment) (const (n)) (reg argl) (reg env))
        (assign arg1 (const 1))
        (save arg1)
        (assign arg1 (const 2))
        (assign arg2 (const 3))
        (assign arg2 (op +) (reg arg1) (reg arg2))
        (restore arg1)
        (assign val (op +) (reg arg1) (reg arg2))
        (goto (reg continue))
        after-lambda1
        (perform (op define-variable!) (const factorial) (reg val) (reg env))
        (assign val (const ok))))
;;EC-Eval value:
ok

(total-pushes = 0 maximum-depth = 0)
;;EC-Eval input:
(factorial 5)
;;EC-Eval value:
6

(total-pushes = 6 maximum-depth = 3)
;;EC-Eval input:
(exit)
#+end_src

**** DONE Exercise 5.39 ~lexical-address-lookup~
     CLOSED: [2020-03-07 Sat 20:41]

#+name: c-lexical-address-lookup
#+begin_src scheme :exports code :results none
  (define (apply-n-times n op stuff)
    (if (= 0 n)
       stuff
       (apply-n-times (- n 1) op (op stuff))))

  (define (lexical-f-c addr env)
    #;(show #t "debug:lexical-f-c:env=" (pretty env))
       (apply-n-times (cadr addr)
		  cdr
		  (frame-values
		  (first-frame
		    (apply-n-times
			  (car addr)
			   enclosing-environment
			    env)))))

  (define (lexical-address-lookup addr env)
    (let ((candidate (car (lexical-f-c addr env))))
       (if (eq? '*unassigned* candidate)
	  #;(error "there is an error")
	  (error "Variable unassigned"
		   (car
		      (apply-n-times
			     (car addr)
			     cdr
			    (frame-variables
			      (first-frame
				(apply-n-times (car addr)
					       enclosing-environment env))))) addr)
	  candidate)))
  (define (lexical-address-set! addr val env)
    #;(show #t "lexical-address-set!" (pretty addr) (pretty env) (pretty val))
    (let ((candidate (lexical-f-c addr env)))
      (set-car! candidate val)))

#+end_src

#+begin_src scheme :exports both :results output scalar code
<<c-lexical-address-lookup>>
<<s-environments>>
(show #t 
  (pretty 
    (lexical-address-lookup
        '(1 1) 
         (extend-environment 
             '(c d)
             '(c d)
              (extend-environment 
                '(a b)
                '(a b)
                the-empty-environment)))))
(define test-env 
   (extend-environment
      '(c d)
      '(c d)
      (extend-environment
          '(a b)
          (list 'a '*unassigned*)
          the-empty-environment)))
(lexical-address-set! '(1 1)  'test-value test-env)
(show #t (pretty test-env))
(call/cc
(lambda (c) (with-exception-handler
(lambda (e) (show #t "Expected error:" (pretty e)) (c))
(lambda () (lexical-address-lookup '(1 1)
                        (extend-environment '(c d)
                                            '(c d)
                                             (extend-environment
                                                 '(a b)
                                                 '(a *unassigned*)
                                                 the-empty-environment)))))))

#+end_src

#+RESULTS[2f008944ac6c16884c738a4e617fa72d6afef402]:
#+begin_src scheme
b
(((c d) c d) ((a b) a test-value))
Expected error:{Exception #19 user "Variable unassigned" (b (1 1)) #f #f}
#+end_src

Seems to be working.

**** DONE Exercise 5.40 maintaining a compile-time environment
     CLOSED: [2020-03-08 Sun 15:02]

#+name: c-compile-lexical
#+begin_src scheme :exports code :results none
  (define (compile exp target linkage compile-env)
    (cond ((self-evaluating? exp)
	   (compile-self-evaluating exp target linkage))
	  ((quoted? exp) (compile-quoted exp target linkage))
	  ((variable? exp)
	   (compile-variable exp target linkage compile-env))
	  ((assignment? exp)
	   (compile-assignment exp target linkage compile-env))
	  ((definition? exp)
	   (compile-definition exp target linkage compile-env))
	  ((if? exp)
           (compile-if exp target linkage compile-env))
	  ((lambda? exp)
           (compile-lambda exp target linkage compile-env))
	  ((begin? exp)
	   (compile-sequence (begin-actions exp) target linkage compile-env))
	  ((cond? exp)
	   (compile (cond->if exp) target linkage compile-env))
	  ((application? exp)
	   (compile-application exp target linkage compile-env))
	  (else
	   (error "Unknown expression type: COMPILE" exp))))
#+end_src

#+name: c-compile-lexical-simple-expressions
#+begin_src scheme :exports code :results none
  (define (compile-self-evaluating exp target linkage)
    (end-with-linkage 
       linkage
       (make-instruction-sequence 
          '()
          (list target)
          `((assign ,target (const ,exp))))))
  (define (compile-quoted exp target linkage)
    (end-with-linkage linkage
		      (make-instruction-sequence '() (list target)
						 `((assign ,target (const ,(text-of-quotation exp)))))))
#+end_src

#+name: c-compile-lexical-definition
#+begin_src scheme :results none
(define (compile-definition exp target linkage compile-env)
    (let ((var (definition-variable exp))
	  (get-value-code
	   (compile (definition-value exp) 'val 'next compile-env)))
      (end-with-linkage linkage
			(preserving '(env)
				    get-value-code
				    (make-instruction-sequence '(env val) (list target)
							       `((perform (op define-variable!)
									  (const ,var)
									  (reg val)
									  (reg env))
								 (assign ,target (const ok))))))))
#+end_src

#+name: c-compile-lexical-if
#+begin_src scheme :exports code :results none
  (define (compile-if exp target linkage compile-env)
    (let ((t-branch (make-label 'true-branch))
	  (f-branch (make-label 'false-branch))
	  (after-if (make-label 'after-if)))
      (let ((consequent-linkage
	     (if (eq? linkage 'next) after-if linkage)))
	(let ((p-code (compile (if-predicate exp) 'val 'next compile-env))
	      (c-code (compile (if-consequent exp) target consequent-linkage compile-env))
	      (a-code
	       (compile (if-alternative exp) target linkage compile-env)))
	  (preserving '(env continue)
		      p-code
		      (append-instruction-sequences
		       (make-instruction-sequence '(val) '()
						  `((test (op false?) (reg val))
						    (branch (label ,f-branch))))
		       (parallel-instruction-sequences
			(append-instruction-sequences t-branch c-code)
			(append-instruction-sequences f-branch a-code))
		       after-if))))))
#+end_src

#+name: c-compile-lexical-sequence
#+begin_src scheme :exports code :results none
  (define (compile-sequence seq target linkage compile-env1)
    #;(show #t "debug:compile-sequence:" "seq=" (pretty seq) "last-exp?=" (pretty (last-exp? seq)))
    (if (last-exp? seq)
	(compile (first-exp seq) target linkage compile-env1)
	(preserving
	 '(env continue)
	 (compile (first-exp seq) target 'next compile-env1)
	 (compile-sequence (rest-exps seq) target linkage compile-env1))))
#+end_src

#+name: c-compile-lexical-lambda
#+begin_src scheme :exports code :results none
  (define (compile-lambda exp target linkage compile-env)
    (let ((proc-entry (make-label 'entry))
	  (after-lambda (make-label 'after-lambda)))
      (let ((lambda-linkage
	     (if (eq? linkage 'next) after-lambda linkage)))
	(append-instruction-sequences
	 (tack-on-instruction-sequence
	  (end-with-linkage lambda-linkage
			    (make-instruction-sequence '(env) (list target)
						       `((assign ,target
								 (op make-compiled-procedure)
								 (label ,proc-entry)
								 (reg env)))))
	  (compile-lambda-body exp proc-entry compile-env))
	 after-lambda))))
#+end_src

#+name: c-compile-lexical-lambda-body
#+begin_src scheme :exports code :results none
  (define (compile-lambda-body exp proc-entry compile-env)
    (let ((formals (lambda-parameters exp)))
      (append-instruction-sequences
       (make-instruction-sequence '(env proc argl) '(env)
				  `(,proc-entry
				    (assign env
					    (op compiled-procedure-env)
					    (reg proc))
				    (assign env
					    (op extend-environment)
					    (const ,formals)
					    (reg argl)
					    (reg env))))
       (compile-sequence (lambda-body exp) 'val 'return (cons formals compile-env))))) ; The only place where we extend a compile-time environment
#+end_src

#+name: c-compile-lexical-application
#+begin_src scheme :exports code :results none
  (define (compile-application exp target linkage compile-env)
    (let ((proc-code (compile (operator exp) 'proc 'next compile-env))
	  (operand-codes
	   (map (lambda
		    (operand) (compile operand 'val 'next compile-env))
		(operands exp))))
      (preserving '(env continue)
		  proc-code
		  (preserving '(proc continue)
			      (construct-arglist operand-codes)
			      (compile-procedure-call target linkage)))))
#+end_src

#+name: c-compile-and-go-lexical
#+begin_src scheme :exports code :results none
  (define (compile-and-go expression)
    (let ((instructions
	   (assemble
	    (statements
	     (compile expression 'val 'return the-global-environment))
	    eceval)))
      (set! the-global-environment (setup-environment))
      (set-register-contents! eceval 'val instructions)
      (set-register-contents! eceval 'flag true)
      (start eceval)))
#+end_src


Now we need to test these many changes. The result should generate the
code using ~lexical-address-lookup~.

#+name: c-lexical-controller-ops
#+begin_src scheme :exports code :results none
(list 'lexical-address-lookup lexical-address-lookup)
(list 'lexical-address-set! lexical-address-set!)
(list 'find-variable find-variable)
#+end_src

#+name: c-test-lexical
#+begin_src shell :exports code :results verbatim output
  cat <<EOF
  (my-fun 1 2 3 4 5)
  (exit)
  EOF
#+end_src


#+header: :stdin c-test-lexical
#+begin_src shell :shebang "#!/usr/bin/chibi-scheme" :exports both :results output scalar code
  <<ec-glue1>>
  <<s-truefalse>>
  <<ec-s-additional-syntax>>
  <<s-syntax>>
  <<s-application>>
  <<s-environments>>
  <<s-compound-procedures>>
  <<s-primitive-procedures>>
  <<s-let-implementation>>
  <<s-cond>>
  <<s-user-prompt-print-with-compiled>>
  <<regmac-make-machine>>
  <<regmac-make-register-tracing>>
  <<regmac-make-stack-with-performance>>
  <<regmac-make-new-machine-with-metadata-instr-count-trace-labels-brk>>
  <<regmac-extract-labels-improved-labels-brk>>
  <<regmac-assembler-with-metadata-register-labels-brk>>
  <<regmac-generating-execution-procedures>>
  <<regmac-make-operation-exp>>
  <<regmac-make-operation-exp-syntax>>
  <<regmac-make-assign>>
  <<regmac-make-test>>
  <<regmac-make-save-restore>>
  <<regmac-other-instructions>>

  <<c-compile-and-go-lexical>>
  <<c-compile-lexical>>
  <<c-make-instruction-sequence-empty-instruction-sequence>>
  <<c-compile-linkage>>
  <<c-end-with-linkage>>
  <<c-compile-lexical-simple-expressions>>
  <<c-compile-lexical-definition>>
  <<c-lexical-compile-variable-compile-assignment>>
  <<c-make-label>>
  <<c-compile-lexical-if>>
  <<c-compile-lexical-sequence>>
  <<c-compiled-procedures>>
  <<c-compile-lexical-lambda>>
  <<c-compile-lexical-lambda-body>>
  <<c-compile-lexical-application>>
  <<c-lexical-address-lookup>>
  <<c-lexical-find-variable>>
  <<c-construct-arglist>>
  <<c-compile-procedure-call>>
  <<c-compile-proc-appl>>
  <<c-combining-registers>>
  <<c-append-instruction-sequences>>
  <<c-list-union>>
  <<c-preserving>>
  <<c-tack-on-instruction-sequence>>
  <<c-parallel-instruction-sequences>>

      (define the-global-environment (setup-environment))
      (define (get-global-environment) the-global-environment)
      (define eceval-operations
	(list
  <<ec-eceval-operations-basic>>
  <<ec-eceval-operations-let-cond>>
  <<ec-eceval-operations-compiled>>
  <<c-lexical-controller-ops>>
    ))

  (define eceval
	(make-machine
	 '() ;'(exp env val proc argl continue unev)
	 eceval-operations
	 (quote (
  <<ec-before-repl-branch-to-compile>>
  <<ec-repl-stack-monitor>>
  <<ec-errors>>
  <<ec-ev-definition>>
  <<ec-ev-assignment>>
  <<ec-ev-if>>
  <<ec-ev-if-decide>>
  <<ec-ev-sequence>>
  <<ec-ev-sequence-continue>>
  <<ec-ev-begin>>
  <<ec-compound-apply>>
  <<ec-primitive-apply>>
  <<ec-ev-application>>
  <<ec-ev-appl-did-operator>>
  <<ec-ev-appl-operand-loop>>
  <<ec-ev-appl-accumulate-arg>>
  <<ec-ev-appl-last-arg>>
  <<ec-ev-appl-accum-last-arg>>
  <<ec-apply-dispatch-with-compiled>>
  <<ec-simple-expressions>>
  <<ec-eval-dispatch-let-cond>>
  <<ec-external-entry>>
    )))
  )
(set-register-contents! eceval 'flag false)

(show #t (pretty (compile
      '((lambda (x y)
           (lambda (a b c d e)
               ((lambda (y z)
                   (* x y z)) (* a b x) (+ c d x)))) 3 4)
      'val
      'next
      the-global-environment)) nl)

(compile-and-go
   '(define my-fun ((lambda (x y)
                         (lambda (a b c d e)
                         ((lambda (y z)
                            (* x y z)) (* a b x) (+ c d x)))) 3 4)))
#+end_src

#+RESULTS[5ee4ca1d612678af038f644c4e03564c5019e1a1]:
#+begin_src shell
((env) (env proc argl continue val)
       ((assign proc (op make-compiled-procedure) (label entry2) (reg env))
        (goto (label after-lambda1))
        entry2
        (assign env (op compiled-procedure-env) (reg proc))
        (assign env
                (op extend-environment)
                (const (x y))
                (reg argl)
                (reg env))
        (assign val (op make-compiled-procedure) (label entry4) (reg env))
        (goto (reg continue))
        entry4
        (assign env (op compiled-procedure-env) (reg proc))
        (assign env
                (op extend-environment)
                (const (a b c d e))
                (reg argl)
                (reg env))
        (assign proc (op make-compiled-procedure) (label entry12) (reg env))
        (goto (label after-lambda11))
        entry12
        (assign env (op compiled-procedure-env) (reg proc))
        (assign env
                (op extend-environment)
                (const (y z))
                (reg argl)
                (reg env))
        (assign proc (op lookup-variable-value) (const *) (reg env))
        (assign val (op lexical-address-lookup) (const (0 1)) (reg env))
        (assign argl (op list) (reg val))
        (assign val (op lexical-address-lookup) (const (0 0)) (reg env))
        (assign argl (op cons) (reg val) (reg argl))
        (assign val (op lexical-address-lookup) (const (2 0)) (reg env))
        (assign argl (op cons) (reg val) (reg argl))
        (test (op primitive-procedure?) (reg proc))
        (branch (label primitive-branch15))
        compiled-branch14
        (assign val (op compiled-procedure-entry) (reg proc))
        (goto (reg val))
        primitive-branch15
        (assign val (op apply-primitive-procedure) (reg proc) (reg argl))
        (goto (reg continue))
        after-call13
        after-lambda11
        (save continue)
        (save proc)
        (save env)
        (assign proc (op lookup-variable-value) (const +) (reg env))
        (assign val (op lexical-address-lookup) (const (1 0)) (reg env))
        (assign argl (op list) (reg val))
        (assign val (op lexical-address-lookup) (const (0 3)) (reg env))
        (assign argl (op cons) (reg val) (reg argl))
        (assign val (op lexical-address-lookup) (const (0 2)) (reg env))
        (assign argl (op cons) (reg val) (reg argl))
        (test (op primitive-procedure?) (reg proc))
        (branch (label primitive-branch10))
        compiled-branch9
        (assign continue (label after-call8))
        (assign val (op compiled-procedure-entry) (reg proc))
        (goto (reg val))
        primitive-branch10
        (assign val (op apply-primitive-procedure) (reg proc) (reg argl))
        after-call8
        (assign argl (op list) (reg val))
        (restore env)
        (save argl)
        (assign proc (op lookup-variable-value) (const *) (reg env))
        (assign val (op lexical-address-lookup) (const (1 0)) (reg env))
        (assign argl (op list) (reg val))
        (assign val (op lexical-address-lookup) (const (0 1)) (reg env))
        (assign argl (op cons) (reg val) (reg argl))
        (assign val (op lexical-address-lookup) (const (0 0)) (reg env))
        (assign argl (op cons) (reg val) (reg argl))
        (test (op primitive-procedure?) (reg proc))
        (branch (label primitive-branch7))
        compiled-branch6
        (assign continue (label after-call5))
        (assign val (op compiled-procedure-entry) (reg proc))
        (goto (reg val))
        primitive-branch7
        (assign val (op apply-primitive-procedure) (reg proc) (reg argl))
        after-call5
        (restore argl)
        (assign argl (op cons) (reg val) (reg argl))
        (restore proc)
        (restore continue)
        (test (op primitive-procedure?) (reg proc))
        (branch (label primitive-branch18))
        compiled-branch17
        (assign val (op compiled-procedure-entry) (reg proc))
        (goto (reg val))
        primitive-branch18
        (assign val (op apply-primitive-procedure) (reg proc) (reg argl))
        (goto (reg continue))
        after-call16
        after-lambda3
        after-lambda1
        (assign val (const 4))
        (assign argl (op list) (reg val))
        (assign val (const 3))
        (assign argl (op cons) (reg val) (reg argl))
        (test (op primitive-procedure?) (reg proc))
        (branch (label primitive-branch21))
        compiled-branch20
        (assign continue (label after-call19))
        (assign val (op compiled-procedure-entry) (reg proc))
        (goto (reg val))
        primitive-branch21
        (assign val (op apply-primitive-procedure) (reg proc) (reg argl))
        after-call19))

;;EC-Eval value:
ok

(total-pushes = 2 maximum-depth = 2)
;;EC-Eval input:
(my-fun 1 2 3 4 5)
;;EC-Eval value:
180

(total-pushes = 21 maximum-depth = 5)
;;EC-Eval input:
(exit)
#+end_src

I am at total loss of words, but it seems to be working. Lexical
addresses are remembered, and variables are looked up successfully.

**** DONE Exercise 5.41 ~find-variable~
     CLOSED: [2020-03-07 Sat 19:37]

#+name: c-lexical-find-variable
#+begin_src scheme :exports code :results none
(define (find-variable var env)
  (define (iter-vars frame candidate)
    (if (null? frame)
      #f
      (if (eq? (car frame) var)
         candidate
         (iter-vars (cdr frame) (+ 1 candidate)))))
  (define (iter-frames test-env candidate)
     (if (null? test-env)
       'not-found
       (let ((candidate-var (iter-vars (first-frame test-env) 0)))
        (if candidate-var
             (list candidate candidate-var)
             (iter-frames (enclosing-environment test-env) (+ 1 candidate))))))
 (iter-frames env 0))
#+end_src

#+begin_src scheme :exports both :results output scalar code
<<s-environments>>
<<c-lexical-find-variable>>
(show #t (displayed (find-variable 'c '((y z) (a b c d e) (x y)))) nl)
(show #t (displayed (find-variable 'x '((y z) (a b c d e) (x y)))) nl)
(show #t (displayed (find-variable 'w '((y z) (a b c d e) (x y)))) nl)
#+end_src

#+RESULTS[43a330cf59cca586f42e759d2d2598fd1fc7d1e1]:
#+begin_src scheme
(1 2)
(2 0)
not-found
#+end_src

Seems to be working.

**** DONE Exercise 5.42 Rewrite ~compile-variable~ and ~compile-assignment~
     CLOSED: [2020-03-08 Sun 12:59]

#+name: c-lexical-compile-variable-compile-assignment
#+begin_src scheme :exports code :results none
  (define (compile-variable exp target linkage compile-env)
    (end-with-linkage linkage
		      (make-instruction-sequence '(env) (list target)
						 (let ((addr (find-variable exp compile-env)))
                                                    (if (not (eq? addr 'not-found))
                                                      `((assign ,target
                                                           (op lexical-address-lookup)
                                                           (const ,addr)
                                                           (reg env)))
                                                      `((assign ,target
							   (op lookup-variable-value)
							   (const ,exp)
							   (reg env))))))))
  (define (compile-assignment exp target linkage compile-env)
    (let ((var (assignment-variable exp))
	  (get-value-code
	   (compile (assignment-value exp) 'val 'next compile-env)))
      (end-with-linkage linkage
			(preserving '(env)
				    get-value-code
				    (make-instruction-sequence '(env val) (list target)
							       (if (not (eq? compile-env the-global-environment))
                                                                 (let ((addr (find-variable var compile-env)))
                                                                  `((perform (op lexical-address-set!)
                                                                             (const ,addr)
                                                                             (reg val)
                                                                             (reg env))
                                                                    (assign ,target (const ok))))
                                                                 `((perform (op set-variable-value!)
									  (const ,var)
									  (reg val)
									  (reg env))
								   (assign ,target (const ok)))))))))
#+end_src

I didn't manage to make simple illustrative tests for this method, but
these functions are indirectly tested by Exercise 5.40.

**** DONE Exercise 5.43 Scanning out defines
     CLOSED: [2020-03-08 Sun 21:00]

Lambda makes procedures, right? Can we just scan-out defines from an
~exp~ inside the ~compile-lambda-body~?

This exercise took me way more than it deserves.

#+name: c-compile-lexical-lambda-body-nodefines
#+begin_src scheme :exports code :results none
  (define (is-define? l)
    (and (list? l) (not (null? l)) (eq? (car l) 'define)))
  (define (no-out-of-order-defines? body non-define-found)
    (cond ((null? body) #t)
	  ((not (list? body)) #t)
	  ((and non-define-found (is-define? (car body))) #f)
	  (else (no-out-of-order-defines? (cdr body)
					  (or non-define-found (not (is-define? (car body))))))))

  (define (body-defines body)
    (filter (lambda (x) (not (null? x))) (map (lambda (sexp)
               (if (is-define? sexp)
                  sexp
                  '())) body)))

  (define (body-operations body)
    (filter (lambda (x) (not (null? x))) (map (lambda (sexp)
               (if (not (is-define? sexp))
                  sexp
                  '())) body)))
  (define (scan-out-defines body)
    #;(show #t "debug:scan-out-defines:" (pretty body))
    (if (not (no-out-of-order-defines? body #f))
	(error "define is only allowed at the beginning of a block" body))
    (let ((defines (body-defines body))
          (operations (body-operations body)))
      (if (null? defines)
	  body
	  (let ((defines-names (map definition-variable defines))
		(defines-bodies (map definition-value defines)))
	    (let ((let-header (map (lambda (x) (list x ''*unassigned*)) defines-names))
		  (let-body (append
			     (map (lambda (x y) (list 'set! x y)) defines-names defines-bodies)
			     operations)))
	      (list (let->combination (make-let let-header let-body))))))))

  (define (compile-lambda-body exp proc-entry compile-env)
    (let ((formals (lambda-parameters exp)))
      (append-instruction-sequences
       (make-instruction-sequence '(env proc argl) '(env)
				  `(,proc-entry
				    (assign env
					    (op compiled-procedure-env)
					    (reg proc))
				    (assign env
					    (op extend-environment)
					    (const ,formals)
					    (reg argl)
					    (reg env))))
        ; The only place where we extend a compile-time environment
       (compile-sequence (scan-out-defines (lambda-body exp)) 'val 'return (cons formals compile-env)))))
#+end_src

#+header: :stdin empty
#+begin_src shell :shebang "#!/usr/bin/chibi-scheme" :exports code :results code output
  (import (scheme small))
  (import (scheme list))
  (import (scheme show))
  (define make-lambda #f)
  <<s-syntax>>
  <<s-let-implementation>>
  <<s-let-star-implementation>>
  <<c-compile-lexical-lambda-body-nodefines>>

  (define test '(
                   (define (a c) c)
	           (define (b) 5)
	           (+ (a (b)) (b))))
  #;(show #t (pretty (body-defines test)))
  #;(show #t (pretty (body-operations test)))
  (show #t (pretty (scan-out-defines
    test)))
  #;(display (scan-out-defines test))
#+end_src

#+RESULTS[5700d118119f0ab7b944f55b75e7eb655b4aaff1]:
#+begin_src shell
WARNING: reference to undefined variable: compile-sequence
WARNING: reference to undefined variable: make-instruction-sequence
WARNING: reference to undefined variable: append-instruction-sequences
(((lambda (a b)
    (set! a (lambda (c) c))
    (set! b (lambda () 5))
    (+ (a (b)) (b))) '*unassigned*
                     '*unassigned*))
#+end_src


#+name: c-test-lexical-scanning-out-defines
#+begin_src shell :exports code :results verbatim output
  cat <<EOF
  (my-fun)
  (exit)
  EOF
#+end_src


#+header: :stdin c-test-lexical-scanning-out-defines
#+begin_src shell :shebang "#!/usr/bin/chibi-scheme" :exports both :results output
  <<ec-glue1>>
  <<s-truefalse>>
  <<s-let-implementation>>
  <<s-let-star-implementation>>
  <<ec-s-additional-syntax>>
  <<s-syntax>>
  <<s-application>>
  <<s-environments>>
  <<s-compound-procedures>>
  <<s-primitive-procedures>>
  <<s-cond>>
  <<s-user-prompt-print-with-compiled>>
  <<regmac-make-machine>>
  <<regmac-make-register-tracing>>
  <<regmac-make-stack-with-performance>>
  <<regmac-make-new-machine-with-metadata-instr-count-trace-labels-brk>>
  <<regmac-extract-labels-improved-labels-brk>>
  <<regmac-assembler-with-metadata-register-labels-brk>>
  <<regmac-generating-execution-procedures>>
  <<regmac-make-operation-exp>>
  <<regmac-make-operation-exp-syntax>>
  <<regmac-make-assign>>
  <<regmac-make-test>>
  <<regmac-make-save-restore>>
  <<regmac-other-instructions>>

  <<c-compile-and-go-lexical>>
  <<c-compile-lexical>>
  <<c-make-instruction-sequence-empty-instruction-sequence>>
  <<c-compile-linkage>>
  <<c-end-with-linkage>>
  <<c-compile-lexical-simple-expressions>>
  <<c-compile-lexical-definition>>
  <<c-lexical-compile-variable-compile-assignment>>
  <<c-make-label>>
  <<c-compile-lexical-if>>
  <<c-compile-lexical-sequence>>
  <<c-compiled-procedures>>
  <<c-compile-lexical-lambda>>
  <<c-compile-lexical-lambda-body-nodefines>>
  <<c-compile-lexical-application>>
  <<c-lexical-address-lookup>>
  <<c-lexical-find-variable>>
  <<c-construct-arglist>>
  <<c-compile-procedure-call>>
  <<c-compile-proc-appl>>
  <<c-combining-registers>>
  <<c-append-instruction-sequences>>
  <<c-list-union>>
  <<c-preserving>>
  <<c-tack-on-instruction-sequence>>
  <<c-parallel-instruction-sequences>>

      (define the-global-environment (setup-environment))
      (define (get-global-environment) the-global-environment)
      (define eceval-operations
	(list
  <<ec-eceval-operations-basic>>
  <<ec-eceval-operations-let-cond>>
  <<ec-eceval-operations-compiled>>
  <<c-lexical-controller-ops>>
    ))

  (define eceval
	(make-machine
	 '() ;'(exp env val proc argl continue unev)
	 eceval-operations
	 (quote (
  <<ec-before-repl-branch-to-compile>>
  <<ec-repl-stack-monitor>>
  <<ec-errors>>
  <<ec-ev-definition>>
  <<ec-ev-assignment>>
  <<ec-ev-if>>
  <<ec-ev-if-decide>>
  <<ec-ev-sequence>>
  <<ec-ev-sequence-continue>>
  <<ec-ev-begin>>
  <<ec-compound-apply>>
  <<ec-primitive-apply>>
  <<ec-ev-application>>
  <<ec-ev-appl-did-operator>>
  <<ec-ev-appl-operand-loop>>
  <<ec-ev-appl-accumulate-arg>>
  <<ec-ev-appl-last-arg>>
  <<ec-ev-appl-accum-last-arg>>
  <<ec-apply-dispatch-with-compiled>>
  <<ec-simple-expressions>>
  <<ec-eval-dispatch-let-cond>>
  <<ec-external-entry>>
    )))
  )
(set-register-contents! eceval 'flag false)

#;(show #t (pretty (compile
      '(define (my-fun)
           (define (a c) c)
	   (define (b) 5)
	   (+ (a (b)) (b)))
      'val
      'next
      the-global-environment)) nl)

(compile-and-go
   '(define (my-fun) (define (a c) c)
	             (define (b) 5)
	              (+ (a (b)) (b))))

#+end_src

#+RESULTS[06fd25123dd62506611308bd060dc52749c574c6]:
#+begin_example
;;EC-Eval value:
ok

(total-pushes = 0 maximum-depth = 0)
;;EC-Eval input:
(my-fun)
;;EC-Eval value:
10

(total-pushes = 8 maximum-depth = 4)
;;EC-Eval input:
(exit)
#+end_example

**** DONE Exercise 5.44 open code with compile-time environment
     CLOSED: [2020-03-08 Sun 21:29]

#+name: c-compile-lexical-open-code
#+begin_src scheme :exports code :results none
  (define (spread-arguments operands-src compile-env)
    (when (not (= 2 (length operands-src)))
	(error "spread-arguments: wrong number of arguments: " (length operands-src)))
    (preserving '(env)
        (compile (car operands-src) 'arg1 'next compile-env)
        (preserving '(arg1)
          (compile (cadr operands-src) 'arg2 'next compile-env)
          (make-instruction-sequence '(arg1) '() '()))))

  (define (compile-open-code-application exp target linkage compile-env)
    (let ((primitive (operator exp))
	  (operand-list (operands exp)))
      (end-with-linkage linkage
	(append-instruction-sequences
	  (spread-arguments operand-list compile-env)
	  (make-instruction-sequence '(arg1 arg2) (list target)
	    `((assign ,target (op ,primitive) (reg arg1) (reg arg2))))))))

  (define (open-code? exp)
    (and (pair? exp) (symbol? (car exp)) (member (car exp) (list '+ '- '* '/))))

#+end_src

#+name: c-compile-lexical-with-open-code
#+begin_src scheme :exports code :results none
  (define (compile exp target linkage compile-env)
    (cond ((self-evaluating? exp)
	   (compile-self-evaluating exp target linkage))
	  ((quoted? exp) (compile-quoted exp target linkage))
	  ((variable? exp)
	   (compile-variable exp target linkage compile-env))
	  ((assignment? exp)
	   (compile-assignment exp target linkage compile-env))
	  ((definition? exp)
	   (compile-definition exp target linkage compile-env))
	  ((if? exp)
           (compile-if exp target linkage compile-env))
	  ((lambda? exp)
           (compile-lambda exp target linkage compile-env))
	  ((begin? exp)
	   (compile-sequence (begin-actions exp) target linkage compile-env))
	  ((cond? exp)
	   (compile (cond->if exp) target linkage compile-env))
          ((and (open-code? exp) (eq? 'not-found (find-variable (operator exp) compile-env)))
           (compile-open-code-application exp target linkage compile-env))
	  ((application? exp)
	   (compile-application exp target linkage compile-env))
	  (else
	   (error "Unknown expression type: COMPILE" exp))))
#+end_src


#+name: c-test-lexical-opencode
#+begin_src shell :exports code :results verbatim output
  cat <<EOF
  (+ 1 2) ; built-ins
  (test 2 3 4 5) ; non-builtins
  (exit)
  EOF
#+end_src


#+header: :stdin c-test-lexical-opencode
#+begin_src shell :shebang "#!/usr/bin/chibi-scheme" :exports both :results output scalar code
  <<ec-glue1>>
  <<s-truefalse>>
  <<s-let-implementation>>
  <<s-let-star-implementation>>
  <<ec-s-additional-syntax>>
  <<s-syntax>>
  <<s-application>>
  <<s-environments>>
  <<s-compound-procedures>>
  <<s-primitive-procedures>>
  <<s-cond>>
  <<s-user-prompt-print-with-compiled>>
  <<regmac-make-machine>>
  <<regmac-make-register-tracing>>
  <<regmac-make-stack-with-performance>>
  <<regmac-make-new-machine-with-metadata-instr-count-trace-labels-brk>>
  <<regmac-extract-labels-improved-labels-brk>>
  <<regmac-assembler-with-metadata-register-labels-brk>>
  <<regmac-generating-execution-procedures>>
  <<regmac-make-operation-exp>>
  <<regmac-make-operation-exp-syntax>>
  <<regmac-make-assign>>
  <<regmac-make-test>>
  <<regmac-make-save-restore>>
  <<regmac-other-instructions>>

  <<c-compile-and-go-lexical>>
  <<c-compile-lexical-with-open-code>>
  <<c-compile-lexical-open-code>>
  <<c-make-instruction-sequence-empty-instruction-sequence>>
  <<c-compile-linkage>>
  <<c-end-with-linkage>>
  <<c-compile-lexical-simple-expressions>>
  <<c-compile-lexical-definition>>
  <<c-lexical-compile-variable-compile-assignment>>
  <<c-make-label>>
  <<c-compile-lexical-if>>
  <<c-compile-lexical-sequence>>
  <<c-compiled-procedures>>
  <<c-compile-lexical-lambda>>
  <<c-compile-lexical-lambda-body-nodefines>>
  <<c-compile-lexical-application>>
  <<c-lexical-address-lookup>>
  <<c-lexical-find-variable>>
  <<c-construct-arglist>>
  <<c-compile-procedure-call>>
  <<c-compile-proc-appl>>
  <<c-combining-registers>>
  <<c-append-instruction-sequences>>
  <<c-list-union>>
  <<c-preserving>>
  <<c-tack-on-instruction-sequence>>
  <<c-parallel-instruction-sequences>>

      (define the-global-environment (setup-environment))
      (define (get-global-environment) the-global-environment)
      (define eceval-operations
	(list
  <<ec-eceval-operations-basic>>
  <<ec-eceval-operations-let-cond>>
  <<ec-eceval-operations-compiled>>
  <<c-lexical-controller-ops>>
  <<ec-eceval-operations-opencode>>
    ))

  (define eceval
	(make-machine
	 '() ;'(exp env val proc argl continue unev)
	 eceval-operations
	 (quote (
  <<ec-before-repl-branch-to-compile>>
  <<ec-repl-stack-monitor>>
  <<ec-errors>>
  <<ec-ev-definition>>
  <<ec-ev-assignment>>
  <<ec-ev-if>>
  <<ec-ev-if-decide>>
  <<ec-ev-sequence>>
  <<ec-ev-sequence-continue>>
  <<ec-ev-begin>>
  <<ec-compound-apply>>
  <<ec-primitive-apply>>
  <<ec-ev-application>>
  <<ec-ev-appl-did-operator>>
  <<ec-ev-appl-operand-loop>>
  <<ec-ev-appl-accumulate-arg>>
  <<ec-ev-appl-last-arg>>
  <<ec-ev-appl-accum-last-arg>>
  <<ec-apply-dispatch-with-compiled>>
  <<ec-simple-expressions>>
  <<ec-eval-dispatch-let-cond>>
  <<ec-external-entry>>
    )))
  )
(set-register-contents! eceval 'flag false)

(show #t (pretty (compile
      '(define (test s p q r)
         (define (plus a b)
             (+ a b))
         (define (mul a b)
             (* a b))
         ((lambda (+ * a b x y)
            (+ (* a x) (* b y))) plus mul s p q r))
      'val
      'next
      the-global-environment)) nl)

(compile-and-go
   '(define (test s p q r)
         (define (plus a b)
             (+ a b))
         (define (mul a b)
             (* a b))
         ((lambda (+ * a b x y)
            (+ (* a x) (* b y))) plus mul s p q r)))

#+end_src

#+RESULTS[c3e6efb63aa29aa7470961468f39172404de7689]:
#+begin_src shell
((env) (val)
       ((assign val (op make-compiled-procedure) (label entry2) (reg env))
        (goto (label after-lambda1))
        entry2
        (assign env (op compiled-procedure-env) (reg proc))
        (assign env
                (op extend-environment)
                (const (s p q r))
                (reg argl)
                (reg env))
        (assign proc (op make-compiled-procedure) (label entry4) (reg env))
        (goto (label after-lambda3))
        entry4
        (assign env (op compiled-procedure-env) (reg proc))
        (assign env
                (op extend-environment)
                (const (plus mul))
                (reg argl)
                (reg env))
        (assign val (op make-compiled-procedure) (label entry22) (reg env))
        (goto (label after-lambda21))
        entry22
        (assign env (op compiled-procedure-env) (reg proc))
        (assign env
                (op extend-environment)
                (const (a b))
                (reg argl)
                (reg env))
        (assign arg1 (op lexical-address-lookup) (const (0 0)) (reg env))
        (assign arg2 (op lexical-address-lookup) (const (0 1)) (reg env))
        (assign val (op +) (reg arg1) (reg arg2))
        (goto (reg continue))
        after-lambda21
        (perform (op lexical-address-set!) (const (0 0)) (reg val) (reg env))
        (assign val (const ok))
        (assign val (op make-compiled-procedure) (label entry20) (reg env))
        (goto (label after-lambda19))
        entry20
        (assign env (op compiled-procedure-env) (reg proc))
        (assign env
                (op extend-environment)
                (const (a b))
                (reg argl)
                (reg env))
        (assign arg1 (op lexical-address-lookup) (const (0 0)) (reg env))
        (assign arg2 (op lexical-address-lookup) (const (0 1)) (reg env))
        (assign val (op *) (reg arg1) (reg arg2))
        (goto (reg continue))
        after-lambda19
        (perform (op lexical-address-set!) (const (0 1)) (reg val) (reg env))
        (assign val (const ok))
        (assign proc (op make-compiled-procedure) (label entry6) (reg env))
        (goto (label after-lambda5))
        entry6
        (assign env (op compiled-procedure-env) (reg proc))
        (assign env
                (op extend-environment)
                (const (+ * a b x y))
                (reg argl)
                (reg env))
        (assign proc (op lexical-address-lookup) (const (0 0)) (reg env))
        (save continue)
        (save proc)
        (save env)
        (assign proc (op lexical-address-lookup) (const (0 1)) (reg env))
        (assign val (op lexical-address-lookup) (const (0 5)) (reg env))
        (assign argl (op list) (reg val))
        (assign val (op lexical-address-lookup) (const (0 3)) (reg env))
        (assign argl (op cons) (reg val) (reg argl))
        (test (op primitive-procedure?) (reg proc))
        (branch (label primitive-branch12))
        compiled-branch11
        (assign continue (label after-call10))
        (assign val (op compiled-procedure-entry) (reg proc))
        (goto (reg val))
        primitive-branch12
        (assign val (op apply-primitive-procedure) (reg proc) (reg argl))
        after-call10
        (assign argl (op list) (reg val))
        (restore env)
        (save argl)
        (assign proc (op lexical-address-lookup) (const (0 1)) (reg env))
        (assign val (op lexical-address-lookup) (const (0 4)) (reg env))
        (assign argl (op list) (reg val))
        (assign val (op lexical-address-lookup) (const (0 2)) (reg env))
        (assign argl (op cons) (reg val) (reg argl))
        (test (op primitive-procedure?) (reg proc))
        (branch (label primitive-branch9))
        compiled-branch8
        (assign continue (label after-call7))
        (assign val (op compiled-procedure-entry) (reg proc))
        (goto (reg val))
        primitive-branch9
        (assign val (op apply-primitive-procedure) (reg proc) (reg argl))
        after-call7
        (restore argl)
        (assign argl (op cons) (reg val) (reg argl))
        (restore proc)
        (restore continue)
        (test (op primitive-procedure?) (reg proc))
        (branch (label primitive-branch15))
        compiled-branch14
        (assign val (op compiled-procedure-entry) (reg proc))
        (goto (reg val))
        primitive-branch15
        (assign val (op apply-primitive-procedure) (reg proc) (reg argl))
        (goto (reg continue))
        after-call13
        after-lambda5
        (assign val (op lexical-address-lookup) (const (1 3)) (reg env))
        (assign argl (op list) (reg val))
        (assign val (op lexical-address-lookup) (const (1 2)) (reg env))
        (assign argl (op cons) (reg val) (reg argl))
        (assign val (op lexical-address-lookup) (const (1 1)) (reg env))
        (assign argl (op cons) (reg val) (reg argl))
        (assign val (op lexical-address-lookup) (const (1 0)) (reg env))
        (assign argl (op cons) (reg val) (reg argl))
        (assign val (op lexical-address-lookup) (const (0 1)) (reg env))
        (assign argl (op cons) (reg val) (reg argl))
        (assign val (op lexical-address-lookup) (const (0 0)) (reg env))
        (assign argl (op cons) (reg val) (reg argl))
        (test (op primitive-procedure?) (reg proc))
        (branch (label primitive-branch18))
        compiled-branch17
        (assign val (op compiled-procedure-entry) (reg proc))
        (goto (reg val))
        primitive-branch18
        (assign val (op apply-primitive-procedure) (reg proc) (reg argl))
        (goto (reg continue))
        after-call16
        after-lambda3
        (assign val (const *unassigned*))
        (assign argl (op list) (reg val))
        (assign val (const *unassigned*))
        (assign argl (op cons) (reg val) (reg argl))
        (test (op primitive-procedure?) (reg proc))
        (branch (label primitive-branch25))
        compiled-branch24
        (assign val (op compiled-procedure-entry) (reg proc))
        (goto (reg val))
        primitive-branch25
        (assign val (op apply-primitive-procedure) (reg proc) (reg argl))
        (goto (reg continue))
        after-call23
        after-lambda1
        (perform (op define-variable!) (const test) (reg val) (reg env))
        (assign val (const ok))))

;;EC-Eval value:
ok

(total-pushes = 0 maximum-depth = 0)
;;EC-Eval input:
(+ 1 2)
;;EC-Eval value:
3

(total-pushes = 8 maximum-depth = 5)
;;EC-Eval input:
(test 2 3 4 5)
;;EC-Eval value:
23

(total-pushes = 18 maximum-depth = 5)
;;EC-Eval input:
(exit)
#+end_src

Seems to be working.

**** DONE Exercise 5.45 stack usage analysis for a ~factorial~
     CLOSED: [2020-03-09 Mon 10:09]

#+name: c-test-factorial-compiler
#+begin_src shell :exports code :results verbatim output
  cat <<EOF
  (compiled-factorial 6)
  (compiled-factorial 7)
  (compiled-factorial 8)
  (compiled-factorial 9)
  (define (interpreted-factorial n)
       (if (= n 1) 1 (* (interpreted-factorial (- n 1)) n)))
  (interpreted-factorial 6)
  (interpreted-factorial 7)
  (interpreted-factorial 8)
  (interpreted-factorial 9)

  (exit)
  EOF
#+end_src


#+header: :stdin c-test-factorial-compiler
#+begin_src shell :shebang "#!/usr/bin/chibi-scheme" :exports both :results output scalar code
  <<ec-glue1>>
  <<s-truefalse>>
  <<s-let-implementation>>
  <<s-let-star-implementation>>
  <<ec-s-additional-syntax>>
  <<s-syntax>>
  <<s-application>>
  <<s-environments>>
  <<s-compound-procedures>>
  <<s-primitive-procedures>>
  <<s-cond>>
  <<s-user-prompt-print-with-compiled>>
  <<regmac-make-machine>>
  <<regmac-make-register-tracing>>
  <<regmac-make-stack-with-performance>>
  <<regmac-make-new-machine-with-metadata-instr-count-trace-labels-brk>>
  <<regmac-extract-labels-improved-labels-brk>>
  <<regmac-assembler-with-metadata-register-labels-brk>>
  <<regmac-generating-execution-procedures>>
  <<regmac-make-operation-exp>>
  <<regmac-make-operation-exp-syntax>>
  <<regmac-make-assign>>
  <<regmac-make-test>>
  <<regmac-make-save-restore>>
  <<regmac-other-instructions>>

  <<c-compile-and-go-lexical>>
  <<c-compile-lexical-with-open-code>>
  <<c-compile-lexical-open-code>>
  <<c-make-instruction-sequence-empty-instruction-sequence>>
  <<c-compile-linkage>>
  <<c-end-with-linkage>>
  <<c-compile-lexical-simple-expressions>>
  <<c-compile-lexical-definition>>
  <<c-lexical-compile-variable-compile-assignment>>
  <<c-make-label>>
  <<c-compile-lexical-if>>
  <<c-compile-lexical-sequence>>
  <<c-compiled-procedures>>
  <<c-compile-lexical-lambda>>
  <<c-compile-lexical-lambda-body-nodefines>>
  <<c-compile-lexical-application>>
  <<c-lexical-address-lookup>>
  <<c-lexical-find-variable>>
  <<c-construct-arglist>>
  <<c-compile-procedure-call>>
  <<c-compile-proc-appl>>
  <<c-combining-registers>>
  <<c-append-instruction-sequences>>
  <<c-list-union>>
  <<c-preserving>>
  <<c-tack-on-instruction-sequence>>
  <<c-parallel-instruction-sequences>>

      (define the-global-environment (setup-environment))
      (define (get-global-environment) the-global-environment)
      (define eceval-operations
	(list
  <<ec-eceval-operations-basic>>
  <<ec-eceval-operations-let-cond>>
  <<ec-eceval-operations-compiled>>
  <<c-lexical-controller-ops>>
  <<ec-eceval-operations-opencode>>
    ))

  (define eceval
	(make-machine
	 '() ;'(exp env val proc argl continue unev)
	 eceval-operations
	 (quote (
  <<ec-before-repl-branch-to-compile>>
  <<ec-repl-stack-monitor>>
  <<ec-errors>>
  <<ec-ev-definition>>
  <<ec-ev-assignment>>
  <<ec-ev-if>>
  <<ec-ev-if-decide>>
  <<ec-ev-sequence>>
  <<ec-ev-sequence-continue>>
  <<ec-ev-begin>>
  <<ec-compound-apply>>
  <<ec-primitive-apply>>
  <<ec-ev-application>>
  <<ec-ev-appl-did-operator>>
  <<ec-ev-appl-operand-loop>>
  <<ec-ev-appl-accumulate-arg>>
  <<ec-ev-appl-last-arg>>
  <<ec-ev-appl-accum-last-arg>>
  <<ec-apply-dispatch-with-compiled>>
  <<ec-simple-expressions>>
  <<ec-eval-dispatch-let-cond>>
  <<ec-external-entry>>
    )))
  )
(set-register-contents! eceval 'flag false)

#;(show #t (pretty (compile
      'placeholder
      'val
      'next
      the-global-environment)) nl)

(compile-and-go
   '(define (compiled-factorial n)
       (if (= n 1) 1 (* (compiled-factorial (- n 1)) n))))

#+end_src

#+RESULTS[0c0754dab6b009f29d072e79c6ee241c22bb62cb]:
#+begin_src shell
;;EC-Eval value:
ok

(total-pushes = 0 maximum-depth = 0)
;;EC-Eval input:
(compiled-factorial 6)
;;EC-Eval value:
720

(total-pushes = 27 maximum-depth = 12)
;;EC-Eval input:
(compiled-factorial 7)
;;EC-Eval value:
5040

(total-pushes = 31 maximum-depth = 14)
;;EC-Eval input:
(compiled-factorial 8)
;;EC-Eval value:
40320

(total-pushes = 35 maximum-depth = 16)
;;EC-Eval input:
(compiled-factorial 9)
;;EC-Eval value:
362880

(total-pushes = 39 maximum-depth = 18)
;;EC-Eval input:
(define (interpreted-factorial n)
  (if (= n 1) 1 (* (interpreted-factorial (- n 1)) n)))
;;EC-Eval value:
ok

(total-pushes = 3 maximum-depth = 3)
;;EC-Eval input:
(interpreted-factorial 6)
;;EC-Eval value:
720

(total-pushes = 176 maximum-depth = 33)
;;EC-Eval input:
(interpreted-factorial 7)
;;EC-Eval value:
5040

(total-pushes = 208 maximum-depth = 38)
;;EC-Eval input:
(interpreted-factorial 8)
;;EC-Eval value:
40320

(total-pushes = 240 maximum-depth = 43)
;;EC-Eval input:
(interpreted-factorial 9)
;;EC-Eval value:
362880

(total-pushes = 272 maximum-depth = 48)
;;EC-Eval input:
(exit)
#+end_src

|                       | Maximum depth | Number of pushes |
|-----------------------+---------------+------------------|
| Compiled factorial    | 2n+0          | 4n+3             |
| Interpreted factorial | 5n+3          | 32n-16           |
| Special machine       | 2n-2          | 2n-2             |

The first good thing is that the results for the interpreted factorial
are reproducible.

The ratio of ~d~ compiled/interpreted is 2/5, and the ratio of ~p~ is 1/8.
For the special-purpose machine, the ratio is the same for the depth,
2/5, and the number of pushes is even smaller, 1/16. Hm... it is about
twice better in terms of the number of pushes, and almost the same
with respect to maximum depth when comparing hand-written assembly and
compiled code.

Scheme community wiki suggests that ~compile-procedure-appl~ loses
operations on saving and restoring all registers, so if it is
optimized, maybe more can be saved. Alternatively, maybe my open-code
implementation saves and restores too much.

**** DONE Exercise 5.46 stack usage analysis for ~fibonacci~
     CLOSED: [2020-03-09 Mon 10:34]

#+name: c-test-fibonacci-compiler
#+begin_src shell :exports code :results verbatim output
  cat <<EOF
  (compiled-fibonacci 6)
  (compiled-fibonacci 7)
  (compiled-fibonacci 8)
  (compiled-fibonacci 9)
  (define (interpreted-fibonacci n)
      (if (< n 2)
        n
        (+ (interpreted-fibonacci (- n 1))
           (interpreted-fibonacci (- n 2)))))
  (interpreted-fibonacci 6)
  (interpreted-fibonacci 7)
  (interpreted-fibonacci 8)
  (interpreted-fibonacci 9)

  (exit)
  EOF
#+end_src


#+header: :stdin c-test-fibonacci-compiler
#+begin_src shell :shebang "#!/usr/bin/chibi-scheme" :exports both :results output scalar code
  <<ec-glue1>>
  <<s-truefalse>>
  <<s-let-implementation>>
  <<s-let-star-implementation>>
  <<ec-s-additional-syntax>>
  <<s-syntax>>
  <<s-application>>
  <<s-environments>>
  <<s-compound-procedures>>
  <<s-primitive-procedures>>
  <<s-cond>>
  <<s-user-prompt-print-with-compiled>>
  <<regmac-make-machine>>
  <<regmac-make-register-tracing>>
  <<regmac-make-stack-with-performance>>
  <<regmac-make-new-machine-with-metadata-instr-count-trace-labels-brk>>
  <<regmac-extract-labels-improved-labels-brk>>
  <<regmac-assembler-with-metadata-register-labels-brk>>
  <<regmac-generating-execution-procedures>>
  <<regmac-make-operation-exp>>
  <<regmac-make-operation-exp-syntax>>
  <<regmac-make-assign>>
  <<regmac-make-test>>
  <<regmac-make-save-restore>>
  <<regmac-other-instructions>>

  <<c-compile-and-go-lexical>>
  <<c-compile-lexical-with-open-code>>
  <<c-compile-lexical-open-code>>
  <<c-make-instruction-sequence-empty-instruction-sequence>>
  <<c-compile-linkage>>
  <<c-end-with-linkage>>
  <<c-compile-lexical-simple-expressions>>
  <<c-compile-lexical-definition>>
  <<c-lexical-compile-variable-compile-assignment>>
  <<c-make-label>>
  <<c-compile-lexical-if>>
  <<c-compile-lexical-sequence>>
  <<c-compiled-procedures>>
  <<c-compile-lexical-lambda>>
  <<c-compile-lexical-lambda-body-nodefines>>
  <<c-compile-lexical-application>>
  <<c-lexical-address-lookup>>
  <<c-lexical-find-variable>>
  <<c-construct-arglist>>
  <<c-compile-procedure-call>>
  <<c-compile-proc-appl>>
  <<c-combining-registers>>
  <<c-append-instruction-sequences>>
  <<c-list-union>>
  <<c-preserving>>
  <<c-tack-on-instruction-sequence>>
  <<c-parallel-instruction-sequences>>

      (define the-global-environment (setup-environment))
      (define (get-global-environment) the-global-environment)
      (define eceval-operations
	(list
  <<ec-eceval-operations-basic>>
  <<ec-eceval-operations-let-cond>>
  <<ec-eceval-operations-compiled>>
  <<c-lexical-controller-ops>>
  <<ec-eceval-operations-opencode>>
    ))

  (define eceval
	(make-machine
	 '() ;'(exp env val proc argl continue unev)
	 eceval-operations
	 (quote (
  <<ec-before-repl-branch-to-compile>>
  <<ec-repl-stack-monitor>>
  <<ec-errors>>
  <<ec-ev-definition>>
  <<ec-ev-assignment>>
  <<ec-ev-if>>
  <<ec-ev-if-decide>>
  <<ec-ev-sequence>>
  <<ec-ev-sequence-continue>>
  <<ec-ev-begin>>
  <<ec-compound-apply>>
  <<ec-primitive-apply>>
  <<ec-ev-application>>
  <<ec-ev-appl-did-operator>>
  <<ec-ev-appl-operand-loop>>
  <<ec-ev-appl-accumulate-arg>>
  <<ec-ev-appl-last-arg>>
  <<ec-ev-appl-accum-last-arg>>
  <<ec-apply-dispatch-with-compiled>>
  <<ec-simple-expressions>>
  <<ec-eval-dispatch-let-cond>>
  <<ec-external-entry>>
    )))
  )
(set-register-contents! eceval 'flag false)

#;(show #t (pretty (compile
      'placeholder
      'val
      'next
      the-global-environment)) nl)

(compile-and-go
   '(define (compiled-fibonacci n)
      (if (< n 2)
        n
        (+ (compiled-fibonacci (- n 1))
           (compiled-fibonacci (- n 2))))))

#+end_src

#+RESULTS[b3b80879cc7aaea6064c62e98c74fe926b8e30bd]:
#+begin_src shell
;;EC-Eval value:
ok

(total-pushes = 0 maximum-depth = 0)
;;EC-Eval input:
(compiled-fibonacci 6)
;;EC-Eval value:
8

(total-pushes = 91 maximum-depth = 12)
;;EC-Eval input:
(compiled-fibonacci 7)
;;EC-Eval value:
13

(total-pushes = 147 maximum-depth = 14)
;;EC-Eval input:
(compiled-fibonacci 8)
;;EC-Eval value:
21

(total-pushes = 238 maximum-depth = 16)
;;EC-Eval input:
(compiled-fibonacci 9)
;;EC-Eval value:
34

(total-pushes = 385 maximum-depth = 18)
;;EC-Eval input:
(define (interpreted-fibonacci n)
  (if (< n 2)
      n
      (+ (interpreted-fibonacci (- n 1)) (interpreted-fibonacci (- n 2)))))
;;EC-Eval value:
ok

(total-pushes = 3 maximum-depth = 3)
;;EC-Eval input:
(interpreted-fibonacci 6)
;;EC-Eval value:
8

(total-pushes = 688 maximum-depth = 33)
;;EC-Eval input:
(interpreted-fibonacci 7)
;;EC-Eval value:
13

(total-pushes = 1136 maximum-depth = 38)
;;EC-Eval input:
(interpreted-fibonacci 8)
;;EC-Eval value:
21

(total-pushes = 1864 maximum-depth = 43)
;;EC-Eval input:
(interpreted-fibonacci 9)
;;EC-Eval value:
34

(total-pushes = 3040 maximum-depth = 48)
;;EC-Eval input:
(exit)
#+end_src

With respect to stack depth, it is (again) nice to see the
reproducibility in the interpreted case. Moreover, maximum depth is
still linear in the compiled case and is \(2n+0\).

The number of pushes used to be \(90\varphi^n - 40\), in the compiled case
it is.

\(a\varphi^9 + b = 385\)
\(a\varphi^8 + b = 238\)
\(a(\varphi^9 - \varphi^8) = 147\)

\(a(72 - 45) = 147 \)
\(a \approx 147/27 \approx 5\)
\(b\approx 13\)

Therefore the compiled version is almost 18 times faster.

**** DONE Exercise 5.47 calling interpreted procedures
     CLOSED: [2020-03-09 Mon 11:45]

#+name: c-compile-procedure-call-with-interpreted
#+begin_src scheme :exports code :results none
  (define (compile-procedure-call target linkage)
    (let ((primitive-branch (make-label 'primitive-branch))
	  (compiled-branch (make-label 'compiled-branch))
          (interpreted-branch (make-label 'interpreted-branch))
	  (after-call (make-label 'after-call)))
      (let ((compiled-linkage
	     (if (eq? linkage 'next) after-call linkage)))
	(append-instruction-sequences
	 (make-instruction-sequence '(proc) '()
				    `((test (op primitive-procedure?) (reg proc))
				      (branch (label ,primitive-branch))))
         (make-instruction-sequence '(proc) '()
				    `((test (op compound-procedure?) (reg proc))
				      (branch (label ,interpreted-branch))))
	 (parallel-instruction-sequences
            (parallel-instruction-sequences
	       (append-instruction-sequences
	          compiled-branch
	          (compile-proc-appl target compiled-linkage))
               (append-instruction-sequences
                  interpreted-branch
                  (compile-interpreted-proc-appl target compiled-linkage)))
	       (append-instruction-sequences
	          primitive-branch
	          (end-with-linkage linkage
			     (make-instruction-sequence '(proc argl)
							(list target)
							`((assign ,target
								  (op apply-primitive-procedure)
								  (reg proc)
								  (reg argl)))))))
	 after-call))))
(define (compile-interpreted-proc-appl target linkage)
    (cond ((and (eq? target 'val) (not (eq? linkage 'return)))
	   (make-instruction-sequence '(proc) all-regs
				      `((assign continue (label ,linkage))
                                        (save continue) ; will be restored by a procedure
					(goto (reg compapp)))))
          ;; TODO
	  ((and (not (eq? target 'val))
		(not (eq? linkage 'return)))
	   (let ((proc-return (make-label 'proc-return)))
	     (make-instruction-sequence '(proc) all-regs
					`((assign continue (label ,proc-return))
                                          (save continue)
					  (goto (reg compapp))
					  ,proc-return
					  (assign ,target (reg val))
					  (goto (label ,linkage))))))
	  ((and (eq? target 'val) (eq? linkage 'return))
	   (make-instruction-sequence
	    '(proc continue)
	    all-regs
	    '((save continue)
	      (goto (reg compapp)))))
	  ((and (not (eq? target 'val))
		(eq? linkage 'return))
	   (error "return linkage, target not val: COMPILE-interpreted-procedure"
		  target))))
#+end_src


#+name: ec-before-repl-compound-apply-reg
#+begin_src scheme :exports code :results none
(assign compapp (label compound-apply))
#+end_src

#+name: c-test-call-interpreted
#+begin_src shell :exports code :results verbatim output
  cat <<EOF
  (define (g my-arg2) my-arg2)
  (f "test")
  (exit)
  EOF
#+end_src


#+header: :stdin c-test-call-interpreted
#+begin_src shell :shebang "#!/usr/bin/chibi-scheme" :exports both :results output scalar code
  <<ec-glue1>>
  <<s-truefalse>>
  <<s-let-implementation>>
  <<s-let-star-implementation>>
  <<ec-s-additional-syntax>>
  <<s-syntax>>
  <<s-application>>
  <<s-environments>>
  <<s-compound-procedures>>
  <<s-primitive-procedures>>
  <<s-cond>>
  <<s-user-prompt-print-with-compiled>>
  <<regmac-make-machine>>
  <<regmac-make-register-tracing>>
  <<regmac-make-stack-with-performance>>
  <<regmac-make-new-machine-with-metadata-instr-count-trace-labels-brk>>
  <<regmac-extract-labels-improved-labels-brk>>
  <<regmac-assembler-with-metadata-register-labels-brk>>
  <<regmac-generating-execution-procedures>>
  <<regmac-make-operation-exp>>
  <<regmac-make-operation-exp-syntax>>
  <<regmac-make-assign>>
  <<regmac-make-test>>
  <<regmac-make-save-restore>>
  <<regmac-other-instructions>>

  <<c-compile-and-go-lexical>>
  <<c-compile-lexical-with-open-code>>
  <<c-compile-lexical-open-code>>
  <<c-make-instruction-sequence-empty-instruction-sequence>>
  <<c-compile-linkage>>
  <<c-end-with-linkage>>
  <<c-compile-lexical-simple-expressions>>
  <<c-compile-lexical-definition>>
  <<c-lexical-compile-variable-compile-assignment>>
  <<c-make-label>>
  <<c-compile-lexical-if>>
  <<c-compile-lexical-sequence>>
  <<c-compiled-procedures>>
  <<c-compile-lexical-lambda>>
  <<c-compile-lexical-lambda-body-nodefines>>
  <<c-compile-lexical-application>>
  <<c-lexical-address-lookup>>
  <<c-lexical-find-variable>>
  <<c-construct-arglist>>
  <<c-compile-procedure-call-with-interpreted>>
  <<c-compile-proc-appl>>
  <<c-combining-registers>>
  <<c-append-instruction-sequences>>
  <<c-list-union>>
  <<c-preserving>>
  <<c-tack-on-instruction-sequence>>
  <<c-parallel-instruction-sequences>>

      (define the-global-environment (setup-environment))
      (define (get-global-environment) the-global-environment)
      (define eceval-operations
	(list
  <<ec-eceval-operations-basic>>
  <<ec-eceval-operations-let-cond>>
  <<ec-eceval-operations-compiled>>
  <<c-lexical-controller-ops>>
  <<ec-eceval-operations-opencode>>
    ))

  (define eceval
	(make-machine
	 '() ;'(exp env val proc argl continue unev)
	 eceval-operations
	 (quote (
  <<ec-before-repl-compound-apply-reg>>
  <<ec-before-repl-branch-to-compile>>
  <<ec-repl-stack-monitor>>
  <<ec-errors>>
  <<ec-ev-definition>>
  <<ec-ev-assignment>>
  <<ec-ev-if>>
  <<ec-ev-if-decide>>
  <<ec-ev-sequence>>
  <<ec-ev-sequence-continue>>
  <<ec-ev-begin>>
  <<ec-compound-apply>>
  <<ec-primitive-apply>>
  <<ec-ev-application>>
  <<ec-ev-appl-did-operator>>
  <<ec-ev-appl-operand-loop>>
  <<ec-ev-appl-accumulate-arg>>
  <<ec-ev-appl-last-arg>>
  <<ec-ev-appl-accum-last-arg>>
  <<ec-apply-dispatch-with-compiled>>
  <<ec-simple-expressions>>
  <<ec-eval-dispatch-let-cond>>
  <<ec-external-entry>>
    )))
  )
(set-register-contents! eceval 'flag false)

#;(show #t (pretty (compile
      'placeholder
      'val
      'next
      the-global-environment)) nl)

(compile-and-go
   '(define (f my-arg)
       (g my-arg)))

#+end_src

#+RESULTS[b70ca9d257407511b679b7b1d57201459e003cef]:
#+begin_src shell
;;EC-Eval value:
ok

(total-pushes = 0 maximum-depth = 0)
;;EC-Eval input:
(define (g my-arg2) my-arg2)
;;EC-Eval value:
ok

(total-pushes = 3 maximum-depth = 3)
;;EC-Eval input:
(f "test")
;;EC-Eval value:
"test"

(total-pushes = 6 maximum-depth = 3)
;;EC-Eval input:
(exit)
#+end_src

Works. It is a little bit suboptimal, because it saves all registers
before a call, but I am too lazy to cherrypick the correct ones.

**** DONE Exercise 5.48 ~compile-and-run~
     CLOSED: [2020-03-10 Tue 12:14]

This exercise is not the same as ``making compiled procedures in
runtime'', because we need to compile and run the code in the same
environment as the procedure that is being called.

The problem with the solution below is that it doesn't use the lexical
addressing optimization in the compilation step. So variable lookup is slow.

#+name: c-ec-compile-and-run
#+begin_src scheme :exports code :results none
(define (compile-and-run? exp) (and (pair? exp) (eq? (car exp) 'compile-and-run)))
#+end_src

#+name: ec-eval-dispatch-let-cond-compile-and-run
#+begin_src scheme :exports code :results none
  eval-dispatch
  (test (op self-evaluating?) (reg exp))
  (branch (label ev-self-eval))
  (test (op variable?) (reg exp))
  (branch (label ev-variable))
  (test (op quoted?) (reg exp))
  (branch (label ev-quoted))
  (test (op assignment?) (reg exp))
  (branch (label ev-assignment))
  (test (op definition?) (reg exp))
  (branch (label ev-definition))
  (test (op if?) (reg exp))
  (branch (label ev-if))
  (test (op lambda?) (reg exp))
  (branch (label ev-lambda))
  (test (op begin?) (reg exp))
  (branch (label ev-begin))
  (test (op let?) (reg exp))
  (branch (label ev-let))
  (test (op cond?) (reg exp))
  (branch (label ev-cond))
  (test (op compile-and-run?) (reg exp))
  (branch (label ev-compile-and-run))
  (test (op application?) (reg exp))
  (branch (label ev-application))
  (goto (label unknown-expression-type))
ev-let
  (assign exp (op let->combination) (reg exp))
  (goto (label eval-dispatch))
ev-cond
  (assign exp (op cond->if) (reg exp))
  (goto (label eval-dispatch))
ev-compile-and-run
  (assign val (op compile-assemble) (reg exp))
  (goto (reg val))
#+end_src


#+name: c-test-compile-and-run
#+begin_src shell :exports code :results code output
  cat <<'EOF'
  (compile-and-run '(display "hello\n"))
  (compile-and-run
    '(define (factorial n)
        (if (= n 1) 1 (* (factorial (- n 1)) n))))
  (factorial 5)
  (exit)
  EOF
#+end_src

#+name: ec-eceval-operations-compile-and-run
#+begin_src scheme :exports code :results none
  (list 'cadr cadr)
  (list 'compile-and-run? compile-and-run?)
  (list 'compile-assemble (lambda (exp)
                          (assemble
                            (statements
                               (compile
                                   (text-of-quotation (cadr exp)) 'val 'return the-empty-environment)) eceval)))
  (list 'compile-assemble-recl (lambda (exp)
                          (assemble
                            (statements
                               (compile exp 'val 'return the-empty-environment)) eceval)))

#+end_src

#+header: :stdin c-test-compile-and-run
#+begin_src shell :shebang "#!/usr/bin/chibi-scheme" :exports both :results output scalar code
  <<ec-glue1>>
  <<s-truefalse>>
  <<s-let-implementation>>
  <<s-let-star-implementation>>
  <<ec-s-additional-syntax>>
  <<s-syntax>>
  <<s-application>>
  <<s-environments>>
  <<s-compound-procedures>>
  <<s-primitive-procedures>>
  <<s-cond>>
  <<s-user-prompt-print-with-compiled>>
  <<regmac-make-machine>>
  <<regmac-make-register-tracing>>
  <<regmac-make-stack-with-performance>>
  <<regmac-make-new-machine-with-metadata-instr-count-trace-labels-brk>>
  <<regmac-extract-labels-improved-labels-brk>>
  <<regmac-assembler-with-metadata-register-labels-brk>>
  <<regmac-generating-execution-procedures>>
  <<regmac-make-operation-exp>>
  <<regmac-make-operation-exp-syntax>>
  <<regmac-make-assign>>
  <<regmac-make-test>>
  <<regmac-make-save-restore>>
  <<regmac-other-instructions>>

  <<c-compile-and-go-lexical>>
  <<c-compile-lexical-with-open-code>>
  <<c-compile-lexical-open-code>>
  <<c-make-instruction-sequence-empty-instruction-sequence>>
  <<c-compile-linkage>>
  <<c-end-with-linkage>>
  <<c-compile-lexical-simple-expressions>>
  <<c-compile-lexical-definition>>
  <<c-lexical-compile-variable-compile-assignment>>
  <<c-make-label>>
  <<c-compile-lexical-if>>
  <<c-compile-lexical-sequence>>
  <<c-compiled-procedures>>
  <<c-compile-lexical-lambda>>
  <<c-compile-lexical-lambda-body-nodefines>>
  <<c-compile-lexical-application>>
  <<c-lexical-address-lookup>>
  <<c-lexical-find-variable>>
  <<c-construct-arglist>>
  <<c-compile-procedure-call-with-interpreted>>
  <<c-compile-proc-appl>>
  <<c-combining-registers>>
  <<c-append-instruction-sequences>>
  <<c-list-union>>
  <<c-preserving>>
  <<c-tack-on-instruction-sequence>>
  <<c-parallel-instruction-sequences>>

  <<c-ec-compile-and-run>>

  (define the-global-environment (setup-environment))
  (define (get-global-environment) the-global-environment)

  (define eceval-operations
	(list
  <<ec-eceval-operations-basic>>
  <<ec-eceval-operations-let-cond>>
  <<ec-eceval-operations-compiled>>
  <<c-lexical-controller-ops>>
  <<ec-eceval-operations-opencode>>
  <<ec-eceval-operations-compile-and-run>>
    ))

  (define eceval
	(make-machine
	 '() ;'(exp env val proc argl continue unev)
	 eceval-operations
	 (quote (
  <<ec-before-repl-compound-apply-reg>>
  <<ec-before-repl-branch-to-compile>>
  <<ec-repl-stack-monitor>>
  <<ec-errors>>
  <<ec-ev-definition>>
  <<ec-ev-assignment>>
  <<ec-ev-if>>
  <<ec-ev-if-decide>>
  <<ec-ev-sequence>>
  <<ec-ev-sequence-continue>>
  <<ec-ev-begin>>
  <<ec-compound-apply>>
  <<ec-primitive-apply>>
  <<ec-ev-application>>
  <<ec-ev-appl-did-operator>>
  <<ec-ev-appl-operand-loop>>
  <<ec-ev-appl-accumulate-arg>>
  <<ec-ev-appl-last-arg>>
  <<ec-ev-appl-accum-last-arg>>
  <<ec-apply-dispatch-with-compiled>>
  <<ec-simple-expressions>>
  <<ec-eval-dispatch-let-cond-compile-and-run>>
  <<ec-external-entry>>
    )))
  )
(set-register-contents! eceval 'flag false)

#;(show #t (pretty (compile
      'placeholder
      'val
      'next
      the-global-environment)) nl)

(start eceval)

#+end_src

#+RESULTS[e785c7798bccbe1e5084399ef301819743e37cb5]:
#+begin_src shell

;;EC-Eval input:
(compile-and-run '(display "hello\n"))
hello
;;EC-Eval value:
#<undef>

(total-pushes = 0 maximum-depth = 0)
;;EC-Eval input:
(compile-and-run
 '(define (factorial n) (if (= n 1) 1 (* (factorial (- n 1)) n))))
;;EC-Eval value:
ok

(total-pushes = 0 maximum-depth = 0)
;;EC-Eval input:
(factorial 5)
;;EC-Eval value:
120

(total-pushes = 23 maximum-depth = 10)
;;EC-Eval input:
(exit)
#+end_src

**** DONE Exercise 5.49 ~read-compile-execute-print~ loop
     CLOSED: [2020-03-10 Tue 12:36]

#+name: ec-repl-stack-monitor-with-compiler
#+begin_src scheme :exports code :results none
read-eval-print-loop
(perform (op initialize-stack))
(perform (op prompt-for-input) (const "\n;;EC-Eval input:"))
(assign exp (op read))
(perform (op user-print) (reg exp))
(assign env (op get-global-environment))
(assign continue (label print-result))
;;(goto (label eval-dispatch))
(assign val (op compile-assemble-recl) (reg exp))
(goto (reg val))
print-result
(perform (op announce-output) (const ";;EC-Eval value:"))
(perform (op user-print) (reg val))
(perform (op print-stack-statistics))
(goto (label read-eval-print-loop))
#+end_src

#+name: c-test-read-compile-execute-print
#+begin_src shell :exports code :results code output
  cat <<'EOF'
  (display "hello\n")
  (define (factorial n)
        (if (= n 1) 1 (* (factorial (- n 1)) n)))
  (factorial 5)
  (exit)
  EOF
#+end_src


#+header: :stdin c-test-read-compile-execute-print
#+begin_src shell :shebang "#!/usr/bin/chibi-scheme" :exports both :results output scalar code
  <<ec-glue1>>
  <<s-truefalse>>
  <<s-let-implementation>>
  <<s-let-star-implementation>>
  <<ec-s-additional-syntax>>
  <<s-syntax>>
  <<s-application>>
  <<s-environments>>
  <<s-compound-procedures>>
  <<s-primitive-procedures>>
  <<s-cond>>
  <<s-user-prompt-print-with-compiled>>
  <<regmac-make-machine>>
  <<regmac-make-register-tracing>>
  <<regmac-make-stack-with-performance>>
  <<regmac-make-new-machine-with-metadata-instr-count-trace-labels-brk>>
  <<regmac-extract-labels-improved-labels-brk>>
  <<regmac-assembler-with-metadata-register-labels-brk>>
  <<regmac-generating-execution-procedures>>
  <<regmac-make-operation-exp>>
  <<regmac-make-operation-exp-syntax>>
  <<regmac-make-assign>>
  <<regmac-make-test>>
  <<regmac-make-save-restore>>
  <<regmac-other-instructions>>

  <<c-compile-and-go-lexical>>
  <<c-compile-lexical-with-open-code>>
  <<c-compile-lexical-open-code>>
  <<c-make-instruction-sequence-empty-instruction-sequence>>
  <<c-compile-linkage>>
  <<c-end-with-linkage>>
  <<c-compile-lexical-simple-expressions>>
  <<c-compile-lexical-definition>>
  <<c-lexical-compile-variable-compile-assignment>>
  <<c-make-label>>
  <<c-compile-lexical-if>>
  <<c-compile-lexical-sequence>>
  <<c-compiled-procedures>>
  <<c-compile-lexical-lambda>>
  <<c-compile-lexical-lambda-body-nodefines>>
  <<c-compile-lexical-application>>
  <<c-lexical-address-lookup>>
  <<c-lexical-find-variable>>
  <<c-construct-arglist>>
  <<c-compile-procedure-call-with-interpreted>>
  <<c-compile-proc-appl>>
  <<c-combining-registers>>
  <<c-append-instruction-sequences>>
  <<c-list-union>>
  <<c-preserving>>
  <<c-tack-on-instruction-sequence>>
  <<c-parallel-instruction-sequences>>

  <<c-ec-compile-and-run>>

  (define the-global-environment (setup-environment))
  (define (get-global-environment) the-global-environment)

  (define eceval-operations
	(list
  <<ec-eceval-operations-basic>>
  <<ec-eceval-operations-let-cond>>
  <<ec-eceval-operations-compiled>>
  <<c-lexical-controller-ops>>
  <<ec-eceval-operations-opencode>>
  <<ec-eceval-operations-compile-and-run>>
    ))

  (define eceval
	(make-machine
	 '() ;'(exp env val proc argl continue unev)
	 eceval-operations
	 (quote (
  <<ec-repl-stack-monitor-with-compiler>>
  <<ec-errors>>
    )))
  )
(set-register-contents! eceval 'flag false)

#;(show #t (pretty (compile
      'placeholder
      'val
      'next
      the-global-environment)) nl)

(start eceval)

#+end_src

#+RESULTS[d6e67522e729ea208310bedcbdd61506a4dd9fd2]:
#+begin_src shell

;;EC-Eval input:
(display "hello\n")
hello
;;EC-Eval value:
#<undef>

(total-pushes = 0 maximum-depth = 0)
;;EC-Eval input:
(define (factorial n) (if (= n 1) 1 (* (factorial (- n 1)) n)))
;;EC-Eval value:
ok

(total-pushes = 0 maximum-depth = 0)
;;EC-Eval input:
(factorial 5)
;;EC-Eval value:
120

(total-pushes = 18 maximum-depth = 10)
;;EC-Eval input:
(exit)
#+end_src

I removed the features related to the explicit control evaluator, and
left just the repl. Everything is offloaded to the compiler now.

**** DONE Exercise 5.50 Compiling the metacircular evaluator
     CLOSED: [2020-03-14 Sat 15:52]

Unlike other solutions, I'm not implementing
~apply-in-underlying-scheme~ as a special form, but rather just make
it a standard lisp function which does dispatch on whether a function
is a real underlying builtin or a compiled builtin. Memory management
is still forwarded to the actual underlying scheme, but the
metacircular evaluator code itself is completely compiled.

Firstly we slightly modify ~compile-and-go~

#+name: c-compile-and-go-lexical-for-compiling
#+begin_src scheme :exports code :results none
  (define (compile-and-go expression)
    (let ((instructions
	   (assemble
            (statements
	    (tack-on-instruction-sequence
               (let ((var 'apply1)
                     (proc-entry (make-label 'entry))
                     (after-lambda (make-label 'after-lambda)))
                  (make-instruction-sequence '() '()
                    `((assign val (op make-compiled-procedure) (label ,proc-entry) (reg env))
                      (perform (op define-variable!) (const ,var) (reg val) (reg env))
                      (goto (label ,after-lambda))
		      ,proc-entry
                       (assign proc (op car) (reg argl))
                       (assign argl (op cadr) (reg argl))
                       (perform (op user-print) (reg argl))
                       (assign val (op compiled-procedure-entry) (reg proc))
                       (goto (reg val))
                      ,after-lambda
                       )))
        	     (compile expression 'val 'return '())))
	    eceval)))
      (set! the-global-environment (setup-environment))
      (define-variable! 'apply-in-real-scheme (list 'primitive apply) the-global-environment)
      (set-register-contents! eceval 'val instructions)
      (set-register-contents! eceval 'flag true)
      (start eceval)))
#+end_src

And add lets to the compiler:

#+name: c-compile-lexical-with-open-code-let
#+begin_src scheme :exports code :results none
  (define (compile exp target linkage compile-env)
    (cond ((self-evaluating? exp)
	   (compile-self-evaluating exp target linkage))
	  ((quoted? exp) (compile-quoted exp target linkage))
	  ((variable? exp)
	   (compile-variable exp target linkage compile-env))
	  ((assignment? exp)
	   (compile-assignment exp target linkage compile-env))
	  ((definition? exp)
	   (compile-definition exp target linkage compile-env))
	  ((if? exp)
           (compile-if exp target linkage compile-env))
	  ((lambda? exp)
           (compile-lambda exp target linkage compile-env))
	  ((begin? exp)
	   (compile-sequence (begin-actions exp) target linkage compile-env))
	  ((cond? exp)
	   (compile (cond->if exp) target linkage compile-env))
          ((let? exp)
           (compile (let->combination exp) target linkage compile-env))
          ((and (open-code? exp) (eq? 'not-found (find-variable (operator exp) compile-env)))
           (compile-open-code-application exp target linkage compile-env))
	  ((application? exp)
	   (compile-application exp target linkage compile-env))
	  (else
	   (error "Unknown expression type: COMPILE" exp))))
#+end_src

Our code uses ~memq~.

#+name: memq
#+begin_src scheme :exports code :results none
  (define (memq item x)
    (cond ((null? x) false)
	  ((eq? item (car x)) x)
	  (else (memq item (cdr x)))))
#+end_src



#+name: ec-end-of-the-world
#+begin_src scheme :exports code :results none
  external-entry
  (perform (op initialize-stack))
  (assign env (op get-global-environment))
  (assign continue (label end))
  (goto (reg val))
end
#+end_src

#+name: compiled-metacircular-test
#+begin_src shell :exports code :results code output
cat <<'EOF'
(display "the real underlying scheme\n")
(memq 'a (list 'a 'b 'c 'd))
(define (factorial n) (if (= n 1) 1 (* (factorial (- n 1)) n)))
(factorial 5)
(exit)
'EOF'
#+end_src


#+header: :stdin compiled-metacircular-test
#+begin_src shell :shebang "#!/usr/bin/chibi-scheme" :exports both :results code output
    <<ec-glue1>>
    <<s-truefalse>>
    <<s-let-implementation>>
    <<s-let-star-implementation>>
    <<ec-s-additional-syntax>>
    <<s-syntax>>
    <<s-application>>
    <<s-environments>>
    <<s-compound-procedures>>
    <<s-primitive-procedures>>
    <<s-cond>>
    <<s-user-prompt-print-with-compiled>>
    <<regmac-make-machine>>
    <<regmac-make-register-tracing>>
    <<regmac-make-stack-with-performance>>
    <<regmac-make-new-machine-with-metadata-instr-count-trace-labels-brk>>
    <<regmac-extract-labels-improved-labels-brk>>
    <<regmac-assembler-with-metadata-register-labels-brk>>
    <<regmac-generating-execution-procedures>>
    <<regmac-make-operation-exp>>
    <<regmac-make-operation-exp-syntax>>
    <<regmac-make-assign>>
    <<regmac-make-test>>
    <<regmac-make-save-restore>>
    <<regmac-other-instructions>>

    <<c-compile-and-go-lexical-for-compiling>>
    <<c-compile-lexical-with-open-code-let>>
    <<c-compile-lexical-open-code>>
    <<c-make-instruction-sequence-empty-instruction-sequence>>
    <<c-compile-linkage>>
    <<c-end-with-linkage>>
    <<c-compile-lexical-simple-expressions>>
    <<c-compile-lexical-definition>>
    <<c-lexical-compile-variable-compile-assignment>>
    <<c-make-label>>
    <<c-compile-lexical-if>>
    <<c-compile-lexical-sequence>>
    <<c-compiled-procedures>>
    <<c-compile-lexical-lambda>>
    <<c-compile-lexical-lambda-body-nodefines>>
    <<c-compile-lexical-application>>
    <<c-lexical-address-lookup>>
    <<c-lexical-find-variable>>
    <<c-construct-arglist>>
    <<c-compile-procedure-call-with-interpreted>>
    <<c-compile-proc-appl>>
    <<c-combining-registers>>
    <<c-append-instruction-sequences>>
    <<c-list-union>>
    <<c-preserving>>
    <<c-tack-on-instruction-sequence>>
    <<c-parallel-instruction-sequences>>

    <<c-ec-compile-and-run>>

    (define the-global-environment (setup-environment))
    ;(define-variable! 'apply-in-underlying-scheme (list 'primitive apply-in-underlying-scheme) the-global-environment)
    (define (get-global-environment) the-global-environment)

    (define eceval-operations
	  (list
    <<ec-eceval-operations-basic>>
    <<ec-eceval-operations-let-cond>>
    <<ec-eceval-operations-compiled>>
    <<c-lexical-controller-ops>>
    <<ec-eceval-operations-opencode>>
    <<ec-eceval-operations-compile-and-run>>
      ))

    (define eceval
	  (make-machine
	   '() ;'(exp env val proc argl continue unev)
	   eceval-operations
	   (quote (
	   <<ec-before-repl-branch-to-compile>>
	   <<ec-end-of-the-world>>
      ))))
  (set-register-contents! eceval 'flag false)

  #;(show #t (pretty (compile
	'placeholder
	'val
	'next
	the-global-environment)) nl)

  (compile-and-go
     '(begin
  (define true #t)
  (define false #f)
  <<accumulate>>
  <<map-append-length>>
  <<memq>>
  (define (apply-in-underlying-scheme proc argl)
    (if (primitive-procedure? proc)
       (apply-in-real-scheme (primitive-implementation proc) argl)
       (apply1 proc argl)))
  <<s-apply>>
  <<s-eval>>
  <<s-list-of-values>>
  <<s-standard-if>>
  <<s-sequences>>
  <<s-assignment>>
  <<s-define>>
  <<s-syntax>>
  <<s-application>>
  <<s-cond>>
  <<s-truefalse>>
  <<s-compound-procedures>>
  <<s-primitive-procedures>>
  <<s-environments>>
  <<s-driver-loop>>
  <<s-glue2>>

  (driver-loop)
  (exit)
  ))
#+end_src

#+RESULTS[f1c1c64488a64bcdd303279e522259a82a03e22c]:
#+begin_src shell

;;; M-Eval input:
(display "the real underlying scheme\n")
the real underlying scheme

;;; M-Eval value:
#<undef>

;;; M-Eval input:
(memq 'a (list 'a 'b 'c 'd))
(a (a b c d))

;;; M-Eval value:
(a b c d)

;;; M-Eval input:
(define (factorial n) (if (= n 1) 1 (* (factorial (- n 1)) n)))

;;; M-Eval value:
ok

;;; M-Eval input:
(factorial 5)

;;; M-Eval value:
120

;;; M-Eval input:
(exit)
#+end_src


**** DONE Exercise 5.51 Translating the EC-evaluator into a low-level language
     CLOSED: [2020-04-13 Mon 11:45]

Firstly I will tangle the whole EC-evaluator into one bit, because
working with many :noweb blocks is unmanageable.

#+name: test-low-level-interpreter
#+begin_src shell :exports code :results verbatim output
  cat <<EOF
  (fib 8)
  (set! test 1)
  (show #t "hello")
  (cons 'a 'b)
  (/ 1 0)
  (car 1)
  (exit)
  EOF
#+end_src


#+hame: low-level-interpreter-original-code
#+begin_src scheme :shebang "#!/usr/bin/chibi-scheme" :exports code :results none
    (import (scheme small))
    (import (scheme list))
    (import (srfi 159))
    (import (srfi 27))
    (define false #t)
    (define true #t)
    (define (tagged-list? exp tag)
	      (if (pair? exp)
		  (eq? (car exp) tag)
		  false))
    (define apply-in-underlying-scheme apply)

    (define (true? v)  (not (false? v)))
    (define (false? v)      (eq? v #f))

    (define primitive-implementation-checkers
      (list
	   (list / (lambda (l)  (cond ((< (length l) 2) 'not-enough-arguments)
			    ((= (cadr l) 0) 'division-by-zero)
			    (else #f))))
	   (list car (lambda (l)  (cond ((not (= (length l) 1)) 'wrong-number-of-arguments)
				   ((not (pair? (car l))) 'car-not-a-pair)
				   (else #f))))
	   (list cdr (lambda (l)  (cond ((not (= (length l) 1)) 'wrong-number-of-arguments)
				   ((not (pair? (car l))) 'cdr-not-a-pair)
				   (else #f)))))
    )

    (define (apply-primitive-procedure-with-errors proc arglist)
      (let ((checker (assoc (primitive-implementation proc)
			     primitive-implementation-checkers)))
	(if checker
	  (let ((error ((cadr checker) arglist)))
	    (if error
		(cons 'error error)
		(cons 'no-error (apply-in-underlying-scheme
		     (primitive-implementation proc) arglist))))
	  (cons 'no-checker (apply-in-underlying-scheme
		     (primitive-implementation proc) arglist)))))
    (define (empty-arglist) '())
    (define (adjoin-arg arg arglist) (append arglist (list arg)))
    (define (last-operand? ops) (null? (cdr ops)))
	      (define (self-evaluating? exp)
		(cond ((number? exp) true)
		      ((string? exp) true)
		      ((eq? #t exp) true)
		      ((eq? #f exp) true)
		      (else false)))
	      (define (variable? exp) (symbol? exp))
	      (define (quoted? exp)
		(tagged-list? exp 'quote))

	      (define (text-of-quotation exp) (cadr exp))
	      (define (tagged-list? exp tag)
		(if (pair? exp)
		    (eq? (car exp) tag)
		    false))
	      (define (assignment? exp)
		(tagged-list? exp 'set!))

	      (define (assignment-variable exp) (cadr exp))

	      (define (assignment-value exp) (caddr exp))
	      (define (definition? exp)
		(tagged-list? exp 'define))

	      (define (definition-variable exp)
		(if (symbol? (cadr exp))
		    (cadr exp)
		    (caadr exp)))

	      (define (definition-value exp)
		(if (symbol? (cadr exp))
		    (caddr exp)
		    (make-lambda (cdadr exp)
				 (cddr exp))))
	      (define (lambda? exp) (tagged-list? exp 'lambda))

	      (define (lambda-parameters exp) (cadr exp))

	      (define (lambda-body exp) (cddr exp))
	      (define (make-lambda parameters body)
		(cons 'lambda (cons parameters body)))
	      (define (if? exp) (tagged-list? exp 'if))

	      (define (if-predicate exp) (cadr exp))

	      (define (if-consequent exp) (caddr exp))

	      (define (if-alternative exp)
		(if (not (null? (cdddr exp)))
		    (cadddr exp)
		    'false))
	      (define (make-if predicate consequent alternative)
		(list 'if predicate consequent alternative))
	      (define (begin? exp) (tagged-list? exp 'begin))

	      (define (begin-actions exp) (cdr exp))

	      (define (last-exp? seq) (null? (cdr seq)))

	      (define (first-exp seq) (car seq))

	      (define (rest-exps seq) (cdr seq))
	      (define (sequence->exp seq)
		(cond ((null? seq) seq)
		      ((last-exp? seq) (first-exp seq))
		      (else (make-begin seq))))

	      (define (make-begin seq) (cons 'begin seq))
    (define (application? exp) (pair? exp))

    (define (operator exp) (car exp))

    (define (operands exp) (cdr exp))

    (define (no-operands? ops) (null? ops))

    (define (first-operand ops) (car ops))

    (define (rest-operands ops) (cdr ops))
    (define (enclosing-environment env) (cdr env))
    (define (first-frame env) (car env))
    (define the-empty-environment '())
    (define (make-frame variables values)
      (cons variables values))
    (define (frame-variables frame) (car frame))
    (define (frame-values frame) (cdr frame))
    (define (add-binding-to-frame! var val frame)
      (set-car! frame (cons var (car frame)))
      (set-cdr! frame (cons val (cdr frame))))
    (define (extend-environment vars vals base-env)
      (if (= (length vars) (length vals))
	  (cons (make-frame vars vals) base-env)
	  (if (< (length vars) (length vals))
	      (error "Too many arguments supplied" vars vals)
	      (error "Too few arguments supplied" vars vals))))
    (define (lookup-variable-value var env)
      (define (env-loop env)
	(define (scan vars vals)
	  (cond ((null? vars)
		 (env-loop (enclosing-environment env)))
		((eq? var (car vars))
		 (cons 'bound (car vals)))
		(else (scan (cdr vars) (cdr vals)))))
	(if (eq? env the-empty-environment)
	    (cons 'unbound 'error)
	    (let ((frame (first-frame env)))
	      (scan (frame-variables frame)
		    (frame-values frame)))))
      (env-loop env))
    (define (set-variable-value! var val env)
      (define (env-loop env)
	(define (scan vars vals)
	  (cond ((null? vars)
		 (env-loop (enclosing-environment env)))
		((eq? var (car vars))
		 (set-car! vals val))
		(else (scan (cdr vars) (cdr vals)))))
	(if (eq? env the-empty-environment)
	    (cons 'unbound 'error)
	    (let ((frame (first-frame env)))
	      (scan (frame-variables frame)
		    (frame-values frame)))))
      (env-loop env))
    (define (define-variable! var val env)
      (let ((frame (first-frame env)))
	(define (scan vars vals)
	  (cond ((null? vars)
		 (add-binding-to-frame! var val frame))
		((eq? var (car vars))
		 (set-car! vals val))
		(else (scan (cdr vars) (cdr vals)))))
	(scan (frame-variables frame)
	      (frame-values frame))))

    (define (make-procedure parameters body env)
      (list 'procedure parameters body env))
    (define (compound-procedure? p)
      (tagged-list? p 'procedure))
    (define (procedure-parameters p) (cadr p))
    (define (procedure-body p) (caddr p))
    (define (procedure-environment p) (cadddr p))
    (define primitive-procedures
      (list (list 'car car)
	    (list 'cdr cdr)
	    (list 'cons cons)
	    (list 'cadr cadr)
	    (list 'null? null?)
	    (list 'exit exit)
	    (list 'display display)
	    (list 'newline newline)
	    (list 'assoc assoc)
	    (list '= =)
	    (list '< <)
	    (list '> >)
	    (list '+ +)
	    (list '- -)
	    (list 'not not)
	    (list '* *)
	    (list 'current-second current-second)
	    (list 'list list)
	    (list 'underlying-cons cons)
	    (list 'underlying-car car)
	    (list 'underlying-cdr cdr)
	    (list 'eq? eq?)
	    (list 'equal? equal?)
	    (list 'pair? pair?)
	    (list 'error error)
	    (list 'random-integer random-integer)
	    (list 'even? even?)
	    (list 'remainder remainder)
	    (list 'square square)
	    (list '/ /)
	    (list 'member member)
	    (list 'abs abs)
	    (list 'cdar cdar)
	    (list 'cdadr cdadr)
	    (list 'caar caar)
	    (list 'caadr caadr)
	    (list 'cddr cddr)
	    (list 'cdddr cdddr)
	    (list 'caddr caddr)
	    (list 'cadddr cadddr)
	    (list 'set-car! set-car!)
	    (list 'set-cdr! set-cdr!)
	    (list 'memq memq)
	    (list 'read read)
	    (list 'show show)
	    (list 'pretty pretty)
	    (list 'number? number?)
	    (list 'string? string?)
	    (list 'symbol? symbol?)
	    ))

    (define (primitive-procedure-names)
      (map car
	   primitive-procedures))
    (define (primitive-procedure-objects)
      (map (lambda (proc) (list 'primitive (cadr proc)))
	   primitive-procedures))
    (define (setup-environment)
      (let ((initial-env
	     (extend-environment (primitive-procedure-names)
				 (primitive-procedure-objects)
				 the-empty-environment)))
	(define-variable! 'true true initial-env)
	(define-variable! 'false false initial-env)
	initial-env))
    (define (primitive-procedure? proc)
      (tagged-list? proc 'primitive))

    (define (primitive-implementation proc) (cadr proc))

    (define (apply-primitive-procedure proc args)
      (apply-in-underlying-scheme
       (primitive-implementation proc) args))
    (define (let? exp) (tagged-list? exp 'let))

    (define (let-bindings exp)
      (cadr exp))
    (define (let-bindings-variables l)
      (map car l))
    (define (let-bindings-expressions l)
      (map cadr l))
    (define (let-contents exp)
	(cddr exp))
    (define (let->combination exp)
      (cons
	 (make-lambda
	      (let-bindings-variables (let-bindings exp))
	      (let-contents exp))
	 (let-bindings-expressions (let-bindings exp))))

    (define (cond? exp) (tagged-list? exp 'cond))

    (define (cond-clauses exp) (cdr exp))

    (define (cond-else-clause? clause)
      (eq? (cond-predicate clause) 'else))

    (define (cond-predicate clause) (car clause))

    (define (cond-actions clause) (cdr clause))

    (define (cond->if exp)
      (expand-clauses (cond-clauses exp)))

    (define (expand-clauses clauses)
      (if (null? clauses)
	  'false
	  (let ((first (car clauses))
		(rest (cdr clauses)))
	    (if (cond-else-clause? first)
		(if (null? rest)
		    (sequence->exp (cond-actions first))
		    (error "ELSE clause isn't last -- COND->IF"
			   clauses))
		(make-if (cond-predicate first)
			 (sequence->exp (cond-actions first))
			 (expand-clauses rest))))))

    (define (prompt-for-input string)
      #;(newline) #;(newline) (display string) (newline))
    (define (announce-output string)
      (newline) (display string) (newline))
    (define (user-print object)
      (if (compound-procedure? object)
	  (show #t (pretty (list 'compound-procedure
		       (procedure-parameters object)
		       (procedure-body object)
		       '<procedure-env>)))
	  (show #t (pretty object))))


    (define (make-machine register-names ops controller-text)
      (let ((machine (make-new-machine)))
	(for-each
	 (lambda (register-name)
	   ((machine 'allocate-register) register-name))
	 register-names)
	((machine 'install-operations) ops)
	((machine 'install-instruction-sequence)
	 (assemble controller-text machine))
	machine))
    (define (make-register name)
      (let ((contents '*unassigned*)
	    (tracing-flag #f))
	(define (dispatch message)
	  (cond ((eq? message 'get) contents)
	      ((eq? message 'set)
	       (lambda (value)
		   (when tracing-flag
		    (show #t "\ntrace:"
			     (written name)
			     ":"
			     (written contents)
			     "->"
			     (written value)))
		   (set! contents value)))
		((eq? message 'trace-on) (set! tracing-flag #t))
		((eq? message 'trace-off) (set! tracing-flag #f))
	      (else
	       (error "Unknown request: REGISTER" message))))
	dispatch))
    (define (get-contents register) (register 'get))
    (define (set-contents! register value)
      ((register 'set) value))
    (define (make-stack)
      (let ((s '())
	  (number-pushes 0)
	  (max-depth 0)
	  (current-depth 0))
	(define (push x)
	  (set! s (cons x s))
	  (set! number-pushes (+ 1 number-pushes))
	  (set! current-depth (+ 1 current-depth))
	  (set! max-depth (max current-depth max-depth)))
	(define (pop)
	  (if (null? s)
	    (error "Empty stack: POP")
	    (let ((top (car s)))
	      (set! s (cdr s))
	      (set! current-depth (- current-depth 1))
	      top)))
	(define (initialize)
	  (set! s '())
	  (set! number-pushes 0)
	  (set! max-depth 0)
	  (set! current-depth 0)
	  'done)
	(define (print-statistics)
	  (newline)
	  (display (list 'total-pushes
		       '= number-pushes
		       'maximum-depth '= max-depth)))
	(define (dispatch message)
	  (cond ((eq? message 'push) push)
	      ((eq? message 'pop) (pop))
	      ((eq? message 'initialize) (initialize))
	      ((eq? message 'print-statistics)
	       (print-statistics))
	      (else (error "Unknown request: STACK" message))))
	dispatch))
    (define (pop stack) (stack 'pop))
    (define (push stack value) ((stack 'push) value))

    (define (make-breakpoint label offset)
      (list label offset))
    (define (breakpoint-label brk)
      (car brk))
    (define (breakpoint-offset brk)
      (cadr brk))

    (define (make-new-machine)
      (let ((pc (make-register 'pc))
	  (flag (make-register 'flag))
	  (stack (make-stack))
	  (the-instruction-sequence '())
	  (the-instruction-counter 0)
	  (tracing-flag #f)
	  (labels-flag #f)
	  (the-labels '())
	  (the-breakpoints '())
	  (reverse-breakpoints '())
	  (metadata '())
	  (resume-continuation '()))
	(let ((the-ops
	     (list (list 'initialize-stack
			 (lambda () (stack 'initialize)))
		   (list 'print-stack-statistics
			 (lambda () (stack 'print-statistics)))))

	    (register-table
	     (list (list 'pc pc) (list 'flag flag))))
	  (define (allocate-register name)
	  (if (assoc name register-table)
	      (error "Multiply defined register: " name)
	      (set! register-table
		(cons (list name (make-register name))
		      register-table)))
	  'register-allocated)
	  (define (lookup-register name)
	  (let ((val (assoc name register-table)))
	    (if val
		(cadr val)
		(error "Unknown register:" name))))
	  (define (all-register-names)
	      (map car register-table))
	  (define (set-breakpoint label offset) ;; brk has label and offset
	  (let ((break (make-breakpoint label offset))
		(target (lookup-label the-labels label)))
	    (when (assoc break the-breakpoints)
	      (error "Breakpoint already set" break))
	    (unless target
	      (error "Label not found" label))
	    (when (< (length target) offset)
	      (error "Wrong offset" offset target))
	    (set! the-breakpoints (cons (list break (list-tail target offset))
					the-breakpoints))
	    (set! reverse-breakpoints (cons (list (list-tail target offset) break)
					    reverse-breakpoints))))
	  (define (cancel-breakpoint label offset)
	  (let ((breakpoint (make-breakpoint label offset)))
	    (unless (assoc breakpoint the-breakpoints)
	      (error "No such breakpoint" breakpoint))
	    (let* ((break (assoc breakpoint the-breakpoints)))
	      (unless (assoc (cadr break) reverse-breakpoints)
		(error "Breakpoints inconsistent: " (cadr break)))
	      (set! the-breakpoints (alist-delete breakpoint the-breakpoints equal?))
	      (set! reverse-breakpoints (alist-delete (cadr break) reverse-breakpoints equal?)))))
	  (define (execute continuation)
	  (let ((insts (get-contents pc)))
	    (set! the-instruction-counter (+ the-instruction-counter 1))
	    (if (null? insts)
		'done
		(begin
		  (if (and labels-flag (not (null? (instruction-labels (car insts)))))
		      (begin
			(display "\nlabels: ")
			(display (instruction-labels (car insts)))))
		  (if tracing-flag
		      (begin
			(display "\ninstruction text: ")
			(display (instruction-text (car insts)))))
		  (when (assoc insts reverse-breakpoints)
		      (show #t "\nBreakpoint: "
			    (pretty (cdr (assoc insts reverse-breakpoints)))
			    "Inst="
			    (pretty (car insts)))
		      (call/cc (lambda (res)
				 (set! resume-continuation res)
				 (continuation)))
			(show #t "\nResuming."))
		  ((instruction-execution-proc (car insts)))
		  (execute continuation)))))
	  (define (dispatch message)
	  (cond ((eq? message 'start)
		 (set-contents! pc the-instruction-sequence)
		 (call/cc execute))
		((eq? message 'install-instruction-sequence)
		 (lambda (seq)
		   (set! the-instruction-sequence seq)))
		((eq? message 'allocate-register)
		 allocate-register)
		((eq? message 'get-register)
		 lookup-register)
		((eq? message 'install-operations)
		 (lambda (ops)
		   (set! the-ops (append the-ops ops))))
		((eq? message 'stack) stack)
		((eq? message 'operations) the-ops)
		((eq? message 'set-metadata!) (lambda (new-metadata) (set! metadata new-metadata)))
		((eq? message 'get-metadata) metadata)
		((eq? message 'get-instruction-count) the-instruction-counter)
		((eq? message 'reset-instruction-count) (set! the-instruction-counter 0))
		((eq? message 'trace-on) (set! tracing-flag #t))
		((eq? message 'trace-off) (set! tracing-flag #f))
		((eq? message 'labels-on) (set! labels-flag #t))
		((eq? message 'labels-off) (set! labels-flag #f))
		  ((eq? message 'all-register-names) (all-register-names))
		((eq? message 'set-breakpoint) set-breakpoint)
		((eq? message 'cancel-breakpoint) cancel-breakpoint)
		((eq? message 'cancel-all-breakpoints)
		 (set! the-breakpoints '())
		 (set! reverse-breakpoints '()))
		((eq? message 'proceed) (resume-continuation))
		((eq? message 'set-labels) (lambda (l) (set! the-labels l)))
		(else (error "Unknown request: MACHINE"
			     message))))
	  dispatch)))
    (define (start machine) (machine 'start))
    (define (get-register-contents machine register-name)
      (get-contents (get-register machine register-name)))
    (define (set-register-contents! machine register-name value)
      (set-contents! (get-register machine register-name)
		   value)
      'done)

    (define (get-register machine reg-name)
      ((machine 'get-register) reg-name))
    (define (advance-pc pc)
      (set-contents! pc (cdr (get-contents pc))))
    (define (set-breakpoint machine label offset)
      ((machine 'set-breakpoint) label offset))
    (define (cancel-breakpoint machine label offset)
      ((machine 'cancel-breakpoint) label offset))
    (define (cancel-all-breakpoints machine)
      (machine 'cancel-all-breakpoints))
    (define (proceed-machine machine) (machine 'proceed))
    (define (add-inst-label! instr label)
      (let* ((label-cell (cddr instr)))
	(set-car! label-cell (cons label (car label-cell)))))
    (define (instruction-labels inst) (caddr inst))

    (define (extract-labels text receive)
      (if (null? text)
	  (receive '() '())
	  (extract-labels
	   (cdr text)
	   (lambda (insts labels)
	   (let ((next-inst (car text)))
	     (if (symbol? next-inst)
		 (receive insts
		     (if (assoc next-inst labels)
			 (error "extract-labels: ambiguous label" next-inst)
			 (begin (unless (null? insts)
				  (add-inst-label! (car insts) next-inst))
				(cons (make-label-entry next-inst insts)
				      labels))))
		 (receive (cons (make-instruction next-inst)
				insts)
		     labels)))))))
    (define (goto-inst? inst) (tagged-list? (instruction-text inst) 'goto))
    (define (save-inst? inst) (tagged-list? (instruction-text inst) 'save))
    (define (restore-inst? inst) (tagged-list? (instruction-text inst) 'restore))
    (define (assign-inst? inst) (tagged-list? (instruction-text inst) 'assign))


    (define (instruction-text-type inst) (car (instruction-text inst)))

    (define (extract-reg source)
      (append-map (lambda (sexp) (if (tagged-list? sexp 'reg)
			      (list (cadr sexp))
			      '())) source))
    (define (extract-registers text)
      (delete-duplicates
       (append-map
	(lambda (sexp)
	  (cond ((symbol? sexp) '())
		((tagged-list? sexp 'assign)
		    (cons (cadr sexp) (extract-reg (cddr sexp))))
		((tagged-list? sexp 'save) (cdr sexp))
		((tagged-list? sexp 'restore) (cdr sexp))
		(else (extract-reg (cdr sexp)))))
	text)))


    (define (assemble controller-text machine)
      (let ((allregs (lset-difference eq? (extract-registers controller-text)
				      (machine 'all-register-names)
				      )))
       (for-each
	 (lambda (reg) ((machine 'allocate-register) reg))
	 allregs))
      (extract-labels
       controller-text
       (lambda (insts labels)
	 (let* ((meta-instructions (delete-duplicates (map instruction-text-type insts)))
	      (meta-entry-registers (delete-duplicates (append-map
							(lambda (inst)
							  (if (and (goto-inst? inst)
								   (register-exp? (goto-dest (instruction-text inst))))
							      (list (register-exp-reg (goto-dest (instruction-text inst))))
							      '())) insts)))
	      (meta-stack-registers (delete-duplicates (append-map
							(lambda (inst)
							  (if (or (save-inst? inst)
								  (restore-inst? inst))
							      (list (cadr (instruction-text inst)))
							      '())) insts)))
	      (meta-datapaths (let* ((todo (append-map
					    (lambda (inst)
					      (if (assign-inst? inst)
						  (list (cons (cadr (instruction-text inst)) (cddr (instruction-text inst))))
						  '())) insts))
				     (s '()))
				(for-each
				 (lambda (sspair)
				   (let ((reg (assoc (car sspair) s)))
				     (if reg
					 (set-cdr! reg (lset-adjoin equal? (cdr reg) (cdr sspair)))
					 (set! s (cons (cons (car sspair) (list (cdr sspair))) s)))))
				 todo) s)))
	   ((machine 'set-metadata!) (make-metadata
				    (list 'instructions meta-instructions)
				    (list 'entry-points meta-entry-registers)
				    (list 'stack-registers meta-stack-registers)
				    (list 'datapaths meta-datapaths)))
	   ((machine 'set-labels) labels)
	   (update-insts! insts labels machine))
	 insts)))
    (define make-metadata list)

    (define (update-insts! insts labels machine)
      (let ((pc (get-register machine 'pc))
	  (flag (get-register machine 'flag))
	  (stack (machine 'stack))
	  (ops (machine 'operations)))
	(for-each
	 (lambda (inst)
	   (set-instruction-execution-proc!
	  inst
	  (make-execution-procedure
	   (instruction-text inst)
	   labels machine pc flag stack ops)))
	 insts)))

    (define (make-instruction text) (list text '() '() '())) ;; text, procedure, labels
    (define (instruction-text inst) (car inst))
    (define (instruction-execution-proc inst) (cadr inst))
    (define (instruction-breakpoints inst) (list-ref inst 3))
    (define (set-instruction-breakpoint! inst break)
	(set-car! (list-tail inst 3)
		  (lset-adjoin equal? (list-tail inst 3) break)))
    (define (clear-instruction-breakpoint! inst break)
	(set-car! (list-tail inst 3)
		  (lset-difference equal? (list-tail inst 3) (list break))))

    (define (set-instruction-execution-proc! inst proc)
      (set-car! (cdr inst) proc))

    (define (make-label-entry label-name insts)
      (cons label-name insts))
    (define (lookup-label labels label-name)
      (let ((val (assoc label-name labels)))
	(if val
	  (cdr val)
	  (error "Undefined label: ASSEMBLE"
		 label-name))))
    (define (make-execution-procedure
	inst labels machine pc flag stack ops)
      (cond ((eq? (car inst) 'assign)
	   (make-assign inst machine labels ops pc))
	  ((eq? (car inst) 'test)
	   (make-test inst machine labels ops flag pc))
	  ((eq? (car inst) 'branch)
	   (make-branch inst machine labels flag pc))
	  ((eq? (car inst) 'goto)
	   (make-goto inst machine labels pc))
	  ((eq? (car inst) 'save)
	   (make-save inst machine stack pc))
	  ((eq? (car inst) 'restore)
	   (make-restore inst machine stack pc))
	  ((eq? (car inst) 'perform)
	   (make-perform inst machine labels ops pc))
	  (else
	   (error "Unknown instruction type: ASSEMBLE"
		  inst))))
    (define (make-operation-exp exp machine labels operations)
      (let ((op (lookup-prim (operation-exp-op exp)
			   operations))
	  (aprocs
	   (map (lambda (e)
		  (if (label-exp? e)
			(error "make-operation-exp: operations cannot be applied to labels"
				e exp)
			(make-primitive-exp e machine labels)))
		(operation-exp-operands exp))))
	(lambda ()
	  (apply op (map (lambda (p) (p)) aprocs)))))
    (define (operation-exp? exp)
      (and (pair? exp) (tagged-list? (car exp) 'op)))
    (define (operation-exp-op operation-exp)
      (cadr (car operation-exp)))
    (define (operation-exp-operands operation-exp)
      (cdr operation-exp))
    (define (lookup-prim symbol operations)
      (let ((val (assoc symbol operations)))
	(if val
	  (cadr val)
	  (error "Unknown operation: ASSEMBLE"
		 symbol))))

    (define (make-assign inst machine labels operations pc)
      (let ((target
	   (get-register machine (assign-reg-name inst)))
	  (value-exp (assign-value-exp inst)))
	(let ((value-proc
	     (if (operation-exp? value-exp)
		 (make-operation-exp
		  value-exp machine labels operations)
		 (make-primitive-exp
		  (car value-exp) machine labels))))
	  (lambda ()  ; execution procedure for assign
	  (set-contents! target (value-proc))
	  (advance-pc pc)))))
    (define (assign-reg-name assign-instruction)
      (cadr assign-instruction))
    (define (assign-value-exp assign-instruction)
      (cddr assign-instruction))

    (define (make-test inst machine labels operations flag pc)
      (let ((condition (test-condition inst)))
	(if (operation-exp? condition)
	  (let ((condition-proc
		 (make-operation-exp
		  condition machine labels operations)))
	    (lambda ()
	      (set-contents! flag (condition-proc))
	      (advance-pc pc)))
	  (error "Bad TEST instruction: ASSEMBLE" inst))))
    (define (test-condition test-instruction)
      (cdr test-instruction))
    (define (make-branch inst machine labels flag pc)
      (let ((dest (branch-dest inst)))
	(if (label-exp? dest)
	  (let ((insts
		 (lookup-label
		  labels
		  (label-exp-label dest))))
	    (lambda ()
	      (if (get-contents flag)
		  (set-contents! pc insts)
		  (advance-pc pc))))
	  (error "Bad BRANCH instruction: ASSEMBLE" inst))))
    (define (branch-dest branch-instruction)
      (cadr branch-instruction))
    (define (make-goto inst machine labels pc)
      (let ((dest (goto-dest inst)))
	(cond ((label-exp? dest)
	     (let ((insts (lookup-label
			   labels
			   (label-exp-label dest))))
	       (lambda () (set-contents! pc insts))))
	    ((register-exp? dest)
	     (let ((reg (get-register
			 machine
			 (register-exp-reg dest))))
	       (lambda ()
		 (set-contents! pc (get-contents reg)))))
	    (else (error "Bad GOTO instruction: ASSEMBLE" inst)))))
    (define (goto-dest goto-instruction)
      (cadr goto-instruction))
    (define (make-save inst machine stack pc)
      (let ((reg (get-register machine
			     (stack-inst-reg-name inst))))
	(lambda ()
	  (push stack (get-contents reg))
	  (advance-pc pc))))
    (define (make-restore inst machine stack pc)
      (let ((reg (get-register machine
			     (stack-inst-reg-name inst))))
	(lambda ()
	  (set-contents! reg (pop stack))
	  (advance-pc pc))))
    (define (stack-inst-reg-name stack-instruction)
      (cadr stack-instruction))
    (define (make-perform inst machine labels operations pc)
      (let ((action (perform-action inst)))
	(if (operation-exp? action)
	  (let ((action-proc
		 (make-operation-exp
		  action machine labels operations)))
	    (lambda () (action-proc) (advance-pc pc)))
	  (error "Bad PERFORM instruction: ASSEMBLE" inst))))
    (define (perform-action inst) (cdr inst))
    (define (make-primitive-exp exp machine labels)
      (cond ((constant-exp? exp)
	   (let ((c (constant-exp-value exp)))
	     (lambda () c)))
	  ((label-exp? exp)
	   (let ((insts (lookup-label
			 labels
			 (label-exp-label exp))))
	     (lambda () insts)))
	  ((register-exp? exp)
	   (let ((r (get-register machine (register-exp-reg exp))))
	     (lambda () (get-contents r))))
	  (else (error "Unknown expression type: ASSEMBLE" exp))))
    (define (register-exp? exp) (tagged-list? exp 'reg))
    (define (register-exp-reg exp) (cadr exp))
    (define (constant-exp? exp) (tagged-list? exp 'const))
    (define (constant-exp-value exp) (cadr exp))
    (define (label-exp? exp) (tagged-list? exp 'label))
    (define (label-exp-label exp) (cadr exp))

    (define the-global-environment (setup-environment))
    (define (get-global-environment) the-global-environment)
    (define eceval-operations
	  (list
             (list 'self-evaluating? self-evaluating?)
    (list 'car car)
    (list 'cdr cdr)
    (list 'cons cons)
    (list 'prompt-for-input prompt-for-input)
    (list 'announce-output announce-output)
    (list 'exit exit)
    (list 'get-global-environment get-global-environment)
    (list 'self-evaluating? self-evaluating?)
    (list 'quoted? quoted?)
    (list 'variable? variable?)
    (list 'assignment? assignment?)
    (list 'definition? definition?)
    (list 'if? if?)
    (list 'lambda? lambda?)
    (list 'begin? begin?)
    (list 'application? application?)
    (list 'lookup-variable-value lookup-variable-value)
    (list 'text-of-quotation text-of-quotation)
    (list 'lambda-parameters lambda-parameters)
    (list 'lambda-body lambda-body)
    (list 'make-procedure make-procedure)
    (list 'operands operands)
    (list 'operator operator)
    (list 'empty-arglist empty-arglist)
    (list 'no-operands? no-operands?)
    (list 'last-operand? last-operand?)
    (list 'first-operand first-operand)
    (list 'adjoin-arg adjoin-arg)
    (list 'rest-operands rest-operands)
    (list 'primitive-procedure? primitive-procedure?)
    (list 'compound-procedure? compound-procedure?)
    (list 'apply-primitive-procedure apply-primitive-procedure)
    (list 'procedure-parameters procedure-parameters)
    (list 'procedure-environment procedure-environment)
    (list 'extend-environment extend-environment)
    (list 'procedure-body procedure-body)
    (list 'begin-actions begin-actions)
    (list 'first-exp first-exp)
    (list 'last-exp? last-exp?)
    (list 'rest-exps rest-exps)
    (list 'if-predicate if-predicate)
    (list 'true? true?)
    (list 'if-alternative if-alternative)
    (list 'if-consequent if-consequent)
    (list 'assignment-variable assignment-variable)
    (list 'assignment-value assignment-value)
    (list 'set-variable-value! set-variable-value!)
    (list 'definition-variable definition-variable)
    (list 'definition-value definition-value)
    (list 'define-variable! define-variable!)
    (list 'read read)
    (list 'user-print user-print)
    (list 'error error)

    (list 'let? let?)
    (list 'let->combination let->combination)
    (list 'cond? cond?)
    (list 'cond->if cond->if)
       (list 'eq? eq?)
       (list 'apply-primitive-procedure-with-errors apply-primitive-procedure-with-errors)
      ))

    (define eceval
	  (make-machine
	   '() ;'(exp env val proc argl continue unev)
	   eceval-operations
	   (quote (
    read-eval-print-loop
    (perform (op initialize-stack))
    (perform (op prompt-for-input) (const "\n;;EC-Eval input:"))
    (assign exp (op read))
    (perform (op user-print) (reg exp))
    (assign env (op get-global-environment))
    (assign continue (label print-result))
    (goto (label eval-dispatch))
    print-result
    (perform (op announce-output) (const ";;EC-Eval value:"))
    (perform (op user-print) (reg val))
    (perform (op print-stack-statistics))
    (goto (label read-eval-print-loop))
    unknown-expression-type
    (assign val (const unknown-expression-type-error))
    (goto (label signal-error))
    unknown-procedure-type
    (restore continue) ; clean up stack (from apply-dispatch )
    (assign val (const unknown-procedure-type-error))
    (goto (label signal-error))
    signal-error
    (perform (op user-print) (reg val))
    (goto (label read-eval-print-loop))
    ev-definition
    (assign unev (op definition-variable) (reg exp))
    (save unev) ; save variable for later
    (assign exp (op definition-value) (reg exp))
    (save env)
    (save continue)
    (assign continue (label ev-definition-1))
    (goto (label eval-dispatch)) ; evaluate the definition value
    ev-definition-1
    (restore continue)
    (restore env)
    (restore unev)
    (perform (op define-variable!) (reg unev) (reg val) (reg env))
    (assign val (const ok))
    (goto (reg continue))
    ev-self-eval
    (assign val (reg exp))
    (goto (reg continue))
    ev-quoted
    (assign val (op text-of-quotation) (reg exp))
    (goto (reg continue))
    ev-lambda
    (assign unev (op lambda-parameters) (reg exp))
    (assign exp (op lambda-body) (reg exp))
    (assign val (op make-procedure) (reg unev) (reg exp) (reg env))
    (goto (reg continue))
    ev-variable
    (assign val (op lookup-variable-value) (reg exp) (reg env))
    (save exp)
    (assign exp (op car) (reg val))
    (test (op eq?) (reg exp) (const unbound))
    (branch (label error-unbound-variable))
    (restore exp)
    (assign val (op cdr) (reg val))
    (goto (reg continue))
    error-unbound-variable
    (restore exp)
    (assign val (op cons) (const unbound-variable-error) (reg exp))
    (goto (label signal-error))
    ev-assignment
    (assign unev (op assignment-variable) (reg exp))
    (save unev) ; save variable for later
    (assign exp (op assignment-value) (reg exp))
    (save env)
    (save continue)
    (assign continue (label ev-assignment-1))
    (goto (label eval-dispatch)) ; evaluate the assignment value
    ev-assignment-1
    (restore continue)
    (restore env)
    (restore unev)
    (assign val (op set-variable-value!) (reg unev) (reg val) (reg env))
    (assign val (op car) (reg val))
    (test (op eq?) (reg val) (const unbound))
    (branch (label assignment-failed))
    (assign val (const ok))
    (goto (reg continue))
    assignment-failed
    (assign exp (reg unev))
    (save exp)
    (goto (label error-unbound-variable))
    ev-if
    (save exp) ; save expression for later
    (save env)
    (save continue)
    (assign continue (label ev-if-decide))
    (assign exp (op if-predicate) (reg exp))
    (goto (label eval-dispatch)) ; evaluate the predicate
    ev-if-decide
    (restore continue)
    (restore env)
    (restore exp)
    (test (op true?) (reg val))
    (branch (label ev-if-consequent))
    ev-if-alternative
    (assign exp (op if-alternative) (reg exp))
    (goto (label eval-dispatch))
    ev-if-consequent
    (assign exp (op if-consequent) (reg exp))
    (goto (label eval-dispatch))
    ev-sequence
    (assign exp (op first-exp) (reg unev))
    (test (op last-exp?) (reg unev))
    (branch (label ev-sequence-last-exp))
    (save unev)
    (save env)
    (assign continue (label ev-sequence-continue))
    (goto (label eval-dispatch))
    ev-sequence-continue
    (restore env)
    (restore unev)
    (assign unev (op rest-exps) (reg unev))
    (goto (label ev-sequence))
    ev-sequence-last-exp
    (restore continue)
    (goto (label eval-dispatch))
    ev-begin
    (assign unev (op begin-actions) (reg exp))
    (save continue)
    (goto (label ev-sequence))
    compound-apply
    (assign unev (op procedure-parameters) (reg proc))
    (assign env (op procedure-environment) (reg proc))
    (assign env (op extend-environment)
    (reg unev) (reg argl) (reg env))
    (assign unev (op procedure-body) (reg proc))
    (goto (label ev-sequence))
    primitive-apply
    (assign val (op apply-primitive-procedure-with-errors) (reg proc) (reg argl))
    (save val)
    (assign val (op car) (reg val)) ; error or not
    (test (op eq?) (const error) (reg val))
    (branch (label primitive-error))
    (restore val)
    (assign val (op cdr) (reg val))
    (restore continue)
    (goto (reg continue))
    primitive-error
    (restore val)
    (assign val (op cdr) (reg val)) ; error-code
    (assign val (op cons) (const primitive-application-error) (reg val))
    (goto (label signal-error))
    ev-application
    (save continue)
    (save env)
    (assign unev (op operands) (reg exp))
    (save unev)
    (assign exp (op operator) (reg exp))
    (assign continue (label ev-appl-did-operator))
    (goto (label eval-dispatch))
    ev-appl-did-operator
    (restore unev) ; the operands
    (restore env)
    (assign argl (op empty-arglist))
    (assign proc (reg val)) ; the operator
    (test (op no-operands?) (reg unev))
    (branch (label apply-dispatch))
    (save proc)
    ev-appl-operand-loop
    (save argl)
    (assign exp (op first-operand) (reg unev))
    (test (op last-operand?) (reg unev))
    (branch (label ev-appl-last-arg))
    (save env)
    (save unev)
    (assign continue (label ev-appl-accumulate-arg))
    (goto (label eval-dispatch))
    ev-appl-accumulate-arg
    (restore unev)
    (restore env)
    (restore argl)
    (assign argl (op adjoin-arg) (reg val) (reg argl))
    (assign unev (op rest-operands) (reg unev))
    (goto (label ev-appl-operand-loop))
    ev-appl-last-arg
    (assign continue (label ev-appl-accum-last-arg))
    (goto (label eval-dispatch))
    ev-appl-accum-last-arg
    (restore argl)
    (assign argl (op adjoin-arg) (reg val) (reg argl))
    (restore proc)
    (goto (label apply-dispatch))
    apply-dispatch
    (test (op primitive-procedure?) (reg proc))
    (branch (label primitive-apply))
    (test (op compound-procedure?) (reg proc))
    (branch (label compound-apply))
    (goto (label unknown-procedure-type))
      eval-dispatch
      (test (op self-evaluating?) (reg exp))
      (branch (label ev-self-eval))
      (test (op variable?) (reg exp))
      (branch (label ev-variable))
      (test (op quoted?) (reg exp))
      (branch (label ev-quoted))
      (test (op assignment?) (reg exp))
      (branch (label ev-assignment))
      (test (op definition?) (reg exp))
      (branch (label ev-definition))
      (test (op if?) (reg exp))
      (branch (label ev-if))
      (test (op lambda?) (reg exp))
      (branch (label ev-lambda))
      (test (op begin?) (reg exp))
      (branch (label ev-begin))
      ;; added
      (test (op let?) (reg exp))
      (branch (label ev-let))
      (test (op cond?) (reg exp))
      (branch (label ev-cond))
      ;; end
      (test (op application?) (reg exp))
      (branch (label ev-application))
      (goto (label unknown-expression-type))
      ;; added
    ev-let
      (assign exp (op let->combination) (reg exp))
      ;(save continue)
      (goto (label eval-dispatch))
    ev-cond
      (assign exp (op cond->if) (reg exp))
      (goto (label eval-dispatch))
      ;; end
      ))))
  (start eceval)
#+end_src

#+name: list-of-scheme-interpreter-operations
#+begin_src scheme :exports code :results none
(define primitive-procedures
    (list (list 'car car)
	  (list 'cdr cdr)
	  (list 'cons cons)
	  (list 'cadr cadr)
	  (list 'null? null?)
	  (list 'exit exit)
	  (list 'display display)
	  (list 'newline newline)
	  (list 'assoc assoc)
	  (list '= =)
	  (list '< <)
	  (list '> >)
	  (list '+ +)
	  (list '- -)
	  (list 'not not)
	  (list '* *)
	  (list 'current-second current-second)
	  (list 'list list)
	  (list 'underlying-cons cons)
	  (list 'underlying-car car)
	  (list 'underlying-cdr cdr)
	  (list 'eq? eq?)
	  (list 'equal? equal?)
	  (list 'pair? pair?)
	  (list 'error error)
	  (list 'random-integer random-integer)
	  (list 'even? even?)
	  (list 'remainder remainder)
	  (list 'square square)
	  (list '/ /)
	  (list 'member member)
	  (list 'abs abs)
	  (list 'cdar cdar)
	  (list 'cdadr cdadr)
	  (list 'caar caar)
	  (list 'caadr caadr)
	  (list 'cddr cddr)
	  (list 'cdddr cdddr)
	  (list 'caddr caddr)
	  (list 'cadddr cadddr)
	  (list 'set-car! set-car!)
	  (list 'set-cdr! set-cdr!)
	  (list 'memq memq)
	  (list 'read read)
	  (list 'show show)
	  (list 'pretty pretty)
	  (list 'number? number?)
	  (list 'string? string?)
	  (list 'symbol? symbol?)
	  ))
#+end_src

#+name: list-of-eceval-operations
#+begin_src scheme :exports code :results none
  (define eceval-operations
    (list
      (list 'self-evaluating? self-evaluating?)
      (list 'car car)
      (list 'cdr cdr)
      (list 'cons cons)
      (list 'prompt-for-input prompt-for-input)
      (list 'announce-output announce-output)
      (list 'exit exit)
      (list 'get-global-environment get-global-environment)
      (list 'self-evaluating? self-evaluating?)
      (list 'quoted? quoted?)
      (list 'variable? variable?)
      (list 'assignment? assignment?)
      (list 'definition? definition?)
      (list 'if? if?)
      (list 'lambda? lambda?)
      (list 'begin? begin?)
      (list 'application? application?)
      (list 'lookup-variable-value lookup-variable-value)
      (list 'text-of-quotation text-of-quotation)
      (list 'lambda-parameters lambda-parameters)
      (list 'lambda-body lambda-body)
      (list 'make-procedure make-procedure)
      (list 'operands operands)
      (list 'operator operator)
      (list 'empty-arglist empty-arglist)
      (list 'no-operands? no-operands?)
      (list 'last-operand? last-operand?)
      (list 'first-operand first-operand)
      (list 'adjoin-arg adjoin-arg)
      (list 'rest-operands rest-operands)
      (list 'primitive-procedure? primitive-procedure?)
      (list 'compound-procedure? compound-procedure?)
      (list 'apply-primitive-procedure apply-primitive-procedure)
      (list 'procedure-parameters procedure-parameters)
      (list 'procedure-environment procedure-environment)
      (list 'extend-environment extend-environment)
      (list 'procedure-body procedure-body)
      (list 'begin-actions begin-actions)
      (list 'first-exp first-exp)
      (list 'last-exp? last-exp?)
      (list 'rest-exps rest-exps)
      (list 'if-predicate if-predicate)
      (list 'true? true?)
      (list 'if-alternative if-alternative)
      (list 'if-consequent if-consequent)
      (list 'assignment-variable assignment-variable)
      (list 'assignment-value assignment-value)
      (list 'set-variable-value! set-variable-value!)
      (list 'definition-variable definition-variable)
      (list 'definition-value definition-value)
      (list 'define-variable! define-variable!)
      (list 'read read)
      (list 'user-print user-print)
      (list 'error error)

      (list 'let? let?)
      (list 'let->combination let->combination)
      (list 'cond? cond?)
      (list 'cond->if cond->if)
	 (list 'eq? eq?)
	 (list 'apply-primitive-procedure-with-errors apply-primitive-procedure-with-errors)
	))
#+end_src

The operations above we probably have to implement ourselves.

The following is the code for the actual "main loop", which
corresponds to the main_ loop() function in the Fortran code.

#+begin_src scheme :exports code :results none
    read-eval-print-loop
    (perform (op initialize-stack))
    (perform (op prompt-for-input) (const "\n;;EC-Eval input:"))
    (assign exp (op read))
    (perform (op user-print) (reg exp))
    (assign env (op get-global-environment))
    (assign continue (label print-result))
    (goto (label eval-dispatch))
    print-result
    (perform (op announce-output) (const ";;EC-Eval value:"))
    (perform (op user-print) (reg val))
    (perform (op print-stack-statistics))
    (goto (label read-eval-print-loop))
    unknown-expression-type
    (assign val (const unknown-expression-type-error))
    (goto (label signal-error))
    unknown-procedure-type
    (restore continue) ; clean up stack (from apply-dispatch )
    (assign val (const unknown-procedure-type-error))
    (goto (label signal-error))
    signal-error
    (perform (op user-print) (reg val))
    (goto (label read-eval-print-loop))
    ev-definition
    (assign unev (op definition-variable) (reg exp))
    (save unev) ; save variable for later
    (assign exp (op definition-value) (reg exp))
    (save env)
    (save continue)
    (assign continue (label ev-definition-1))
    (goto (label eval-dispatch)) ; evaluate the definition value
    ev-definition-1
    (restore continue)
    (restore env)
    (restore unev)
    (perform (op define-variable!) (reg unev) (reg val) (reg env))
    (assign val (const ok))
    (goto (reg continue))
    ev-self-eval
    (assign val (reg exp))
    (goto (reg continue))
    ev-quoted
    (assign val (op text-of-quotation) (reg exp))
    (goto (reg continue))
    ev-lambda
    (assign unev (op lambda-parameters) (reg exp))
    (assign exp (op lambda-body) (reg exp))
    (assign val (op make-procedure) (reg unev) (reg exp) (reg env))
    (goto (reg continue))
    ev-variable
    (assign val (op lookup-variable-value) (reg exp) (reg env))
    (save exp)
    (assign exp (op car) (reg val))
    (test (op eq?) (reg exp) (const unbound))
    (branch (label error-unbound-variable))
    (restore exp)
    (assign val (op cdr) (reg val))
    (goto (reg continue))
    error-unbound-variable
    (restore exp)
    (assign val (op cons) (const unbound-variable-error) (reg exp))
    (goto (label signal-error))
    ev-assignment
    (assign unev (op assignment-variable) (reg exp))
    (save unev) ; save variable for later
    (assign exp (op assignment-value) (reg exp))
    (save env)
    (save continue)
    (assign continue (label ev-assignment-1))
    (goto (label eval-dispatch)) ; evaluate the assignment value
    ev-assignment-1
    (restore continue)
    (restore env)
    (restore unev)
    (assign val (op set-variable-value!) (reg unev) (reg val) (reg env))
    (assign val (op car) (reg val))
    (test (op eq?) (reg val) (const unbound))
    (branch (label assignment-failed))
    (assign val (const ok))
    (goto (reg continue))
    assignment-failed
    (assign exp (reg unev))
    (save exp)
    (goto (label error-unbound-variable))
    ev-if
    (save exp) ; save expression for later
    (save env)
    (save continue)
    (assign continue (label ev-if-decide))
    (assign exp (op if-predicate) (reg exp))
    (goto (label eval-dispatch)) ; evaluate the predicate
    ev-if-decide
    (restore continue)
    (restore env)
    (restore exp)
    (test (op true?) (reg val))
    (branch (label ev-if-consequent))
    ev-if-alternative
    (assign exp (op if-alternative) (reg exp))
    (goto (label eval-dispatch))
    ev-if-consequent
    (assign exp (op if-consequent) (reg exp))
    (goto (label eval-dispatch))
    ev-sequence
    (assign exp (op first-exp) (reg unev))
    (test (op last-exp?) (reg unev))
    (branch (label ev-sequence-last-exp))
    (save unev)
    (save env)
    (assign continue (label ev-sequence-continue))
    (goto (label eval-dispatch))
    ev-sequence-continue
    (restore env)
    (restore unev)
    (assign unev (op rest-exps) (reg unev))
    (goto (label ev-sequence))
    ev-sequence-last-exp
    (restore continue)
    (goto (label eval-dispatch))
    ev-begin
    (assign unev (op begin-actions) (reg exp))
    (save continue)
    (goto (label ev-sequence))
    compound-apply
    (assign unev (op procedure-parameters) (reg proc))
    (assign env (op procedure-environment) (reg proc))
    (assign env (op extend-environment)
    (reg unev) (reg argl) (reg env))
    (assign unev (op procedure-body) (reg proc))
    (goto (label ev-sequence))
    primitive-apply
    (assign val (op apply-primitive-procedure-with-errors) (reg proc) (reg argl))
    (save val)
    (assign val (op car) (reg val)) ; error or not
    (test (op eq?) (const error) (reg val))
    (branch (label primitive-error))
    (restore val)
    (assign val (op cdr) (reg val))
    (restore continue)
    (goto (reg continue))
    primitive-error
    (restore val)
    (assign val (op cdr) (reg val)) ; error-code
    (assign val (op cons) (const primitive-application-error) (reg val))
    (goto (label signal-error))
    ev-application
    (save continue)
    (save env)
    (assign unev (op operands) (reg exp))
    (save unev)
    (assign exp (op operator) (reg exp))
    (assign continue (label ev-appl-did-operator))
    (goto (label eval-dispatch))
    ev-appl-did-operator
    (restore unev) ; the operands
    (restore env)
    (assign argl (op empty-arglist))
    (assign proc (reg val)) ; the operator
    (test (op no-operands?) (reg unev))
    (branch (label apply-dispatch))
    (save proc)
    ev-appl-operand-loop
    (save argl)
    (assign exp (op first-operand) (reg unev))
    (test (op last-operand?) (reg unev))
    (branch (label ev-appl-last-arg))
    (save env)
    (save unev)
    (assign continue (label ev-appl-accumulate-arg))
    (goto (label eval-dispatch))
    ev-appl-accumulate-arg
    (restore unev)
    (restore env)
    (restore argl)
    (assign argl (op adjoin-arg) (reg val) (reg argl))
    (assign unev (op rest-operands) (reg unev))
    (goto (label ev-appl-operand-loop))
    ev-appl-last-arg
    (assign continue (label ev-appl-accum-last-arg))
    (goto (label eval-dispatch))
    ev-appl-accum-last-arg
    (restore argl)
    (assign argl (op adjoin-arg) (reg val) (reg argl))
    (restore proc)
    (goto (label apply-dispatch))
    apply-dispatch
    (test (op primitive-procedure?) (reg proc))
    (branch (label primitive-apply))
    (test (op compound-procedure?) (reg proc))
    (branch (label compound-apply))
    (goto (label unknown-procedure-type))
      eval-dispatch
      (test (op self-evaluating?) (reg exp))
      (branch (label ev-self-eval))
      (test (op variable?) (reg exp))
      (branch (label ev-variable))
      (test (op quoted?) (reg exp))
      (branch (label ev-quoted))
      (test (op assignment?) (reg exp))
      (branch (label ev-assignment))
      (test (op definition?) (reg exp))
      (branch (label ev-definition))
      (test (op if?) (reg exp))
      (branch (label ev-if))
      (test (op lambda?) (reg exp))
      (branch (label ev-lambda))
      (test (op begin?) (reg exp))
      (branch (label ev-begin))
      ;; added
      (test (op let?) (reg exp))
      (branch (label ev-let))
      (test (op cond?) (reg exp))
      (branch (label ev-cond))
      ;; end
      (test (op application?) (reg exp))
      (branch (label ev-application))
      (goto (label unknown-expression-type))
      ;; added
    ev-let
      (assign exp (op let->combination) (reg exp))
      ;(save continue)
      (goto (label eval-dispatch))
    ev-cond
      (assign exp (op cond->if) (reg exp))
      (goto (label eval-dispatch))

#+end_src


#+name: fortran-scheme-interpreter-runtime-prologue
#+begin_src f90 :exports code :results none
	module system_interface
	  use, intrinsic :: iso_fortran_env, only: input_unit
	  implicit none
	 contains
	  function read_until_eof() result( retval )
	    character(len=:), allocatable :: retval
	    character(len=1) :: buffer
	    integer :: reason
	    ! this function is broken and doesn't support comments
	    reader: do
	       read (input_unit, '(a1)', iostat=reason, advance='no') buffer
	       if (is_iostat_end(reason))  then
		   print *, "debug: end of input (EOF)", retval
		  !stop 0
		  exit reader
	       else if (is_iostat_eor(reason)) then
		  !print *, "debug: end of record (newline)"
		  exit reader
	       else if (reason > 0) then
		  exit reader
		  print*, "Fortran:read error"
		  error stop "reading problems"
	       else
		  !print *, "debug:read:char=", buffer, " code=", iachar(buffer)
		  retval = retval//buffer;
	       end if
	    end do reader
	    !print *, "debug:", retval, new_line('a')
	  end function read_until_eof
	end module system_interface

	module scheme
	  !  use, non_intrinsic :: system_interface, only: c_exit
	  use, intrinsic :: iso_fortran_env
	  implicit none
	  integer, parameter :: memory_size = 102400

	  type, abstract :: scheme_object
	   contains
	     procedure, pass :: generic_scheme_print => print_scheme_object
	     procedure, pass :: debug_display => debug_display_object
	     generic, public :: write (formatted) => generic_scheme_print
	     !final :: deallocate_scheme_object_value
	  end type scheme_object

	  type, extends( scheme_object ) :: scheme_string
	     character(len=:), pointer :: value
	   contains
	     procedure :: debug_display => debug_display_string
	     procedure :: generic_scheme_print => print_scheme_string
	     !      generic :: write (formatted) => print_scheme_string
	     final :: scheme_string_deallocate
	  end type scheme_string
	  type, extends( scheme_object ) :: scheme_number
	     integer :: value
	   contains
	     procedure :: debug_display => debug_display_number
             procedure :: generic_scheme_print => print_scheme_number

	  end type scheme_number

	  type, extends( scheme_object ) :: scheme_pair
	     integer :: value
	   contains
	     procedure :: debug_display  => debug_display_pair
	     procedure :: generic_scheme_print => print_scheme_pair
	     !final :: scheme_pair_deallocate
	  end type scheme_pair


	  type, extends( scheme_object ) :: scheme_symbol
	     character(len=:), pointer :: value
	   contains
	     procedure :: debug_display => debug_display_symbol
	     procedure :: generic_scheme_print => print_scheme_symbol
	     procedure :: eq_symbol_symbol
	     procedure :: eq_symbol_string
	!     generic, public :: eq =>  eq_symbol_symbol, eq_symbol_string
	     generic, public :: operator(==) => eq_symbol_symbol, eq_symbol_string
	  end type scheme_symbol


	  type, extends( scheme_object ) :: scheme_empty_list
	   contains
	     procedure :: debug_display => debug_display_empty_list
	     procedure :: generic_scheme_print => print_scheme_empty_list
	  end type scheme_empty_list

	  type(scheme_empty_list), target :: the_null

	  type, extends( scheme_object ) :: scheme_boolean
	     logical :: value
	   contains
	     procedure :: debug_display => debug_display_boolean
             procedure :: generic_scheme_print => print_scheme_boolean
	  end type scheme_boolean

	  type(scheme_boolean), target :: the_false = scheme_boolean( .false. )
	  type(scheme_boolean), target :: the_true  = scheme_boolean( .true.  )

	  type, extends( scheme_object ) :: scheme_broken_heart
	  end type scheme_broken_heart

	  type, extends( scheme_object ) :: scheme_forwarding_address
	     integer :: moved_to
	  end type scheme_forwarding_address

	  type, extends( scheme_object ) :: scheme_primitive_procedure
	     character(len=:), pointer :: name
	     procedure(packageable_procedure), pointer, nopass :: proc_pointer
	   contains
	     procedure, pass :: generic_scheme_print => print_scheme_primitive_procedure
	  end type scheme_primitive_procedure

	  abstract interface
	     function packageable_procedure( argl, env ) result( retval )
	       import :: scheme_object
	       class(scheme_object), pointer :: retval
	       class(scheme_object), pointer :: argl
	       class(scheme_object), pointer :: env
	     end function packageable_procedure

	  end interface

	  interface
	     recursive function mappable_proc( arg ) result(retval)
	       import scheme_object
	       class(scheme_object), pointer, intent(in) :: arg
	       class(scheme_object), pointer :: retval
	     end function mappable_proc
	  end interface


	  type scheme_pointer
	     class(scheme_object), pointer :: contents
	  end type scheme_pointer

	  type(scheme_pointer), dimension(memory_size) :: the_cars
	  type(scheme_pointer), dimension(memory_size) :: the_cdrs
	  integer :: free = 1

	  class(scheme_object), pointer :: exp => null()
	  class(scheme_object), pointer :: env => null()
	  class(scheme_object), pointer :: val => null()
	  class(scheme_object), pointer :: proc => null()
	  class(scheme_object), pointer :: argl => null()
	  class(scheme_object), pointer :: unev => null()
	  class(scheme_object), pointer :: the_global_environment => null()
	  class(scheme_object), pointer :: the_stack => the_null
	  class(scheme_symbol), pointer :: reg_continue
	  class(scheme_symbol), pointer :: compapp
	  class(scheme_object), pointer :: arg1
	  class(scheme_object), pointer :: arg2



	  integer :: stack_number_pushes = 0
	  integer :: stack_max_depth = 0
	  integer :: stack_current_depth = 0

          logical :: garbage_collector_on = .false.
	  ! continue is a special register. It keeps labels rather than scheme objects

	  interface save_scheme
	     module procedure scheme_save_reg
	     !module procedure scheme_save_continue
	  end interface save_scheme

	contains
	  function eq_symbol_symbol( this, that ) result( retval )
	    class(scheme_symbol), intent(in) :: this
	    class(scheme_symbol), intent(in) :: that
	    logical :: retval
	!    write (*,*) "this%value=", this%value, " that%value=", that%value
	    if ( this%value .eq. that%value ) then
	       retval = .true.
	    else
	       retval = .false.
	    end if
	  end function eq_symbol_symbol

	  function eq_symbol_string( this, that ) result( retval )
	    class(scheme_symbol), intent(in) :: this
	    character, intent(in) :: that
	    logical :: retval
	    if ( this%value .eq. that ) then
	       retval = .true.
	    else
	       retval = .false.
	    end if
	  end function eq_symbol_string


	  subroutine scheme_string_deallocate( this )
	    type(scheme_string) :: this
	    deallocate( this%value )
	    print *, "de-allocating string"
	  end subroutine scheme_string_deallocate

	  !  subroutine scheme_pair_deallocate( this )
	  !    type(scheme_pair) :: this
	  !    deallocate( this%value )
	  !    print *, "de-allocating pair"
	  !  end subroutine scheme_pair_deallocate

	  subroutine print_scheme_object(this, unit, iotype, v_list, iostat, iomsg)
	    class(scheme_object), intent(in) :: this
	    integer, intent(in)         :: unit
	    character(*), intent(in)    :: iotype
	    integer, intent(in)         :: v_list (:)
	    integer, intent(out)        :: iostat
	    character(*), intent(inout) :: iomsg
	    write (unit, fmt=*, iostat=iostat, iomsg=iomsg) "#<unknown scheme object>"
	  end subroutine print_scheme_object

	  subroutine print_scheme_primitive_procedure(this, unit, iotype, v_list,&
	       iostat, iomsg)
	    class(scheme_primitive_procedure), intent(in) :: this
	    integer, intent(in)         :: unit
	    character(*), intent(in)    :: iotype
	    integer, intent(in)         :: v_list (:)
	    integer, intent(out)        :: iostat
	    character(*), intent(inout) :: iomsg
	    write (unit, fmt='(a,a,a)', iostat=iostat, iomsg=iomsg, advance='no') &
		 "#<opcode ", this%name, ">"
	  end subroutine print_scheme_primitive_procedure


	  subroutine print_scheme_string(this, unit, iotype, v_list, iostat, iomsg)
	    class(scheme_string), intent(in) :: this
	    integer, intent(in)         :: unit
	    character(*), intent(in)    :: iotype
	    integer, intent(in)         :: v_list (:)
	    integer, intent(out)        :: iostat
	    character(*), intent(inout) :: iomsg
	    !    select type ( temp => this%value )
	    !    type is (character(len=*))
	    write (unit, fmt='(a)', iostat=iostat, iomsg=iomsg, advance='no') &
		 '#<scheme_string "' // this%value // '">'
	    !    class default
	    !       print *, 'error'
	    ! iostat = c_exit(1)
	    !       error stop "wrong string contents"
	    !    end select
	  end subroutine print_scheme_string

	  subroutine print_scheme_pair(this, unit, iotype, v_list, iostat, iomsg)
	    class(scheme_pair), intent(in) :: this
	    integer, intent(in)         :: unit
	    character(*), intent(in)    :: iotype
	    integer, intent(in)         :: v_list (:)
	    integer, intent(out)        :: iostat
	    character(*), intent(inout) :: iomsg
	    !    select type ( temp => this%value )
	    !    type is (integer)
	    write (unit, fmt='(a,i0,a)', iostat=iostat, iomsg=iomsg, advance='no') &
		 '#<scheme_pair address=', this%value, '>'
	    !    class default
	    !       print *, 'error'
	    !       error stop "wrong pair contents"
	    ! iostat = c_exit(1)
	    !    end select
	  end subroutine print_scheme_pair

        subroutine print_scheme_number(this, unit, iotype, v_list, iostat, iomsg)
	  class(scheme_number), intent(in) :: this
	  integer, intent(in)         :: unit
	  character(*), intent(in)    :: iotype
	  integer, intent(in)         :: v_list (:)
	  integer, intent(out)        :: iostat
	  character(*), intent(inout) :: iomsg
	  !    select type ( temp => this%value )
	  !    type is (character(len=*))
	  write (unit, fmt='(a,i0,a)', iostat=iostat, iomsg=iomsg, advance='no') &
	       '#<scheme_number "', this%value, '">'
	  !    class default
	  !       print *, 'error'
	  ! iostat = c_exit(1)
	  !       error stop "wrong string contents"
	  !    end select
	end subroutine print_scheme_number

        subroutine print_scheme_boolean(this, unit, iotype, v_list, iostat, iomsg)
	  class(scheme_boolean), intent(in) :: this
	  integer, intent(in)         :: unit
	  character(*), intent(in)    :: iotype
	  integer, intent(in)         :: v_list (:)
	  integer, intent(out)        :: iostat
	  character(*), intent(inout) :: iomsg
	  !    select type ( temp => this%value )
	  !    type is (character(len=*))
	  write (unit, fmt='(a,l0,a)', iostat=iostat, iomsg=iomsg, advance='no') &
	       '#<scheme_boolean "', this%value, '">'
	  !    class default
	  !       print *, 'error'
	  ! iostat = c_exit(1)
	  !       error stop "wrong string contents"
	  !    end select
	end subroutine print_scheme_boolean


	  subroutine print_scheme_empty_list(this, unit, iotype, v_list, iostat, iomsg)
	    class(scheme_empty_list), intent(in) :: this
	    integer, intent(in)         :: unit
	    character(*), intent(in)    :: iotype
	    integer, intent(in)         :: v_list (:)
	    integer, intent(out)        :: iostat
	    character(*), intent(inout) :: iomsg
	    write (unit, fmt=*, iostat=iostat, iomsg=iomsg) &
		 '#<scheme_empty_list', '>'
	  end subroutine print_scheme_empty_list


	  subroutine print_scheme_symbol(this, unit, iotype, v_list, iostat, iomsg)
	    class(scheme_symbol), intent(in) :: this
	    integer, intent(in)         :: unit
	    character(*), intent(in)    :: iotype
	    integer, intent(in)         :: v_list (:)
	    integer, intent(out)        :: iostat
	    character(*), intent(inout) :: iomsg
	    !    select type ( temp => this%value )
	    !    type is (character(len=*))
	    write (unit, fmt='(A)', iostat=iostat, iomsg=iomsg, advance='no') '#<scheme_symbol "' // this%value // '">'
	    !    class default
	    !       print *, 'error'
	    !       error stop "wrong scheme symbol contents"
	    ! iostat = c_exit(1)
	    !    end select
	  end subroutine print_scheme_symbol

	  subroutine debug_display_object( this ) ! for the root object
	    class(scheme_object), intent(in) :: this
	    write (output_unit, fmt='(dt)', advance='no') this
	  end subroutine debug_display_object

	  function remove_junk( arg ) result( intermediate )
	    character(:), intent(in), allocatable :: arg
	    character(:), allocatable :: intermediate
	    integer :: i
	    logical :: comment_flag = .false.
	    character, parameter :: newline = new_line('a')
	    !    print *, "trace:remove_junk"
	    !    print *, "remove_junk:arg=", arg
	    intermediate = ""
	    do i=1,len(arg)
	       if (arg(i:i) == ';') then
		  comment_flag = .true.
	       else if (arg(i:i) == newline) then
		  comment_flag = .false.
	       end if
	       if ((arg(i:i) == newline) .or. comment_flag) then
		  cycle
	       end if
	       intermediate = intermediate//arg(i:i)
	    end do
	    !print *, new_line('a'), "remove_junk:result=", intermediate
	  end function remove_junk

	  function make_string( string ) result( retval )
	    character(len=*), intent(in) :: string
	    type(scheme_string), pointer :: retval
	    integer :: strlen
	    strlen = len(string)
	    allocate( scheme_string :: retval )
	    allocate( retval%value, source=string )
	    !    select type( temp => retval%value )
	    !    type is (character(*))
	    !       temp = string
	    !    class default
	    !       error stop "wrong string contents"
	    !    end select
	  end function make_string


	  function parse_string( arg ) result( token )
	    character(:), pointer, intent(inout) :: arg
	    class(scheme_object), pointer :: token
	    integer :: caret = 1
	    character(:), allocatable :: interim_string
	    allocate(interim_string, source="")
	    caret = 1 ! skipping the first quotation mark '"'
	    do
	       caret = caret + 1
	       if (arg(caret:caret) == '"') then
		  caret = caret + 1
		  exit
	       end if
	       interim_string = interim_string // arg(caret:caret)
	    end do
	    token => make_string( interim_string )
	    arg => arg(caret:)
	  end function parse_string

	  function make_symbol( string ) result( retval )
	    character(len=*), intent(in) :: string
	    type(scheme_symbol), pointer :: retval
	    integer :: strlen
	    strlen = len(string)
	    allocate( scheme_symbol :: retval )
	    allocate( retval%value, source=string )
	  end function make_symbol

	  function make_number( fortran_number ) result(retval)
	    type(scheme_number), pointer :: token
	    class(scheme_object), pointer :: retval
	    integer :: fortran_number
	    allocate( scheme_number :: token )
	    token%value = fortran_number
	    retval => token
	  end function

	  function parse_symbol( arg ) result( token )
	    character(:), pointer, intent(inout) :: arg
	    class(scheme_object), pointer :: token
	    integer :: caret = 1
	    character, parameter, dimension(*) :: allowed_chars = (/ 'a', 'b', 'c', &
		 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', &
		 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '-', '+', '*', &
		 '/', '=', '!', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9' /)
	    character(:), allocatable, target :: interim_string
	    allocate( interim_string, source="")
	    !token%value = "BUG1"
	    caret = 0
	    do
	       caret = caret + 1
	       if (.not.any( arg(caret:caret) == allowed_chars )) then
		  exit
	       end if
	       interim_string = interim_string // arg(caret:caret) ! does it reallocate every assignment?
	    end do
	    !    token%value = interim_string
	    token => make_symbol( interim_string )
	    arg => arg(caret:)
	  end function parse_symbol

	  function parse_number( arg ) result( token )
	    character(:), pointer, intent(inout) :: arg
	    class(scheme_number), pointer :: token
	    integer :: caret = 1
	    character, parameter, dimension(*) :: allowed_chars = (/ '1', '2', '3', &
		 '4', '5', '6', '7', '8', '9', '0' /)
	    character(:), allocatable :: interim_string
	    allocate( scheme_number :: token )
	    !    allocate( integer :: token%value )
	    allocate( interim_string, source="")
	    !    token%value = int(z"DEAD")
	    caret = 0
	    do
	       caret = caret + 1
	       if (.not.any( arg(caret:caret) == allowed_chars )) then
		  exit
	       end if
	       interim_string = interim_string // arg(caret:caret) ! does it reallocate every assignment?
	    end do
	    !token%value = interim_string
	    !    select type (temp => token%value)
	    !    type is (integer)
	    read (interim_string, *) token%value
	    !    class default
	    !       error stop "wrong number contents"
	    !    end select
	    arg => arg(caret:)
	  end function parse_number



	  recursive function parse_list( arg ) result( retval )
	    character(:), pointer :: arg
	    class(scheme_object), pointer :: retval
	    do while (arg(1:1) == ' ')
	       arg => arg(2:)
	    end do
	    if (arg(1:1) == ")") then
	       retval => the_null
	       arg => arg(2:) ! is this correct?
	       return
	    end if
	    retval => cons( parse_sexp(arg), parse_list( arg ) ) ! memory leak?
	  end function parse_list

	  recursive function parse_sexp( arg ) result( retval )
	    character(:), pointer, intent(inout) :: arg
	    class(scheme_object), pointer :: retval

	    sexp_detector: select case (arg(1:1))
	    case ('(')
	!       print *, "debug: parsing list"
	       arg => arg(2:)
	       retval => parse_list( arg )
	    case ( "'" )
	       !print *, "parse_sexp: parsing quote"
	       arg => arg(2:)
	       retval => cons( make_symbol("quote"), cons( parse_sexp(arg), the_null ))
	    case ('"')
	       !print *, "parse_sexp: parsing string"
	       retval => parse_string( arg ) ! returns sexp and moves arg
	    case ( '0', '1', '2', '3', '4', '5', '6', '7', '8', '9')
	       !print *, "parse_sexp: parsing number"
	       retval => parse_number( arg )
	    case ( ')' )
	       error stop "Closing parenthesis should be processed in parse_list"
	       retval => the_null
	    case ( '#')
	       hashed_select: select case (arg(2:2))
	       case ('t')
		  retval => the_true
	       case ('f')
		  retval => the_false
	       case default
		  error stop "Additional read syntax not implemented."
	       end select hashed_select
	       arg => arg(3:)
	    case default
	       !       print *, new_line('a'), "debug: parse symbol"

	       retval => parse_symbol( arg )
	    end select sexp_detector

	  end function parse_sexp

          recursive subroutine debug_is_environment_well_formed_p( env, lineno )
            class(scheme_object), pointer :: env
            integer :: lineno
            if (lineno > 0) then
               print *, "checking environment instance ", lineno
            end if
            select type (env)
            class is (scheme_empty_list)
                !write (*,*) "seems to be ok"
                return
            class is (scheme_pair)
                call debug_is_frame_well_p( car(car(env)), cdr(car(env)) )
                call debug_is_environment_well_formed_p( cdr(env), -1 )
            class default
                error stop "malformed environment"
            end select
          contains
             recursive subroutine debug_is_frame_well_p( vars, vals )
               class(scheme_object), pointer :: vars
               class(scheme_object), pointer :: vals ! ignored
               select type (vars)
               class is (scheme_empty_list)
                 select type (vals)
                 class is (scheme_empty_list)
                   !seems ok
                 class default
                   error stop "vars empty, vals not empty"
                 end select
               class is (scheme_pair)
                 select type ( v1 => car(vars) )
                 class is (scheme_symbol)
                    ! seems fine
                    ! checking for validity of vals is not implemented
                    call debug_is_frame_well_p( cdr(vars), cdr(vals) )
                 class default
                    print *,"v1=", v1
                    error stop "var name is not a symbol"
                 end select
               class default
                 error stop "vars not empty and not a pair"
               end select
             end subroutine debug_is_frame_well_p
          end subroutine

	  function cons( a, b) result( retval )
	    class(scheme_object), pointer, intent(in) :: a
	    class(scheme_object), pointer, intent(in) :: b
	    type(scheme_pair), pointer :: retval
	    !the_cars(free)%contents => a ! allocate? structure-copying?
	    allocate( the_cars(free)%contents, source=a )
	    !the_cdrs(free)%contents => b ! allocate? structure-copying?
	    allocate( the_cdrs(free)%contents, source=b )
	    allocate( retval )
	    !    allocate( integer :: retval%value )
	    retval%value = free
	    free = free + 1
	    !print *, "garbage collection not implemented yet"
	  end function cons

	  function ll_cons( a, b) result( retval )
	    class(scheme_object), pointer, intent(in) :: a
	    class(scheme_object), pointer, intent(in) :: b
	    type(scheme_pair), pointer :: retval
	    !the_cars(free)%contents => a ! allocate? structure-copying?
	    allocate( the_cars(free)%contents, source=a )
	    !the_cdrs(free)%contents => b ! allocate? structure-copying?
	    allocate( the_cdrs(free)%contents, source=b )
	    allocate( retval )
	    !    allocate( integer :: retval%value )
	    retval%value = free
	    free = free + 1
	    !print *, "garbage collection not implemented yet"
	  end function ll_cons

	  function packaged_cons( argl, env ) result( retval )
	    class(scheme_object), pointer :: argl
	    class(scheme_object), pointer :: env
	    class(scheme_object), pointer :: retval
	    retval => cons( car(argl), car(cdr(argl)) )
	  end function packaged_cons

	  function car( pair ) result( retval )
	    class(scheme_object), intent(in) :: pair
	    class(scheme_object), pointer :: retval
	    select type (pair)
	    class is (scheme_pair)
	       if (.not. associated(the_cars(pair%value)%contents)) then
		  write (error_unit, fmt='(a,i0)') "error:car:disassociated pointer: address=", pair%value
                  write (error_unit, '(a,i0)') "free=", free
		  error stop "disassociated pointer"
	       end if
	       retval => the_cars(pair%value)%contents
            class is (scheme_object)
	       write (error_unit,fmt='(a,a,a,a)', advance='no') new_line('a'), "argument is: ", pair, ":  "
	       call pair%debug_display()
               write (error_unit, '(a,i0)') "free=", free
	       error stop "car: argument is not a pair"
	    class default
	       write (error_unit,fmt='(a,a)', advance='no') new_line('a'), "cdr: not even scheme object, argument is: "
	       call pair%debug_display()
               write (error_unit, '(a,i0)') "free=", free
	       error stop "car: argument is not a pair"
	    end select
	    !    select type( temp => pair%value )
	    !    type is (integer)
	    !    class default
	    !       error stop "wrong pair contents"
	    !    end select
	  end function car

	  function packaged_car( argl, env) result( retval )
	    class(scheme_object), pointer :: argl
	    class(scheme_object), pointer :: env
	    class(scheme_object), pointer :: retval
	    retval => car( car(argl) )
	  end function packaged_car


	  function cdr( pair ) result( retval )
	    class(scheme_object), intent(in) :: pair
	    class(scheme_object), pointer :: retval
	    select type (pair)
	    class is (scheme_pair)
	       if (.not. associated(the_cdrs(pair%value)%contents)) then
		  write (error_unit, fmt='(a,i0)') "error:cdr:disassociated pointer: address=", pair%value
                  write (error_unit, '(a,i0)') "free=", free
		  error stop "disassociated pointer"
	       end if
	       retval => the_cdrs(pair%value)%contents
            class is (scheme_object)
               write (error_unit,fmt='(a,a,dt)', advance='no') new_line('a'), "argument is: ", pair
               call pair%debug_display()
               write (error_unit, '(a,i0)') "free=", free
               error stop "cdr given not a pair"
	    class default
	       write (error_unit,fmt='(a,a)', advance='no') new_line('a'), "argument is: "
	       call pair%debug_display()
               write (error_unit, '(a,i0)') "free=", free
	       error stop "cdr: argument is not a scheme_object"
	    end select
	    !   select type( temp => pair%value )
	    !   type is (integer)
	    !      retval => the_cdrs(temp)%contents
	    !   class default
	    !      error stop "wrong pair contents"
	    !   end select
	  end function cdr

	  function packaged_cdr( argl, env) result( retval )
	    class(scheme_object), pointer :: argl
	    class(scheme_object), pointer :: env
	    class(scheme_object), pointer :: retval
	       retval => cdr( car(argl) )
	  end function packaged_cdr

!	  function packaged_cadr( argl, env) result( retval )
!	    class(scheme_object), pointer :: argl
!	    class(scheme_object), pointer :: env
!	    class(scheme_object), pointer :: retval
!	       retval => car(cdr( car(argl) ))
!	  end function packaged_cadr

	  function packaged_null_p( argl, env) result( retval )
	    class(scheme_object), pointer :: argl
	    class(scheme_object), pointer :: env
	    class(scheme_object), pointer :: retval
	       !retval => car(cdr( car(argl) ))
	    select type( tmp => car(argl) )
	    class is (scheme_empty_list)
		retval => the_true
	    class default
		retval => the_false
	    end select
	  end function packaged_null_p

	  function packaged_not( argl, env) result( retval )
	    class(scheme_object), pointer :: argl
	    class(scheme_object), pointer :: env
	    class(scheme_object), pointer :: retval
	       !retval => car(cdr( car(argl) ))
	    select type( tmp => car(argl) )
	    class is (scheme_boolean)
		if (tmp%value .eqv. .false.) then
		    retval => the_true
		else
		    retval => the_false
		end if
	    class default
		retval => the_false
	    end select
	  end function packaged_not



	  function packaged_pair_p( argl, env) result( retval )
	    class(scheme_object), pointer :: argl
	    class(scheme_object), pointer :: env
	    class(scheme_object), pointer :: retval
	       !retval => car(cdr( car(argl) ))
	    select type( tmp => car(argl) )
	    class is (scheme_pair)
		retval => the_true
	    class default
		retval => the_false
	    end select
	  end function packaged_pair_p



	  function packaged_newline( argl, env) result( retval )
	    class(scheme_object), pointer :: argl
	    class(scheme_object), pointer :: env
	    class(scheme_object), pointer :: retval
	    retval => make_symbol( "ok" )
	    print *,""
	  end function packaged_newline

  !(define (assoc key records)
  !  (cond ((null? records) false)
  !        ((equal? key (caar records)) (car records))
  !        (else (assoc key (cdr records)))))
  !       recursive function packaged_assoc( argl, env) result( retval )
  !         class(scheme_object), pointer :: argl
  !         class(scheme_object), pointer :: env
  !         class(scheme_object), pointer :: retval
  !          select type( records => car(cdr( argl )))
  !          class is (scheme_empty_list)
  !              retval => the_false
  !          class is (scheme_pair)
  !              if ( car(argl) == car( car( records )) ) then
  !                  retval => car( records )
  !              else
  !                 retval => packaged_assoc( cons( ))
  !          cla
  !
  !
  !       end function packaged_assoc

	  function packaged_list( argl, env) result( retval )
	    class(scheme_object), pointer :: argl
	    class(scheme_object), pointer :: env
	    class(scheme_object), pointer :: retval
	    retval => argl
	  end function packaged_list

	  function packaged_symbol_p( argl, env) result( retval )
	    class(scheme_object), pointer :: argl
	    class(scheme_object), pointer :: env
	    class(scheme_object), pointer :: retval
	    select type( tmp => car(argl) )
	    class is (scheme_symbol)
		retval => the_true
	    class default
		retval => the_false
	    end select
	  end function packaged_symbol_p

	  function packaged_number_p( argl, env) result( retval )
	    class(scheme_object), pointer :: argl
	    class(scheme_object), pointer :: env
	    class(scheme_object), pointer :: retval
	    select type( tmp => car(argl) )
	    class is (scheme_number)
		retval => the_true
	    class default
		retval => the_false
	    end select
	  end function packaged_number_p

	  function packaged_pretty( argl, env) result( retval )
	    class(scheme_object), pointer :: argl
	    class(scheme_object), pointer :: env
	    class(scheme_object), pointer :: retval
	    retval => car(argl) ! not impelemented
	  end function packaged_pretty


	  function packaged_string_p( argl, env) result( retval )
	    class(scheme_object), pointer :: argl
	    class(scheme_object), pointer :: env
	    class(scheme_object), pointer :: retval
	    select type( tmp => car(argl) )
	    class is (scheme_string)
		retval => the_true
	    class default
		retval => the_false
	    end select
	  end function packaged_string_p


	  function packaged_less( argl, env) result( retval )
	    class(scheme_object), pointer :: argl
	    class(scheme_object), pointer :: env
	    class(scheme_object), pointer :: retval
	    select type( arg1 => car(argl) )
	    class is (scheme_number)
	      select type (arg2 => car(cdr(argl)))
	      class is (scheme_number)
		 if (arg1%value < arg2%value) then
		    retval => the_true
		 else
		    retval => the_false
		 end if
	      class default
		 error stop "less (<) only works for numbers. Second argument not a number"
	      end select
	    class default
		error stop "less (<) only works for numbers. First argument not a number"
	    end select
	  end function packaged_less

	  function packaged_more( argl, env) result( retval )
	    class(scheme_object), pointer :: argl
	    class(scheme_object), pointer :: env
	    class(scheme_object), pointer :: retval
	    select type( arg1 => car(argl) )
	    class is (scheme_number)
	      select type (arg2 => car(cdr(argl)))
	      class is (scheme_number)
		 if (arg1%value > arg2%value) then
		    retval => the_true
		 else
		    retval => the_false
		 end if
	      class default
		 error stop "less (<) only works for numbers. Second argument not a number"
	      end select
	    class default
		error stop "less (<) only works for numbers. First argument not a number"
	    end select
	  end function packaged_more

	  function packaged_notimplemented(argl, env ) result( retval )
	    class(scheme_object), pointer :: argl
	    class(scheme_object), pointer :: env
	    class(scheme_object), pointer :: retval
	    error stop "Not implemented function"
	  end function packaged_notimplemented

	  integer function run_garbage_collector( oldfree ) result(retval)
	    integer :: dstat
	    character(:), allocatable :: derr
	    integer :: oldfree
	    class(scheme_object), pointer, save :: root => null()
	    type(scheme_pointer), dimension(memory_size) :: new_cars
	    type(scheme_pointer), dimension(memory_size) :: new_cdrs
	    type(scheme_broken_heart), target :: the_broken_heart
	    type(scheme_forwarding_address), pointer :: &
		 new_forwarding_address_holder  ! this place may be wrong. m.b. pointer?
	    integer :: newfree
	    integer :: scan
	    newfree = 1
	    scan = 1
	    if (.not.(newfree == 1)) then
	       write(*,fmt='(a,a,i0)') new_line(''), "error:gc:free=", newfree
	       error stop "assertion failed"
	    end if

	    write (*,fmt='(a,a)', advance='no') new_line(''), "gc:debug:exp="; call exp%debug_display()
	    write (*,fmt='(a,a)', advance='no') new_line(''), "gc:debug:env="; call env%debug_display()
	    write (*,fmt='(a,a)', advance='no') new_line(''), "gc:debug:val="; call val%debug_display()
	    write (*,fmt='(a,a)', advance='no') new_line(''), "gc:debug:proc="; call proc%debug_display()
	    write (*,fmt='(a,a)', advance='no') new_line(''), "gc:debug:argl="; call argl%debug_display()
	    write (*,fmt='(a,a)', advance='no') new_line(''), "gc:debug:unev="; call unev%debug_display()
	    write (*,fmt='(a,a)', advance='no') new_line(''), "gc:debug:reg_continue="; call reg_continue%debug_display()
	    if (.not.(newfree == 1)) then
	       write(*,fmt='(a,a,i0)') new_line(''), "error:gc:free=", newfree
	       error stop "assertion failed"
	    end if


	    root => cons(  exp, &
		    cons(  env, &
		    cons(  val, &
		    cons( proc, &
		    cons( argl, &
		    cons( unev, &
		    cons( the_global_environment, &
		    cons( the_stack, &
		    cons( reg_continue, the_null))))))))) ! do we even need "continue"?
	    if (.not.(newfree == 1)) then
	       write(*,fmt='(a,a,i0)') new_line(''), "error:gc:free=", newfree
	       error stop "assertion failed"
	    end if

	    allocate( new_cars(newfree)%contents, source=car(root))
	    allocate( new_cdrs(newfree)%contents, source=cdr(root))

	    if (.not.(newfree == 1)) then
	       write(*,fmt='(a,a,i0)') new_line(''), "error:gc:free=", newfree
	       error stop "assertion failed"
	    end if

	    select type (root)
	    class is (scheme_pair)
	       allocate( the_cars(root%value)%contents, source=the_broken_heart )
	       allocate(new_forwarding_address_holder) ! if it deallocates, I'm wrong
	       new_forwarding_address_holder%moved_to = newfree
	       the_cdrs(root%value)%contents => new_forwarding_address_holder
	       root%value = newfree ! in the new memory
	    class default
	       error stop "run_garbage_collector: root not a pair."
	    end select
	    newfree = newfree + 1
	    scanning: do
	       if ( scan >= newfree) exit scanning
	       ! move car
	       select type (scan_car => new_cars(scan)%contents)
	       class is (scheme_pair) ! update the pair
		  select type (scan_car_pointee => the_cars(scan_car%value)%contents)
		  class is (scheme_broken_heart) ! actualize the pointer
		     select type (new_address => the_cdrs(scan_car%value)%contents)
		     class is (scheme_forwarding_address)
			scan_car%value = new_address%moved_to
		     class default
			error stop "gc: broken heart with no address"
		     end select
		  class default ! not broken heart, copy contents
		     ! m.b. transfer? copy? =?
		     !new_cars(free)%contents => scan_car_pointee
		     allocate( new_cars(newfree)%contents, &
		       source=the_cars(scan_car%value)%contents)
		     deallocate( the_cars(scan_car%value)%contents )

		     ! m.b. transfer? copy? =?
		     !new_cdrs(free)%contents => the_cdrs(scan_car%value)%contents
		     allocate( new_cdrs(newfree)%contents, &
			  source=the_cdrs(scan_car%value)%contents)
		     deallocate( the_cdrs(scan_car%value)%contents )

		     !the_cars(scan_car%value)%contents => the_broken_heart
		     allocate( the_cars(scan_car%value)%contents, source=the_broken_heart)
		     allocate(new_forwarding_address_holder) ! if it deallocates, I'm wrong
		     new_forwarding_address_holder%moved_to = newfree
		     the_cdrs(scan_car%value)%contents => new_forwarding_address_holder
		     ! record where to moved
		     scan_car%value = newfree
		     newfree = newfree + 1
		  end select
	       class default
		  ! no need to actualize the pointer for a non-pair
	       end select
	       ! move cdr
	       select type (scan_cdr => new_cdrs(scan)%contents)
	       class is (scheme_pair) ! update the pair
		  select type (scan_cdr_pointee => the_cars(scan_cdr%value)%contents)
		  class is (scheme_broken_heart) ! actualize the pointer
		     select type (new_address => the_cdrs(scan_cdr%value)%contents)
		     class is (scheme_forwarding_address)
			scan_cdr%value = new_address%moved_to
		     class default
			error stop "gc: broken heart with no address"
		     end select
		  class default ! not broken heart, copy contents
		     ! m.b. transfer? copy? =?
		     !new_cars(free)%contents => scan_car_pointee
		     allocate( new_cars(newfree)%contents, source=the_cars(scan_cdr%value)%contents)
		     deallocate( the_cars(scan_cdr%value)%contents )
		     ! m.b. transfer? copy? =?
		     !new_cdrs(free)%contents => the_cdrs(scan_car%value)%contents
		     allocate( new_cdrs(newfree)%contents, source=the_cdrs(scan_cdr%value)%contents)
		     deallocate( the_cdrs(scan_cdr%value)%contents )

		     !the_cars(scan_cdr%value)%contents => the_broken_heart
		     allocate( the_cars(scan_cdr%value)%contents, source=the_broken_heart )
		     allocate(new_forwarding_address_holder) ! if it deallocates, I'm wrong
		     new_forwarding_address_holder%moved_to = newfree
		     the_cdrs(scan_cdr%value)%contents => new_forwarding_address_holder
		     ! record where to moved
		     scan_cdr%value = newfree
		     newfree = newfree + 1
		  end select
	       class default
		  ! no need to actualize the pointer for a non-pair
	       end select
	       scan = scan + 1
	    end do scanning
	    write (*, fmt='(a,a,i0)') new_line(''), "Collected garbage. newfree=", newfree

	    scan = 1
	    deallocation: do
	       if ( scan == (oldfree-1)) exit deallocation
	       if (associated(the_cars(scan)%contents)) then
		  !deallocate(the_cars(scan)%contents, stat=dstat, errmsg=derr)
		  deallocate( the_cars(scan)%contents )
	       end if
	       if (associated(the_cdrs(scan)%contents)) then
		  !deallocate(the_cdrs(scan)%contents, stat=dstat, errmsg=derr)
		  deallocate( the_cdrs(scan)%contents )
	       end if
	       scan = scan + 1
	    end do deallocation

	    the_cars = new_cars
	    the_cdrs = new_cdrs
	    ! root => cons(  exp, &
	    !         cons(  env, &
	    !         cons(  val, &
	    !         cons( proc, &
	    !         cons( argl, &
	    !         cons( unev, &
	    !         cons( the_global_environment, &
	    !         cons( the_stack, &
	    !         cons( reg_continue, the_null))))))))) ! do we even need "continue"?

	    exp =>  car(root)
	    env =>  car(cdr(root))
	    val =>  car(cdr(cdr(root)))
	    proc => car(cdr(cdr(cdr(root))))
	    argl => car(cdr(cdr(cdr(cdr(root)))))
	    unev => car(cdr(cdr(cdr(cdr(cdr(root))))))
	    the_global_environment => &
		    car(cdr(cdr(cdr(cdr(cdr(cdr(root)))))))
	    the_stack => &
		    car(cdr(cdr(cdr(cdr(cdr(cdr(cdr(root))))))))
	    ! write (*,fmt='(a,a)', advance='no') new_line(''), "gc:debug:exp="; call exp%debug_display()
	    ! write (*,fmt='(a,a)', advance='no') new_line(''), "gc:debug:env="; call env%debug_display()
	    ! write (*,fmt='(a,a)', advance='no') new_line(''), "gc:debug:val="; call val%debug_display()
	    ! write (*,fmt='(a,a)', advance='no') new_line(''), "gc:debug:proc="; call proc%debug_display()
	    ! write (*,fmt='(a,a)', advance='no') new_line(''), "gc:debug:argl="; call argl%debug_display()
	    ! write (*,fmt='(a,a)', advance='no') new_line(''), "gc:debug:unev="; call unev%debug_display()

	    select type (tmp2 => car(cdr(cdr(cdr(cdr(cdr(cdr(cdr(cdr(root))))))))))
	    class is (scheme_symbol)
	       reg_continue => tmp2
	    class is (scheme_object)
	       write (*,fmt='(a,a)', advance='no') new_line('a'), "argument is: "
	       call tmp2%debug_display()
	       error stop "garbage collection failed"
	    class default
	       error stop "garbage collection failed even more"
	    end select
	    !write (*,fmt='(a,a)', advance='no') new_line(''), "gc:debug:reg_continue="; call reg_continue%debug_display()
	    retval = newfree
	  end function run_garbage_collector

	  function packaged_blurb( argl, env ) result( retval )
	    class(scheme_object), pointer :: argl
	    class(scheme_object), pointer :: env
	    class(scheme_object), pointer :: retval
	    retval => the_null
	    write (*,*) "packaged_blurb test output"
	  end function packaged_blurb

	  function ll_lookup_variable_value( var, env ) result( retval )
	    type(scheme_symbol), pointer, intent(in) :: var
	    class(scheme_object), pointer, intent(in) :: env
	    class(scheme_object), pointer :: retval
	    select type( env )
	    class is ( scheme_empty_list )
	       retval => cons( make_symbol("unbound"), var )
	    class is (scheme_pair)
	       retval => frame_loop( car(car(env)), cdr(car(env)))
	    class default
	       write (*, "(a)", advance='no') "error:irritant:var="
	       call var%debug_display()
	       write (*, "(a)", advance='no') "irritant:env="
	       !call env%debug_display()
	       write (*,*) ""
	       error stop "ll_lookup_variable_value: wrong object in an env"
	    end select
	  contains

	    recursive function frame_loop( vars, vals ) result( retval )
	      class(scheme_object), pointer, intent(in) :: vars
	      class(scheme_object), pointer, intent(in) :: vals
	      class(scheme_object), pointer :: retval
	      select type (vars)
	      type is (scheme_empty_list) ! frame empty
		 retval => ll_lookup_variable_value( var, cdr(env) )
	      class is (scheme_pair) ! frame is a list
		 select type ( name => car(vars) )
		 class is (scheme_symbol)
		    if ( name == var ) then
		       retval => cons( make_symbol("bound"), car(vals))
		    else
		       retval => frame_loop( cdr(vars), cdr(vals))
		    end if
		 class default
                    print *,  "ll_lookup_variable_value::frame_loop: variable name not a symbol"
                    print *, "free=", free
                    stop 0
		    !error stop
		 end select
	      class default ! frame is not a list
		 !error stop "ll_lookup_variable_value::frame_loop: vars is not a list"
		 print *,"ll_lookup_variable_value::frame_loop: vars is not a list,\n vars="
		 call vars%debug_display()
		 print *," vals= NOT IMPLEMENTED"
		 !call vals%debug_display()

		 error stop
		 stop 0
	      end select

	    end function frame_loop

	  end function ll_lookup_variable_value

	  recursive subroutine debug_display_pair( this )
	    class(scheme_pair), intent(in) :: this
	    !    class(scheme_object), pointer :: arg
	    !    associate ( temp => x%value )
	    !      select type (temp => this%value )
	    !      type is ( integer )
	    !print *,"("
	    write (output_unit, fmt='(1a)', advance='no') "("
	    !arg => the_cars(temp)%contents
	    call the_cars(this%value)%contents%debug_display()
	    !retval = lowLevelDisplay( arg )
	    !call arg%debug_display
	    !print *, " . "
	    write (output_unit, fmt='(1a)', advance='no') " . "
	    !arg => the_cdrs(temp)%contents
	    !call arg%debug_display
	    call the_cdrs(this%value)%contents%debug_display()
	    !retval = lowLevelDisplay( arg )
	    !print *, ")"
	    write (output_unit, fmt='(1a)', advance='no') ")"
	    !      class default
	    !         error stop "wrong pair contents"
	    !      end select
	    !    end associate
	  end subroutine debug_display_pair

	  subroutine debug_display_string( this )
	    class(scheme_string), intent(in):: this
	    !    select type (temp => this%value )
	    !      type is ( character(len=*) )
	    write (output_unit, fmt='(a,a,a)', advance='no') '"', this%value, '"'
	    !      end select
	  end subroutine debug_display_string

	  subroutine debug_display_boolean( this )
	    class(scheme_boolean), intent(in):: this
	    !    select type (temp => this%value )
	    !      type is ( character(len=*) )
	    character(len=:), allocatable :: marker
	    marker = 'fixme'
	    if ( this%value .eqv. .true.) then
	       marker = 't'
	    else if ( this%value .eqv. .false. ) then
	       marker = 'f'
	    else
	       error stop "Wrong logical contents"
	    end if
	    write (output_unit, fmt='(a,a)', advance='no') '#', marker
	    !      end select
	  end subroutine debug_display_boolean


	  subroutine debug_display_symbol( this )
	    class(scheme_symbol), intent(in) :: this
	    !    select type (temp => this%value )
	    !    type is ( character(len=*) )
	    write (output_unit, fmt='(a)', advance='no') this%value
	    !    class default
	    !       error stop "non-character symbol value"
	    !    end select
	  end subroutine debug_display_symbol
	  subroutine debug_display_number( this )
	    class(scheme_number), intent(in) :: this
	    !    select type (temp => this%value )
	    !    type is (integer)
	    write (output_unit, fmt='(i0)', advance='no') this%value
	    !    end select
	  end subroutine debug_display_number


	  subroutine debug_display_empty_list( this )
	    class(scheme_empty_list), intent(in) :: this
	    write (output_unit, fmt='(a)', advance='no') '()'
	  end subroutine debug_display_empty_list

	  function ll_read() result( parsed_expression )
	    use system_interface, only : read_until_eof
	    class(scheme_object), pointer :: parsed_expression
	    character(len=:), allocatable, target :: test_string
	    character(len=:), pointer     :: test_string_pointer

	    test_string =  read_until_eof()

	    test_string = remove_junk( test_string ) ! test_string should be a string
	!        print *, "ll_read: got ", test_string
	    test_string_pointer => test_string
	    parsed_expression => parse_sexp( test_string_pointer )
	  end function ll_read

	  function packaged_read( argl, env ) result(retval)
	    class(scheme_object), pointer :: argl
	    class(scheme_object), pointer :: env
	    class(scheme_object), pointer :: retval
	    retval => ll_read()
	  end function packaged_read

	  subroutine set_cdr_b( pair, v )
	    class(scheme_object), pointer :: pair
	    class(scheme_object), pointer :: v
	    select type( pair )
	    class is (scheme_pair)
		 the_cdrs(pair%value)%contents => v
	    class default
		 write (*,'(a)', advance='no') "error: set-cdr! first argument not a pair, but is "
		 call pair%debug_display()
                 stop 0
	    end select
	  end subroutine set_cdr_b

	  function packaged_set_cdr_b( argl, env ) result( retval )
	    class(scheme_object), pointer :: argl
	    class(scheme_object), pointer :: env
	    class(scheme_object), pointer :: retval
	    call set_cdr_b( car(argl), car(cdr(argl)))
	    retval => make_symbol( "ok" )
	  end function packaged_set_cdr_b

	  subroutine set_car_b( pair, v )
	    class(scheme_object), pointer :: pair
	    class(scheme_object), pointer :: v
	    select type( pair )
	    class is (scheme_pair)
		 the_cars(pair%value)%contents => v
	    class default
		 write (error_unit,'(a)', advance='no') "error: set-car! first argument not a pair, but is "
		 call pair%debug_display()
                 stop 0
	    end select
	  end subroutine set_car_b

	  function packaged_set_car_b( argl, env ) result( retval )
	    class(scheme_object), pointer :: argl
	    class(scheme_object), pointer :: env
	    class(scheme_object), pointer :: retval
	    call set_car_b( car(argl), car(cdr(argl)))
	    retval => make_symbol( "ok" )
	  end function packaged_set_car_b


	  function ll_make_frame( vars, vals ) result( retval )
	    class(scheme_object), pointer, intent(in) :: vars
	    class(scheme_object), pointer, intent(in) :: vals
	    type(scheme_pair), pointer  :: retval
	    retval => cons( vars, vals )
	  end function ll_make_frame

	  function ll_list( arg ) result( retval )
	    class(scheme_object), pointer, intent(in) :: arg
	    type(scheme_pair), pointer  :: retval
	    retval => cons( arg, the_null )
	  end function ll_list


	  function ll_extend_environment( names, objects, base_env ) result( retval )
	    ! used to create an initial environment, as well as when running a
	    ! compound procedure
	    class(scheme_object), pointer, intent(in) :: names
	    class(scheme_object), pointer, intent(in) :: objects
	    class(scheme_object), pointer, intent(in) :: base_env
	    type(scheme_pair), pointer :: retval
	!    class(scheme_object), pointer :: intermediate_object
	    !intermediate_object => ll_make_frame(names,objects) ! why the hell do I need this?
	    !answer to myself one day later: you need to mark a as pointer, intent(in)!
	    !retval => cons( intermediate_object, base_env )
	    retval => cons( ll_make_frame(names,objects) , base_env )
	  end function ll_extend_environment

	  ! function packaged_ll_extend_environment( argl, env) result(retval)
	  !   class(scheme_object), pointer :: argl
	  !   class(scheme_object), pointer :: env
	  !   class(scheme_object), pointer :: retval
	  !   retval => ll_extend_environment( car(argl), car(car(argl)), car(car(car(argl))) )
	  ! end function packaged_ll_extend_environment

	  function packaged_exit( argl, env ) result(retval)
	    class(scheme_object), pointer :: argl
	    class(scheme_object), pointer :: env
	    class(scheme_object), pointer :: retval
	    stop 0
	  end function packaged_exit

	  function packaged_error( argl, env ) result(retval)
	    class(scheme_object), pointer :: argl
	    class(scheme_object), pointer :: env
	    class(scheme_object), pointer :: retval
            write (error_unit,*) ""
            write (error_unit,'(a)', advance='no') "Error. Irritants: "
            call argl%debug_display()
            write (*,*) ""
	    error stop "Error called."
	  end function packaged_error


	  function packaged_display( argl, env ) result(retval)
	    class(scheme_object), pointer :: argl
	    class(scheme_object), pointer :: env
	    class(scheme_object), pointer :: retval
	    retval => the_null
	    select type (tmp => car(argl))
	    class is (scheme_object)
	       call tmp%debug_display()
	    class default
	       error stop "Critical error. This should never get executed."
	    end select
	  end function packaged_display

	  function packaged_show( argl, env ) result(retval)
	    class(scheme_object), pointer :: argl
	    class(scheme_object), pointer :: env
	    class(scheme_object), pointer :: retval
	    retval => the_null
	    select type (tmp => car(cdr(argl))) ! this is the only difference with display
	    class is (scheme_object)
	       call tmp%debug_display()
	    class default
	       error stop "Critical error. This should never get executed."
	    end select
	  end function packaged_show

	  function packaged_division( argl, env ) result(retval)
	    class(scheme_object), pointer :: argl
	    class(scheme_object), pointer :: env
	    class(scheme_object), pointer :: retval
	    select type (t1 => car(argl))
	    class is (scheme_number)
	       select type (t2 => car(cdr(argl)))
	       class is (scheme_number)
		  allocate( scheme_number :: retval )
		  select type (retval)
		  class is (scheme_number)
		     retval%value = t1%value / t2%value
		  end select
	       class default
		  error stop "packaged_division (/)): second argument not a number"
	       end select
	    class default
	       error stop "packaged_division (/): first argument not a number"
	    end select
	  end function packaged_division

	  function packaged_remainder( argl, env ) result(retval)
	    class(scheme_object), pointer :: argl
	    class(scheme_object), pointer :: env
	    class(scheme_object), pointer :: retval
	    select type (t1 => car(argl))
	    class is (scheme_number)
	       select type (t2 => car(cdr(argl)))
	       class is (scheme_number)
		  allocate( scheme_number :: retval )
		  select type (retval)
		  class is (scheme_number)
		     retval%value = mod( t1%value, t2%value )
		  end select
	       class default
		  error stop "packaged_remainder: second argument not a number"
	       end select
	    class default
	       error stop "packaged_remainder: first argument not a number"
	    end select
	  end function packaged_remainder


	  function packaged_mul( argl, env ) result(retval)
	    class(scheme_object), pointer :: argl
	    class(scheme_object), pointer :: env
	    class(scheme_object), pointer :: retval
	    select type (t1 => car(argl))
	    class is (scheme_number)
	       select type (t2 => car(cdr(argl)))
	       class is (scheme_number)
		  allocate( scheme_number :: retval )
		  select type (retval)
		  class is (scheme_number)
		     retval%value = t1%value * t2%value
		  end select
	       class default
		  error stop "mul: second argument not a number"
	       end select
	    class default
	       error stop "mul: first argument not a number"
	    end select
	  end function packaged_mul

	  function packaged_plus( argl, env ) result(retval)
	    class(scheme_object), pointer :: argl
	    class(scheme_object), pointer :: env
	    class(scheme_object), pointer :: retval
	    select type (t1 => car(argl))
	    class is (scheme_number)
	       select type (t2 => car(cdr(argl)))
	       class is (scheme_number)
		  allocate( scheme_number :: retval )
		  select type (retval)
		  class is (scheme_number)
		     retval%value = t1%value + t2%value
		  end select
	       class default
		  error stop "plus (+): second argument not a number"
	       end select
	    class default
	       error stop "plus (+): first argument not a number"
	    end select
	  end function packaged_plus

	  function packaged_minus( argl, env ) result(retval)
	    class(scheme_object), pointer :: argl
	    class(scheme_object), pointer :: env
	    class(scheme_object), pointer :: retval
	    select type (t1 => car(argl))
	    class is (scheme_number)
	       select type (t2 => car(cdr(argl)))
	       class is (scheme_number)
		  allocate( scheme_number :: retval )
		  select type (retval)
		  class is (scheme_number)
		     retval%value = t1%value - t2%value
		  end select
	       class default
		  error stop "minus: second argument not a number"
	       end select
	    class default
	       error stop "minus: first argument not a number"
	    end select
	  end function packaged_minus

	  function packaged_equality( argl, env ) result(retval)
	    class(scheme_object), pointer :: argl
	    class(scheme_object), pointer :: env
	    class(scheme_object), pointer :: retval
	    select type (t1 => car(argl))
	    class is (scheme_number)
	       select type (t2 => car(cdr(argl)))
	       class is (scheme_number)
		     if ( t1%value == t2%value)  then
			!allocate( retval, source=the_true)
                        retval => the_true
		     else
			!allocate( retval, source=the_false)
                        retval => the_false
		     end if
	       class default
		  error stop "=: second argument not a number"
	       end select
	    class default
	       error stop "=: first argument not a number"
	    end select
	  end function packaged_equality

	  function packaged_eq_p( argl, env ) result(retval)
	    class(scheme_object), pointer :: argl
	    class(scheme_object), pointer :: env
	    class(scheme_object), pointer :: retval
	    select type (t1 => car(argl))
	    class is (scheme_symbol)
	       select type (t2 => car(cdr(argl)))
	       class is (scheme_symbol)
		     if ( t1%value == t2%value)  then
			allocate( retval, source=the_true)
		     else
			allocate( retval, source=the_false)
		     end if
	       class default
		  retval => the_false ! allocate?
	       end select
	    class is (scheme_pair)
	       select type(t2 => car(cdr(argl)))
	       class is (scheme_pair)
		     if ( t1%value == t2%value)  then
			allocate( retval, source=the_true)
		     else
			allocate( retval, source=the_false)
		     end if
	       class default
		  retval => the_false ! allocate?
	       end select
            class is (scheme_empty_list)
	       select type(t2 => car(cdr(argl)))
	       class is (scheme_empty_list)
			allocate( retval, source=the_true)
	       class default
		  retval => the_false ! allocate?
	       end select
	    class is (scheme_boolean)
	       select type(t2 => car(cdr(argl)))
	       class is (scheme_boolean)
		     if ( t1%value .eqv. t2%value)  then
			allocate( retval, source=the_true)
		     else
			allocate( retval, source=the_false)
		     end if
	       class default
		  retval => the_false ! allocate?
	       end select
	    class default
	       retval => the_false ! allocate?
	    end select
	  end function packaged_eq_p


	  function make_primitive_procedure_object( proc1, name ) result( retval )
	    character(len=*) :: name
	    procedure(packageable_procedure), pointer, intent(in) :: proc1
	    type(scheme_primitive_procedure), pointer :: retval
	    allocate( retval )
	    allocate( retval%name, source=name )
	    retval%proc_pointer => proc1
	  end function make_primitive_procedure_object


	  function ll_setup_global_environment() result(retval)
	    character(len=:), allocatable, target :: function_name
	    procedure(packageable_procedure), pointer :: proc
	    type(scheme_symbol), pointer :: symbol_primitive
	    type(scheme_pair), pointer :: list_primitive_names
	    type(scheme_pair), pointer :: list_primitive_objects
	    class(scheme_object), pointer :: retval
	    allocate( symbol_primitive )
	    allocate( symbol_primitive%value, source="primitive" )

	    ! cons
	    allocate( function_name, source="cons")
	    proc => packaged_cons
	    list_primitive_names => cons( make_symbol(function_name), the_null )
	    list_primitive_objects => cons( cons( symbol_primitive, &
		 make_primitive_procedure_object( proc, "packaged_cons" ) ), the_null)
	    ! car
	    function_name = "car"    ! automatic reallocation
	    proc => packaged_car
	    list_primitive_names => cons( make_symbol(function_name), &
		 list_primitive_names)
	    list_primitive_objects => cons( cons( symbol_primitive, &
		 make_primitive_procedure_object( proc, "packaged_car" ) ), &
		 list_primitive_objects)
	    ! cdr
	    function_name="cdr" ! automatic reallocation?
	    proc => packaged_cdr
	    list_primitive_names => cons( make_symbol(function_name), &
		 list_primitive_names)
	    list_primitive_objects => cons( cons( symbol_primitive, &
		 make_primitive_procedure_object( proc, "packaged_cdr" ) ), &
		 list_primitive_objects)
	    ! ersatz-display
	    function_name = "display"
	    proc => packaged_display
	    list_primitive_names => cons( make_symbol(function_name), &
		 list_primitive_names)
	    list_primitive_objects => cons( cons( symbol_primitive, &
		 make_primitive_procedure_object( proc, "packaged_blurb" ) ), &
		 list_primitive_objects)
	    ! blurb
	    function_name = "blurb" ! automatic reallocation?
	    proc => packaged_blurb
	    list_primitive_names => cons( make_symbol(function_name), &
		 list_primitive_names)
	    list_primitive_objects => cons( cons( symbol_primitive, &
		 make_primitive_procedure_object( proc, "packaged_blurb" ) ), &
		 list_primitive_objects)
	    ! exit
	    function_name = "exit" ! automatic reallocation?
	    proc => packaged_exit
	    list_primitive_names => cons( make_symbol(function_name), &
		 list_primitive_names)
	    list_primitive_objects => cons( cons( symbol_primitive, &
		 make_primitive_procedure_object( proc, "packaged_exit" ) ), &
		 list_primitive_objects)
	    ! mul
	    function_name = "*" ! automatic reallocation?
	    proc => packaged_mul
	    list_primitive_names => cons( make_symbol(function_name), &
		 list_primitive_names)
	    list_primitive_objects => cons( cons( symbol_primitive, &
		 make_primitive_procedure_object( proc, "packaged_mul" ) ), &
		 list_primitive_objects)

	    ! minus
	    function_name = "-" ! automatic reallocation?
	    proc => packaged_minus
	    list_primitive_names => cons( make_symbol(function_name), &
		 list_primitive_names)
	    list_primitive_objects => cons( cons( symbol_primitive, &
		 make_primitive_procedure_object( proc, "packaged_minus" ) ), &
		 list_primitive_objects)

	    ! plus
	    function_name = "+" ! automatic reallocation?
	    proc => packaged_plus
	    list_primitive_names => cons( make_symbol(function_name), &
		 list_primitive_names)
	    list_primitive_objects => cons( cons( symbol_primitive, &
		 make_primitive_procedure_object( proc, "packaged_plus" ) ), &
		 list_primitive_objects)

	    ! division
	    function_name = "/" ! automatic reallocation?
	    proc => packaged_division
	    list_primitive_names => cons( make_symbol(function_name), &
		 list_primitive_names)
	    list_primitive_objects => cons( cons( symbol_primitive, &
		 make_primitive_procedure_object( proc, "packaged_division" ) ), &
		 list_primitive_objects)

	    ! remainder
	    function_name = "remainder" ! automatic reallocation?
	    proc => packaged_remainder
	    list_primitive_names => cons( make_symbol(function_name), &
		 list_primitive_names)
	    list_primitive_objects => cons( cons( symbol_primitive, &
		 make_primitive_procedure_object( proc, "packaged_remainder" ) ), &
		 list_primitive_objects)

	    ! random-integer
	    function_name = "random-integer" ! automatic reallocation?
	    proc => packaged_notimplemented
	    list_primitive_names => cons( make_symbol(function_name), &
		 list_primitive_names)
	    list_primitive_objects => cons( cons( symbol_primitive, &
		 make_primitive_procedure_object( proc, "packaged_notimplemented" ) ), &
		 list_primitive_objects)

	    ! error
	    function_name = "error" ! automatic reallocation?
	    proc => packaged_error
	    list_primitive_names => cons( make_symbol(function_name), &
		 list_primitive_names)
	    list_primitive_objects => cons( cons( symbol_primitive, &
		 make_primitive_procedure_object( proc, "packaged_error" ) ), &
		 list_primitive_objects)

	    ! pair?
	    function_name = "pair?" ! automatic reallocation?
	    proc => packaged_pair_p
	    list_primitive_names => cons( make_symbol(function_name), &
		 list_primitive_names)
	    list_primitive_objects => cons( cons( symbol_primitive, &
		 make_primitive_procedure_object( proc, "packaged_pair_p" ) ), &
		 list_primitive_objects)

	    ! eq?
	    function_name = "eq?" ! automatic reallocation?
	    proc => packaged_eq_p
	    list_primitive_names => cons( make_symbol(function_name), &
		 list_primitive_names)
	    list_primitive_objects => cons( cons( symbol_primitive, &
		 make_primitive_procedure_object( proc, "packaged_eq_p" ) ), &
		 list_primitive_objects)

	    ! not
	    function_name = "not" ! automatic reallocation?
	    proc => packaged_not
	    list_primitive_names => cons( make_symbol(function_name), &
		 list_primitive_names)
	    list_primitive_objects => cons( cons( symbol_primitive, &
		 make_primitive_procedure_object( proc, "packaged_not" ) ), &
		 list_primitive_objects)


	    ! equality
	    function_name = "=" ! automatic reallocation?
	    proc => packaged_equality
	    list_primitive_names => cons( make_symbol(function_name), &
		 list_primitive_names)
	    list_primitive_objects => cons( cons( symbol_primitive, &
		 make_primitive_procedure_object( proc, "packaged_equality" ) ), &
		 list_primitive_objects)

!	    function_name = "cadr" ! automatic reallocation?
!	    proc => packaged_cadr
!	    list_primitive_names => cons( make_symbol(function_name), &
!		 list_primitive_names)
!	    list_primitive_objects => cons( cons( symbol_primitive, &
!		 make_primitive_procedure_object( proc, "packaged_cadr" ) ), &
!		 list_primitive_objects)

	    function_name = "null?" ! automatic reallocation?
	    proc => packaged_null_p
	    list_primitive_names => cons( make_symbol(function_name), &
		 list_primitive_names)
	    list_primitive_objects => cons( cons( symbol_primitive, &
		 make_primitive_procedure_object( proc, "packaged_null_p" ) ), &
		 list_primitive_objects)


	    function_name = "newline" ! automatic reallocation?
	    proc => packaged_newline
	    list_primitive_names => cons( make_symbol(function_name), &
		 list_primitive_names)
	    list_primitive_objects => cons( cons( symbol_primitive, &
		 make_primitive_procedure_object( proc, "packaged_newline" ) ), &
		 list_primitive_objects)

	    function_name = "list" ! automatic reallocation?
	    proc => packaged_list
	    list_primitive_names => cons( make_symbol(function_name), &
		 list_primitive_names)
	    list_primitive_objects => cons( cons( symbol_primitive, &
		 make_primitive_procedure_object( proc, "packaged_list" ) ), &
		 list_primitive_objects)

	    function_name = "symbol?" ! automatic reallocation?
	    proc => packaged_symbol_p
	    list_primitive_names => cons( make_symbol(function_name), &
		 list_primitive_names)
	    list_primitive_objects => cons( cons( symbol_primitive, &
		 make_primitive_procedure_object( proc, "packaged_symbol_p" ) ), &
		 list_primitive_objects)

	    function_name = "<" ! automatic reallocation?
	    proc => packaged_less
	    list_primitive_names => cons( make_symbol(function_name), &
		 list_primitive_names)
	    list_primitive_objects => cons( cons( symbol_primitive, &
		 make_primitive_procedure_object( proc, "packaged_less" ) ), &
		 list_primitive_objects)

	    function_name = ">" ! automatic reallocation?
	    proc => packaged_more
	    list_primitive_names => cons( make_symbol(function_name), &
		 list_primitive_names)
	    list_primitive_objects => cons( cons( symbol_primitive, &
		 make_primitive_procedure_object( proc, "packaged_more" ) ), &
		 list_primitive_objects)


	    function_name = "current-second" ! automatic reallocation?
	    proc => packaged_notimplemented
	    list_primitive_names => cons( make_symbol(function_name), &
		 list_primitive_names)
	    list_primitive_objects => cons( cons( symbol_primitive, &
		 make_primitive_procedure_object( proc, "packaged_current_second" ) ), &
		 list_primitive_objects)

	    function_name = "string?" ! automatic reallocation?
	    proc => packaged_string_p
	    list_primitive_names => cons( make_symbol(function_name), &
		 list_primitive_names)
	    list_primitive_objects => cons( cons( symbol_primitive, &
		 make_primitive_procedure_object( proc, "packaged_string_p" ) ), &
		 list_primitive_objects)

	    function_name = "number?" ! automatic reallocation?
	    proc => packaged_number_p
	    list_primitive_names => cons( make_symbol(function_name), &
		 list_primitive_names)
	    list_primitive_objects => cons( cons( symbol_primitive, &
		 make_primitive_procedure_object( proc, "packaged_number_p" ) ), &
		 list_primitive_objects)

	    function_name = "pretty" ! automatic reallocation?
	    proc => packaged_pretty
	    list_primitive_names => cons( make_symbol(function_name), &
		 list_primitive_names)
	    list_primitive_objects => cons( cons( symbol_primitive, &
		 make_primitive_procedure_object( proc, "packaged_pretty_not_implemented_uses_identity" ) ), &
		 list_primitive_objects)

	    function_name = "show" ! automatic reallocation?
	    proc => packaged_show
	    list_primitive_names => cons( make_symbol(function_name), &
		 list_primitive_names)
	    list_primitive_objects => cons( cons( symbol_primitive, &
		 make_primitive_procedure_object( proc, "packaged_show" ) ), &
		 list_primitive_objects)

	    function_name = "read" ! automatic reallocation?
	    proc => packaged_read
	    list_primitive_names => cons( make_symbol(function_name), &
		 list_primitive_names)
	    list_primitive_objects => cons( cons( symbol_primitive, &
		 make_primitive_procedure_object( proc, "packaged_read" ) ), &
		 list_primitive_objects)

	    function_name = "set-cdr!" ! automatic reallocation?
	    proc => packaged_set_cdr_b
	    list_primitive_names => cons( make_symbol(function_name), &
		 list_primitive_names)
	    list_primitive_objects => cons( cons( symbol_primitive, &
		 make_primitive_procedure_object( proc, "packaged_set_cdr_b" ) ), &
		 list_primitive_objects)

	    function_name = "set-car!" ! automatic reallocation?
	    proc => packaged_set_car_b
	    list_primitive_names => cons( make_symbol(function_name), &
		 list_primitive_names)
	    list_primitive_objects => cons( cons( symbol_primitive, &
		 make_primitive_procedure_object( proc, "packaged_set_car_b" ) ), &
		 list_primitive_objects)

	    function_name = "apply-in-real-scheme" ! automatic reallocation?
	    proc => packaged_apply_in_real_scheme
	    list_primitive_names => cons( make_symbol(function_name), &
		 list_primitive_names)
	    list_primitive_objects => cons( cons( symbol_primitive, &
		 make_primitive_procedure_object( proc, "packaged_apply_in_real_scheme" ) ), &
		 list_primitive_objects)


	    ! extend initial_environment
	    ! env => cons( cons( list_primitive_names, list_primitive_objects ), &
	    !              the_null )
	    retval => ll_extend_environment( list_primitive_names, &
		 list_primitive_objects, the_null)
	  end function ll_setup_global_environment

	  !  character(len=:), allocatable, target :: test_string
	  !  character(len=:), pointer     :: test_string_pointer
	  !  logical :: useless_retval
	  !  allocate( the_null%value, source="empty list" )
	  !class(scheme_object), pointer :: test_object
	  !test_object => read_sexp()
	  ! 001 write (output_unit,'(a,i1)') "Hello, world, ", counter
	  !   allocate(scheme_string :: test_object) ! memory leak?
	  !   counter = counter + 1
	  !   nullify( test_object )
	  !   if (counter < 3) goto 001

	  !  test_string =  read_until_eof()
	  !  test_string = remove_junk( test_string ) ! test_string should be a string
	  !  test_string_pointer => test_string
	  !  parsed_expression => parse_sexp( test_string_pointer )
	  !  print *, parsed_expression
	  !useless_retval =  lowLevelDisplay( parsed_expression )
	  !parsed_expression => ll_read()
	  !call parsed_expression%debug_display()
	  !fake = c_exit(0)

	  logical function is_self_evaluating_p( arg ) result( retval )
	    class(scheme_object), pointer, intent(in) :: arg
	    select type (arg)
	    class is (scheme_string)
	       retval = .true.
	    class is (scheme_number)
	       retval = .true.
	    class is (scheme_boolean)
	       retval = .true.
	    class default
	       retval = .false.
	    end select
	  end function is_self_evaluating_p

	  logical function is_symbol_p( arg ) result( retval )
	    class(scheme_object), pointer, intent(in) :: arg
	    select type (arg)
	    class is (scheme_symbol)
	       retval = .true.
	    class default
	       retval = .false.
	    end select
	  end function is_symbol_p

	  logical function is_tagged_list_p( arg, tag ) result( retval )
	    class(scheme_object), pointer, intent(in) :: arg
	    class(scheme_symbol), pointer, intent(in) :: tag
	    select type (arg)
	    class is (scheme_pair)
	       select type (sym => car(arg))
	       class is (scheme_symbol)
		  if ( sym == tag ) then ! TODO: double check that this works
		     retval = .true.
		  end if
	       class default
		  retval = .false.
	       end select
	    class default
	       retval = .false.
	    end select
	  end function is_tagged_list_p

	  logical function is_quoted_p( exp ) result( retval )
	    class(scheme_object), pointer, intent(in) :: exp
	    character(:), allocatable :: tag
	    tag = "quote" ! what the hell am I doing?
	    retval = is_tagged_list_p( exp, make_symbol(tag) )
	  end function is_quoted_p

	  logical function is_assignment_p( exp ) result( retval )
	    class(scheme_object), pointer, intent(in) :: exp
	    character(:), allocatable :: tag
	    tag = "set!" ! what the hell am I doing?
	    retval = is_tagged_list_p( exp, make_symbol(tag) )
	  end function is_assignment_p

	  logical function is_definition_p( exp ) result( retval )
	    class(scheme_object), pointer, intent(in) :: exp
	    character(:), allocatable :: tag
	    tag = "define" ! what the hell am I doing?
	    retval = is_tagged_list_p( exp, make_symbol(tag) )
	  end function is_definition_p

	  logical function is_if_p( exp ) result( retval )
	    class(scheme_object), pointer, intent(in) :: exp
	    character(:), allocatable :: tag
	    tag = "if" ! what the hell am I doing?
	    retval = is_tagged_list_p( exp, make_symbol(tag) )
	  end function is_if_p

	  logical function is_lambda_p( exp ) result( retval )
	    class(scheme_object), pointer, intent(in) :: exp
	    character(:), allocatable :: tag
	    tag = "lambda" ! what the hell am I doing?
	    retval = is_tagged_list_p( exp, make_symbol(tag) )
	  end function is_lambda_p

	  logical function is_begin_p( exp ) result( retval )
	    class(scheme_object), pointer, intent(in) :: exp
	    character(:), allocatable :: tag
	    tag = "begin" ! what the hell am I doing?
	    retval = is_tagged_list_p( exp, make_symbol(tag) )
	  end function is_begin_p

	  logical function is_let_p( exp ) result( retval )
	    class(scheme_object), pointer, intent(in) :: exp
	    character(:), allocatable :: tag
	    tag = "let" ! what the hell am I doing?
	    retval = is_tagged_list_p( exp, make_symbol(tag) )
	  end function is_let_p

	  logical function is_cond_p( exp ) result( retval )
	    class(scheme_object), pointer, intent(in) :: exp
	    character(:), allocatable :: tag
	    tag = "cond" ! what the hell am I doing?
	    retval = is_tagged_list_p( exp, make_symbol(tag) )
	  end function is_cond_p

	  logical function is_application_p( exp ) result( retval )
	    class(scheme_object), pointer, intent(in) :: exp
	    select type (exp)
	    class is (scheme_pair)
	       retval = .true.
	    class default
	       retval = .false.
	    end select
	  end function is_application_p

	  logical function is_null_p( arg ) result( retval )
	    class(scheme_object), pointer, intent(in) :: arg
	    select type (arg)
	    class is (scheme_empty_list)
	       retval = .true.
	    class default
	       retval = .false.
	    end select
	  end function is_null_p

	  logical function ll_last_operand_p( arg ) result( retval )
	    class(scheme_object), pointer, intent(in) :: arg
	    select type (arg)
	    class is (scheme_pair)
	       retval = is_null_p( cdr(arg) )
	    class default
	       error stop "ll_last_operand_p: expected a pair"
	    end select
	  end function ll_last_operand_p

	  subroutine scheme_save_reg( val )
	    class(scheme_object), pointer, intent(in) :: val
	    stack_number_pushes = stack_number_pushes + 1
	    stack_current_depth = stack_current_depth + 1
	    stack_max_depth = max( stack_current_depth, stack_max_depth )
	    the_stack => cons(val, the_stack)
	  end subroutine scheme_save_reg

	  function scheme_restore() result( retval )
	    class(scheme_object), pointer :: retval
	    stack_current_depth = stack_current_depth - 1
	    retval => car(the_stack)
	    the_stack => cdr(the_stack)
	  end function scheme_restore

	  subroutine print_stack_statistics()
	    write (*,fmt='(a,a,i0,a,i0,a,i0)', advance='no') new_line('a'), "total-pushes=", stack_number_pushes, &
		 " maximum-depth=", stack_max_depth, " free=", free
	  end subroutine print_stack_statistics

	  subroutine initialize_stack()
	    the_stack => the_null
	    stack_number_pushes = 0
	    stack_max_depth = 0
	    stack_current_depth = 0
	  end subroutine initialize_stack

	  function ll_operator(exp) result(retval)
	    class(scheme_object), pointer, intent(in) :: exp
	    class(scheme_object), pointer :: retval
	    retval => car(exp)
	  end function ll_operator

	  function ll_operands(exp) result(retval)
	    class(scheme_object), pointer, intent(in) :: exp
	    class(scheme_object), pointer :: retval
	    retval => cdr(exp)
	  end function ll_operands

	  function ll_first_operand_p(exp) result(retval)
	    class(scheme_object), pointer, intent(in) :: exp
	    class(scheme_object), pointer :: retval
	    retval => car(exp)
	  end function ll_first_operand_p

	  function ll_rest_operands(exp) result(retval)
	    class(scheme_object), pointer, intent(in) :: exp
	    class(scheme_object), pointer :: retval
	    retval => cdr(exp)
	  end function ll_rest_operands


	  logical function ll_primitive_procedure_p( arg ) result(retval)
	    class(scheme_object), pointer, intent(in) :: arg
	    retval = is_tagged_list_p( arg, make_symbol("primitive"))
	  end function ll_primitive_procedure_p

	  logical function ll_compound_procedure_p( arg ) result(retval)
	    class(scheme_object), pointer, intent(in) :: arg
	    retval = is_tagged_list_p( arg, make_symbol("procedure"))
	  end function ll_compound_procedure_p

	  ! Is this even remotely going to work?
	  ! (define (append list1 list2)
	  ! (if (null? list1)
	  !     list2
	  !     (cons (car list1) (append (cdr list1) list2))))
	  recursive function ll_append( list1, list2 ) result(retval)
	    class(scheme_object), pointer, intent(in) :: list1
	    class(scheme_object), pointer, intent(in) :: list2
	    class(scheme_object), pointer :: retval
	    if (is_null_p(list1)) then
	       retval => list2
	    else
	       retval => cons( car(list1), ll_append( cdr(list1), list2))
	    end if
	  end function ll_append

	  !(define (adjoin-arg arg arglist) (append arglist (list arg)))
	  function ll_adjoin_arg(arg, arglist) result(retval)
	    class(scheme_object), pointer, intent(in) :: arg
	    class(scheme_object), pointer, intent(in) :: arglist
	    class(scheme_object), pointer :: retval
	    retval => ll_append( arglist, cons( arg, the_null ) )
	  end function ll_adjoin_arg

	  function ll_if_predicate( arg ) result( retval )
	    class(scheme_object), pointer, intent(in) :: arg
	    class(scheme_object), pointer :: retval
	    retval => car(cdr( arg ))
	  end function ll_if_predicate

	  function ll_if_alternative( arg ) result( retval )
	    class(scheme_object), pointer, intent(in) :: arg
	    class(scheme_object), pointer :: retval
	    select type (tmp => cdr(cdr(cdr(arg))))
	    class is (scheme_empty_list)
	       retval => the_false
	    class is (scheme_pair)
	       retval => car( tmp )
	    class default
	       error stop "Critical error. If structure is malformed."
	    end select
	  end function ll_if_alternative

	  function ll_if_consequent( arg ) result( retval )
	    class(scheme_object), pointer, intent(in) :: arg
	    class(scheme_object), pointer :: retval
	    retval => car(cdr(cdr(arg)))
	  end function ll_if_consequent

	  logical function ll_true_p( arg ) result( retval )
	    class(scheme_object), pointer, intent(in) :: arg
	    select type (arg)
	    class is (scheme_boolean)
	       if (arg%value .eqv. the_false%value) then
		  retval = .false.
	       else
		  retval = .true.
	       end if
	    class default
	       retval = .true.
	    end select
	  end function ll_true_p

	  logical function ll_false_p( arg ) result( retval )
	    class(scheme_object), pointer, intent(in) :: arg
	    select type (arg)
	    class is (scheme_boolean)
	       if (arg%value .eqv. the_false%value) then
		  retval = .true.
	       else
		  retval = .false.
	       end if
	    class default
	       retval = .false.
	    end select

	  end function ll_false_p

	  function ll_begin_actions( arg ) result( retval )
	    class(scheme_object), pointer, intent(in) :: arg
	    class(scheme_object), pointer :: retval
	    retval => cdr(arg)
	  end function ll_begin_actions

	  function ll_first_exp( arg ) result( retval )
	    class(scheme_object), pointer, intent(in) :: arg
	    class(scheme_object), pointer :: retval
	    retval => car(arg)
	  end function ll_first_exp

	  logical function ll_last_exp_p( arg ) result( retval )
	    class(scheme_object), pointer, intent(in) :: arg
	    select type (arg)
	    class is (scheme_pair)
	       retval = is_null_p( cdr(arg) )
	    class default
	       error stop "ll_last_exp_p: expected a pair"
	    end select
	  end function ll_last_exp_p

	  function ll_rest_exps( arg ) result( retval )
	    class(scheme_object), pointer, intent(in) :: arg
	    class(scheme_object), pointer :: retval
	    retval => cdr(arg)
	  end function ll_rest_exps

	  function ll_text_of_quotation( arg ) result( retval )
	    class(scheme_object), pointer, intent(in) :: arg
	    class(scheme_object), pointer :: retval
	    retval => car(cdr(arg))
	  end function ll_text_of_quotation

	  function ll_lambda_parameters( arg ) result( retval )
	    class(scheme_object), pointer, intent(in) :: arg
	    class(scheme_object), pointer :: retval
	    retval => car(cdr(arg))
	  end function ll_lambda_parameters

	  function ll_lambda_body( arg ) result( retval )
	    class(scheme_object), pointer, intent(in) :: arg
	    class(scheme_object), pointer :: retval
	    retval => cdr(cdr(arg))
	  end function ll_lambda_body

	  ! (define (make-procedure parameters body env)
	  !    (list 'procedure parameters body env))
	  function ll_make_procedure( parameters, body, env ) result( retval )
	    class(scheme_object), pointer, intent(in) :: parameters
	    class(scheme_object), pointer, intent(in) :: body
	    class(scheme_object), pointer, intent(in) :: env
	    class(scheme_object), pointer :: retval
	    retval => cons( make_symbol("procedure"), cons( parameters, &
	       cons( body, cons( env, the_null))))
	  end function ll_make_procedure

	  function ll_assignment_variable( arg ) result( retval )
	    class(scheme_object), pointer, intent(in) :: arg
	    class(scheme_object), pointer :: retval
	    retval => car(cdr(arg))
	  end function ll_assignment_variable

	  function ll_assignment_value( arg ) result( retval )
	    class(scheme_object), pointer, intent(in) :: arg
	    class(scheme_object), pointer :: retval
	    retval => car(cdr(cdr(arg)))
	  end function ll_assignment_value

	      ! (define (set-variable-value! var val env)
	      ! (define (env-loop env)
	      !   (define (scan vars vals)
	      !     (cond ((null? vars)
	      !            (env-loop (enclosing-environment env)))
	      !           ((eq? var (car vars))
	      !            (set-car! vals val))
	      !           (else (scan (cdr vars) (cdr vals)))))
	      !   (if (eq? env the-empty-environment)
	      !       (cons 'unbound 'error)
	      !       (let ((frame (first-frame env)))
	      !         (scan (frame-variables frame)
	      !               (frame-values frame)))))
	      ! (env-loop env))
	  function ll_set_variable_value_b( var, val, env ) result( retval )
	    type(scheme_symbol), pointer, intent(in) :: var
	    class(scheme_object), pointer, intent(in) :: val
	    class(scheme_object), pointer, intent(in) :: env
	    class(scheme_object), pointer :: retval
	    select type( env )
	    class is ( scheme_empty_list )
	       retval => cons( make_symbol("unbound"), make_symbol("error"))
	    class is (scheme_pair)
	       retval => frame_loop( car(car(env)), cdr(car(env)))
	    class default
	       error stop "set_variable_value_b: wrong object in an env"
	    end select
	    !error stop "set-variable-value! not implemented"
	  contains

	    recursive function frame_loop( vars, vals ) result( retval )
	      class(scheme_object), pointer, intent(in) :: vars
	      class(scheme_object), pointer, intent(in) :: vals
	      class(scheme_object), pointer :: retval

	      select type (vars)
	      type is (scheme_empty_list) ! frame empty
		 retval => ll_set_variable_value_b( var, val, cdr(env) )
	      class is (scheme_pair) ! frame is a list
		 select type ( name => car(vars) )
		 class is (scheme_symbol)
		    if ( name == var ) then
		       !retval => cons( make_symbol("bound"), car(vals))
		       !(set-car! vals val)
		       select type( vals )
		       class is (scheme_pair)
			  ! todo: implement set-car!
			  ! the following line is creepy
			  the_cars(vals%value)%contents => val !do I actually need = ?
			  retval => cons(make_symbol("ok"), make_symbol("no-error"))
			  ! cons( make_symbol("bound"), )
		       class default
			  error stop "set_variable_value_b: weird error"
		       end select
		    else
		       retval => frame_loop( cdr(vars), cdr(vals))
		    end if
		 class default
		    error stop "set_variable_value_b::frame_loop: variable name not a symbol"
		 end select
	      class default ! frame is not a list
		 error stop "set_variable_value_b::frame_loop: frame-vars is not a list"
	      end select
	    end function frame_loop
	  end function ll_set_variable_value_b

	  function ll_definition_variable( arg ) result( retval )
	    class(scheme_object), pointer, intent(in) :: arg
	    class(scheme_object), pointer :: retval
	    select type (tmp => car(cdr(arg)))
	    class is (scheme_symbol)
	       retval => tmp
	    class default
	       retval => car( tmp )
	    end select
	  end function ll_definition_variable

	  ! (define (definition-value exp)
	  !               (if (symbol? (cadr exp))
	  !                   (caddr exp)
	  !                   (make-lambda (cdadr exp)
	  !                                (cddr exp))))
	  function ll_definition_value( arg ) result( retval )
	    class(scheme_object), pointer, intent(in) :: arg
	    class(scheme_object), pointer :: retval
	    select type (tmp => car(cdr(arg)))
	    class is (scheme_symbol)
	       retval => car(cdr(cdr( exp )))
	    class default
	       retval => ll_make_lambda( cdr(car(cdr(exp))), cdr(cdr(exp)))
	    end select
	  end function ll_definition_value

	  function ll_make_lambda( parameters, body ) result( retval )
	    class(scheme_object), pointer, intent(in) :: parameters
	    class(scheme_object), pointer, intent(in) :: body
	    class(scheme_object), pointer :: retval
	    retval => cons( make_symbol("lambda"), cons( parameters, body ) )
	  end function ll_make_lambda

	      ! (define (define-variable! var val env)
	      ! (let ((frame (first-frame env)))
	      !   (define (scan vars vals)
	      !     (cond ((null? vars)
	      !            (add-binding-to-frame! var val frame))
	      !           ((eq? var (car vars))
	      !            (set-car! vals val))
	      !           (else (scan (cdr vars) (cdr vals)))))
	      !   (scan (frame-variables frame)
	      !         (frame-values frame))))
	  subroutine ll_define_variable_b( var, val, env)
	    type(scheme_symbol), pointer, intent(in) :: var
	    class(scheme_object), pointer, intent(in) :: val
	    class(scheme_object), pointer, intent(in) :: env
	    select type( env )
	    class is (scheme_pair)
	      call frame_loop( car(car(env)), cdr(car(env)))
	    class default
	       write (*, "(a)", advance='no') "error:irritant:var="
	       call var%debug_display()
	       write (*, "(a)", advance='no') " irritant:env="
	       call env%debug_display()
	       write (*,*) ""
	       stop 0
	       error stop "ll_define_variable_b: wrong object in an env"
	    end select
	    !error stop "set-variable-value! not implemented"
	  contains
	    recursive subroutine frame_loop( vars, vals )
	      class(scheme_object), pointer, intent(in) :: vars
	      class(scheme_object), pointer, intent(in) :: vals
	      select type (vars)
	      type is (scheme_empty_list) ! frame empty
		call ll_add_binding_to_frame_b( var, val, car(env))
	      class is (scheme_pair) ! frame is a list
		 select type ( name => car(vars) )
		 class is (scheme_symbol)
		    if ( name == var ) then
		       !(set-car! vals val)
		       select type( vals )
		       class is (scheme_pair)
			  ! todo: implement set-car!
			  ! the following line is creepy
			  the_cars(vals%value)%contents => val !do I actually need = ?
		       class default
			  error stop "ll_define_variable_b: vals not a list"
		       end select
		    else
		       call frame_loop( cdr(vars), cdr(vals))
		    end if
		 class default
		    error stop "ll_define_variable_b::frame_loop: variable name not a symbol"
		 end select
	      class default ! frame is not a list
		 error stop "set_variable_value_b::frame_loop: frame-vars is not a list"
	      end select
	    end subroutine frame_loop
	      !   (define (add-binding-to-frame! var val frame)
	      !      (set-car! frame (cons var (car frame)))
	      !      (set-cdr! frame (cons val (cdr frame))))
	    subroutine ll_add_binding_to_frame_b( var, val, frame)
	      class(scheme_object), pointer, intent(in) :: var
	      class(scheme_object), pointer, intent(in) :: val
	      class(scheme_object), pointer, intent(in) :: frame
	      select type (frame)
	      class is (scheme_pair)
		 the_cars(frame%value)%contents => cons( var, car(frame))
		 the_cdrs(frame%value)%contents => cons( val, cdr(frame))
	      class default
		 error stop "ll_add_binding_to_frame_b: Error. Frame not a pair."
	      end select
	    end subroutine ll_add_binding_to_frame_b
	  end subroutine ll_define_variable_b

	  function ll_procedure_parameters( arg ) result( retval )
	    class(scheme_object), pointer, intent(in) :: arg
	    class(scheme_object), pointer :: retval
	    retval => car(cdr(arg))
	  end function ll_procedure_parameters

	  function ll_procedure_body( arg ) result( retval )
	    class(scheme_object), pointer, intent(in) :: arg
	    class(scheme_object), pointer :: retval
	    retval => car(cdr(cdr(arg)))
	  end function ll_procedure_body

	  function ll_procedure_environment( arg ) result( retval )
	    class(scheme_object), pointer, intent(in) :: arg
	    class(scheme_object), pointer :: retval
	    retval => car(cdr(cdr(cdr(arg))))
	  end function ll_procedure_environment

	  ! (define (let-bindings exp)
	  !   (cadr exp))
	  function ll_let_bindings( arg ) result( retval )
	    class(scheme_object), pointer, intent(in) :: arg
	    class(scheme_object), pointer :: retval
	    retval => car(cdr(arg))
	  end function ll_let_bindings

	  recursive function ll_map( proc1, lst ) result( retval )
	    class(scheme_object), pointer, intent(in) :: lst
	    class(scheme_object), pointer :: retval
	    procedure(mappable_proc), pointer :: proc1
	    select type (lst)
	    class is (scheme_empty_list)
	       retval => the_null
	    class is (scheme_pair)
	       retval => cons( proc1( car(lst) ), ll_map( proc1, cdr(lst) ) )
	    end select
	  end function ll_map
	  ! (define (let-bindings-variables l)
	  !   (map car l))
	  recursive function ll_let_bindings_variables( arg ) result( retval )
	    class(scheme_object), pointer, intent(in) :: arg
	    class(scheme_object), pointer :: retval
	    procedure(mappable_proc), pointer :: tmp => car
	    retval => ll_map( tmp, arg)
	  end function ll_let_bindings_variables

	  function cadr( arg ) result( retval )
	    class(scheme_object), pointer, intent(in) :: arg
	    class(scheme_object), pointer :: retval
	    retval => car(cdr(arg))
	  end function cadr
	    ! (define (let-bindings-expressions l)
	    !   (map cadr l))
	  function ll_bindings_expressions( arg ) result( retval )
	    class(scheme_object), pointer, intent(in) :: arg
	    class(scheme_object), pointer :: retval
	    procedure(mappable_proc), pointer :: tmp => cadr
	    retval => ll_map( tmp, arg)
	  end function ll_bindings_expressions

	  ! (define (let-contents exp)
	  !     (cddr exp))
	  function ll_let_contents( arg ) result( retval )
	    class(scheme_object), pointer, intent(in) :: arg
	    class(scheme_object), pointer :: retval
	    retval => cdr(cdr(arg))
	  end function ll_let_contents

	    ! (define (let->combination exp)
	    !   (cons
	    !      (make-lambda
	    !           (let-bindings-variables (let-bindings exp))
	    !           (let-contents exp))
	    !      (let-bindings-expressions (let-bindings exp))))
	  function ll_let_to_combination( arg ) result(retval)
	    class(scheme_object), pointer, intent(in) :: arg
	    class(scheme_object), pointer :: retval
	    retval => &
		 cons( &
		 ll_make_lambda( &
		 ll_let_bindings_variables( ll_let_bindings( arg )), &
		 ll_let_contents( arg )), &
		 ll_bindings_expressions( ll_let_bindings( arg )))
	  end function ll_let_to_combination

	  ! (define (cond-clauses exp) (cdr exp))
	  function ll_cond_clauses( arg ) result (retval)
	    class(scheme_object), pointer, intent(in) :: arg
	    class(scheme_object), pointer :: retval
	    retval => cdr( arg )
	  end function ll_cond_clauses

	  ! (define (cond-else-clause? clause)
	  !   (eq? (cond-predicate clause) 'else))
	  logical function ll_cond_else_clause_p( arg ) result( retval )
	    class(scheme_object), pointer, intent(in) :: arg
	    select type (tmp => ll_cond_predicate(arg))
	    class is (scheme_symbol)
	       if (tmp == make_symbol( "else") ) then
		  retval = .true.
	       else
		  retval = .false.
	       end if
	    class default
	       retval = .false.
	    end select
	  end function ll_cond_else_clause_p

	  ! (define (cond-predicate clause) (car clause))
	  function ll_cond_predicate( arg ) result( retval )
	    class(scheme_object), pointer, intent(in) :: arg
	    class(scheme_object), pointer :: retval
	    retval => car( arg )
	  end function ll_cond_predicate

	  ! (define (cond-actions clause) (cdr clause))
	  function ll_cond_actions( arg ) result( retval )
	    class(scheme_object), pointer, intent(in) :: arg
	    class(scheme_object), pointer :: retval
	    retval => cdr(arg)
	  end function ll_cond_actions

	    ! (define (cond->if exp)
	    !   (expand-clauses (cond-clauses exp)))
	  function ll_cond_to_if( arg ) result (retval)
	    class(scheme_object), pointer, intent(in) :: arg
	    class(scheme_object), pointer :: retval
	    retval => ll_expand_clauses( ll_cond_clauses( arg ) )
	  end function ll_cond_to_if

	  ! (define (expand-clauses clauses)
	  !   (if (null? clauses)
	  !       'false
	  !       (let ((first (car clauses))
	  !       (rest (cdr clauses)))
	  !         (if (cond-else-clause? first)
	  !       (if (null? rest)
	  !           (sequence->exp (cond-actions first))
	  !           (error "ELSE clause isn't last -- COND->IF"
	  !                  clauses))
	  !       (make-if (cond-predicate first)
	  !                (sequence->exp (cond-actions first))
	  !                (expand-clauses rest))))))
	  recursive function ll_expand_clauses( arg ) result( retval )
	    class(scheme_object), pointer, intent(in) :: arg
	    class(scheme_object), pointer :: retval
	    class(scheme_object), pointer :: first
	    class(scheme_object), pointer :: rest
	    select type (arg)
	    class is (scheme_empty_list)
	       retval => the_false
	    class is (scheme_pair)
	       first => car(arg)
	       rest  => cdr(arg)
	       if (ll_cond_else_clause_p(first)) then
		  if (is_null_p(rest)) then
		     retval => ll_sequence_to_exp( ll_cond_actions( first ))
		  else
		     error stop "cond->if: else clause is not last"
		  end if
	       else
		  retval => ll_make_if( &
			      ll_cond_predicate(first), &
			      ll_sequence_to_exp( ll_cond_actions(first)), &
			      ll_expand_clauses(rest))
	       end if
	    class default
	       error stop "ll_expand_clauses: malformed sequence"
	    end select
	  end function ll_expand_clauses

	  ! (define (sequence->exp seq)
	  !   (cond ((null? seq) seq)
	  !         ((last-exp? seq) (first-exp seq))
	  !         (else (make-begin seq))))
	  function ll_sequence_to_exp(seq) result( retval )
	    class(scheme_object), pointer, intent(in) :: seq
	    class(scheme_object), pointer :: retval
	    if (is_null_p(seq)) then
	       retval => seq
	    elseif (is_last_exp_p(seq)) then
	       retval => ll_first_exp(seq)
	    else
	       retval => ll_make_begin(seq)
	    end if
	  end function ll_sequence_to_exp

	  !(define (last-exp? seq) (null? (cdr seq)))
	  logical function is_last_exp_p(seq) result(retval)
	    class(scheme_object), pointer, intent(in) :: seq
	    select type( tmp => cdr(seq))
	    class is (scheme_empty_list)
	       retval = .true.
	    class default
	       retval = .false.
	    end select
	  end function is_last_exp_p

	  function ll_make_begin( seq ) result(retval)
	    class(scheme_object), pointer, intent(in) :: seq
	    class(scheme_object), pointer :: retval
	    retval => cons( make_symbol("begin"), seq)
	  end function ll_make_begin

	  function ll_make_if( predicate, consequent, alternative ) result(retval)
	    class(scheme_object), pointer, intent(in) :: predicate
	    class(scheme_object), pointer, intent(in) :: consequent
	    class(scheme_object), pointer, intent(in) :: alternative
	    class(scheme_object), pointer :: retval
	    retval => cons( make_symbol("if"), &
			cons( predicate, &
			  cons( consequent, &
			    cons( alternative, the_null))))
	  end function ll_make_if

      !  (define (make-compiled-procedure entry env)
      !    (list 'compiled-procedure entry env))
	  function ll_make_compiled_procedure( entry1, env ) result(retval)
	    class(scheme_object), pointer, intent(in) :: entry1
	    class(scheme_object), pointer, intent(in) :: env
	    class(scheme_object), pointer :: retval
	    retval => cons( make_symbol("compiled-procedure"), &
			cons( entry1, &
			    cons( env, the_null)))
	  end function ll_make_compiled_procedure

      !  (define (compiled-procedure? proc)
      !    (tagged-list? proc 'compiled-procedure))
	  logical function ll_compiled_procedure_p( arg ) result(retval)
	    class(scheme_object), pointer, intent(in) :: arg
	    retval = is_tagged_list_p( arg, make_symbol("compiled-procedure"))
	  end function ll_compiled_procedure_p

      !  (define (compiled-procedure-entry c-proc) (cadr c-proc))
	  function ll_compiled_procedure_entry( arg ) result(retval)
	    class(scheme_object), pointer, intent(in) :: arg
	    class(scheme_object), pointer :: retval
	    retval => car( cdr( arg ) )
	  end function ll_compiled_procedure_entry

      !  (define (compiled-procedure-env c-proc) (caddr c-proc))
	  function ll_compiled_procedure_env( arg ) result(retval)
	    class(scheme_object), pointer, intent(in) :: arg
	    class(scheme_object), pointer :: retval
	    retval => car( cdr( cdr(arg) ) )
	  end function ll_compiled_procedure_env

	  function ll_lexical_address_lookup( addr, env1 ) result( retval )
	    class(scheme_object), pointer, intent(in) :: addr
	    class(scheme_object), pointer, intent(in) :: env1
	    class(scheme_object), pointer :: tmp_env
	    class(scheme_object), pointer :: tmp_frame
	    class(scheme_object), pointer :: retval
	    integer :: frame_number   = 0
	    integer :: order_in_frame = 0
	    integer :: i = 0

	    select type( a1 => car( addr ) )
	    class is (scheme_number)
	       frame_number = a1%value
	    class default
	       error stop "lexical (frame number) address not a number"
	    end select

	    select type( a2 => car( cdr( addr )) )
	    class is (scheme_number)
	       order_in_frame = a2%value
	    class default
	       error stop "lexical (order within frame) address not a number"
	    end select

	    tmp_env => env1
	    do i=1,frame_number
	       tmp_env => cdr( tmp_env )
	    end do
	    tmp_frame => car( tmp_env ) ! frame
	    tmp_frame => cdr( tmp_frame ) ! list of values, second part of frame

	    do i=1,order_in_frame
	       tmp_frame => cdr( tmp_frame )
	    end do
	    tmp_frame => car( tmp_frame ) ! the actual value
	    select type( tmp_frame )
	    class is ( scheme_symbol )
	       if (tmp_frame%value == "*unassigned") then
		  error stop "lexical lookup Variable unassigned"
	       end if
	    end select
	    retval => tmp_frame
	  end function ll_lexical_address_lookup

	  subroutine ll_lexical_address_set_b( addr, val, env )
	    class(scheme_object), pointer, intent(in) :: addr
	    class(scheme_object), pointer, intent(in) :: val
	    class(scheme_object), pointer, intent(in) :: env
	    class(scheme_object), pointer :: tmp_env
	    class(scheme_object), pointer :: tmp_frame
	    class(scheme_object), pointer :: retval
	    integer :: frame_number   = 0
	    integer :: order_in_frame = 0
	    integer :: i = 0
	    select type( a1 => car( addr ) )
	    class is (scheme_number)
	       frame_number = a1%value
	    class default
	       error stop "lexical (frame number) address not a number"
	    end select
	    select type( a2 => car( cdr( addr )) )
	    class is (scheme_number)
	       order_in_frame = a2%value
	    class default
	       error stop "lexical (order within frame) address not a number"
	    end select
	    tmp_env => env
	    do i=1,frame_number
	       tmp_env => cdr( tmp_env )
	    end do
	    tmp_frame => car( tmp_env ) !
	    tmp_frame => cdr( tmp_frame ) ! list of values
	    do i=1,order_in_frame
	       tmp_frame => cdr( tmp_frame )
	    end do
	    select type( tmp_frame )
	    class is (scheme_pair)
	       ! shall I deallocate here?
	       deallocate( the_cars( tmp_frame%value )%contents )
	       allocate( the_cars( tmp_frame%value )%contents, source=val )
	       !the_cars( tmp_frame%value )%contents => val
	    class default
	       error stop "lexical_address_set_b: pair not a pair"
	    end select

	  end subroutine ll_lexical_address_set_b


	  function ll_apply_primitive_procedure( proc, argl ) result(retval)
	    class(scheme_object), pointer :: retval
	    class(scheme_object), pointer, intent(in) :: proc
	    class(scheme_object), pointer, intent(in) :: argl
	    !class(scheme_object), pointer, intent(in) :: env

            select type( tmp => car(proc))
            class is (scheme_object)
                !write (*,'(a)', advance='no') "ll_apply_primitive_proc, car is: "
                !call tmp%debug_display()
                !print *,""
            class default
                error stop "ll_appl_primi_proc: car not a scheme object"
            end select

	    select type (proc_object => cdr(proc))
	    class is (scheme_primitive_procedure)
	       ! TODO: implement type checkers
	       retval => cons( make_symbol("no-error"), proc_object%proc_pointer( argl , env ))
	    class is (scheme_object)
             write (error_unit,'(a,dt)') "debug: ll_apply_primitive_procedure received not a procedure, instead=>: ", proc_object
             call proc_object%debug_display()
             select type( tmp => car(proc))
             class is (scheme_object)
                write (error_unit,'(a,dt,a)', advance='no') "\nll_apply_primitive_proc, car is: ", tmp, " : "
                call tmp%debug_display()
                print *,""
               class default
                   error stop "ll_appl_primi_proc: car not a scheme object"
               end select

               ! call proc_object%debug_display()
               !stop 0
	       error stop "apply-primitive-procedure: expected procedure object &
		    & not actually a procedure"
	    class default
               write (*,*) "debug: ll_apply_primitive_procedure received non-scheme thingy"
	       error stop "apply-primitive-procedure: expected procedure object &
		    & not actually a scheme_object"
	    end select
	  end function ll_apply_primitive_procedure

	  function packaged_apply_in_real_scheme( argl, env ) result( retval )
	    class(scheme_object), pointer :: argl
	    class(scheme_object), pointer :: env
	    class(scheme_object), pointer :: retval

	    retval => cdr(ll_apply_primitive_procedure( car(argl), car(cdr(argl))))
	  end function packaged_apply_in_real_scheme



	  function ll_plus( arg1, arg2 ) result( retval )
	    class(scheme_object), pointer, intent(in) :: arg1
	    class(scheme_object), pointer, intent(in) :: arg2
	    class(scheme_object), pointer :: retval
	    select type( arg1 )
	    class is( scheme_number )
	       select type( arg2 )
	       class is( scheme_number )
		  retval => make_number( arg1%value + arg2%value )
	       class default
		  error stop "Open coded plus: arg2 is not a number"
	       end select
	    class default
		  error stop "Open coded plus: arg1 is not a number"
	    end select
	  end function ll_plus

	  function ll_mul( arg1, arg2 ) result( retval )
	    class(scheme_object), pointer, intent(in) :: arg1
	    class(scheme_object), pointer, intent(in) :: arg2
	    class(scheme_object), pointer :: retval
	    select type( arg1 )
	    class is( scheme_number )
	       select type( arg2 )
	       class is( scheme_number )
		  retval => make_number( arg1%value * arg2%value )
	       class default
		  error stop "Open coded plus: arg2 is not a number"
	       end select
	    class default
		  error stop "Open coded plus: arg1 is not a number"
	    end select
	  end function ll_mul

	  recursive subroutine main_loop()
	    ! procedure(packageable_procedure), pointer :: proc
	    ! class(scheme_object), pointer :: retval
	    ! type(scheme_primitive_procedure), pointer :: proc_holder
	    ! not sure it is the best place for it
	    character(len=:), allocatable :: label_value
	    logical :: test = .false.
	    the_global_environment => ll_setup_global_environment()
	    env => the_global_environment
	    call initialize_stack()
	    reg_continue => make_symbol( "delibrately-invalid" )
            call debug_is_environment_well_formed_p( env, 0 )
	    label_value = "read-eval-print-loop"
	001 label_selector: select case (label_value)
	    case default
              !(let ((var 'apply1)
              !       (proc-entry (make-label 'entry))
              !       (after-lambda (make-label 'after-lambda)))
              !    (make-instruction-sequence '() '()
              !      `((assign val (op make-compiled-procedure) (label ,proc-entry) (reg env))
              val => ll_make_compiled_procedure( make_symbol("entry-special-apply1"), env)
              !        (perform (op define-variable!) (const ,var) (reg val) (reg env))
              call ll_define_variable_b( make_symbol( "apply1"), val, env)
              !        (goto (label ,after-lambda))
              label_value = "after-apply1-body"
              goto 001
              ! ,proc-entry
              ! entry-special-apply (handwritten)
              label_value="entry-special-apply1"
              goto 001
              case ( "entry-special-apply1" )
              !  (assign proc (op car) (reg argl))
              proc => car(argl)
              !  (assign argl (op cadr) (reg argl))
              argl => car(cdr(argl))
              !  (perform (op user-print) (reg argl))
              ! no need?
              !  (assign val (op compiled-procedure-entry) (reg proc))
              val => ll_compiled_procedure_entry( proc )
              !  (goto (reg val))
              select type (val)
              class is (scheme_symbol)
                    label_value = val%value
                    goto 001
              class default
                    error stop "compiled procedure is not a symbol (not a label)"
              end select
              !        ,after-lambda
              label_value = "after-apply1-body"
              goto 001
              case ( "after-apply1-body" )

#+end_src

#+name: fortran-scheme-interpreter-runtime-epilogue
#+begin_src fortran :exports code :results none
      end select label_selector
      error stop "Critical error. The end of main loop should never be reached."
    end subroutine main_loop


  end module scheme

  program main
    use :: scheme, only : main_loop
    use, intrinsic :: iso_fortran_env
    !  use, non_intrinsic :: system_interface, only: read_until_eof
    implicit none
    !  integer :: fake = 0
    !  class(scheme_object), pointer :: parsed_expression
    print *, "Welcome to the rudimentary scheme in fortran" ! hello, world
    call main_loop()
    stop 0
  end program main
#+end_src



#+name: fortran-scheme-interpreter
#+begin_src f90 :exports code :results none :stdin fortran-scheme-test
  <<fortran-scheme-interpreter-runtime-prologue>>
            error stop "Critical error. Default case should never be reached."
	case ("read-eval-print-loop")
	   ! (perform (op initialize-stack))
	   call initialize_stack()
	   ! (perform (op prompt-for-input) (const "\n;;EC-Eval input:"))
	   write (*,fmt='(a,a)', advance='no') new_line(''), "SCHEMETRAN-Input: " !
	   ! (assign exp (op read))
	   exp => ll_read()
	   ! (perform (op user-print) (reg exp))
	   write (*, fmt='(a,a)', advance='no') &
		new_line(''), "debug: I parsed as: "
	   call exp%debug_display() ;     write (*,'(a)', advance='no') new_line('a')
	   !(assign env (op get-global-environment))
	   env => the_global_environment
	   !(assign continue (label print-result))
	   reg_continue => make_symbol("print-result")
	   ! (goto (label eval-dispatch))
	   label_value = "eval-dispatch"
	   goto 001
	case ("print-result") ! ec-label: print-result
	   !(perform (op announce-output) (const ";;EC-Eval value:"))
	   write (*,fmt='(a,a)', advance='no') new_line(''), "SCHEMETRAN-Value: "
	   !(perform (op user-print) (reg val))
	   call val%debug_display() !; write (*, fmt='(a)') new_line('a')
	   !(perform (op print-stack-statistics))
	   call print_stack_statistics()
	   !(goto (label read-eval-print-loop))
	   label_value = "read-eval-print-loop"
	   goto 001
	case ("unknown-expression-type")
	   !(assign val (const unknown-expression-type-error))
	   val => make_symbol("unknown-expression-type-error")
	   !(goto (label signal-error))
	   label_value = "signal-error"
	   goto 001
	case ("unknown-procedure-type")
	   !(restore continue) ; clean up stack (from apply-dispatch )
	   select type (temp => scheme_restore())
	   class is (scheme_symbol)
	      reg_continue => temp
	   class default
	      error stop "unknown-procedure-type:&
	       & cannot restore reg_continue, wrong type"
	   end select
	   !(assign val (const unknown-procedure-type-error))
	   val => make_symbol("unknown-procedure-type-error")
	   !(goto (label signal-error))
	   label_value = "signal-error"
	   goto 001
	case ("signal-error")
	   !(perform (op user-print) (reg val))
	   call val%debug_display()
	   !(goto (label read-eval-print-loop))
	   label_value = "read-eval-print-loop"
	   goto 001
	case ("ev-definition")
	   !(assign unev (op definition-variable) (reg exp))
	   unev => ll_definition_variable( exp )
	   !(save unev) ; save variable for later
	   call scheme_save_reg( unev )
	   !(assign exp (op definition-value) (reg exp))
	   exp => ll_definition_value( exp )
	   !(save env)
	   call scheme_save_reg( env )
	   !(save continue)
	   call scheme_save_reg( reg_continue )
	   !(assign continue (label ev-definition-1))
	   reg_continue => make_symbol( "ev-definition-1" )
	   !(goto (label eval-dispatch)) ; evaluate the definition value
	   label_value = "eval-dispatch"
	   goto 001
	   error stop "ev-definition guard"
	case ("ev-definition-1")
	   !(restore continue)
	   select type (temp => scheme_restore())
	   class is (scheme_symbol)
	      reg_continue => temp
	   class default
	      error stop "ev-definition-1:&
	       & cannot restore reg_continue, wrong type"
	   end select
	   !(restore env)
	   env => scheme_restore()
	   !(restore unev)
	   unev => scheme_restore()
	   !(perform (op define-variable!) (reg unev) (reg val) (reg env))
	   select type (unev)
	   class is (scheme_symbol)
	      call ll_define_variable_b( unev, val, env )
	   class default
	      error stop "ev-definition-1: Error. Definition variable not a symbol."
	   end select
	   !(assign val (const ok))
	   val => make_symbol( "ok" )
	   !(goto (reg continue))
	   label_value = reg_continue%value
	   goto 001
	   error stop "ev-definition-1 guard"
	case ("ev-self-eval")
	   !(assign val (reg exp))
	   val => exp
	   !(goto (reg continue))
	   label_value = reg_continue%value
	   goto 001
	case ("ev-quoted")
	   !(assign val (op text-of-quotation) (reg exp))
	   val => ll_text_of_quotation( exp )
	   !(goto (reg continue))
	   label_value = reg_continue%value
	   goto 001
	   error stop "ev-quoted guard"
	case ("ev-lambda")
	   !(assign unev (op lambda-parameters) (reg exp))
	   unev => ll_lambda_parameters( exp )
	   !(assign exp (op lambda-body) (reg exp))
	   exp => ll_lambda_body( exp )
	   !(assign val (op make-procedure) (reg unev) (reg exp) (reg env))
	   val => ll_make_procedure( unev, exp, env)
	   !(goto (reg continue))
	   label_value = reg_continue%value
	   goto 001
	   error stop "ev-lambda guard"
	case ("ev-variable")
	   !(assign val (op lookup-variable-value) (reg exp) (reg env))
	   select type (exp)
	   class is (scheme_symbol)
	      val => ll_lookup_variable_value( exp, env )
	   class default
	      error stop "ev-variable: variable name is not a symbol"
	   end select
	   !(save exp)
	   call scheme_save_reg( exp )
	   !(assign exp (op car) (reg val))
	   exp => car( val )
	   !(test (op eq?) (reg exp) (const unbound))
	   select type (exp)
	   class is (scheme_symbol)
	      if ( exp == make_symbol("unbound")) then
		 !(branch (label error-unbound-variable))
		 label_value = "error-unbound-variable"
		 goto 001
	      end if
	   class default
	      error stop "ev-variable: lookup-variable-value returned rubbish"
	   end select
	   !(restore exp)
	   exp => scheme_restore()
	   !(assign val (op cdr) (reg val))
	   val => cdr(val)
	   !(goto (reg continue))
	   label_value = reg_continue%value
	   goto 001
	case ("error-unbound-variable")
	   !(restore exp)
	   exp => scheme_restore()
	   !(assign val (op cons) (const unbound-variable-error) (reg exp))
	   val => cons( make_symbol("unbound-variable-error"), exp)
	   !(goto (label signal-error))
	   label_value = "signal-error"
	   goto 001
	   error stop "error-unbound-variable guard"
	case ("ev-assignment")
	   ! (assign unev (op assignment-variable) (reg exp))
	   unev => ll_assignment_variable( exp )
	   ! (save unev) ; save variable for later
	   call scheme_save_reg( unev )
	   ! (assign exp (op assignment-value) (reg exp))
	   exp => ll_assignment_value( exp )
	   ! (save env)
	   call scheme_save_reg(env)
	   ! (save continue)
	   call scheme_save_reg(reg_continue)
	   ! (assign continue (label ev-assignment-1))
	   reg_continue => make_symbol( "ev-assignment-1" )
	   ! (goto (label eval-dispatch)) ; evaluate the assignment value
	   label_value = "eval-dispatch"
	   goto 001
	   error stop "ev-assignment guard"
	case ("ev-assignment-1")
	   ! (restore continue)
	   select type (temp => scheme_restore())
	   class is (scheme_symbol)
	      reg_continue => temp
	   class default
	      error stop "ev-assignment-1:&
		   & cannot restore reg_continue, wrong type"
	   end select
	   ! (restore env)
	   env => scheme_restore()
	   ! (restore unev)
	   unev => scheme_restore()
	   ! (assign val (op set-variable-value!) (reg unev) (reg val) (reg env))
	   select type( unev )
	   class is (scheme_symbol)
	      val => ll_set_variable_value_b( unev, val, env )
	   class default
	      error stop "ev-assignment-1: Non-symbol passed as a variable name."
	   end select
	   ! (assign val (op car) (reg val))
	   val => car(val)
	   ! (test (op eq?) (reg val) (const unbound))
	   select type (val)
	   class is (scheme_symbol)
	      if ( val == make_symbol("unbound")) then
		 ! (branch (label assignment-failed))
		 label_value = "assignment-failed"
		 goto 001
	      end if
	   class default
	      error stop "ev-assignment-1: Error. assignment return not a symbol"
	   end select
	   ! (assign val (const ok))
	   val => make_symbol( "ok" )
	   ! (goto (reg continue))
	   label_value = reg_continue%value
	   goto 001
	   error stop "ev-assignment-1 guard"
	case ("assignment-failed")
	   ! (assign exp (reg unev))
	   exp => unev
	   ! (save exp)
	   call scheme_save_reg( exp )
	   ! (goto (label error-unbound-variable))
	   label_value = "error-unbound-variable"
	   goto 001
	   error stop "assignment-failed guard"
	case ("ev-if")
	   ! (save exp) ; save expression for later
	   call scheme_save_reg( exp )
	   ! (save env)
	   call scheme_save_reg( env )
	   ! (save continue)
	   call scheme_save_reg( reg_continue )
	   ! (assign continue (label ev-if-decide))
	   reg_continue => make_symbol( "ev-if-decide" )
	   ! (assign exp (op if-predicate) (reg exp))
	   exp => ll_if_predicate( exp )
	   ! (goto (label eval-dispatch)) ; evaluate the predicate
	   label_value = "eval-dispatch"
	   goto 001
	case ("ev-if-decide")
	   ! (restore continue)
	   select type (temp => scheme_restore())
	   class is (scheme_symbol)
	      reg_continue => temp
	   class default
	      error stop "ev-if-decide:&
	       & cannot restore reg_continue, wrong type"
	   end select
	   ! (restore env)
	   env => scheme_restore()
	   ! (restore exp)
	   exp => scheme_restore()
	   ! (test (op true?) (reg val))
	   if (ll_true_p(val)) then
	      ! (branch (label ev-if-consequent))
	      label_value = "ev-if-consequent"
	      goto 001
	   end if
	   label_value = "ev-if-alternative"
	   goto 001
	   error stop "ev-if-decide guard"
	case ("ev-if-alternative")
	   ! (assign exp (op if-alternative) (reg exp))
	   exp => ll_if_alternative( exp )
	   ! (goto (label eval-dispatch))
	   label_value = "eval-dispatch"
	   goto 001
	case ("ev-if-consequent")
	   ! (assign exp (op if-consequent) (reg exp))
	   exp => ll_if_consequent( exp )
	   ! (goto (label eval-dispatch))
	   label_value = "eval-dispatch"
	   goto 001
	   error stop "ev-if-consequent guard"
	case ("ev-sequence")
	   ! (assign exp (op first-exp) (reg unev))
	   exp => ll_first_exp( unev )
	   ! (test (op last-exp?) (reg unev))
	   if (ll_last_exp_p(unev)) then
	      ! (branch (label ev-sequence-last-exp))
	      label_value = "ev-sequence-last-exp"
	      goto 001
	   end if
	   ! (save unev)
	   call scheme_save_reg( unev )
	   ! (save env)
	   call scheme_save_reg( env  )
	   ! (assign continue (label ev-sequence-continue))
	   reg_continue => make_symbol( "ev-sequence-continue" )
	   ! (goto (label eval-dispatch))
	   label_value = "eval-dispatch"
	   goto 001
	   error stop "ev-sequence guard"
	case ("ev-sequence-continue")
	   ! (restore env)
	   env => scheme_restore()
	   ! (restore unev)
	   unev => scheme_restore()
	   ! (assign unev (op rest-exps) (reg unev))
	   unev => ll_rest_exps( unev )
	   ! (goto (label ev-sequence))
	   label_value = "ev-sequence"
	   goto 001
	   error stop "ev-sequence-continue guard"
	case ("ev-sequence-last-exp")
	   ! (restore continue)
	   select type (temp => scheme_restore())
	   class is (scheme_symbol)
	      reg_continue => temp
	   class default
	      error stop "ev-sequence-last-exp:&
		   & cannot restore reg_continue, wrong type"
	   end select
	   ! (goto (label eval-dispatch))
	   label_value = "eval-dispatch"
	   goto 001
	   error stop "ev-sequence-last-exp guard"
	case ("ev-begin")
	   ! (assign unev (op begin-actions) (reg exp))
	   unev => ll_begin_actions( exp )
	   ! (save continue)
	   call scheme_save_reg( reg_continue )
	   ! (goto (label ev-sequence))
	   label_value = "ev-sequence"
	   goto 001
	   error stop "ev-begin guard"
	case ("compound-apply")
	   ! (assign unev (op procedure-parameters) (reg proc))
	   unev => ll_procedure_parameters( proc )
	   ! (assign env (op procedure-environment) (reg proc))
	   env => ll_procedure_environment( proc )
	   ! (assign env (op extend-environment)
	   !     (reg unev) (reg argl) (reg env))
	   env => ll_extend_environment( unev, argl, env )
	   ! (assign unev (op procedure-body) (reg proc))
	   unev => ll_procedure_body( proc )
	   ! (goto (label ev-sequence))
	   label_value = "ev-sequence"
	   goto 001
	   error stop "compound-apply guard"
	case ("primitive-apply")
	   ! (assign val (op apply-primitive-procedure-with-errors) (reg proc) (reg argl))
	   val => ll_apply_primitive_procedure( proc, argl )
	   ! (save val)
	   call scheme_save_reg( val )
	   ! (assign val (op car) (reg val)) ; error or not
	   val => car(val)
	   ! (test (op eq?) (const error) (reg val))
	   select type (val)
	   class is (scheme_symbol)
	      if ( val == make_symbol("error")) then
		 ! (branch (label primitive-error))
		 label_value = "primitive-error"
		 goto 001
	      end if
	   class default
	      error stop "primitive-apply: apply-primitive-procedure returned garbage"
	   end select
	   ! (restore val)
	   val => scheme_restore()
	   ! (assign val (op cdr) (reg val))
	   val => cdr(val)
	   ! (restore continue)
	   select type (temp => scheme_restore())
	   class is (scheme_symbol)
	      reg_continue => temp
	   class default
	      error stop "primitive-apply: cannot restore reg_continue, wrong type"
	   end select
	   ! (goto (reg continue))
	   label_value = reg_continue%value
	   goto 001
	case ("primitive-error")
	   ! (restore val)
	   val => scheme_restore()
	   ! (assign val (op cdr) (reg val)) ; error-code
	   val => cdr(val)
	   ! (assign val (op cons) (const primitive-application-error) (reg val))
	   val => cons( make_symbol( "primitive-application-error" ), val)
	   ! (goto (label signal-error))
	   label_value = "signal-error"
	   goto 001
	case ("ev-application")
	   ! (save continue)
	   call scheme_save_reg(reg_continue)
	   ! (save env)
	   call scheme_save_reg( env )
	   ! (assign unev (op operands) (reg exp))
	   unev => ll_operands(exp)
	   ! (save unev)
	   call scheme_save_reg(unev)
	   ! (assign exp (op operator) (reg exp))
	   exp => ll_operator(exp)
	   ! (assign continue (label ev-appl-did-operator))
	   reg_continue => make_symbol("ev-appl-did-operator")
	   ! (goto (label eval-dispatch))
	   label_value = "eval-dispatch"
	   goto 001
	case ("ev-appl-did-operator")
	   ! (restore unev) ; the operands
	   unev => scheme_restore()
	   ! (restore env)
	   env => scheme_restore()
	   ! (assign argl (op empty-arglist))
	   argl => the_null
	   ! (assign proc (reg val)) ; the operator
	   proc => val
	   ! (test (op no-operands?) (reg unev))
	   if (is_null_p(unev)) then
	      ! (branch (label apply-dispatch))
	      label_value = "apply-dispatch"
	      goto 001
	   end if
	   ! (save proc)
	   call scheme_save_reg( proc )
	   label_value = "ev-appl-operand-loop"
	   goto 001
	case ("ev-appl-operand-loop")
	   ! (save argl)
	   call scheme_save_reg( argl )
	   ! (assign exp (op first-operand) (reg unev))
	   exp => ll_first_operand_p(unev)
	   ! (test (op last-operand?) (reg unev))
	   if (ll_last_operand_p(unev)) then
	      ! (branch (label ev-appl-last-arg))
	      label_value = "ev-appl-last-arg"
	      goto 001
	   end if
	   ! (save env)
	   call scheme_save_reg( env )
	   ! (save unev)
	   call scheme_save_reg( unev )
	   ! (assign continue (label ev-appl-accumulate-arg))
	   reg_continue => make_symbol("ev-appl-accumulate-arg")
	   ! (goto (label eval-dispatch))
	   label_value = "eval-dispatch"
	   goto 001
	case ("ev-appl-accumulate-arg")
	   ! (restore unev)
	   unev => scheme_restore()
	   ! (restore env)
	   env => scheme_restore()
	   ! (restore argl)
	   argl => scheme_restore()
	   ! (assign argl (op adjoin-arg) (reg val) (reg argl))
	   argl => ll_adjoin_arg( val, argl )
	   ! (assign unev (op rest-operands) (reg unev))
	   unev => ll_rest_operands( unev )
	   ! (goto (label ev-appl-operand-loop))
	   label_value = "ev-appl-operand-loop"
	   goto 001
	case ("ev-appl-last-arg")
	   ! (assign continue (label ev-appl-accum-last-arg))
	   reg_continue => make_symbol( "ev-appl-accum-last-arg" )
	   ! (goto (label eval-dispatch))
	   label_value = "eval-dispatch"
	   goto 001
	case ("ev-appl-accum-last-arg")
	   ! (restore argl)
	   argl => scheme_restore()
	   ! (assign argl (op adjoin-arg) (reg val) (reg argl))
	   argl => ll_adjoin_arg( val, argl )
	   ! (restore proc)
	   proc => scheme_restore()
	   ! (goto (label apply-dispatch))
	   label_value = "apply-dispatch"
	   goto 001
	case ("apply-dispatch")
	   ! (test (op primitive-procedure?) (reg proc))
	   if (ll_primitive_procedure_p(proc)) then
	      ! (branch (label primitive-apply))
	      label_value = "primitive-apply"
	      goto 001
	   end if
	   ! (test (op compound-procedure?) (reg proc))
	   if (ll_compound_procedure_p(proc)) then
	      ! (branch (label compound-apply))
	      label_value = "compound-apply"
	      goto 001
	   end if
	   ! (goto (label unknown-procedure-type))
	   label_value = "unknown-procedure-type"
	   goto 001
	case ("eval-dispatch")
	   if (free >= memory_size*0.9) then ! is this a good place?
	      free = run_garbage_collector(free)
	   end if
	   ! (test (op self-evaluating?) (reg exp))
	   if (is_self_evaluating_p(exp)) then
	      ! (branch (label ev-self-eval))
	      label_value = "ev-self-eval"
	      goto 001
	   end if
	   ! (test (op variable?) (reg exp))
	   if (is_symbol_p(exp)) then
	      ! (branch (label ev-variable))
	      label_value = "ev-variable"
	      goto 001
	   end if
	   ! (test (op quoted?) (reg exp))
	   if (is_quoted_p(exp)) then
	      ! (branch (label ev-quoted))
	      label_value = "ev-quoted"
	      goto 001
	   end if
	   ! (test (op assignment?) (reg exp))
	   if (is_assignment_p(exp)) then
	      ! (branch (label ev-assignment))
	      label_value = "ev-assignment"
	      goto 001
	   end if
	   ! (test (op definition?) (reg exp))
	   if (is_definition_p(exp)) then
	      ! (branch (label ev-definition))
	      label_value = "ev-definition"
	      goto 001
	   end if
	   ! (test (op if?) (reg exp))
	   if (is_if_p(exp)) then
	      ! (branch (label ev-if))
	      label_value = "ev-if"
	      goto 001
	   end if
	   ! (test (op lambda?) (reg exp))
	   if (is_lambda_p(exp)) then
	      ! (branch (label ev-lambda))
	      label_value = "ev-lambda"
	      goto 001
	   end if
	   ! (test (op begin?) (reg exp))
	   if (is_begin_p(exp)) then
	      ! (branch (label ev-begin))
	      label_value = "ev-begin"
	      goto 001
	   end if
	   ! (test (op let?) (reg exp))
	   if (is_let_p(exp)) then
	      ! (branch (label ev-let))
	      label_value = "ev-let"
	      goto 001
	   end if
	   ! (test (op cond?) (reg exp))
	   if (is_cond_p(exp)) then
	      ! (branch (label ev-cond))
	      label_value = "ev-cond"
	      goto 001
	   end if
	   ! (test (op application?) (reg exp))
	   if (is_application_p(exp)) then
	      ! (branch (label ev-application))
	      label_value = "ev-application"
	      goto 001
	   end if
	   ! (goto (label unknown-expression-type))
	   label_value = "unknown-expression-type"
	   goto 001
	case ("ev-let")
	   ! (assign exp (op let->combination) (reg exp))
	   exp => ll_let_to_combination( exp )
	   !write (*,*) "debug"
	   !call exp%debug_display()
	   ! ;(save continue)
	   !call scheme_save_reg( reg_continue )
	   ! (goto (label eval-dispatch))
	   label_value = "eval-dispatch"
	   goto 001
	   error stop "ev-let guard"
	case ("ev-cond")
	   ! (assign exp (op cond->if) (reg exp))
	   exp => ll_cond_to_if( exp )
	   ! (goto (label eval-dispatch))
	   label_value = "eval-dispatch"
	   goto 001
	   error stop "ev-cond guard"
  <<fortran-scheme-interpreter-runtime-epilogue>>
#+end_src

#+name: fortran-scheme-test
#+begin_src scheme :exports code :results none
(display "hello")
(let ((a 1)) (display a))
(if #t 1 2)
(if #f 1 2)
(define (fac x) (if (= 1 x) 1 (* x (fac (- x 1)))))
(fac 6)
(exit)
#+end_src


#+header: :stdin empty
#+begin_src shell :results output code :exports both
  cat <<'EOF' > interpreter.f90
  <<fortran-scheme-interpreter>>
  EOF
  gfortran -Wno-all interpreter.f90 -o schemetran

  cat <<'EOF' > testfile.scm
  <<fortran-scheme-test>>
  EOF

  ./schemetran < testfile.scm
  rm -rf schemetran
  rm -rf testfile.scm
  rm -rf system_interface.mod
  rm -rf scheme.mod
#+end_src

#+RESULTS[2112aa67d21d596f5c1525c8ed56c48113556c01]:
#+begin_src shell
 Welcome to the rudimentary scheme in fortran

SCHEMETRAN-Input: 
debug: I parsed as: (display . ("hello" . ()))
"hello"
SCHEMETRAN-Value: ()
total-pushes=7 maximum-depth=4 free=111
SCHEMETRAN-Input: 
debug: I parsed as: (let . (((a . (1 . ())) . ()) . ((display . (a . ())) . ())))
1
SCHEMETRAN-Value: ()
total-pushes=13 maximum-depth=4 free=148
SCHEMETRAN-Input: 
debug: I parsed as: (if . (#t . (1 . (2 . ()))))

SCHEMETRAN-Value: 1
total-pushes=3 maximum-depth=3 free=155
SCHEMETRAN-Input: 
debug: I parsed as: (if . (#f . (1 . (2 . ()))))

SCHEMETRAN-Value: 2
total-pushes=3 maximum-depth=3 free=162
SCHEMETRAN-Input: 
debug: I parsed as: (define . ((fac . (x . ())) . ((if . ((= . (1 . (x . ()))) . (1 . ((* . (x . ((fac . ((- . (x . (1 . ()))) . ())) . ()))) . ())))) . ())))

SCHEMETRAN-Value: ok
total-pushes=3 maximum-depth=3 free=193
SCHEMETRAN-Input: 
debug: I parsed as: (fac . (6 . ()))

SCHEMETRAN-Value: 720
total-pushes=230 maximum-depth=24 free=545
SCHEMETRAN-Input: 
debug: I parsed as: (exit . ())
STOP 0
#+end_src



This exercise took me about 104 hours of work.

**** DONE Exercise 5.52 Making a compiler for scheme
     CLOSED: [2020-05-06 Wed 11:09]

Important: this exercise does not include the garbage collector, as it
has already been implemented in 5.51. It is not hard to add it, but I
didn't bother.

 - [X] transpile labels
 - [X] transpile (perform)
 - [X] transpile (assign)
 - [X] transpile (save)
 - [X] transpile (restore)
 - [X] transpile (goto)
 - [X] transpile (reg)
 - [X] transpile (test)
 - [X] transpile (branch)
 - [X] transpile (const)
 - [X] transpile (op)
 - [X] transpile ll_... lots of unimplemented functions
 - [X] transpile (list)
 - [X] make a list of functions to transpile
 - [X] 5.51 prologue
 - [X] 5.51 epilogue
 - [X] 5.51 manual ec-eval
 - [X] rename functions
 - [X] ll-lookup-variable-value
 - [X] ll-lexical-address-lookup
 - [X] ll-make-compiled-procedure
 - [X] make-number
 - [X] ll-compiled-procedure-env
 - [X] ll-extend-environment
 - [X] ll-list
 - [X] ll-compound-procedure-p
 - [X] ll_apply_primitive_procedure
 - [X] ll-cons
 - [X] ll-false-p
 - [X] implement packaged procedures
 - [X] car
 - [X] cdr
 - [X] cons
 - [X] cadr
 - [X] null?
 - [X] newline
 - [X] assoc
 - [X] =
 - [X] <
 - [X] >
 - [X] +
 - [X] -
 - [X] not
 - [X] *
 - [X] current-second
 - [X] list
 - [X] eq?
 - [X] equal?
 - [X] pair?
 - [X] error
 - [X] random-integer
 - [X] even?
 - [X] remainder
 - [X] square
 - [X] /
 - [X] member
 - [X] abs
 - [X] cdar
 - [X] cdadr
 - [X] caar
 - [X] caadr
 - [X] cddr
 - [X] cdddr
 - [X] caddr
 - [X] cadddr
 - [X] set-car!
 - [X] set-cdr!
 - [X] memq
 - [X] read
 - [X] show
 - [X] pretty
 - [X] number?
 - [X] string?
 - [X] symbol?
 - [X] apply1

This is a bit of an evil task for a person who just wrote a scheme
interpreter in fortran. Would it be fair if I just make a compiler
from scheme into Fortran? Then I would be able to just reuse the
run-time support from Fortran, rather than writing it from scratch in C.

#+name: c-fortran-compile-and-dont-go
#+begin_src scheme :exports code :results none
(define ec-label? symbol?)
(define (ec-perform? statement)
  (tagged-list? statement 'perform))
(define (ec-assign? statement)
  (tagged-list? statement 'assign))
(define (ec-label-label? statement)
  (tagged-list? statement 'label))
(define (ec-save? statement)
  (tagged-list? statement 'save))
(define (ec-restore? statement)
  (tagged-list? statement 'restore))
(define (ec-goto? statement)
  (tagged-list? statement 'goto))
(define (ec-test? statement)
  (tagged-list? statement 'test))
(define (ec-branch? statement)
  (tagged-list? statement 'branch))

(define (ec-const? statement)
  (tagged-list? statement 'const))
(define (ec-reg? statement)
  (tagged-list? statement 'reg))

(define (ec-opname-get statement) (cadar statement))
(define (ec-arglist-get statement) (cdr statement))
(define (ec-arglist-eval arglist)
   (map const-or-reg arglist))

(define (ec-process-const e)
  (cond ((symbol? e) (string-append "make_symbol( \"" (symbol->string e) "\")" ))
        ((boolean? e) (if e "the_true" "the_false"))
        ((null? e) "the_null")
        ((pair? e) (string-append "cons( " (ec-process-const (car e))
                                    " ,&\n "
                                           (ec-process-const (cdr e))
                                    " ) "))
        ((number? e) (string-append "make_number( " (number->string e) " )"))
        ((string? e) (string-append "make_string( \"" e "\" )"))
        (else (string-append "todo-eval-const:" (write-to-string e)))))

(define (ec-process-reg exp)
  (if (eq? exp 'continue)
     "reg_continue"
     (write-to-string exp)))

(define (ec-label-to-funarg label)
   (string-append " make_symbol( \"" (symbol->string (cadr label)) "\" )"))

(define (const-or-reg clause)
   (cond ((ec-const? clause) (ec-process-const (cadr clause)))
         ((ec-reg? clause) (ec-process-reg (cadr clause)))
         ((ec-label-label? clause) (ec-label-to-funarg clause))
         (else (error "TODO arglist unhandled: " clause))))

(define (string-list-decorate l d)
  (cond ((null? l) "")
        ((= 1 (length l)) (car l))
        (else (string-append (car l) d (string-list-decorate (cdr l) d)))))

(define idx 0)
(define (ec-statement->string statement)
(string-append
  "!" (write-to-string statement) "\n"
  ;"call debug_is_environment_well_formed_p( env, " (begin (set! idx (+ idx 1)) (write-to-string idx)) " ) !super slow\n"
  (car (list ;'was (write-to-string statement) 'became
    (cond ((ec-label? statement) (ec-label->fortran-label statement))
        ((ec-perform? statement)
           (ec-perform->fortran-application statement)
           #;(write-to-string statement))
        ((ec-assign? statement)
           (ec-assign->fortran-assignment statement))
        ((ec-save? statement) (save-statement->fortran statement)
           #;(write-to-string statement))
        ((ec-restore? statement) (restore-statement->fortran statement)
           #;(write-to-string statement))
        ((ec-goto? statement) (goto-statement->fortran statement))
        ((ec-test? statement) (test-statement->fortran statement))
        ((ec-branch? statement) (branch-statement->fortran statement))
        (else (write-to-string statement)))))))

(define (write-to-string form)
  (let ((out (open-output-string)))
    (write form out)
    (get-output-string out)))

(define (branch-statement->fortran s)
  (string-append "if( test ) then\n     label_value=\""
      (symbol->string (cadadr s)) "\"\n     goto 001\n end if" ))

(define test-contents cdr)
(define (test-statement->fortran s)
  (string-append "test = " (ec-make-fortran-funcall (test-contents s))))


(define (save-statement->fortran s)
  (string-append "call scheme_save_reg( " (ec-process-reg (cadr s)) " )" ))
(define (restore-statement->fortran s)
  (let ((r (cadr s)))
    (cond ((eq? r 'continue)
             (string-append "select type ( tmp => scheme_restore())\n"
              "class is (scheme_symbol)\n"
                   "reg_continue => tmp\n"
              "class default\n"
                   "error stop \"restoring continue not a label\"\n"
              "end select"))
          (else (string-append (ec-process-reg r)
                    " => scheme_restore( )" )))))


(define (goto-kind s)
  (car s))
(define (goto-contents s)
  (cadr s))

(define (goto-statement->fortran s)
(let ((s (cadr s)))  (string-append
    (cond ((ec-label-label? s)
            (string-append "label_value=\"" (symbol->string (cadr s)) "\"" ))
          ((ec-reg? s)
             (string-append
"	 select type (" (ec-process-reg (cadr s)) ")\n	 class is (scheme_symbol)\n"

"label_value = " (ec-process-reg (cadr s))  "%value" "
class default
   error stop \"goto target not a label\"\n end select"))
        (else (string-append "check this" (write-to-string s))))
    "\ngoto 001")))

(define (ec-label->fortran-label label)
  (let* ((label-value (symbol->string label))
         (answer (string-append "label_value=\"" label-value  "\"\ngoto 001\ncase ( \"" label-value "\" )")))
       ;(display "debug-print: ") (newline) (display answer)
       answer))

(define (fortranise-symbol c)
   (cond ((equal? c #\-) "_")
         ((equal? c #\!) "_b")
         ((equal? c #\?) "_p")
         ((equal? c #\+) "plus")
         ((equal? c #\*) "mul")
         (else (list->string (list c)))))

(define (fortranise-name name)
   (fold-right string-append "" (map fortranise-symbol (string->list name))))

(define (ec-make-fortran-funcall lst)
;(display "debug:") (display lst ) (newline)
   (string-append
       "ll_" (fortranise-name (symbol->string (ec-opname-get lst)))
       "( "
       (string-list-decorate
          (ec-arglist-eval
             (ec-arglist-get lst)) " , ")
       " )"))
(define (ec-perform-body statement)
   (cdr statement))
(define (ec-perform->fortran-application statement)
   (string-append "call "
       (ec-make-fortran-funcall (ec-perform-body statement))))
(define (ec-assign-target statement)
  (cadr statement))
(define (ec-assign-source statement)
  (cddr statement))
(define (ec-op? s)
  (tagged-list? s 'op))
(define (ec-assign->fortran-assignment statement)
   (string-append
      (ec-process-reg (ec-assign-target statement)) " => "
      (cond ((ec-const? (car (ec-assign-source statement)))
               (ec-process-const (cadar (ec-assign-source statement))))
            ((ec-op? (car (ec-assign-source statement)))
               (string-append
                   (ec-make-fortran-funcall (ec-assign-source statement))
                   (if (eq? 'lookup-variable-value (cadr (car (ec-assign-source statement))))
                       (string-append
	   "\nselect type (val1 => car(" (ec-process-reg (ec-assign-target statement)) "))
class is (scheme_symbol)\n
if ( val1 == make_symbol(\"unbound\")) then\n
  print *, \"lookup-variable-value: unbound symbol: \"\n
 "
  (ec-process-reg (ec-assign-target statement)) " => cdr( " (ec-process-reg (ec-assign-target statement)) ")\n"
  "call "(ec-process-reg (ec-assign-target statement)) "%debug_display()\n"
  "stop 0
  !error stop \"lookup-variable-value: unbound symbol\"
	      end if
	   class default
	      error stop \"ev-assignment-1: Error. lookup-variable-value status return not a symbol\"
	   end select"
           "\n"
           (ec-process-reg (ec-assign-target statement))
                 " => cdr( "
                 (ec-process-reg (ec-assign-target statement))
                        ")")
              "\n!not lookup variable")
              (if (eq? 'apply-primitive-procedure (cadr (car (ec-assign-source statement))))
                  (string-append "\n" (ec-process-reg (ec-assign-target statement)) " => cdr( " (ec-process-reg (ec-assign-target statement)) ")\n")
                  "")))
            ((ec-label-label? (car (ec-assign-source statement)))
               (string-append "make_symbol(\""
                 (symbol->string (cadr (car (ec-assign-source statement))))
                              "\")"))
            (else (string-append "assign-todo: " (write-to-string statement))))))

(define (compile-and-dont-go code)
  (for-each (lambda (x) (display x) (newline))
    (map ec-statement->string (statements (compile code 'val 'return '())))) #t)

#+end_src

The following piece of code is only needed to shorten the testing.

#+name: simple-test-ec-to-fortran
#+begin_src shell :shebang "#!/usr/bin/chibi-scheme" :stdin empty :exports none :results output
    <<ec-glue1>>
    <<s-truefalse>>
    <<s-let-implementation>>
    <<s-let-star-implementation>>
    <<ec-s-additional-syntax>>
    <<s-syntax>>
    <<s-application>>
    <<s-environments>>
    <<s-compound-procedures>>
    <<s-primitive-procedures>>
    <<s-cond>>
    <<s-user-prompt-print-with-compiled>>

    <<c-compile-lexical-with-open-code-let>>
    <<c-compile-lexical-open-code>>
    <<c-make-instruction-sequence-empty-instruction-sequence>>
    <<c-compile-linkage>>
    <<c-end-with-linkage>>
    <<c-compile-lexical-simple-expressions>>
    <<c-compile-lexical-definition>>
    <<c-lexical-compile-variable-compile-assignment>>
    <<c-make-label>>
    <<c-compile-lexical-if>>
    <<c-compile-lexical-sequence>>
    <<c-compiled-procedures>>
    <<c-compile-lexical-lambda>>
    <<c-compile-lexical-lambda-body-nodefines>>
    <<c-compile-lexical-application>>
    <<c-lexical-address-lookup>>
    <<c-lexical-find-variable>>
    <<c-construct-arglist>>
    <<c-compile-procedure-call-with-interpreted>>
    <<c-compile-proc-appl>>
    <<c-combining-registers>>
    <<c-append-instruction-sequences>>
    <<c-list-union>>
    <<c-preserving>>
    <<c-tack-on-instruction-sequence>>
    <<c-parallel-instruction-sequences>>

    <<c-fortran-compile-and-dont-go>>

    (define the-global-environment (setup-environment))

  ;(show #t
  ;(pretty
  (compile-and-dont-go
 '(begin
  (define (accumulate op initial sequence)
    (if (null? sequence)
	initial
	(op (car sequence)
	    (accumulate op initial (cdr sequence)))))
  (define (length sequence)
    (accumulate (lambda (x y)  (+ 1 y)) 0 sequence))
   (display (length (list 1 2 3 4)))
   (exit)
  ))
;)
;)
#+end_src

#+name: transpiled-metacircular-evaluator-small-test
#+begin_src fortran :exports none :flags -g :results code output
      <<fortran-scheme-interpreter-runtime-prologue>>
      <<simple-test-ec-to-fortran()>>
      <<fortran-scheme-interpreter-runtime-epilogue>>
#+end_src

#+RESULTS[1652f57993c029e510e322f7348e7e05c40cd324]: transpiled-metacircular-evaluator-small-test
#+begin_src fortran
Welcome to the rudimentary scheme in fortran
4
#+end_src

#+name: fortran-scheme-interpreter-interlogue
#+begin_src shell :shebang "#!/usr/bin/chibi-scheme" :exports code :results code output
      <<ec-glue1>>
      <<s-truefalse>>
      <<s-let-implementation>>
      <<s-let-star-implementation>>
      <<ec-s-additional-syntax>>
      <<s-syntax>>
      <<s-application>>
      <<s-environments>>
      <<s-compound-procedures>>
      <<s-primitive-procedures>>
      <<s-cond>>
      <<s-user-prompt-print-with-compiled>>

      <<c-compile-lexical-with-open-code-let>>
      <<c-compile-lexical-open-code>>
      <<c-make-instruction-sequence-empty-instruction-sequence>>
      <<c-compile-linkage>>
      <<c-end-with-linkage>>
      <<c-compile-lexical-simple-expressions>>
      <<c-compile-lexical-definition>>
      <<c-lexical-compile-variable-compile-assignment>>
      <<c-make-label>>
      <<c-compile-lexical-if>>
      <<c-compile-lexical-sequence>>
      <<c-compiled-procedures>>
      <<c-compile-lexical-lambda>>
      <<c-compile-lexical-lambda-body-nodefines>>
      <<c-compile-lexical-application>>
      <<c-lexical-address-lookup>>
      <<c-lexical-find-variable>>
      <<c-construct-arglist>>
      <<c-compile-procedure-call-with-interpreted>>
      <<c-compile-proc-appl>>
      <<c-combining-registers>>
      <<c-append-instruction-sequences>>
      <<c-list-union>>
      <<c-preserving>>
      <<c-tack-on-instruction-sequence>>
      <<c-parallel-instruction-sequences>>

      <<c-fortran-compile-and-dont-go>>

      (define the-global-environment (setup-environment))

    ;(show #t (pretty
    (compile-and-dont-go
       '(begin
    (define true #t)
    (define false #f)
    (define (assoc key records)
      (cond ((null? records) false)
	    ((equal? key (caar records)) (car records))
	    (else (assoc key (cdr records)))))
    (define (cadr l)
       (car (cdr l)))
    (define (cadddr l)
       (car (cdr (cdr (cdr l)))))
    (define (caddr l)
       (car (cdr (cdr l))))
    (define (cdadr l)
       (cdr (car (cdr l))))
    (define (caadr l)
       (car (car (cdr l))))
    (define (cdddr l)
       (cdr (cdr (cdr l))))
    (define (cddr l)
       (cdr (cdr l)))
    (define (caar l)
       (car (car l)))
    (define (cdar l)
       (cdr (car l)))
    (define (abs v)
       (if (> v 0)
	  v
	  (* -1 v)))
    (define (member item x)
       (cond ((null? x) false)
	     ((equal? item (car x)) x)
	     (else (member item (cdr x)))))
    (define (square v)
       (* v v))
    (define (even? x)
       (if (= 0 (remainder x 2))
	  #t
	  #f))
    (define (equal? o1 o2)
      (cond ((eq? o1 o2) #t)
	    ((and (list? o1) (list? o2))  (accumulate (lambda (x y) (and x y)) #t (map equal? o1 o2)))
	    ((and (number? o1) (number? o2)) (= o1 o2))
	    (else #f)))
    (define (written x) x)

    <<accumulate>>
    <<map-append-length>>
    <<memq>>

    (define (apply-in-underlying-scheme proc argl)
      (if (primitive-procedure? proc)
	 (apply-in-real-scheme proc argl)
	 (apply1 proc argl)
         )) ; compiled procedure
    <<s-apply>>
    <<s-eval>>
    <<s-list-of-values>>
    <<s-standard-if>>
    <<s-sequences>>
    <<s-assignment>>
    <<s-define>>
    <<s-syntax>>
    <<s-application>>
    <<s-cond>>
    <<s-truefalse>>
    <<s-compound-procedures>>
    <<s-environments>>
    <<s-primitive-procedures>>
    <<s-driver-loop>>

    <<s-glue2>>
    (driver-loop)
    (exit)
    ))
  ;))
#+end_src


#+name: transpiled-metacircular-evaluator-bigger-test
#+begin_src fortran :exports code :results raw output code :flags -g :stdin fortran-scheme-test-last-1
      <<fortran-scheme-interpreter-runtime-prologue>>
      <<fortran-scheme-interpreter-interlogue()>>
      <<fortran-scheme-interpreter-runtime-epilogue>>
#+end_src


#+name: fortran-scheme-test-last-1
#+begin_src scheme :exports code
(if #t 1 2)
(if #f 1 2)
(display "hello")
(cadr (list 1 2 3))
(define (fac x) (if (= x 1) 1 (* x (fac (- x 1)))))
(fac 6)
(exit)
#+end_src

#+header: :stdin empty
#+begin_src shell :results output code :exports both
  cat <<'EOF' > interpreter-compiled.f90
  <<transpiled-metacircular-evaluator-bigger-test>>
  EOF
  gfortran -Wno-all -g interpreter-compiled.f90 -o schemetran-compiled

  cat <<'EOF' > testfile.scm
  <<fortran-scheme-test-last-1>>
  EOF

  ./schemetran-compiled < testfile.scm
  #rm -rf schemetran-compiled
  #rm -rf testfile.scm
  #rm -rf system_interface.mod
  #rm -rf scheme.mod
#+end_src

#+RESULTS[e47a84fa9a02d487849d294713707207812ee5bb]:
#+begin_src shell
 Welcome to the rudimentary scheme in fortran
 
";;; M-Eval input:" 
(if . (#t . (1 . (2 . ())))) 
";;; M-Eval value:" 
1 
";;; M-Eval input:" 
(if . (#f . (1 . (2 . ())))) 
";;; M-Eval value:" 
2 
";;; M-Eval input:" 
(display . ("hello" . ()))"hello" 
";;; M-Eval value:" 
() 
";;; M-Eval input:" 
(cadr . ((list . (1 . (2 . (3 . ())))) . ())) 
";;; M-Eval value:" 
2 
";;; M-Eval input:" 
(define . ((fac . (x . ())) . ((if . ((= . (x . (1 . ()))) . (1 . ((* . (x . ((fac . ((- . (x . (1 . ()))) . ())) . ()))) . ())))) . ()))) 
";;; M-Eval value:" 
ok 
";;; M-Eval input:" 
(fac . (6 . ())) 
";;; M-Eval value:" 
720 
";;; M-Eval input:" 
(exit . ())STOP 0
#+end_src


Since debugging took a lot of time, I'm testing this again:

#+begin_src shell :shebang "#!/usr/bin/chibi-scheme" :exports both :results code output
    <<ec-glue1>>
    <<s-truefalse>>
    <<s-let-implementation>>
    <<s-let-star-implementation>>
    <<ec-s-additional-syntax>>
    <<s-syntax>>
    <<s-application>>
    <<s-environments>>
    <<s-compound-procedures>>
    <<s-primitive-procedures>>
    <<s-cond>>
    <<s-user-prompt-print-with-compiled>>
    <<regmac-make-machine>>
    <<regmac-make-register-tracing>>
    <<regmac-make-stack-with-performance>>
    <<regmac-make-new-machine-with-metadata-instr-count-trace-labels-brk>>
    <<regmac-extract-labels-improved-labels-brk>>
    <<regmac-assembler-with-metadata-register-labels-brk>>
    <<regmac-generating-execution-procedures>>
    <<regmac-make-operation-exp>>
    <<regmac-make-operation-exp-syntax>>
    <<regmac-make-assign>>
    <<regmac-make-test>>
    <<regmac-make-save-restore>>
    <<regmac-other-instructions>>

    <<c-compile-and-go-lexical-for-compiling>>
    <<c-compile-lexical-with-open-code-let>>
    <<c-compile-lexical-open-code>>
    <<c-make-instruction-sequence-empty-instruction-sequence>>
    <<c-compile-linkage>>
    <<c-end-with-linkage>>
    <<c-compile-lexical-simple-expressions>>
    <<c-compile-lexical-definition>>
    <<c-lexical-compile-variable-compile-assignment>>
    <<c-make-label>>
    <<c-compile-lexical-if>>
    <<c-compile-lexical-sequence>>
    <<c-compiled-procedures>>
    <<c-compile-lexical-lambda>>
    <<c-compile-lexical-lambda-body-nodefines>>
    <<c-compile-lexical-application>>
    <<c-lexical-address-lookup>>
    <<c-lexical-find-variable>>
    <<c-construct-arglist>>
    <<c-compile-procedure-call-with-interpreted>>
    <<c-compile-proc-appl>>
    <<c-combining-registers>>
    <<c-append-instruction-sequences>>
    <<c-list-union>>
    <<c-preserving>>
    <<c-tack-on-instruction-sequence>>
    <<c-parallel-instruction-sequences>>

    <<c-ec-compile-and-run>>

    (define the-global-environment (setup-environment))
    ;(define-variable! 'apply-in-underlying-scheme (list 'primitive apply-in-underlying-scheme) the-global-environment)
    (define (get-global-environment) the-global-environment)

    (define eceval-operations
	  (list
    <<ec-eceval-operations-basic>>
    <<ec-eceval-operations-let-cond>>
    <<ec-eceval-operations-compiled>>
    <<c-lexical-controller-ops>>
    <<ec-eceval-operations-opencode>>
    <<ec-eceval-operations-compile-and-run>>
      ))

    (define eceval
	  (make-machine
	   '() ;'(exp env val proc argl continue unev)
	   eceval-operations
	   (quote (
	   <<ec-before-repl-branch-to-compile>>
	   <<ec-end-of-the-world>>
      ))))
  (set-register-contents! eceval 'flag false)

  #;(show #t (pretty (compile
	'placeholder
	'val
	'next
	the-global-environment)) nl)

  (compile-and-go
     '(begin
  (define (accumulate op initial sequence)
    (if (null? sequence)
	initial
	(op (car sequence)
	    (accumulate op initial (cdr sequence)))))
  (define (length sequence)
    (accumulate (lambda (x y) (+ 1 y)) 0 sequence))
   (display (length (list 1 2 3 4)))

  (exit)
  ))
#+end_src

#+RESULTS:
#+begin_src shell
4
#+end_src



* Afterword

This was a huge project. Even just revising it, going through it to
check if every piece of code runs, took a week's time. 

The document should be now exportable to PDF, and potentially in some other formats.
At the end Emacs became slow under the load of a 78 thousand-long file.
I had to turn off company-mode and font-lock-mode to make is reasonable.


* Footnotes
[fn:1] This exercise took me 7 hours.
[fn:2] This exercise took me about 40 hours.
